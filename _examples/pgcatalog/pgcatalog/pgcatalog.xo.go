// Package pgcatalog contains generated code for schema 'pg_catalog'.
package pgcatalog

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"encoding/csv"
	"fmt"
	"io"
	"regexp"
	"strings"
	"time"

	"github.com/google/uuid"

	"github.com/mmmcorp/xo/_examples/pgcatalog/pgtypes"

	"github.com/google/uuid"
)

var (
	// logf is used by generated code to log SQL queries.
	logf = func(string, ...interface{}) {}
	// errf is used by generated code to log SQL errors.
	errf = func(string, ...interface{}) {}
)

// logerror logs the error and returns it.
func logerror(err error) error {
	errf("ERROR: %v", err)
	return err
}

// Logf logs a message using the package logger.
func Logf(s string, v ...interface{}) {
	logf(s, v...)
}

// SetLogger sets the package logger. Valid logger types:
//
//     io.Writer
//     func(string, ...interface{}) (int, error) // fmt.Printf
//     func(string, ...interface{}) // log.Printf
//
func SetLogger(logger interface{}) {
	logf = convLogger(logger)
}

// Errorf logs an error message using the package error logger.
func Errorf(s string, v ...interface{}) {
	errf(s, v...)
}

// SetErrorLogger sets the package error logger. Valid logger types:
//
//     io.Writer
//     func(string, ...interface{}) (int, error) // fmt.Printf
//     func(string, ...interface{}) // log.Printf
//
func SetErrorLogger(logger interface{}) {
	errf = convLogger(logger)
}

// convLogger converts logger to the standard logger interface.
func convLogger(logger interface{}) func(string, ...interface{}) {
	switch z := logger.(type) {
	case io.Writer:
		return func(s string, v ...interface{}) {
			fmt.Fprintf(z, s, v...)
		}
	case func(string, ...interface{}) (int, error): // fmt.Printf
		return func(s string, v ...interface{}) {
			_, _ = z(s, v...)
		}
	case func(string, ...interface{}): // log.Printf
		return z
	}
	panic(fmt.Sprintf("unsupported logger type %T", logger))
}

// DB is the common interface for database operations that can be used with
// types from schema 'pg_catalog'.
//
// This works with both database/sql.DB and database/sql.Tx.
type DB interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

// Error is an error.
type Error string

// Error satisfies the error interface.
func (err Error) Error() string {
	return string(err)
}

// Error values.
const (
	// ErrAlreadyExists is the already exists error.
	ErrAlreadyExists Error = "already exists"
	// ErrDoesNotExist is the does not exist error.
	ErrDoesNotExist Error = "does not exist"
	// ErrMarkedForDeletion is the marked for deletion error.
	ErrMarkedForDeletion Error = "marked for deletion"
)

// ErrInsertFailed is the insert failed error.
type ErrInsertFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrInsertFailed) Error() string {
	return fmt.Sprintf("insert failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrInsertFailed) Unwrap() error {
	return err.Err
}

// ErrUpdateFailed is the update failed error.
type ErrUpdateFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrUpdateFailed) Error() string {
	return fmt.Sprintf("update failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrUpdateFailed) Unwrap() error {
	return err.Err
}

// ErrUpsertFailed is the upsert failed error.
type ErrUpsertFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrUpsertFailed) Error() string {
	return fmt.Sprintf("upsert failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrUpsertFailed) Unwrap() error {
	return err.Err
}

// ErrDecodeFailed is the decode failed error.
type ErrDecodeFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrDecodeFailed) Error() string {
	return fmt.Sprintf("unable to decode: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrDecodeFailed) Unwrap() error {
	return err.Err
}

// ErrInvalidStringSlice is the invalid StringSlice error.
const ErrInvalidStringSlice Error = "invalid StringSlice"

// StringSlice is a slice of strings.
type StringSlice []string

// Scan satisfies the sql.Scanner interface for StringSlice.
func (ss *StringSlice) Scan(v interface{}) error {
	buf, ok := v.([]byte)
	if !ok {
		return logerror(ErrInvalidStringSlice)
	}
	// change quote escapes for csv parser
	str := strings.Replace(quoteEscRE.ReplaceAllString(string(buf), `$1""`), `\\`, `\`, -1)
	str = str[1 : len(str)-1]
	// bail if only one
	if len(str) == 0 {
		return nil
	}
	// parse with csv reader
	r := csv.NewReader(strings.NewReader(str))
	line, err := r.Read()
	if err != nil {
		return logerror(&ErrDecodeFailed{err})
	}
	*ss = StringSlice(line)
	return nil
}

// quoteEscRE matches escaped characters in a string.
var quoteEscRE = regexp.MustCompile(`([^\\]([\\]{2})*)\\"`)

// Value satisfies the sql/driver.Valuer interface.
func (ss StringSlice) Value() (driver.Value, error) {
	v := make([]string, len(ss))
	for i, s := range ss {
		v[i] = `"` + strings.Replace(strings.Replace(s, `\`, `\\\`, -1), `"`, `\"`, -1) + `"`
	}
	return "{" + strings.Join(v, ",") + "}", nil
}

// PgAggregate represents a row from 'pg_catalog.pg_aggregate'.
type PgAggregate struct {
	Tableoid         pgtypes.Oid     `json:"tableoid"`         // tableoid
	Cmax             pgtypes.Cid     `json:"cmax"`             // cmax
	Xmax             pgtypes.Xid     `json:"xmax"`             // xmax
	Cmin             pgtypes.Cid     `json:"cmin"`             // cmin
	Xmin             pgtypes.Xid     `json:"xmin"`             // xmin
	Ctid             pgtypes.Tid     `json:"ctid"`             // ctid
	Aggfnoid         pgtypes.Regproc `json:"aggfnoid"`         // aggfnoid
	Aggkind          pgtypes.Char    `json:"aggkind"`          // aggkind
	Aggnumdirectargs int16           `json:"aggnumdirectargs"` // aggnumdirectargs
	Aggtransfn       pgtypes.Regproc `json:"aggtransfn"`       // aggtransfn
	Aggfinalfn       pgtypes.Regproc `json:"aggfinalfn"`       // aggfinalfn
	Aggcombinefn     pgtypes.Regproc `json:"aggcombinefn"`     // aggcombinefn
	Aggserialfn      pgtypes.Regproc `json:"aggserialfn"`      // aggserialfn
	Aggdeserialfn    pgtypes.Regproc `json:"aggdeserialfn"`    // aggdeserialfn
	Aggmtransfn      pgtypes.Regproc `json:"aggmtransfn"`      // aggmtransfn
	Aggminvtransfn   pgtypes.Regproc `json:"aggminvtransfn"`   // aggminvtransfn
	Aggmfinalfn      pgtypes.Regproc `json:"aggmfinalfn"`      // aggmfinalfn
	Aggfinalextra    bool            `json:"aggfinalextra"`    // aggfinalextra
	Aggmfinalextra   bool            `json:"aggmfinalextra"`   // aggmfinalextra
	Aggfinalmodify   pgtypes.Char    `json:"aggfinalmodify"`   // aggfinalmodify
	Aggmfinalmodify  pgtypes.Char    `json:"aggmfinalmodify"`  // aggmfinalmodify
	Aggsortop        pgtypes.Oid     `json:"aggsortop"`        // aggsortop
	Aggtranstype     pgtypes.Oid     `json:"aggtranstype"`     // aggtranstype
	Aggtransspace    int             `json:"aggtransspace"`    // aggtransspace
	Aggmtranstype    pgtypes.Oid     `json:"aggmtranstype"`    // aggmtranstype
	Aggmtransspace   int             `json:"aggmtransspace"`   // aggmtransspace
	Agginitval       sql.NullString  `json:"agginitval"`       // agginitval
	Aggminitval      sql.NullString  `json:"aggminitval"`      // aggminitval
}

// PgAm represents a row from 'pg_catalog.pg_am'.
type PgAm struct {
	Tableoid  pgtypes.Oid     `json:"tableoid"`  // tableoid
	Cmax      pgtypes.Cid     `json:"cmax"`      // cmax
	Xmax      pgtypes.Xid     `json:"xmax"`      // xmax
	Cmin      pgtypes.Cid     `json:"cmin"`      // cmin
	Xmin      pgtypes.Xid     `json:"xmin"`      // xmin
	Ctid      pgtypes.Tid     `json:"ctid"`      // ctid
	Oid       pgtypes.Oid     `json:"oid"`       // oid
	Amname    pgtypes.Name    `json:"amname"`    // amname
	Amhandler pgtypes.Regproc `json:"amhandler"` // amhandler
	Amtype    pgtypes.Char    `json:"amtype"`    // amtype
}

// PgAmop represents a row from 'pg_catalog.pg_amop'.
type PgAmop struct {
	Tableoid       pgtypes.Oid  `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid  `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid  `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid  `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid  `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid  `json:"ctid"`           // ctid
	Oid            pgtypes.Oid  `json:"oid"`            // oid
	Amopfamily     pgtypes.Oid  `json:"amopfamily"`     // amopfamily
	Amoplefttype   pgtypes.Oid  `json:"amoplefttype"`   // amoplefttype
	Amoprighttype  pgtypes.Oid  `json:"amoprighttype"`  // amoprighttype
	Amopstrategy   int16        `json:"amopstrategy"`   // amopstrategy
	Amoppurpose    pgtypes.Char `json:"amoppurpose"`    // amoppurpose
	Amopopr        pgtypes.Oid  `json:"amopopr"`        // amopopr
	Amopmethod     pgtypes.Oid  `json:"amopmethod"`     // amopmethod
	Amopsortfamily pgtypes.Oid  `json:"amopsortfamily"` // amopsortfamily
}

// PgAmproc represents a row from 'pg_catalog.pg_amproc'.
type PgAmproc struct {
	Tableoid        pgtypes.Oid     `json:"tableoid"`        // tableoid
	Cmax            pgtypes.Cid     `json:"cmax"`            // cmax
	Xmax            pgtypes.Xid     `json:"xmax"`            // xmax
	Cmin            pgtypes.Cid     `json:"cmin"`            // cmin
	Xmin            pgtypes.Xid     `json:"xmin"`            // xmin
	Ctid            pgtypes.Tid     `json:"ctid"`            // ctid
	Oid             pgtypes.Oid     `json:"oid"`             // oid
	Amprocfamily    pgtypes.Oid     `json:"amprocfamily"`    // amprocfamily
	Amproclefttype  pgtypes.Oid     `json:"amproclefttype"`  // amproclefttype
	Amprocrighttype pgtypes.Oid     `json:"amprocrighttype"` // amprocrighttype
	Amprocnum       int16           `json:"amprocnum"`       // amprocnum
	Amproc          pgtypes.Regproc `json:"amproc"`          // amproc
}

// PgAttrdef represents a row from 'pg_catalog.pg_attrdef'.
type PgAttrdef struct {
	Tableoid pgtypes.Oid        `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid        `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid        `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid        `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid        `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid        `json:"ctid"`     // ctid
	Oid      pgtypes.Oid        `json:"oid"`      // oid
	Adrelid  pgtypes.Oid        `json:"adrelid"`  // adrelid
	Adnum    int16              `json:"adnum"`    // adnum
	Adbin    pgtypes.PgNodeTree `json:"adbin"`    // adbin
}

// PgAttribute represents a row from 'pg_catalog.pg_attribute'.
type PgAttribute struct {
	Tableoid      pgtypes.Oid       `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid       `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid       `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid       `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid       `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid       `json:"ctid"`          // ctid
	Attrelid      pgtypes.Oid       `json:"attrelid"`      // attrelid
	Attname       pgtypes.Name      `json:"attname"`       // attname
	Atttypid      pgtypes.Oid       `json:"atttypid"`      // atttypid
	Attstattarget int               `json:"attstattarget"` // attstattarget
	Attlen        int16             `json:"attlen"`        // attlen
	Attnum        int16             `json:"attnum"`        // attnum
	Attndims      int               `json:"attndims"`      // attndims
	Attcacheoff   int               `json:"attcacheoff"`   // attcacheoff
	Atttypmod     int               `json:"atttypmod"`     // atttypmod
	Attbyval      bool              `json:"attbyval"`      // attbyval
	Attstorage    pgtypes.Char      `json:"attstorage"`    // attstorage
	Attalign      pgtypes.Char      `json:"attalign"`      // attalign
	Attnotnull    bool              `json:"attnotnull"`    // attnotnull
	Atthasdef     bool              `json:"atthasdef"`     // atthasdef
	Atthasmissing bool              `json:"atthasmissing"` // atthasmissing
	Attidentity   pgtypes.Char      `json:"attidentity"`   // attidentity
	Attgenerated  pgtypes.Char      `json:"attgenerated"`  // attgenerated
	Attisdropped  bool              `json:"attisdropped"`  // attisdropped
	Attislocal    bool              `json:"attislocal"`    // attislocal
	Attinhcount   int               `json:"attinhcount"`   // attinhcount
	Attcollation  pgtypes.Oid       `json:"attcollation"`  // attcollation
	Attacl        []pgtypes.Aclitem `json:"attacl"`        // attacl
	Attoptions    []sql.NullString  `json:"attoptions"`    // attoptions
	Attfdwoptions []sql.NullString  `json:"attfdwoptions"` // attfdwoptions
	Attmissingval pgtypes.Anyarray  `json:"attmissingval"` // attmissingval
}

// PgAuthMember represents a row from 'pg_catalog.pg_auth_members'.
type PgAuthMember struct {
	Tableoid    pgtypes.Oid `json:"tableoid"`     // tableoid
	Cmax        pgtypes.Cid `json:"cmax"`         // cmax
	Xmax        pgtypes.Xid `json:"xmax"`         // xmax
	Cmin        pgtypes.Cid `json:"cmin"`         // cmin
	Xmin        pgtypes.Xid `json:"xmin"`         // xmin
	Ctid        pgtypes.Tid `json:"ctid"`         // ctid
	Roleid      pgtypes.Oid `json:"roleid"`       // roleid
	Member      pgtypes.Oid `json:"member"`       // member
	Grantor     pgtypes.Oid `json:"grantor"`      // grantor
	AdminOption bool        `json:"admin_option"` // admin_option
}

// PgAuthid represents a row from 'pg_catalog.pg_authid'.
type PgAuthid struct {
	Tableoid       pgtypes.Oid    `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid    `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid    `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid    `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid    `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid    `json:"ctid"`           // ctid
	Oid            pgtypes.Oid    `json:"oid"`            // oid
	Rolname        pgtypes.Name   `json:"rolname"`        // rolname
	Rolsuper       bool           `json:"rolsuper"`       // rolsuper
	Rolinherit     bool           `json:"rolinherit"`     // rolinherit
	Rolcreaterole  bool           `json:"rolcreaterole"`  // rolcreaterole
	Rolcreatedb    bool           `json:"rolcreatedb"`    // rolcreatedb
	Rolcanlogin    bool           `json:"rolcanlogin"`    // rolcanlogin
	Rolreplication bool           `json:"rolreplication"` // rolreplication
	Rolbypassrls   bool           `json:"rolbypassrls"`   // rolbypassrls
	Rolconnlimit   int            `json:"rolconnlimit"`   // rolconnlimit
	Rolpassword    sql.NullString `json:"rolpassword"`    // rolpassword
	Rolvaliduntil  sql.NullTime   `json:"rolvaliduntil"`  // rolvaliduntil
}

// PgAvailableExtension represents a row from 'pg_catalog.pg_available_extensions'.
type PgAvailableExtension struct {
	Name             pgtypes.Name   `json:"name"`              // name
	DefaultVersion   sql.NullString `json:"default_version"`   // default_version
	InstalledVersion sql.NullString `json:"installed_version"` // installed_version
	Comment          sql.NullString `json:"comment"`           // comment
}

// PgAvailableExtensionVersion represents a row from 'pg_catalog.pg_available_extension_versions'.
type PgAvailableExtensionVersion struct {
	Name        pgtypes.Name   `json:"name"`        // name
	Version     sql.NullString `json:"version"`     // version
	Installed   sql.NullBool   `json:"installed"`   // installed
	Superuser   sql.NullBool   `json:"superuser"`   // superuser
	Trusted     sql.NullBool   `json:"trusted"`     // trusted
	Relocatable sql.NullBool   `json:"relocatable"` // relocatable
	Schema      pgtypes.Name   `json:"schema"`      // schema
	Requires    []pgtypes.Name `json:"requires"`    // requires
	Comment     sql.NullString `json:"comment"`     // comment
}

// PgCast represents a row from 'pg_catalog.pg_cast'.
type PgCast struct {
	Tableoid    pgtypes.Oid  `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid  `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid  `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid  `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid  `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid  `json:"ctid"`        // ctid
	Oid         pgtypes.Oid  `json:"oid"`         // oid
	Castsource  pgtypes.Oid  `json:"castsource"`  // castsource
	Casttarget  pgtypes.Oid  `json:"casttarget"`  // casttarget
	Castfunc    pgtypes.Oid  `json:"castfunc"`    // castfunc
	Castcontext pgtypes.Char `json:"castcontext"` // castcontext
	Castmethod  pgtypes.Char `json:"castmethod"`  // castmethod
}

// PgClass represents a row from 'pg_catalog.pg_class'.
type PgClass struct {
	Tableoid            pgtypes.Oid        `json:"tableoid"`            // tableoid
	Cmax                pgtypes.Cid        `json:"cmax"`                // cmax
	Xmax                pgtypes.Xid        `json:"xmax"`                // xmax
	Cmin                pgtypes.Cid        `json:"cmin"`                // cmin
	Xmin                pgtypes.Xid        `json:"xmin"`                // xmin
	Ctid                pgtypes.Tid        `json:"ctid"`                // ctid
	Oid                 pgtypes.Oid        `json:"oid"`                 // oid
	Relname             pgtypes.Name       `json:"relname"`             // relname
	Relnamespace        pgtypes.Oid        `json:"relnamespace"`        // relnamespace
	Reltype             pgtypes.Oid        `json:"reltype"`             // reltype
	Reloftype           pgtypes.Oid        `json:"reloftype"`           // reloftype
	Relowner            pgtypes.Oid        `json:"relowner"`            // relowner
	Relam               pgtypes.Oid        `json:"relam"`               // relam
	Relfilenode         pgtypes.Oid        `json:"relfilenode"`         // relfilenode
	Reltablespace       pgtypes.Oid        `json:"reltablespace"`       // reltablespace
	Relpages            int                `json:"relpages"`            // relpages
	Reltuples           float32            `json:"reltuples"`           // reltuples
	Relallvisible       int                `json:"relallvisible"`       // relallvisible
	Reltoastrelid       pgtypes.Oid        `json:"reltoastrelid"`       // reltoastrelid
	Relhasindex         bool               `json:"relhasindex"`         // relhasindex
	Relisshared         bool               `json:"relisshared"`         // relisshared
	Relpersistence      pgtypes.Char       `json:"relpersistence"`      // relpersistence
	Relkind             pgtypes.Char       `json:"relkind"`             // relkind
	Relnatts            int16              `json:"relnatts"`            // relnatts
	Relchecks           int16              `json:"relchecks"`           // relchecks
	Relhasrules         bool               `json:"relhasrules"`         // relhasrules
	Relhastriggers      bool               `json:"relhastriggers"`      // relhastriggers
	Relhassubclass      bool               `json:"relhassubclass"`      // relhassubclass
	Relrowsecurity      bool               `json:"relrowsecurity"`      // relrowsecurity
	Relforcerowsecurity bool               `json:"relforcerowsecurity"` // relforcerowsecurity
	Relispopulated      bool               `json:"relispopulated"`      // relispopulated
	Relreplident        pgtypes.Char       `json:"relreplident"`        // relreplident
	Relispartition      bool               `json:"relispartition"`      // relispartition
	Relrewrite          pgtypes.Oid        `json:"relrewrite"`          // relrewrite
	Relfrozenxid        pgtypes.Xid        `json:"relfrozenxid"`        // relfrozenxid
	Relminmxid          pgtypes.Xid        `json:"relminmxid"`          // relminmxid
	Relacl              []pgtypes.Aclitem  `json:"relacl"`              // relacl
	Reloptions          []sql.NullString   `json:"reloptions"`          // reloptions
	Relpartbound        pgtypes.PgNodeTree `json:"relpartbound"`        // relpartbound
}

// PgCollation represents a row from 'pg_catalog.pg_collation'.
type PgCollation struct {
	Tableoid            pgtypes.Oid    `json:"tableoid"`            // tableoid
	Cmax                pgtypes.Cid    `json:"cmax"`                // cmax
	Xmax                pgtypes.Xid    `json:"xmax"`                // xmax
	Cmin                pgtypes.Cid    `json:"cmin"`                // cmin
	Xmin                pgtypes.Xid    `json:"xmin"`                // xmin
	Ctid                pgtypes.Tid    `json:"ctid"`                // ctid
	Oid                 pgtypes.Oid    `json:"oid"`                 // oid
	Collname            pgtypes.Name   `json:"collname"`            // collname
	Collnamespace       pgtypes.Oid    `json:"collnamespace"`       // collnamespace
	Collowner           pgtypes.Oid    `json:"collowner"`           // collowner
	Collprovider        pgtypes.Char   `json:"collprovider"`        // collprovider
	Collisdeterministic bool           `json:"collisdeterministic"` // collisdeterministic
	Collencoding        int            `json:"collencoding"`        // collencoding
	Collcollate         pgtypes.Name   `json:"collcollate"`         // collcollate
	Collctype           pgtypes.Name   `json:"collctype"`           // collctype
	Collversion         sql.NullString `json:"collversion"`         // collversion
}

// PgConfig represents a row from 'pg_catalog.pg_config'.
type PgConfig struct {
	Name    sql.NullString `json:"name"`    // name
	Setting sql.NullString `json:"setting"` // setting
}

// PgConstraint represents a row from 'pg_catalog.pg_constraint'.
type PgConstraint struct {
	Tableoid      pgtypes.Oid        `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid        `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid        `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid        `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid        `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid        `json:"ctid"`          // ctid
	Oid           pgtypes.Oid        `json:"oid"`           // oid
	Conname       pgtypes.Name       `json:"conname"`       // conname
	Connamespace  pgtypes.Oid        `json:"connamespace"`  // connamespace
	Contype       pgtypes.Char       `json:"contype"`       // contype
	Condeferrable bool               `json:"condeferrable"` // condeferrable
	Condeferred   bool               `json:"condeferred"`   // condeferred
	Convalidated  bool               `json:"convalidated"`  // convalidated
	Conrelid      pgtypes.Oid        `json:"conrelid"`      // conrelid
	Contypid      pgtypes.Oid        `json:"contypid"`      // contypid
	Conindid      pgtypes.Oid        `json:"conindid"`      // conindid
	Conparentid   pgtypes.Oid        `json:"conparentid"`   // conparentid
	Confrelid     pgtypes.Oid        `json:"confrelid"`     // confrelid
	Confupdtype   pgtypes.Char       `json:"confupdtype"`   // confupdtype
	Confdeltype   pgtypes.Char       `json:"confdeltype"`   // confdeltype
	Confmatchtype pgtypes.Char       `json:"confmatchtype"` // confmatchtype
	Conislocal    bool               `json:"conislocal"`    // conislocal
	Coninhcount   int                `json:"coninhcount"`   // coninhcount
	Connoinherit  bool               `json:"connoinherit"`  // connoinherit
	Conkey        []sql.NullInt64    `json:"conkey"`        // conkey
	Confkey       []sql.NullInt64    `json:"confkey"`       // confkey
	Conpfeqop     []pgtypes.Oid      `json:"conpfeqop"`     // conpfeqop
	Conppeqop     []pgtypes.Oid      `json:"conppeqop"`     // conppeqop
	Conffeqop     []pgtypes.Oid      `json:"conffeqop"`     // conffeqop
	Conexclop     []pgtypes.Oid      `json:"conexclop"`     // conexclop
	Conbin        pgtypes.PgNodeTree `json:"conbin"`        // conbin
}

// PgConversion represents a row from 'pg_catalog.pg_conversion'.
type PgConversion struct {
	Tableoid       pgtypes.Oid     `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid     `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid     `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid     `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid     `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid     `json:"ctid"`           // ctid
	Oid            pgtypes.Oid     `json:"oid"`            // oid
	Conname        pgtypes.Name    `json:"conname"`        // conname
	Connamespace   pgtypes.Oid     `json:"connamespace"`   // connamespace
	Conowner       pgtypes.Oid     `json:"conowner"`       // conowner
	Conforencoding int             `json:"conforencoding"` // conforencoding
	Contoencoding  int             `json:"contoencoding"`  // contoencoding
	Conproc        pgtypes.Regproc `json:"conproc"`        // conproc
	Condefault     bool            `json:"condefault"`     // condefault
}

// PgCursor represents a row from 'pg_catalog.pg_cursors'.
type PgCursor struct {
	Name         sql.NullString `json:"name"`          // name
	Statement    sql.NullString `json:"statement"`     // statement
	IsHoldable   sql.NullBool   `json:"is_holdable"`   // is_holdable
	IsBinary     sql.NullBool   `json:"is_binary"`     // is_binary
	IsScrollable sql.NullBool   `json:"is_scrollable"` // is_scrollable
	CreationTime sql.NullTime   `json:"creation_time"` // creation_time
}

// PgDatabase represents a row from 'pg_catalog.pg_database'.
type PgDatabase struct {
	Tableoid      pgtypes.Oid       `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid       `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid       `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid       `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid       `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid       `json:"ctid"`          // ctid
	Oid           pgtypes.Oid       `json:"oid"`           // oid
	Datname       pgtypes.Name      `json:"datname"`       // datname
	Datdba        pgtypes.Oid       `json:"datdba"`        // datdba
	Encoding      int               `json:"encoding"`      // encoding
	Datcollate    pgtypes.Name      `json:"datcollate"`    // datcollate
	Datctype      pgtypes.Name      `json:"datctype"`      // datctype
	Datistemplate bool              `json:"datistemplate"` // datistemplate
	Datallowconn  bool              `json:"datallowconn"`  // datallowconn
	Datconnlimit  int               `json:"datconnlimit"`  // datconnlimit
	Datlastsysoid pgtypes.Oid       `json:"datlastsysoid"` // datlastsysoid
	Datfrozenxid  pgtypes.Xid       `json:"datfrozenxid"`  // datfrozenxid
	Datminmxid    pgtypes.Xid       `json:"datminmxid"`    // datminmxid
	Dattablespace pgtypes.Oid       `json:"dattablespace"` // dattablespace
	Datacl        []pgtypes.Aclitem `json:"datacl"`        // datacl
}

// PgDbRoleSetting represents a row from 'pg_catalog.pg_db_role_setting'.
type PgDbRoleSetting struct {
	Tableoid    pgtypes.Oid      `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid      `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid      `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid      `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid      `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid      `json:"ctid"`        // ctid
	Setdatabase pgtypes.Oid      `json:"setdatabase"` // setdatabase
	Setrole     pgtypes.Oid      `json:"setrole"`     // setrole
	Setconfig   []sql.NullString `json:"setconfig"`   // setconfig
}

// PgDefaultACL represents a row from 'pg_catalog.pg_default_acl'.
type PgDefaultACL struct {
	Tableoid        pgtypes.Oid       `json:"tableoid"`        // tableoid
	Cmax            pgtypes.Cid       `json:"cmax"`            // cmax
	Xmax            pgtypes.Xid       `json:"xmax"`            // xmax
	Cmin            pgtypes.Cid       `json:"cmin"`            // cmin
	Xmin            pgtypes.Xid       `json:"xmin"`            // xmin
	Ctid            pgtypes.Tid       `json:"ctid"`            // ctid
	Oid             pgtypes.Oid       `json:"oid"`             // oid
	Defaclrole      pgtypes.Oid       `json:"defaclrole"`      // defaclrole
	Defaclnamespace pgtypes.Oid       `json:"defaclnamespace"` // defaclnamespace
	Defaclobjtype   pgtypes.Char      `json:"defaclobjtype"`   // defaclobjtype
	Defaclacl       []pgtypes.Aclitem `json:"defaclacl"`       // defaclacl
}

// PgDepend represents a row from 'pg_catalog.pg_depend'.
type PgDepend struct {
	Tableoid    pgtypes.Oid  `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid  `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid  `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid  `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid  `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid  `json:"ctid"`        // ctid
	Classid     pgtypes.Oid  `json:"classid"`     // classid
	Objid       pgtypes.Oid  `json:"objid"`       // objid
	Objsubid    int          `json:"objsubid"`    // objsubid
	Refclassid  pgtypes.Oid  `json:"refclassid"`  // refclassid
	Refobjid    pgtypes.Oid  `json:"refobjid"`    // refobjid
	Refobjsubid int          `json:"refobjsubid"` // refobjsubid
	Deptype     pgtypes.Char `json:"deptype"`     // deptype
}

// PgDescription represents a row from 'pg_catalog.pg_description'.
type PgDescription struct {
	Tableoid    pgtypes.Oid `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid `json:"ctid"`        // ctid
	Objoid      pgtypes.Oid `json:"objoid"`      // objoid
	Classoid    pgtypes.Oid `json:"classoid"`    // classoid
	Objsubid    int         `json:"objsubid"`    // objsubid
	Description string      `json:"description"` // description
}

// PgEnum represents a row from 'pg_catalog.pg_enum'.
type PgEnum struct {
	Tableoid      pgtypes.Oid  `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid  `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid  `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid  `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid  `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid  `json:"ctid"`          // ctid
	Oid           pgtypes.Oid  `json:"oid"`           // oid
	Enumtypid     pgtypes.Oid  `json:"enumtypid"`     // enumtypid
	Enumsortorder float32      `json:"enumsortorder"` // enumsortorder
	Enumlabel     pgtypes.Name `json:"enumlabel"`     // enumlabel
}

// PgEventTrigger represents a row from 'pg_catalog.pg_event_trigger'.
type PgEventTrigger struct {
	Tableoid   pgtypes.Oid      `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid      `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid      `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid      `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid      `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid      `json:"ctid"`       // ctid
	Oid        pgtypes.Oid      `json:"oid"`        // oid
	Evtname    pgtypes.Name     `json:"evtname"`    // evtname
	Evtevent   pgtypes.Name     `json:"evtevent"`   // evtevent
	Evtowner   pgtypes.Oid      `json:"evtowner"`   // evtowner
	Evtfoid    pgtypes.Oid      `json:"evtfoid"`    // evtfoid
	Evtenabled pgtypes.Char     `json:"evtenabled"` // evtenabled
	Evttags    []sql.NullString `json:"evttags"`    // evttags
}

// PgExtension represents a row from 'pg_catalog.pg_extension'.
type PgExtension struct {
	Tableoid       pgtypes.Oid      `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid      `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid      `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid      `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid      `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid      `json:"ctid"`           // ctid
	Oid            pgtypes.Oid      `json:"oid"`            // oid
	Extname        pgtypes.Name     `json:"extname"`        // extname
	Extowner       pgtypes.Oid      `json:"extowner"`       // extowner
	Extnamespace   pgtypes.Oid      `json:"extnamespace"`   // extnamespace
	Extrelocatable bool             `json:"extrelocatable"` // extrelocatable
	Extversion     string           `json:"extversion"`     // extversion
	Extconfig      []pgtypes.Oid    `json:"extconfig"`      // extconfig
	Extcondition   []sql.NullString `json:"extcondition"`   // extcondition
}

// PgFileSetting represents a row from 'pg_catalog.pg_file_settings'.
type PgFileSetting struct {
	Sourcefile sql.NullString `json:"sourcefile"` // sourcefile
	Sourceline sql.NullInt64  `json:"sourceline"` // sourceline
	Seqno      sql.NullInt64  `json:"seqno"`      // seqno
	Name       sql.NullString `json:"name"`       // name
	Setting    sql.NullString `json:"setting"`    // setting
	Applied    sql.NullBool   `json:"applied"`    // applied
	Error      sql.NullString `json:"error"`      // error
}

// PgForeignDataWrapper represents a row from 'pg_catalog.pg_foreign_data_wrapper'.
type PgForeignDataWrapper struct {
	Tableoid     pgtypes.Oid       `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid       `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid       `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid       `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid       `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid       `json:"ctid"`         // ctid
	Oid          pgtypes.Oid       `json:"oid"`          // oid
	Fdwname      pgtypes.Name      `json:"fdwname"`      // fdwname
	Fdwowner     pgtypes.Oid       `json:"fdwowner"`     // fdwowner
	Fdwhandler   pgtypes.Oid       `json:"fdwhandler"`   // fdwhandler
	Fdwvalidator pgtypes.Oid       `json:"fdwvalidator"` // fdwvalidator
	Fdwacl       []pgtypes.Aclitem `json:"fdwacl"`       // fdwacl
	Fdwoptions   []sql.NullString  `json:"fdwoptions"`   // fdwoptions
}

// PgForeignServer represents a row from 'pg_catalog.pg_foreign_server'.
type PgForeignServer struct {
	Tableoid   pgtypes.Oid       `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid       `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid       `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid       `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid       `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid       `json:"ctid"`       // ctid
	Oid        pgtypes.Oid       `json:"oid"`        // oid
	Srvname    pgtypes.Name      `json:"srvname"`    // srvname
	Srvowner   pgtypes.Oid       `json:"srvowner"`   // srvowner
	Srvfdw     pgtypes.Oid       `json:"srvfdw"`     // srvfdw
	Srvtype    sql.NullString    `json:"srvtype"`    // srvtype
	Srvversion sql.NullString    `json:"srvversion"` // srvversion
	Srvacl     []pgtypes.Aclitem `json:"srvacl"`     // srvacl
	Srvoptions []sql.NullString  `json:"srvoptions"` // srvoptions
}

// PgForeignTable represents a row from 'pg_catalog.pg_foreign_table'.
type PgForeignTable struct {
	Tableoid  pgtypes.Oid      `json:"tableoid"`  // tableoid
	Cmax      pgtypes.Cid      `json:"cmax"`      // cmax
	Xmax      pgtypes.Xid      `json:"xmax"`      // xmax
	Cmin      pgtypes.Cid      `json:"cmin"`      // cmin
	Xmin      pgtypes.Xid      `json:"xmin"`      // xmin
	Ctid      pgtypes.Tid      `json:"ctid"`      // ctid
	Ftrelid   pgtypes.Oid      `json:"ftrelid"`   // ftrelid
	Ftserver  pgtypes.Oid      `json:"ftserver"`  // ftserver
	Ftoptions []sql.NullString `json:"ftoptions"` // ftoptions
}

// PgGroup represents a row from 'pg_catalog.pg_group'.
type PgGroup struct {
	Groname  pgtypes.Name  `json:"groname"`  // groname
	Grosysid pgtypes.Oid   `json:"grosysid"` // grosysid
	Grolist  []pgtypes.Oid `json:"grolist"`  // grolist
}

// PgHbaFileRule represents a row from 'pg_catalog.pg_hba_file_rules'.
type PgHbaFileRule struct {
	LineNumber sql.NullInt64    `json:"line_number"` // line_number
	Type       sql.NullString   `json:"type"`        // type
	Database   []sql.NullString `json:"database"`    // database
	UserName   []sql.NullString `json:"user_name"`   // user_name
	Address    sql.NullString   `json:"address"`     // address
	Netmask    sql.NullString   `json:"netmask"`     // netmask
	AuthMethod sql.NullString   `json:"auth_method"` // auth_method
	Options    []sql.NullString `json:"options"`     // options
	Error      sql.NullString   `json:"error"`       // error
}

// PgIndex represents a row from 'pg_catalog.pg_index'.
type PgIndex struct {
	Tableoid       pgtypes.Oid        `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid        `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid        `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid        `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid        `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid        `json:"ctid"`           // ctid
	Indexrelid     pgtypes.Oid        `json:"indexrelid"`     // indexrelid
	Indrelid       pgtypes.Oid        `json:"indrelid"`       // indrelid
	Indnatts       int16              `json:"indnatts"`       // indnatts
	Indnkeyatts    int16              `json:"indnkeyatts"`    // indnkeyatts
	Indisunique    bool               `json:"indisunique"`    // indisunique
	Indisprimary   bool               `json:"indisprimary"`   // indisprimary
	Indisexclusion bool               `json:"indisexclusion"` // indisexclusion
	Indimmediate   bool               `json:"indimmediate"`   // indimmediate
	Indisclustered bool               `json:"indisclustered"` // indisclustered
	Indisvalid     bool               `json:"indisvalid"`     // indisvalid
	Indcheckxmin   bool               `json:"indcheckxmin"`   // indcheckxmin
	Indisready     bool               `json:"indisready"`     // indisready
	Indislive      bool               `json:"indislive"`      // indislive
	Indisreplident bool               `json:"indisreplident"` // indisreplident
	Indkey         pgtypes.Int2vector `json:"indkey"`         // indkey
	Indcollation   pgtypes.Oidvector  `json:"indcollation"`   // indcollation
	Indclass       pgtypes.Oidvector  `json:"indclass"`       // indclass
	Indoption      pgtypes.Int2vector `json:"indoption"`      // indoption
	Indexprs       pgtypes.PgNodeTree `json:"indexprs"`       // indexprs
	Indpred        pgtypes.PgNodeTree `json:"indpred"`        // indpred
}

// PgIndex represents a row from 'pg_catalog.pg_indexes'.
type PgIndex struct {
	Schemaname pgtypes.Name   `json:"schemaname"` // schemaname
	Tablename  pgtypes.Name   `json:"tablename"`  // tablename
	Indexname  pgtypes.Name   `json:"indexname"`  // indexname
	Tablespace pgtypes.Name   `json:"tablespace"` // tablespace
	Indexdef   sql.NullString `json:"indexdef"`   // indexdef
}

// PgInherit represents a row from 'pg_catalog.pg_inherits'.
type PgInherit struct {
	Tableoid  pgtypes.Oid `json:"tableoid"`  // tableoid
	Cmax      pgtypes.Cid `json:"cmax"`      // cmax
	Xmax      pgtypes.Xid `json:"xmax"`      // xmax
	Cmin      pgtypes.Cid `json:"cmin"`      // cmin
	Xmin      pgtypes.Xid `json:"xmin"`      // xmin
	Ctid      pgtypes.Tid `json:"ctid"`      // ctid
	Inhrelid  pgtypes.Oid `json:"inhrelid"`  // inhrelid
	Inhparent pgtypes.Oid `json:"inhparent"` // inhparent
	Inhseqno  int         `json:"inhseqno"`  // inhseqno
}

// PgInitPriv represents a row from 'pg_catalog.pg_init_privs'.
type PgInitPriv struct {
	Tableoid  pgtypes.Oid       `json:"tableoid"`  // tableoid
	Cmax      pgtypes.Cid       `json:"cmax"`      // cmax
	Xmax      pgtypes.Xid       `json:"xmax"`      // xmax
	Cmin      pgtypes.Cid       `json:"cmin"`      // cmin
	Xmin      pgtypes.Xid       `json:"xmin"`      // xmin
	Ctid      pgtypes.Tid       `json:"ctid"`      // ctid
	Objoid    pgtypes.Oid       `json:"objoid"`    // objoid
	Classoid  pgtypes.Oid       `json:"classoid"`  // classoid
	Objsubid  int               `json:"objsubid"`  // objsubid
	Privtype  pgtypes.Char      `json:"privtype"`  // privtype
	Initprivs []pgtypes.Aclitem `json:"initprivs"` // initprivs
}

// PgLanguage represents a row from 'pg_catalog.pg_language'.
type PgLanguage struct {
	Tableoid      pgtypes.Oid       `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid       `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid       `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid       `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid       `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid       `json:"ctid"`          // ctid
	Oid           pgtypes.Oid       `json:"oid"`           // oid
	Lanname       pgtypes.Name      `json:"lanname"`       // lanname
	Lanowner      pgtypes.Oid       `json:"lanowner"`      // lanowner
	Lanispl       bool              `json:"lanispl"`       // lanispl
	Lanpltrusted  bool              `json:"lanpltrusted"`  // lanpltrusted
	Lanplcallfoid pgtypes.Oid       `json:"lanplcallfoid"` // lanplcallfoid
	Laninline     pgtypes.Oid       `json:"laninline"`     // laninline
	Lanvalidator  pgtypes.Oid       `json:"lanvalidator"`  // lanvalidator
	Lanacl        []pgtypes.Aclitem `json:"lanacl"`        // lanacl
}

// PgLargeobject represents a row from 'pg_catalog.pg_largeobject'.
type PgLargeobject struct {
	Tableoid pgtypes.Oid `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid `json:"ctid"`     // ctid
	Loid     pgtypes.Oid `json:"loid"`     // loid
	Pageno   int         `json:"pageno"`   // pageno
	Data     []byte      `json:"data"`     // data
}

// PgLargeobjectMetadatum represents a row from 'pg_catalog.pg_largeobject_metadata'.
type PgLargeobjectMetadatum struct {
	Tableoid pgtypes.Oid       `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid       `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid       `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid       `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid       `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid       `json:"ctid"`     // ctid
	Oid      pgtypes.Oid       `json:"oid"`      // oid
	Lomowner pgtypes.Oid       `json:"lomowner"` // lomowner
	Lomacl   []pgtypes.Aclitem `json:"lomacl"`   // lomacl
}

// PgLock represents a row from 'pg_catalog.pg_locks'.
type PgLock struct {
	Locktype           sql.NullString `json:"locktype"`           // locktype
	Database           pgtypes.Oid    `json:"database"`           // database
	Relation           pgtypes.Oid    `json:"relation"`           // relation
	Page               sql.NullInt64  `json:"page"`               // page
	Tuple              sql.NullInt64  `json:"tuple"`              // tuple
	Virtualxid         sql.NullString `json:"virtualxid"`         // virtualxid
	Transactionid      pgtypes.Xid    `json:"transactionid"`      // transactionid
	Classid            pgtypes.Oid    `json:"classid"`            // classid
	Objid              pgtypes.Oid    `json:"objid"`              // objid
	Objsubid           sql.NullInt64  `json:"objsubid"`           // objsubid
	Virtualtransaction sql.NullString `json:"virtualtransaction"` // virtualtransaction
	Pid                sql.NullInt64  `json:"pid"`                // pid
	Mode               sql.NullString `json:"mode"`               // mode
	Granted            sql.NullBool   `json:"granted"`            // granted
	Fastpath           sql.NullBool   `json:"fastpath"`           // fastpath
}

// PgMatview represents a row from 'pg_catalog.pg_matviews'.
type PgMatview struct {
	Schemaname   pgtypes.Name   `json:"schemaname"`   // schemaname
	Matviewname  pgtypes.Name   `json:"matviewname"`  // matviewname
	Matviewowner pgtypes.Name   `json:"matviewowner"` // matviewowner
	Tablespace   pgtypes.Name   `json:"tablespace"`   // tablespace
	Hasindexes   sql.NullBool   `json:"hasindexes"`   // hasindexes
	Ispopulated  sql.NullBool   `json:"ispopulated"`  // ispopulated
	Definition   sql.NullString `json:"definition"`   // definition
}

// PgNamespace represents a row from 'pg_catalog.pg_namespace'.
type PgNamespace struct {
	Tableoid pgtypes.Oid       `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid       `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid       `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid       `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid       `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid       `json:"ctid"`     // ctid
	Oid      pgtypes.Oid       `json:"oid"`      // oid
	Nspname  pgtypes.Name      `json:"nspname"`  // nspname
	Nspowner pgtypes.Oid       `json:"nspowner"` // nspowner
	Nspacl   []pgtypes.Aclitem `json:"nspacl"`   // nspacl
}

// PgOpclass represents a row from 'pg_catalog.pg_opclass'.
type PgOpclass struct {
	Tableoid     pgtypes.Oid  `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid  `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid  `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid  `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid  `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid  `json:"ctid"`         // ctid
	Oid          pgtypes.Oid  `json:"oid"`          // oid
	Opcmethod    pgtypes.Oid  `json:"opcmethod"`    // opcmethod
	Opcname      pgtypes.Name `json:"opcname"`      // opcname
	Opcnamespace pgtypes.Oid  `json:"opcnamespace"` // opcnamespace
	Opcowner     pgtypes.Oid  `json:"opcowner"`     // opcowner
	Opcfamily    pgtypes.Oid  `json:"opcfamily"`    // opcfamily
	Opcintype    pgtypes.Oid  `json:"opcintype"`    // opcintype
	Opcdefault   bool         `json:"opcdefault"`   // opcdefault
	Opckeytype   pgtypes.Oid  `json:"opckeytype"`   // opckeytype
}

// PgOperator represents a row from 'pg_catalog.pg_operator'.
type PgOperator struct {
	Tableoid     pgtypes.Oid     `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid     `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid     `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid     `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid     `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid     `json:"ctid"`         // ctid
	Oid          pgtypes.Oid     `json:"oid"`          // oid
	Oprname      pgtypes.Name    `json:"oprname"`      // oprname
	Oprnamespace pgtypes.Oid     `json:"oprnamespace"` // oprnamespace
	Oprowner     pgtypes.Oid     `json:"oprowner"`     // oprowner
	Oprkind      pgtypes.Char    `json:"oprkind"`      // oprkind
	Oprcanmerge  bool            `json:"oprcanmerge"`  // oprcanmerge
	Oprcanhash   bool            `json:"oprcanhash"`   // oprcanhash
	Oprleft      pgtypes.Oid     `json:"oprleft"`      // oprleft
	Oprright     pgtypes.Oid     `json:"oprright"`     // oprright
	Oprresult    pgtypes.Oid     `json:"oprresult"`    // oprresult
	Oprcom       pgtypes.Oid     `json:"oprcom"`       // oprcom
	Oprnegate    pgtypes.Oid     `json:"oprnegate"`    // oprnegate
	Oprcode      pgtypes.Regproc `json:"oprcode"`      // oprcode
	Oprrest      pgtypes.Regproc `json:"oprrest"`      // oprrest
	Oprjoin      pgtypes.Regproc `json:"oprjoin"`      // oprjoin
}

// PgOpfamily represents a row from 'pg_catalog.pg_opfamily'.
type PgOpfamily struct {
	Tableoid     pgtypes.Oid  `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid  `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid  `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid  `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid  `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid  `json:"ctid"`         // ctid
	Oid          pgtypes.Oid  `json:"oid"`          // oid
	Opfmethod    pgtypes.Oid  `json:"opfmethod"`    // opfmethod
	Opfname      pgtypes.Name `json:"opfname"`      // opfname
	Opfnamespace pgtypes.Oid  `json:"opfnamespace"` // opfnamespace
	Opfowner     pgtypes.Oid  `json:"opfowner"`     // opfowner
}

// PgPartitionedTable represents a row from 'pg_catalog.pg_partitioned_table'.
type PgPartitionedTable struct {
	Tableoid      pgtypes.Oid        `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid        `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid        `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid        `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid        `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid        `json:"ctid"`          // ctid
	Partrelid     pgtypes.Oid        `json:"partrelid"`     // partrelid
	Partstrat     pgtypes.Char       `json:"partstrat"`     // partstrat
	Partnatts     int16              `json:"partnatts"`     // partnatts
	Partdefid     pgtypes.Oid        `json:"partdefid"`     // partdefid
	Partattrs     pgtypes.Int2vector `json:"partattrs"`     // partattrs
	Partclass     pgtypes.Oidvector  `json:"partclass"`     // partclass
	Partcollation pgtypes.Oidvector  `json:"partcollation"` // partcollation
	Partexprs     pgtypes.PgNodeTree `json:"partexprs"`     // partexprs
}

// PgPolicy represents a row from 'pg_catalog.pg_policy'.
type PgPolicy struct {
	Tableoid      pgtypes.Oid        `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid        `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid        `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid        `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid        `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid        `json:"ctid"`          // ctid
	Oid           pgtypes.Oid        `json:"oid"`           // oid
	Polname       pgtypes.Name       `json:"polname"`       // polname
	Polrelid      pgtypes.Oid        `json:"polrelid"`      // polrelid
	Polcmd        pgtypes.Char       `json:"polcmd"`        // polcmd
	Polpermissive bool               `json:"polpermissive"` // polpermissive
	Polroles      []pgtypes.Oid      `json:"polroles"`      // polroles
	Polqual       pgtypes.PgNodeTree `json:"polqual"`       // polqual
	Polwithcheck  pgtypes.PgNodeTree `json:"polwithcheck"`  // polwithcheck
}

// PgPolicy represents a row from 'pg_catalog.pg_policies'.
type PgPolicy struct {
	Schemaname pgtypes.Name   `json:"schemaname"` // schemaname
	Tablename  pgtypes.Name   `json:"tablename"`  // tablename
	Policyname pgtypes.Name   `json:"policyname"` // policyname
	Permissive sql.NullString `json:"permissive"` // permissive
	Roles      []pgtypes.Name `json:"roles"`      // roles
	Cmd        sql.NullString `json:"cmd"`        // cmd
	Qual       sql.NullString `json:"qual"`       // qual
	WithCheck  sql.NullString `json:"with_check"` // with_check
}

// PgPreparedStatement represents a row from 'pg_catalog.pg_prepared_statements'.
type PgPreparedStatement struct {
	Name           sql.NullString    `json:"name"`            // name
	Statement      sql.NullString    `json:"statement"`       // statement
	PrepareTime    sql.NullTime      `json:"prepare_time"`    // prepare_time
	ParameterTypes []pgtypes.Regtype `json:"parameter_types"` // parameter_types
	FromSQL        sql.NullBool      `json:"from_sql"`        // from_sql
}

// PgPreparedXact represents a row from 'pg_catalog.pg_prepared_xacts'.
type PgPreparedXact struct {
	Transaction pgtypes.Xid    `json:"transaction"` // transaction
	Gid         sql.NullString `json:"gid"`         // gid
	Prepared    sql.NullTime   `json:"prepared"`    // prepared
	Owner       pgtypes.Name   `json:"owner"`       // owner
	Database    pgtypes.Name   `json:"database"`    // database
}

// PgProc represents a row from 'pg_catalog.pg_proc'.
type PgProc struct {
	Tableoid        pgtypes.Oid        `json:"tableoid"`        // tableoid
	Cmax            pgtypes.Cid        `json:"cmax"`            // cmax
	Xmax            pgtypes.Xid        `json:"xmax"`            // xmax
	Cmin            pgtypes.Cid        `json:"cmin"`            // cmin
	Xmin            pgtypes.Xid        `json:"xmin"`            // xmin
	Ctid            pgtypes.Tid        `json:"ctid"`            // ctid
	Oid             pgtypes.Oid        `json:"oid"`             // oid
	Proname         pgtypes.Name       `json:"proname"`         // proname
	Pronamespace    pgtypes.Oid        `json:"pronamespace"`    // pronamespace
	Proowner        pgtypes.Oid        `json:"proowner"`        // proowner
	Prolang         pgtypes.Oid        `json:"prolang"`         // prolang
	Procost         float32            `json:"procost"`         // procost
	Prorows         float32            `json:"prorows"`         // prorows
	Provariadic     pgtypes.Oid        `json:"provariadic"`     // provariadic
	Prosupport      pgtypes.Regproc    `json:"prosupport"`      // prosupport
	Prokind         pgtypes.Char       `json:"prokind"`         // prokind
	Prosecdef       bool               `json:"prosecdef"`       // prosecdef
	Proleakproof    bool               `json:"proleakproof"`    // proleakproof
	Proisstrict     bool               `json:"proisstrict"`     // proisstrict
	Proretset       bool               `json:"proretset"`       // proretset
	Provolatile     pgtypes.Char       `json:"provolatile"`     // provolatile
	Proparallel     pgtypes.Char       `json:"proparallel"`     // proparallel
	Pronargs        int16              `json:"pronargs"`        // pronargs
	Pronargdefaults int16              `json:"pronargdefaults"` // pronargdefaults
	Prorettype      pgtypes.Oid        `json:"prorettype"`      // prorettype
	Proargtypes     pgtypes.Oidvector  `json:"proargtypes"`     // proargtypes
	Proallargtypes  []pgtypes.Oid      `json:"proallargtypes"`  // proallargtypes
	Proargmodes     []pgtypes.Char     `json:"proargmodes"`     // proargmodes
	Proargnames     []sql.NullString   `json:"proargnames"`     // proargnames
	Proargdefaults  pgtypes.PgNodeTree `json:"proargdefaults"`  // proargdefaults
	Protrftypes     []pgtypes.Oid      `json:"protrftypes"`     // protrftypes
	Prosrc          string             `json:"prosrc"`          // prosrc
	Probin          sql.NullString     `json:"probin"`          // probin
	Proconfig       []sql.NullString   `json:"proconfig"`       // proconfig
	Proacl          []pgtypes.Aclitem  `json:"proacl"`          // proacl
}

// PgPublication represents a row from 'pg_catalog.pg_publication'.
type PgPublication struct {
	Tableoid     pgtypes.Oid  `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid  `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid  `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid  `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid  `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid  `json:"ctid"`         // ctid
	Oid          pgtypes.Oid  `json:"oid"`          // oid
	Pubname      pgtypes.Name `json:"pubname"`      // pubname
	Pubowner     pgtypes.Oid  `json:"pubowner"`     // pubowner
	Puballtables bool         `json:"puballtables"` // puballtables
	Pubinsert    bool         `json:"pubinsert"`    // pubinsert
	Pubupdate    bool         `json:"pubupdate"`    // pubupdate
	Pubdelete    bool         `json:"pubdelete"`    // pubdelete
	Pubtruncate  bool         `json:"pubtruncate"`  // pubtruncate
	Pubviaroot   bool         `json:"pubviaroot"`   // pubviaroot
}

// PgPublicationRel represents a row from 'pg_catalog.pg_publication_rel'.
type PgPublicationRel struct {
	Tableoid pgtypes.Oid `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid `json:"ctid"`     // ctid
	Oid      pgtypes.Oid `json:"oid"`      // oid
	Prpubid  pgtypes.Oid `json:"prpubid"`  // prpubid
	Prrelid  pgtypes.Oid `json:"prrelid"`  // prrelid
}

// PgPublicationTable represents a row from 'pg_catalog.pg_publication_tables'.
type PgPublicationTable struct {
	Pubname    pgtypes.Name `json:"pubname"`    // pubname
	Schemaname pgtypes.Name `json:"schemaname"` // schemaname
	Tablename  pgtypes.Name `json:"tablename"`  // tablename
}

// PgRange represents a row from 'pg_catalog.pg_range'.
type PgRange struct {
	Tableoid     pgtypes.Oid     `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid     `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid     `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid     `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid     `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid     `json:"ctid"`         // ctid
	Rngtypid     pgtypes.Oid     `json:"rngtypid"`     // rngtypid
	Rngsubtype   pgtypes.Oid     `json:"rngsubtype"`   // rngsubtype
	Rngcollation pgtypes.Oid     `json:"rngcollation"` // rngcollation
	Rngsubopc    pgtypes.Oid     `json:"rngsubopc"`    // rngsubopc
	Rngcanonical pgtypes.Regproc `json:"rngcanonical"` // rngcanonical
	Rngsubdiff   pgtypes.Regproc `json:"rngsubdiff"`   // rngsubdiff
}

// PgReplicationOrigin represents a row from 'pg_catalog.pg_replication_origin'.
type PgReplicationOrigin struct {
	Tableoid pgtypes.Oid `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid `json:"ctid"`     // ctid
	Roident  pgtypes.Oid `json:"roident"`  // roident
	Roname   string      `json:"roname"`   // roname
}

// PgReplicationOriginStatus represents a row from 'pg_catalog.pg_replication_origin_status'.
type PgReplicationOriginStatus struct {
	LocalID    pgtypes.Oid    `json:"local_id"`    // local_id
	ExternalID sql.NullString `json:"external_id"` // external_id
	RemoteLsn  pgtypes.PgLsn  `json:"remote_lsn"`  // remote_lsn
	LocalLsn   pgtypes.PgLsn  `json:"local_lsn"`   // local_lsn
}

// PgReplicationSlot represents a row from 'pg_catalog.pg_replication_slots'.
type PgReplicationSlot struct {
	SlotName          pgtypes.Name   `json:"slot_name"`           // slot_name
	Plugin            pgtypes.Name   `json:"plugin"`              // plugin
	SlotType          sql.NullString `json:"slot_type"`           // slot_type
	Datoid            pgtypes.Oid    `json:"datoid"`              // datoid
	Database          pgtypes.Name   `json:"database"`            // database
	Temporary         sql.NullBool   `json:"temporary"`           // temporary
	Active            sql.NullBool   `json:"active"`              // active
	ActivePid         sql.NullInt64  `json:"active_pid"`          // active_pid
	Xmin              pgtypes.Xid    `json:"xmin"`                // xmin
	CatalogXmin       pgtypes.Xid    `json:"catalog_xmin"`        // catalog_xmin
	RestartLsn        pgtypes.PgLsn  `json:"restart_lsn"`         // restart_lsn
	ConfirmedFlushLsn pgtypes.PgLsn  `json:"confirmed_flush_lsn"` // confirmed_flush_lsn
	WalStatus         sql.NullString `json:"wal_status"`          // wal_status
	SafeWalSize       sql.NullInt64  `json:"safe_wal_size"`       // safe_wal_size
}

// PgRewrite represents a row from 'pg_catalog.pg_rewrite'.
type PgRewrite struct {
	Tableoid  pgtypes.Oid        `json:"tableoid"`   // tableoid
	Cmax      pgtypes.Cid        `json:"cmax"`       // cmax
	Xmax      pgtypes.Xid        `json:"xmax"`       // xmax
	Cmin      pgtypes.Cid        `json:"cmin"`       // cmin
	Xmin      pgtypes.Xid        `json:"xmin"`       // xmin
	Ctid      pgtypes.Tid        `json:"ctid"`       // ctid
	Oid       pgtypes.Oid        `json:"oid"`        // oid
	Rulename  pgtypes.Name       `json:"rulename"`   // rulename
	EvClass   pgtypes.Oid        `json:"ev_class"`   // ev_class
	EvType    pgtypes.Char       `json:"ev_type"`    // ev_type
	EvEnabled pgtypes.Char       `json:"ev_enabled"` // ev_enabled
	IsInstead bool               `json:"is_instead"` // is_instead
	EvQual    pgtypes.PgNodeTree `json:"ev_qual"`    // ev_qual
	EvAction  pgtypes.PgNodeTree `json:"ev_action"`  // ev_action
}

// PgRole represents a row from 'pg_catalog.pg_roles'.
type PgRole struct {
	Rolname        pgtypes.Name     `json:"rolname"`        // rolname
	Rolsuper       sql.NullBool     `json:"rolsuper"`       // rolsuper
	Rolinherit     sql.NullBool     `json:"rolinherit"`     // rolinherit
	Rolcreaterole  sql.NullBool     `json:"rolcreaterole"`  // rolcreaterole
	Rolcreatedb    sql.NullBool     `json:"rolcreatedb"`    // rolcreatedb
	Rolcanlogin    sql.NullBool     `json:"rolcanlogin"`    // rolcanlogin
	Rolreplication sql.NullBool     `json:"rolreplication"` // rolreplication
	Rolconnlimit   sql.NullInt64    `json:"rolconnlimit"`   // rolconnlimit
	Rolpassword    sql.NullString   `json:"rolpassword"`    // rolpassword
	Rolvaliduntil  sql.NullTime     `json:"rolvaliduntil"`  // rolvaliduntil
	Rolbypassrls   sql.NullBool     `json:"rolbypassrls"`   // rolbypassrls
	Rolconfig      []sql.NullString `json:"rolconfig"`      // rolconfig
	Oid            pgtypes.Oid      `json:"oid"`            // oid
}

// PgRule represents a row from 'pg_catalog.pg_rules'.
type PgRule struct {
	Schemaname pgtypes.Name   `json:"schemaname"` // schemaname
	Tablename  pgtypes.Name   `json:"tablename"`  // tablename
	Rulename   pgtypes.Name   `json:"rulename"`   // rulename
	Definition sql.NullString `json:"definition"` // definition
}

// PgSeclabel represents a row from 'pg_catalog.pg_seclabels'.
type PgSeclabel struct {
	Objoid       pgtypes.Oid    `json:"objoid"`       // objoid
	Classoid     pgtypes.Oid    `json:"classoid"`     // classoid
	Objsubid     sql.NullInt64  `json:"objsubid"`     // objsubid
	Objtype      sql.NullString `json:"objtype"`      // objtype
	Objnamespace pgtypes.Oid    `json:"objnamespace"` // objnamespace
	Objname      sql.NullString `json:"objname"`      // objname
	Provider     sql.NullString `json:"provider"`     // provider
	Label        sql.NullString `json:"label"`        // label
}

// PgSeclabel represents a row from 'pg_catalog.pg_seclabel'.
type PgSeclabel struct {
	Tableoid pgtypes.Oid `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid `json:"ctid"`     // ctid
	Objoid   pgtypes.Oid `json:"objoid"`   // objoid
	Classoid pgtypes.Oid `json:"classoid"` // classoid
	Objsubid int         `json:"objsubid"` // objsubid
	Provider string      `json:"provider"` // provider
	Label    string      `json:"label"`    // label
}

// PgSequence represents a row from 'pg_catalog.pg_sequence'.
type PgSequence struct {
	Tableoid     pgtypes.Oid `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid `json:"ctid"`         // ctid
	Seqrelid     pgtypes.Oid `json:"seqrelid"`     // seqrelid
	Seqtypid     pgtypes.Oid `json:"seqtypid"`     // seqtypid
	Seqstart     int64       `json:"seqstart"`     // seqstart
	Seqincrement int64       `json:"seqincrement"` // seqincrement
	Seqmax       int64       `json:"seqmax"`       // seqmax
	Seqmin       int64       `json:"seqmin"`       // seqmin
	Seqcache     int64       `json:"seqcache"`     // seqcache
	Seqcycle     bool        `json:"seqcycle"`     // seqcycle
}

// PgSequence represents a row from 'pg_catalog.pg_sequences'.
type PgSequence struct {
	Schemaname    pgtypes.Name    `json:"schemaname"`    // schemaname
	Sequencename  pgtypes.Name    `json:"sequencename"`  // sequencename
	Sequenceowner pgtypes.Name    `json:"sequenceowner"` // sequenceowner
	DataType      pgtypes.Regtype `json:"data_type"`     // data_type
	StartValue    sql.NullInt64   `json:"start_value"`   // start_value
	MinValue      sql.NullInt64   `json:"min_value"`     // min_value
	MaxValue      sql.NullInt64   `json:"max_value"`     // max_value
	IncrementBy   sql.NullInt64   `json:"increment_by"`  // increment_by
	Cycle         sql.NullBool    `json:"cycle"`         // cycle
	CacheSize     sql.NullInt64   `json:"cache_size"`    // cache_size
	LastValue     sql.NullInt64   `json:"last_value"`    // last_value
}

// PgSetting represents a row from 'pg_catalog.pg_settings'.
type PgSetting struct {
	Name           sql.NullString   `json:"name"`            // name
	Setting        sql.NullString   `json:"setting"`         // setting
	Unit           sql.NullString   `json:"unit"`            // unit
	Category       sql.NullString   `json:"category"`        // category
	ShortDesc      sql.NullString   `json:"short_desc"`      // short_desc
	ExtraDesc      sql.NullString   `json:"extra_desc"`      // extra_desc
	Context        sql.NullString   `json:"context"`         // context
	Vartype        sql.NullString   `json:"vartype"`         // vartype
	Source         sql.NullString   `json:"source"`          // source
	MinVal         sql.NullString   `json:"min_val"`         // min_val
	MaxVal         sql.NullString   `json:"max_val"`         // max_val
	Enumvals       []sql.NullString `json:"enumvals"`        // enumvals
	BootVal        sql.NullString   `json:"boot_val"`        // boot_val
	ResetVal       sql.NullString   `json:"reset_val"`       // reset_val
	Sourcefile     sql.NullString   `json:"sourcefile"`      // sourcefile
	Sourceline     sql.NullInt64    `json:"sourceline"`      // sourceline
	PendingRestart sql.NullBool     `json:"pending_restart"` // pending_restart
}

// PgShadow represents a row from 'pg_catalog.pg_shadow'.
type PgShadow struct {
	Usename      pgtypes.Name     `json:"usename"`      // usename
	Usesysid     pgtypes.Oid      `json:"usesysid"`     // usesysid
	Usecreatedb  sql.NullBool     `json:"usecreatedb"`  // usecreatedb
	Usesuper     sql.NullBool     `json:"usesuper"`     // usesuper
	Userepl      sql.NullBool     `json:"userepl"`      // userepl
	Usebypassrls sql.NullBool     `json:"usebypassrls"` // usebypassrls
	Passwd       sql.NullString   `json:"passwd"`       // passwd
	Valuntil     sql.NullTime     `json:"valuntil"`     // valuntil
	Useconfig    []sql.NullString `json:"useconfig"`    // useconfig
}

// PgShdepend represents a row from 'pg_catalog.pg_shdepend'.
type PgShdepend struct {
	Tableoid   pgtypes.Oid  `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid  `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid  `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid  `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid  `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid  `json:"ctid"`       // ctid
	Dbid       pgtypes.Oid  `json:"dbid"`       // dbid
	Classid    pgtypes.Oid  `json:"classid"`    // classid
	Objid      pgtypes.Oid  `json:"objid"`      // objid
	Objsubid   int          `json:"objsubid"`   // objsubid
	Refclassid pgtypes.Oid  `json:"refclassid"` // refclassid
	Refobjid   pgtypes.Oid  `json:"refobjid"`   // refobjid
	Deptype    pgtypes.Char `json:"deptype"`    // deptype
}

// PgShdescription represents a row from 'pg_catalog.pg_shdescription'.
type PgShdescription struct {
	Tableoid    pgtypes.Oid `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid `json:"ctid"`        // ctid
	Objoid      pgtypes.Oid `json:"objoid"`      // objoid
	Classoid    pgtypes.Oid `json:"classoid"`    // classoid
	Description string      `json:"description"` // description
}

// PgShmemAllocation represents a row from 'pg_catalog.pg_shmem_allocations'.
type PgShmemAllocation struct {
	Name          sql.NullString `json:"name"`           // name
	Off           sql.NullInt64  `json:"off"`            // off
	Size          sql.NullInt64  `json:"size"`           // size
	AllocatedSize sql.NullInt64  `json:"allocated_size"` // allocated_size
}

// PgShseclabel represents a row from 'pg_catalog.pg_shseclabel'.
type PgShseclabel struct {
	Tableoid pgtypes.Oid `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid `json:"ctid"`     // ctid
	Objoid   pgtypes.Oid `json:"objoid"`   // objoid
	Classoid pgtypes.Oid `json:"classoid"` // classoid
	Provider string      `json:"provider"` // provider
	Label    string      `json:"label"`    // label
}

// PgStat represents a row from 'pg_catalog.pg_stats'.
type PgStat struct {
	Schemaname          pgtypes.Name      `json:"schemaname"`             // schemaname
	Tablename           pgtypes.Name      `json:"tablename"`              // tablename
	Attname             pgtypes.Name      `json:"attname"`                // attname
	Inherited           sql.NullBool      `json:"inherited"`              // inherited
	NullFrac            sql.NullFloat64   `json:"null_frac"`              // null_frac
	AvgWidth            sql.NullInt64     `json:"avg_width"`              // avg_width
	NDistinct           sql.NullFloat64   `json:"n_distinct"`             // n_distinct
	MostCommonVals      pgtypes.Anyarray  `json:"most_common_vals"`       // most_common_vals
	MostCommonFreqs     []sql.NullFloat64 `json:"most_common_freqs"`      // most_common_freqs
	HistogramBounds     pgtypes.Anyarray  `json:"histogram_bounds"`       // histogram_bounds
	Correlation         sql.NullFloat64   `json:"correlation"`            // correlation
	MostCommonElems     pgtypes.Anyarray  `json:"most_common_elems"`      // most_common_elems
	MostCommonElemFreqs []sql.NullFloat64 `json:"most_common_elem_freqs"` // most_common_elem_freqs
	ElemCountHistogram  []sql.NullFloat64 `json:"elem_count_histogram"`   // elem_count_histogram
}

// PgStatActivity represents a row from 'pg_catalog.pg_stat_activity'.
type PgStatActivity struct {
	Datid           pgtypes.Oid    `json:"datid"`            // datid
	Datname         pgtypes.Name   `json:"datname"`          // datname
	Pid             sql.NullInt64  `json:"pid"`              // pid
	LeaderPid       sql.NullInt64  `json:"leader_pid"`       // leader_pid
	Usesysid        pgtypes.Oid    `json:"usesysid"`         // usesysid
	Usename         pgtypes.Name   `json:"usename"`          // usename
	ApplicationName sql.NullString `json:"application_name"` // application_name
	ClientAddr      sql.NullString `json:"client_addr"`      // client_addr
	ClientHostname  sql.NullString `json:"client_hostname"`  // client_hostname
	ClientPort      sql.NullInt64  `json:"client_port"`      // client_port
	BackendStart    sql.NullTime   `json:"backend_start"`    // backend_start
	XactStart       sql.NullTime   `json:"xact_start"`       // xact_start
	QueryStart      sql.NullTime   `json:"query_start"`      // query_start
	StateChange     sql.NullTime   `json:"state_change"`     // state_change
	WaitEventType   sql.NullString `json:"wait_event_type"`  // wait_event_type
	WaitEvent       sql.NullString `json:"wait_event"`       // wait_event
	State           sql.NullString `json:"state"`            // state
	BackendXid      pgtypes.Xid    `json:"backend_xid"`      // backend_xid
	BackendXmin     pgtypes.Xid    `json:"backend_xmin"`     // backend_xmin
	Query           sql.NullString `json:"query"`            // query
	BackendType     sql.NullString `json:"backend_type"`     // backend_type
}

// PgStatAllIndex represents a row from 'pg_catalog.pg_stat_all_indexes'.
type PgStatAllIndex struct {
	Relid        pgtypes.Oid   `json:"relid"`         // relid
	Indexrelid   pgtypes.Oid   `json:"indexrelid"`    // indexrelid
	Schemaname   pgtypes.Name  `json:"schemaname"`    // schemaname
	Relname      pgtypes.Name  `json:"relname"`       // relname
	Indexrelname pgtypes.Name  `json:"indexrelname"`  // indexrelname
	IdxScan      sql.NullInt64 `json:"idx_scan"`      // idx_scan
	IdxTupRead   sql.NullInt64 `json:"idx_tup_read"`  // idx_tup_read
	IdxTupFetch  sql.NullInt64 `json:"idx_tup_fetch"` // idx_tup_fetch
}

// PgStatAllTable represents a row from 'pg_catalog.pg_stat_all_tables'.
type PgStatAllTable struct {
	Relid            pgtypes.Oid   `json:"relid"`               // relid
	Schemaname       pgtypes.Name  `json:"schemaname"`          // schemaname
	Relname          pgtypes.Name  `json:"relname"`             // relname
	SeqScan          sql.NullInt64 `json:"seq_scan"`            // seq_scan
	SeqTupRead       sql.NullInt64 `json:"seq_tup_read"`        // seq_tup_read
	IdxScan          sql.NullInt64 `json:"idx_scan"`            // idx_scan
	IdxTupFetch      sql.NullInt64 `json:"idx_tup_fetch"`       // idx_tup_fetch
	NTupIns          sql.NullInt64 `json:"n_tup_ins"`           // n_tup_ins
	NTupUpd          sql.NullInt64 `json:"n_tup_upd"`           // n_tup_upd
	NTupDel          sql.NullInt64 `json:"n_tup_del"`           // n_tup_del
	NTupHotUpd       sql.NullInt64 `json:"n_tup_hot_upd"`       // n_tup_hot_upd
	NLiveTup         sql.NullInt64 `json:"n_live_tup"`          // n_live_tup
	NDeadTup         sql.NullInt64 `json:"n_dead_tup"`          // n_dead_tup
	NModSinceAnalyze sql.NullInt64 `json:"n_mod_since_analyze"` // n_mod_since_analyze
	NInsSinceVacuum  sql.NullInt64 `json:"n_ins_since_vacuum"`  // n_ins_since_vacuum
	LastVacuum       sql.NullTime  `json:"last_vacuum"`         // last_vacuum
	LastAutovacuum   sql.NullTime  `json:"last_autovacuum"`     // last_autovacuum
	LastAnalyze      sql.NullTime  `json:"last_analyze"`        // last_analyze
	LastAutoanalyze  sql.NullTime  `json:"last_autoanalyze"`    // last_autoanalyze
	VacuumCount      sql.NullInt64 `json:"vacuum_count"`        // vacuum_count
	AutovacuumCount  sql.NullInt64 `json:"autovacuum_count"`    // autovacuum_count
	AnalyzeCount     sql.NullInt64 `json:"analyze_count"`       // analyze_count
	AutoanalyzeCount sql.NullInt64 `json:"autoanalyze_count"`   // autoanalyze_count
}

// PgStatArchiver represents a row from 'pg_catalog.pg_stat_archiver'.
type PgStatArchiver struct {
	ArchivedCount    sql.NullInt64  `json:"archived_count"`     // archived_count
	LastArchivedWal  sql.NullString `json:"last_archived_wal"`  // last_archived_wal
	LastArchivedTime sql.NullTime   `json:"last_archived_time"` // last_archived_time
	FailedCount      sql.NullInt64  `json:"failed_count"`       // failed_count
	LastFailedWal    sql.NullString `json:"last_failed_wal"`    // last_failed_wal
	LastFailedTime   sql.NullTime   `json:"last_failed_time"`   // last_failed_time
	StatsReset       sql.NullTime   `json:"stats_reset"`        // stats_reset
}

// PgStatBgwriter represents a row from 'pg_catalog.pg_stat_bgwriter'.
type PgStatBgwriter struct {
	CheckpointsTimed    sql.NullInt64   `json:"checkpoints_timed"`     // checkpoints_timed
	CheckpointsReq      sql.NullInt64   `json:"checkpoints_req"`       // checkpoints_req
	CheckpointWriteTime sql.NullFloat64 `json:"checkpoint_write_time"` // checkpoint_write_time
	CheckpointSyncTime  sql.NullFloat64 `json:"checkpoint_sync_time"`  // checkpoint_sync_time
	BuffersCheckpoint   sql.NullInt64   `json:"buffers_checkpoint"`    // buffers_checkpoint
	BuffersClean        sql.NullInt64   `json:"buffers_clean"`         // buffers_clean
	MaxwrittenClean     sql.NullInt64   `json:"maxwritten_clean"`      // maxwritten_clean
	BuffersBackend      sql.NullInt64   `json:"buffers_backend"`       // buffers_backend
	BuffersBackendFsync sql.NullInt64   `json:"buffers_backend_fsync"` // buffers_backend_fsync
	BuffersAlloc        sql.NullInt64   `json:"buffers_alloc"`         // buffers_alloc
	StatsReset          sql.NullTime    `json:"stats_reset"`           // stats_reset
}

// PgStatDatabase represents a row from 'pg_catalog.pg_stat_database'.
type PgStatDatabase struct {
	Datid               pgtypes.Oid     `json:"datid"`                 // datid
	Datname             pgtypes.Name    `json:"datname"`               // datname
	Numbackends         sql.NullInt64   `json:"numbackends"`           // numbackends
	XactCommit          sql.NullInt64   `json:"xact_commit"`           // xact_commit
	XactRollback        sql.NullInt64   `json:"xact_rollback"`         // xact_rollback
	BlksRead            sql.NullInt64   `json:"blks_read"`             // blks_read
	BlksHit             sql.NullInt64   `json:"blks_hit"`              // blks_hit
	TupReturned         sql.NullInt64   `json:"tup_returned"`          // tup_returned
	TupFetched          sql.NullInt64   `json:"tup_fetched"`           // tup_fetched
	TupInserted         sql.NullInt64   `json:"tup_inserted"`          // tup_inserted
	TupUpdated          sql.NullInt64   `json:"tup_updated"`           // tup_updated
	TupDeleted          sql.NullInt64   `json:"tup_deleted"`           // tup_deleted
	Conflicts           sql.NullInt64   `json:"conflicts"`             // conflicts
	TempFiles           sql.NullInt64   `json:"temp_files"`            // temp_files
	TempBytes           sql.NullInt64   `json:"temp_bytes"`            // temp_bytes
	Deadlocks           sql.NullInt64   `json:"deadlocks"`             // deadlocks
	ChecksumFailures    sql.NullInt64   `json:"checksum_failures"`     // checksum_failures
	ChecksumLastFailure sql.NullTime    `json:"checksum_last_failure"` // checksum_last_failure
	BlkReadTime         sql.NullFloat64 `json:"blk_read_time"`         // blk_read_time
	BlkWriteTime        sql.NullFloat64 `json:"blk_write_time"`        // blk_write_time
	StatsReset          sql.NullTime    `json:"stats_reset"`           // stats_reset
}

// PgStatDatabaseConflict represents a row from 'pg_catalog.pg_stat_database_conflicts'.
type PgStatDatabaseConflict struct {
	Datid           pgtypes.Oid   `json:"datid"`            // datid
	Datname         pgtypes.Name  `json:"datname"`          // datname
	ConflTablespace sql.NullInt64 `json:"confl_tablespace"` // confl_tablespace
	ConflLock       sql.NullInt64 `json:"confl_lock"`       // confl_lock
	ConflSnapshot   sql.NullInt64 `json:"confl_snapshot"`   // confl_snapshot
	ConflBufferpin  sql.NullInt64 `json:"confl_bufferpin"`  // confl_bufferpin
	ConflDeadlock   sql.NullInt64 `json:"confl_deadlock"`   // confl_deadlock
}

// PgStatGssapi represents a row from 'pg_catalog.pg_stat_gssapi'.
type PgStatGssapi struct {
	Pid              sql.NullInt64  `json:"pid"`               // pid
	GssAuthenticated sql.NullBool   `json:"gss_authenticated"` // gss_authenticated
	Principal        sql.NullString `json:"principal"`         // principal
	Encrypted        sql.NullBool   `json:"encrypted"`         // encrypted
}

// PgStatProgressAnalyze represents a row from 'pg_catalog.pg_stat_progress_analyze'.
type PgStatProgressAnalyze struct {
	Pid                    sql.NullInt64  `json:"pid"`                       // pid
	Datid                  pgtypes.Oid    `json:"datid"`                     // datid
	Datname                pgtypes.Name   `json:"datname"`                   // datname
	Relid                  pgtypes.Oid    `json:"relid"`                     // relid
	Phase                  sql.NullString `json:"phase"`                     // phase
	SampleBlksTotal        sql.NullInt64  `json:"sample_blks_total"`         // sample_blks_total
	SampleBlksScanned      sql.NullInt64  `json:"sample_blks_scanned"`       // sample_blks_scanned
	ExtStatsTotal          sql.NullInt64  `json:"ext_stats_total"`           // ext_stats_total
	ExtStatsComputed       sql.NullInt64  `json:"ext_stats_computed"`        // ext_stats_computed
	ChildTablesTotal       sql.NullInt64  `json:"child_tables_total"`        // child_tables_total
	ChildTablesDone        sql.NullInt64  `json:"child_tables_done"`         // child_tables_done
	CurrentChildTableRelid pgtypes.Oid    `json:"current_child_table_relid"` // current_child_table_relid
}

// PgStatProgressBasebackup represents a row from 'pg_catalog.pg_stat_progress_basebackup'.
type PgStatProgressBasebackup struct {
	Pid                 sql.NullInt64  `json:"pid"`                  // pid
	Phase               sql.NullString `json:"phase"`                // phase
	BackupTotal         sql.NullInt64  `json:"backup_total"`         // backup_total
	BackupStreamed      sql.NullInt64  `json:"backup_streamed"`      // backup_streamed
	TablespacesTotal    sql.NullInt64  `json:"tablespaces_total"`    // tablespaces_total
	TablespacesStreamed sql.NullInt64  `json:"tablespaces_streamed"` // tablespaces_streamed
}

// PgStatProgressCluster represents a row from 'pg_catalog.pg_stat_progress_cluster'.
type PgStatProgressCluster struct {
	Pid               sql.NullInt64  `json:"pid"`                 // pid
	Datid             pgtypes.Oid    `json:"datid"`               // datid
	Datname           pgtypes.Name   `json:"datname"`             // datname
	Relid             pgtypes.Oid    `json:"relid"`               // relid
	Command           sql.NullString `json:"command"`             // command
	Phase             sql.NullString `json:"phase"`               // phase
	ClusterIndexRelid pgtypes.Oid    `json:"cluster_index_relid"` // cluster_index_relid
	HeapTuplesScanned sql.NullInt64  `json:"heap_tuples_scanned"` // heap_tuples_scanned
	HeapTuplesWritten sql.NullInt64  `json:"heap_tuples_written"` // heap_tuples_written
	HeapBlksTotal     sql.NullInt64  `json:"heap_blks_total"`     // heap_blks_total
	HeapBlksScanned   sql.NullInt64  `json:"heap_blks_scanned"`   // heap_blks_scanned
	IndexRebuildCount sql.NullInt64  `json:"index_rebuild_count"` // index_rebuild_count
}

// PgStatProgressCreateIndex represents a row from 'pg_catalog.pg_stat_progress_create_index'.
type PgStatProgressCreateIndex struct {
	Pid              sql.NullInt64  `json:"pid"`                // pid
	Datid            pgtypes.Oid    `json:"datid"`              // datid
	Datname          pgtypes.Name   `json:"datname"`            // datname
	Relid            pgtypes.Oid    `json:"relid"`              // relid
	IndexRelid       pgtypes.Oid    `json:"index_relid"`        // index_relid
	Command          sql.NullString `json:"command"`            // command
	Phase            sql.NullString `json:"phase"`              // phase
	LockersTotal     sql.NullInt64  `json:"lockers_total"`      // lockers_total
	LockersDone      sql.NullInt64  `json:"lockers_done"`       // lockers_done
	CurrentLockerPid sql.NullInt64  `json:"current_locker_pid"` // current_locker_pid
	BlocksTotal      sql.NullInt64  `json:"blocks_total"`       // blocks_total
	BlocksDone       sql.NullInt64  `json:"blocks_done"`        // blocks_done
	TuplesTotal      sql.NullInt64  `json:"tuples_total"`       // tuples_total
	TuplesDone       sql.NullInt64  `json:"tuples_done"`        // tuples_done
	PartitionsTotal  sql.NullInt64  `json:"partitions_total"`   // partitions_total
	PartitionsDone   sql.NullInt64  `json:"partitions_done"`    // partitions_done
}

// PgStatProgressVacuum represents a row from 'pg_catalog.pg_stat_progress_vacuum'.
type PgStatProgressVacuum struct {
	Pid              sql.NullInt64  `json:"pid"`                // pid
	Datid            pgtypes.Oid    `json:"datid"`              // datid
	Datname          pgtypes.Name   `json:"datname"`            // datname
	Relid            pgtypes.Oid    `json:"relid"`              // relid
	Phase            sql.NullString `json:"phase"`              // phase
	HeapBlksTotal    sql.NullInt64  `json:"heap_blks_total"`    // heap_blks_total
	HeapBlksScanned  sql.NullInt64  `json:"heap_blks_scanned"`  // heap_blks_scanned
	HeapBlksVacuumed sql.NullInt64  `json:"heap_blks_vacuumed"` // heap_blks_vacuumed
	IndexVacuumCount sql.NullInt64  `json:"index_vacuum_count"` // index_vacuum_count
	MaxDeadTuples    sql.NullInt64  `json:"max_dead_tuples"`    // max_dead_tuples
	NumDeadTuples    sql.NullInt64  `json:"num_dead_tuples"`    // num_dead_tuples
}

// PgStatReplication represents a row from 'pg_catalog.pg_stat_replication'.
type PgStatReplication struct {
	Pid             sql.NullInt64  `json:"pid"`              // pid
	Usesysid        pgtypes.Oid    `json:"usesysid"`         // usesysid
	Usename         pgtypes.Name   `json:"usename"`          // usename
	ApplicationName sql.NullString `json:"application_name"` // application_name
	ClientAddr      sql.NullString `json:"client_addr"`      // client_addr
	ClientHostname  sql.NullString `json:"client_hostname"`  // client_hostname
	ClientPort      sql.NullInt64  `json:"client_port"`      // client_port
	BackendStart    sql.NullTime   `json:"backend_start"`    // backend_start
	BackendXmin     pgtypes.Xid    `json:"backend_xmin"`     // backend_xmin
	State           sql.NullString `json:"state"`            // state
	SentLsn         pgtypes.PgLsn  `json:"sent_lsn"`         // sent_lsn
	WriteLsn        pgtypes.PgLsn  `json:"write_lsn"`        // write_lsn
	FlushLsn        pgtypes.PgLsn  `json:"flush_lsn"`        // flush_lsn
	ReplayLsn       pgtypes.PgLsn  `json:"replay_lsn"`       // replay_lsn
	WriteLag        []byte         `json:"write_lag"`        // write_lag
	FlushLag        []byte         `json:"flush_lag"`        // flush_lag
	ReplayLag       []byte         `json:"replay_lag"`       // replay_lag
	SyncPriority    sql.NullInt64  `json:"sync_priority"`    // sync_priority
	SyncState       sql.NullString `json:"sync_state"`       // sync_state
	ReplyTime       sql.NullTime   `json:"reply_time"`       // reply_time
}

// PgStatSlru represents a row from 'pg_catalog.pg_stat_slru'.
type PgStatSlru struct {
	Name        sql.NullString `json:"name"`         // name
	BlksZeroed  sql.NullInt64  `json:"blks_zeroed"`  // blks_zeroed
	BlksHit     sql.NullInt64  `json:"blks_hit"`     // blks_hit
	BlksRead    sql.NullInt64  `json:"blks_read"`    // blks_read
	BlksWritten sql.NullInt64  `json:"blks_written"` // blks_written
	BlksExists  sql.NullInt64  `json:"blks_exists"`  // blks_exists
	Flushes     sql.NullInt64  `json:"flushes"`      // flushes
	Truncates   sql.NullInt64  `json:"truncates"`    // truncates
	StatsReset  sql.NullTime   `json:"stats_reset"`  // stats_reset
}

// PgStatSsl represents a row from 'pg_catalog.pg_stat_ssl'.
type PgStatSsl struct {
	Pid          sql.NullInt64   `json:"pid"`           // pid
	Ssl          sql.NullBool    `json:"ssl"`           // ssl
	Version      sql.NullString  `json:"version"`       // version
	Cipher       sql.NullString  `json:"cipher"`        // cipher
	Bits         sql.NullInt64   `json:"bits"`          // bits
	Compression  sql.NullBool    `json:"compression"`   // compression
	ClientDn     sql.NullString  `json:"client_dn"`     // client_dn
	ClientSerial sql.NullFloat64 `json:"client_serial"` // client_serial
	IssuerDn     sql.NullString  `json:"issuer_dn"`     // issuer_dn
}

// PgStatSubscription represents a row from 'pg_catalog.pg_stat_subscription'.
type PgStatSubscription struct {
	Subid              pgtypes.Oid   `json:"subid"`                 // subid
	Subname            pgtypes.Name  `json:"subname"`               // subname
	Pid                sql.NullInt64 `json:"pid"`                   // pid
	Relid              pgtypes.Oid   `json:"relid"`                 // relid
	ReceivedLsn        pgtypes.PgLsn `json:"received_lsn"`          // received_lsn
	LastMsgSendTime    sql.NullTime  `json:"last_msg_send_time"`    // last_msg_send_time
	LastMsgReceiptTime sql.NullTime  `json:"last_msg_receipt_time"` // last_msg_receipt_time
	LatestEndLsn       pgtypes.PgLsn `json:"latest_end_lsn"`        // latest_end_lsn
	LatestEndTime      sql.NullTime  `json:"latest_end_time"`       // latest_end_time
}

// PgStatSysIndex represents a row from 'pg_catalog.pg_stat_sys_indexes'.
type PgStatSysIndex struct {
	Relid        pgtypes.Oid   `json:"relid"`         // relid
	Indexrelid   pgtypes.Oid   `json:"indexrelid"`    // indexrelid
	Schemaname   pgtypes.Name  `json:"schemaname"`    // schemaname
	Relname      pgtypes.Name  `json:"relname"`       // relname
	Indexrelname pgtypes.Name  `json:"indexrelname"`  // indexrelname
	IdxScan      sql.NullInt64 `json:"idx_scan"`      // idx_scan
	IdxTupRead   sql.NullInt64 `json:"idx_tup_read"`  // idx_tup_read
	IdxTupFetch  sql.NullInt64 `json:"idx_tup_fetch"` // idx_tup_fetch
}

// PgStatSysTable represents a row from 'pg_catalog.pg_stat_sys_tables'.
type PgStatSysTable struct {
	Relid            pgtypes.Oid   `json:"relid"`               // relid
	Schemaname       pgtypes.Name  `json:"schemaname"`          // schemaname
	Relname          pgtypes.Name  `json:"relname"`             // relname
	SeqScan          sql.NullInt64 `json:"seq_scan"`            // seq_scan
	SeqTupRead       sql.NullInt64 `json:"seq_tup_read"`        // seq_tup_read
	IdxScan          sql.NullInt64 `json:"idx_scan"`            // idx_scan
	IdxTupFetch      sql.NullInt64 `json:"idx_tup_fetch"`       // idx_tup_fetch
	NTupIns          sql.NullInt64 `json:"n_tup_ins"`           // n_tup_ins
	NTupUpd          sql.NullInt64 `json:"n_tup_upd"`           // n_tup_upd
	NTupDel          sql.NullInt64 `json:"n_tup_del"`           // n_tup_del
	NTupHotUpd       sql.NullInt64 `json:"n_tup_hot_upd"`       // n_tup_hot_upd
	NLiveTup         sql.NullInt64 `json:"n_live_tup"`          // n_live_tup
	NDeadTup         sql.NullInt64 `json:"n_dead_tup"`          // n_dead_tup
	NModSinceAnalyze sql.NullInt64 `json:"n_mod_since_analyze"` // n_mod_since_analyze
	NInsSinceVacuum  sql.NullInt64 `json:"n_ins_since_vacuum"`  // n_ins_since_vacuum
	LastVacuum       sql.NullTime  `json:"last_vacuum"`         // last_vacuum
	LastAutovacuum   sql.NullTime  `json:"last_autovacuum"`     // last_autovacuum
	LastAnalyze      sql.NullTime  `json:"last_analyze"`        // last_analyze
	LastAutoanalyze  sql.NullTime  `json:"last_autoanalyze"`    // last_autoanalyze
	VacuumCount      sql.NullInt64 `json:"vacuum_count"`        // vacuum_count
	AutovacuumCount  sql.NullInt64 `json:"autovacuum_count"`    // autovacuum_count
	AnalyzeCount     sql.NullInt64 `json:"analyze_count"`       // analyze_count
	AutoanalyzeCount sql.NullInt64 `json:"autoanalyze_count"`   // autoanalyze_count
}

// PgStatUserFunction represents a row from 'pg_catalog.pg_stat_user_functions'.
type PgStatUserFunction struct {
	Funcid     pgtypes.Oid     `json:"funcid"`     // funcid
	Schemaname pgtypes.Name    `json:"schemaname"` // schemaname
	Funcname   pgtypes.Name    `json:"funcname"`   // funcname
	Calls      sql.NullInt64   `json:"calls"`      // calls
	TotalTime  sql.NullFloat64 `json:"total_time"` // total_time
	SelfTime   sql.NullFloat64 `json:"self_time"`  // self_time
}

// PgStatUserIndex represents a row from 'pg_catalog.pg_stat_user_indexes'.
type PgStatUserIndex struct {
	Relid        pgtypes.Oid   `json:"relid"`         // relid
	Indexrelid   pgtypes.Oid   `json:"indexrelid"`    // indexrelid
	Schemaname   pgtypes.Name  `json:"schemaname"`    // schemaname
	Relname      pgtypes.Name  `json:"relname"`       // relname
	Indexrelname pgtypes.Name  `json:"indexrelname"`  // indexrelname
	IdxScan      sql.NullInt64 `json:"idx_scan"`      // idx_scan
	IdxTupRead   sql.NullInt64 `json:"idx_tup_read"`  // idx_tup_read
	IdxTupFetch  sql.NullInt64 `json:"idx_tup_fetch"` // idx_tup_fetch
}

// PgStatUserTable represents a row from 'pg_catalog.pg_stat_user_tables'.
type PgStatUserTable struct {
	Relid            pgtypes.Oid   `json:"relid"`               // relid
	Schemaname       pgtypes.Name  `json:"schemaname"`          // schemaname
	Relname          pgtypes.Name  `json:"relname"`             // relname
	SeqScan          sql.NullInt64 `json:"seq_scan"`            // seq_scan
	SeqTupRead       sql.NullInt64 `json:"seq_tup_read"`        // seq_tup_read
	IdxScan          sql.NullInt64 `json:"idx_scan"`            // idx_scan
	IdxTupFetch      sql.NullInt64 `json:"idx_tup_fetch"`       // idx_tup_fetch
	NTupIns          sql.NullInt64 `json:"n_tup_ins"`           // n_tup_ins
	NTupUpd          sql.NullInt64 `json:"n_tup_upd"`           // n_tup_upd
	NTupDel          sql.NullInt64 `json:"n_tup_del"`           // n_tup_del
	NTupHotUpd       sql.NullInt64 `json:"n_tup_hot_upd"`       // n_tup_hot_upd
	NLiveTup         sql.NullInt64 `json:"n_live_tup"`          // n_live_tup
	NDeadTup         sql.NullInt64 `json:"n_dead_tup"`          // n_dead_tup
	NModSinceAnalyze sql.NullInt64 `json:"n_mod_since_analyze"` // n_mod_since_analyze
	NInsSinceVacuum  sql.NullInt64 `json:"n_ins_since_vacuum"`  // n_ins_since_vacuum
	LastVacuum       sql.NullTime  `json:"last_vacuum"`         // last_vacuum
	LastAutovacuum   sql.NullTime  `json:"last_autovacuum"`     // last_autovacuum
	LastAnalyze      sql.NullTime  `json:"last_analyze"`        // last_analyze
	LastAutoanalyze  sql.NullTime  `json:"last_autoanalyze"`    // last_autoanalyze
	VacuumCount      sql.NullInt64 `json:"vacuum_count"`        // vacuum_count
	AutovacuumCount  sql.NullInt64 `json:"autovacuum_count"`    // autovacuum_count
	AnalyzeCount     sql.NullInt64 `json:"analyze_count"`       // analyze_count
	AutoanalyzeCount sql.NullInt64 `json:"autoanalyze_count"`   // autoanalyze_count
}

// PgStatWalReceiver represents a row from 'pg_catalog.pg_stat_wal_receiver'.
type PgStatWalReceiver struct {
	Pid                sql.NullInt64  `json:"pid"`                   // pid
	Status             sql.NullString `json:"status"`                // status
	ReceiveStartLsn    pgtypes.PgLsn  `json:"receive_start_lsn"`     // receive_start_lsn
	ReceiveStartTli    sql.NullInt64  `json:"receive_start_tli"`     // receive_start_tli
	WrittenLsn         pgtypes.PgLsn  `json:"written_lsn"`           // written_lsn
	FlushedLsn         pgtypes.PgLsn  `json:"flushed_lsn"`           // flushed_lsn
	ReceivedTli        sql.NullInt64  `json:"received_tli"`          // received_tli
	LastMsgSendTime    sql.NullTime   `json:"last_msg_send_time"`    // last_msg_send_time
	LastMsgReceiptTime sql.NullTime   `json:"last_msg_receipt_time"` // last_msg_receipt_time
	LatestEndLsn       pgtypes.PgLsn  `json:"latest_end_lsn"`        // latest_end_lsn
	LatestEndTime      sql.NullTime   `json:"latest_end_time"`       // latest_end_time
	SlotName           sql.NullString `json:"slot_name"`             // slot_name
	SenderHost         sql.NullString `json:"sender_host"`           // sender_host
	SenderPort         sql.NullInt64  `json:"sender_port"`           // sender_port
	Conninfo           sql.NullString `json:"conninfo"`              // conninfo
}

// PgStatXactAllTable represents a row from 'pg_catalog.pg_stat_xact_all_tables'.
type PgStatXactAllTable struct {
	Relid       pgtypes.Oid   `json:"relid"`         // relid
	Schemaname  pgtypes.Name  `json:"schemaname"`    // schemaname
	Relname     pgtypes.Name  `json:"relname"`       // relname
	SeqScan     sql.NullInt64 `json:"seq_scan"`      // seq_scan
	SeqTupRead  sql.NullInt64 `json:"seq_tup_read"`  // seq_tup_read
	IdxScan     sql.NullInt64 `json:"idx_scan"`      // idx_scan
	IdxTupFetch sql.NullInt64 `json:"idx_tup_fetch"` // idx_tup_fetch
	NTupIns     sql.NullInt64 `json:"n_tup_ins"`     // n_tup_ins
	NTupUpd     sql.NullInt64 `json:"n_tup_upd"`     // n_tup_upd
	NTupDel     sql.NullInt64 `json:"n_tup_del"`     // n_tup_del
	NTupHotUpd  sql.NullInt64 `json:"n_tup_hot_upd"` // n_tup_hot_upd
}

// PgStatXactSysTable represents a row from 'pg_catalog.pg_stat_xact_sys_tables'.
type PgStatXactSysTable struct {
	Relid       pgtypes.Oid   `json:"relid"`         // relid
	Schemaname  pgtypes.Name  `json:"schemaname"`    // schemaname
	Relname     pgtypes.Name  `json:"relname"`       // relname
	SeqScan     sql.NullInt64 `json:"seq_scan"`      // seq_scan
	SeqTupRead  sql.NullInt64 `json:"seq_tup_read"`  // seq_tup_read
	IdxScan     sql.NullInt64 `json:"idx_scan"`      // idx_scan
	IdxTupFetch sql.NullInt64 `json:"idx_tup_fetch"` // idx_tup_fetch
	NTupIns     sql.NullInt64 `json:"n_tup_ins"`     // n_tup_ins
	NTupUpd     sql.NullInt64 `json:"n_tup_upd"`     // n_tup_upd
	NTupDel     sql.NullInt64 `json:"n_tup_del"`     // n_tup_del
	NTupHotUpd  sql.NullInt64 `json:"n_tup_hot_upd"` // n_tup_hot_upd
}

// PgStatXactUserFunction represents a row from 'pg_catalog.pg_stat_xact_user_functions'.
type PgStatXactUserFunction struct {
	Funcid     pgtypes.Oid     `json:"funcid"`     // funcid
	Schemaname pgtypes.Name    `json:"schemaname"` // schemaname
	Funcname   pgtypes.Name    `json:"funcname"`   // funcname
	Calls      sql.NullInt64   `json:"calls"`      // calls
	TotalTime  sql.NullFloat64 `json:"total_time"` // total_time
	SelfTime   sql.NullFloat64 `json:"self_time"`  // self_time
}

// PgStatXactUserTable represents a row from 'pg_catalog.pg_stat_xact_user_tables'.
type PgStatXactUserTable struct {
	Relid       pgtypes.Oid   `json:"relid"`         // relid
	Schemaname  pgtypes.Name  `json:"schemaname"`    // schemaname
	Relname     pgtypes.Name  `json:"relname"`       // relname
	SeqScan     sql.NullInt64 `json:"seq_scan"`      // seq_scan
	SeqTupRead  sql.NullInt64 `json:"seq_tup_read"`  // seq_tup_read
	IdxScan     sql.NullInt64 `json:"idx_scan"`      // idx_scan
	IdxTupFetch sql.NullInt64 `json:"idx_tup_fetch"` // idx_tup_fetch
	NTupIns     sql.NullInt64 `json:"n_tup_ins"`     // n_tup_ins
	NTupUpd     sql.NullInt64 `json:"n_tup_upd"`     // n_tup_upd
	NTupDel     sql.NullInt64 `json:"n_tup_del"`     // n_tup_del
	NTupHotUpd  sql.NullInt64 `json:"n_tup_hot_upd"` // n_tup_hot_upd
}

// PgStatioAllIndex represents a row from 'pg_catalog.pg_statio_all_indexes'.
type PgStatioAllIndex struct {
	Relid        pgtypes.Oid   `json:"relid"`         // relid
	Indexrelid   pgtypes.Oid   `json:"indexrelid"`    // indexrelid
	Schemaname   pgtypes.Name  `json:"schemaname"`    // schemaname
	Relname      pgtypes.Name  `json:"relname"`       // relname
	Indexrelname pgtypes.Name  `json:"indexrelname"`  // indexrelname
	IdxBlksRead  sql.NullInt64 `json:"idx_blks_read"` // idx_blks_read
	IdxBlksHit   sql.NullInt64 `json:"idx_blks_hit"`  // idx_blks_hit
}

// PgStatioAllSequence represents a row from 'pg_catalog.pg_statio_all_sequences'.
type PgStatioAllSequence struct {
	Relid      pgtypes.Oid   `json:"relid"`      // relid
	Schemaname pgtypes.Name  `json:"schemaname"` // schemaname
	Relname    pgtypes.Name  `json:"relname"`    // relname
	BlksRead   sql.NullInt64 `json:"blks_read"`  // blks_read
	BlksHit    sql.NullInt64 `json:"blks_hit"`   // blks_hit
}

// PgStatioAllTable represents a row from 'pg_catalog.pg_statio_all_tables'.
type PgStatioAllTable struct {
	Relid         pgtypes.Oid   `json:"relid"`           // relid
	Schemaname    pgtypes.Name  `json:"schemaname"`      // schemaname
	Relname       pgtypes.Name  `json:"relname"`         // relname
	HeapBlksRead  sql.NullInt64 `json:"heap_blks_read"`  // heap_blks_read
	HeapBlksHit   sql.NullInt64 `json:"heap_blks_hit"`   // heap_blks_hit
	IdxBlksRead   sql.NullInt64 `json:"idx_blks_read"`   // idx_blks_read
	IdxBlksHit    sql.NullInt64 `json:"idx_blks_hit"`    // idx_blks_hit
	ToastBlksRead sql.NullInt64 `json:"toast_blks_read"` // toast_blks_read
	ToastBlksHit  sql.NullInt64 `json:"toast_blks_hit"`  // toast_blks_hit
	TidxBlksRead  sql.NullInt64 `json:"tidx_blks_read"`  // tidx_blks_read
	TidxBlksHit   sql.NullInt64 `json:"tidx_blks_hit"`   // tidx_blks_hit
}

// PgStatioSysIndex represents a row from 'pg_catalog.pg_statio_sys_indexes'.
type PgStatioSysIndex struct {
	Relid        pgtypes.Oid   `json:"relid"`         // relid
	Indexrelid   pgtypes.Oid   `json:"indexrelid"`    // indexrelid
	Schemaname   pgtypes.Name  `json:"schemaname"`    // schemaname
	Relname      pgtypes.Name  `json:"relname"`       // relname
	Indexrelname pgtypes.Name  `json:"indexrelname"`  // indexrelname
	IdxBlksRead  sql.NullInt64 `json:"idx_blks_read"` // idx_blks_read
	IdxBlksHit   sql.NullInt64 `json:"idx_blks_hit"`  // idx_blks_hit
}

// PgStatioSysSequence represents a row from 'pg_catalog.pg_statio_sys_sequences'.
type PgStatioSysSequence struct {
	Relid      pgtypes.Oid   `json:"relid"`      // relid
	Schemaname pgtypes.Name  `json:"schemaname"` // schemaname
	Relname    pgtypes.Name  `json:"relname"`    // relname
	BlksRead   sql.NullInt64 `json:"blks_read"`  // blks_read
	BlksHit    sql.NullInt64 `json:"blks_hit"`   // blks_hit
}

// PgStatioSysTable represents a row from 'pg_catalog.pg_statio_sys_tables'.
type PgStatioSysTable struct {
	Relid         pgtypes.Oid   `json:"relid"`           // relid
	Schemaname    pgtypes.Name  `json:"schemaname"`      // schemaname
	Relname       pgtypes.Name  `json:"relname"`         // relname
	HeapBlksRead  sql.NullInt64 `json:"heap_blks_read"`  // heap_blks_read
	HeapBlksHit   sql.NullInt64 `json:"heap_blks_hit"`   // heap_blks_hit
	IdxBlksRead   sql.NullInt64 `json:"idx_blks_read"`   // idx_blks_read
	IdxBlksHit    sql.NullInt64 `json:"idx_blks_hit"`    // idx_blks_hit
	ToastBlksRead sql.NullInt64 `json:"toast_blks_read"` // toast_blks_read
	ToastBlksHit  sql.NullInt64 `json:"toast_blks_hit"`  // toast_blks_hit
	TidxBlksRead  sql.NullInt64 `json:"tidx_blks_read"`  // tidx_blks_read
	TidxBlksHit   sql.NullInt64 `json:"tidx_blks_hit"`   // tidx_blks_hit
}

// PgStatioUserIndex represents a row from 'pg_catalog.pg_statio_user_indexes'.
type PgStatioUserIndex struct {
	Relid        pgtypes.Oid   `json:"relid"`         // relid
	Indexrelid   pgtypes.Oid   `json:"indexrelid"`    // indexrelid
	Schemaname   pgtypes.Name  `json:"schemaname"`    // schemaname
	Relname      pgtypes.Name  `json:"relname"`       // relname
	Indexrelname pgtypes.Name  `json:"indexrelname"`  // indexrelname
	IdxBlksRead  sql.NullInt64 `json:"idx_blks_read"` // idx_blks_read
	IdxBlksHit   sql.NullInt64 `json:"idx_blks_hit"`  // idx_blks_hit
}

// PgStatioUserSequence represents a row from 'pg_catalog.pg_statio_user_sequences'.
type PgStatioUserSequence struct {
	Relid      pgtypes.Oid   `json:"relid"`      // relid
	Schemaname pgtypes.Name  `json:"schemaname"` // schemaname
	Relname    pgtypes.Name  `json:"relname"`    // relname
	BlksRead   sql.NullInt64 `json:"blks_read"`  // blks_read
	BlksHit    sql.NullInt64 `json:"blks_hit"`   // blks_hit
}

// PgStatioUserTable represents a row from 'pg_catalog.pg_statio_user_tables'.
type PgStatioUserTable struct {
	Relid         pgtypes.Oid   `json:"relid"`           // relid
	Schemaname    pgtypes.Name  `json:"schemaname"`      // schemaname
	Relname       pgtypes.Name  `json:"relname"`         // relname
	HeapBlksRead  sql.NullInt64 `json:"heap_blks_read"`  // heap_blks_read
	HeapBlksHit   sql.NullInt64 `json:"heap_blks_hit"`   // heap_blks_hit
	IdxBlksRead   sql.NullInt64 `json:"idx_blks_read"`   // idx_blks_read
	IdxBlksHit    sql.NullInt64 `json:"idx_blks_hit"`    // idx_blks_hit
	ToastBlksRead sql.NullInt64 `json:"toast_blks_read"` // toast_blks_read
	ToastBlksHit  sql.NullInt64 `json:"toast_blks_hit"`  // toast_blks_hit
	TidxBlksRead  sql.NullInt64 `json:"tidx_blks_read"`  // tidx_blks_read
	TidxBlksHit   sql.NullInt64 `json:"tidx_blks_hit"`   // tidx_blks_hit
}

// PgStatistic represents a row from 'pg_catalog.pg_statistic'.
type PgStatistic struct {
	Tableoid    pgtypes.Oid       `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid       `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid       `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid       `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid       `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid       `json:"ctid"`        // ctid
	Starelid    pgtypes.Oid       `json:"starelid"`    // starelid
	Staattnum   int16             `json:"staattnum"`   // staattnum
	Stainherit  bool              `json:"stainherit"`  // stainherit
	Stanullfrac float32           `json:"stanullfrac"` // stanullfrac
	Stawidth    int               `json:"stawidth"`    // stawidth
	Stadistinct float32           `json:"stadistinct"` // stadistinct
	Stakind1    int16             `json:"stakind1"`    // stakind1
	Stakind2    int16             `json:"stakind2"`    // stakind2
	Stakind3    int16             `json:"stakind3"`    // stakind3
	Stakind4    int16             `json:"stakind4"`    // stakind4
	Stakind5    int16             `json:"stakind5"`    // stakind5
	Staop1      pgtypes.Oid       `json:"staop1"`      // staop1
	Staop2      pgtypes.Oid       `json:"staop2"`      // staop2
	Staop3      pgtypes.Oid       `json:"staop3"`      // staop3
	Staop4      pgtypes.Oid       `json:"staop4"`      // staop4
	Staop5      pgtypes.Oid       `json:"staop5"`      // staop5
	Stacoll1    pgtypes.Oid       `json:"stacoll1"`    // stacoll1
	Stacoll2    pgtypes.Oid       `json:"stacoll2"`    // stacoll2
	Stacoll3    pgtypes.Oid       `json:"stacoll3"`    // stacoll3
	Stacoll4    pgtypes.Oid       `json:"stacoll4"`    // stacoll4
	Stacoll5    pgtypes.Oid       `json:"stacoll5"`    // stacoll5
	Stanumbers1 []sql.NullFloat64 `json:"stanumbers1"` // stanumbers1
	Stanumbers2 []sql.NullFloat64 `json:"stanumbers2"` // stanumbers2
	Stanumbers3 []sql.NullFloat64 `json:"stanumbers3"` // stanumbers3
	Stanumbers4 []sql.NullFloat64 `json:"stanumbers4"` // stanumbers4
	Stanumbers5 []sql.NullFloat64 `json:"stanumbers5"` // stanumbers5
	Stavalues1  pgtypes.Anyarray  `json:"stavalues1"`  // stavalues1
	Stavalues2  pgtypes.Anyarray  `json:"stavalues2"`  // stavalues2
	Stavalues3  pgtypes.Anyarray  `json:"stavalues3"`  // stavalues3
	Stavalues4  pgtypes.Anyarray  `json:"stavalues4"`  // stavalues4
	Stavalues5  pgtypes.Anyarray  `json:"stavalues5"`  // stavalues5
}

// PgStatisticExt represents a row from 'pg_catalog.pg_statistic_ext'.
type PgStatisticExt struct {
	Tableoid      pgtypes.Oid        `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid        `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid        `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid        `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid        `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid        `json:"ctid"`          // ctid
	Oid           pgtypes.Oid        `json:"oid"`           // oid
	Stxrelid      pgtypes.Oid        `json:"stxrelid"`      // stxrelid
	Stxname       pgtypes.Name       `json:"stxname"`       // stxname
	Stxnamespace  pgtypes.Oid        `json:"stxnamespace"`  // stxnamespace
	Stxowner      pgtypes.Oid        `json:"stxowner"`      // stxowner
	Stxstattarget int                `json:"stxstattarget"` // stxstattarget
	Stxkeys       pgtypes.Int2vector `json:"stxkeys"`       // stxkeys
	Stxkind       []pgtypes.Char     `json:"stxkind"`       // stxkind
}

// PgStatisticExtDatum represents a row from 'pg_catalog.pg_statistic_ext_data'.
type PgStatisticExtDatum struct {
	Tableoid         pgtypes.Oid            `json:"tableoid"`         // tableoid
	Cmax             pgtypes.Cid            `json:"cmax"`             // cmax
	Xmax             pgtypes.Xid            `json:"xmax"`             // xmax
	Cmin             pgtypes.Cid            `json:"cmin"`             // cmin
	Xmin             pgtypes.Xid            `json:"xmin"`             // xmin
	Ctid             pgtypes.Tid            `json:"ctid"`             // ctid
	Stxoid           pgtypes.Oid            `json:"stxoid"`           // stxoid
	Stxdndistinct    pgtypes.PgNdistinct    `json:"stxdndistinct"`    // stxdndistinct
	Stxddependencies pgtypes.PgDependencies `json:"stxddependencies"` // stxddependencies
	Stxdmcv          pgtypes.PgMcvList      `json:"stxdmcv"`          // stxdmcv
}

// PgStatsExt represents a row from 'pg_catalog.pg_stats_ext'.
type PgStatsExt struct {
	Schemaname           pgtypes.Name           `json:"schemaname"`             // schemaname
	Tablename            pgtypes.Name           `json:"tablename"`              // tablename
	StatisticsSchemaname pgtypes.Name           `json:"statistics_schemaname"`  // statistics_schemaname
	StatisticsName       pgtypes.Name           `json:"statistics_name"`        // statistics_name
	StatisticsOwner      pgtypes.Name           `json:"statistics_owner"`       // statistics_owner
	Attnames             []pgtypes.Name         `json:"attnames"`               // attnames
	Kinds                []pgtypes.Char         `json:"kinds"`                  // kinds
	NDistinct            pgtypes.PgNdistinct    `json:"n_distinct"`             // n_distinct
	Dependencies         pgtypes.PgDependencies `json:"dependencies"`           // dependencies
	MostCommonVals       []sql.NullString       `json:"most_common_vals"`       // most_common_vals
	MostCommonValNulls   []sql.NullBool         `json:"most_common_val_nulls"`  // most_common_val_nulls
	MostCommonFreqs      []sql.NullFloat64      `json:"most_common_freqs"`      // most_common_freqs
	MostCommonBaseFreqs  []sql.NullFloat64      `json:"most_common_base_freqs"` // most_common_base_freqs
}

// PgSubscription represents a row from 'pg_catalog.pg_subscription'.
type PgSubscription struct {
	Tableoid        pgtypes.Oid  `json:"tableoid"`        // tableoid
	Cmax            pgtypes.Cid  `json:"cmax"`            // cmax
	Xmax            pgtypes.Xid  `json:"xmax"`            // xmax
	Cmin            pgtypes.Cid  `json:"cmin"`            // cmin
	Xmin            pgtypes.Xid  `json:"xmin"`            // xmin
	Ctid            pgtypes.Tid  `json:"ctid"`            // ctid
	Oid             pgtypes.Oid  `json:"oid"`             // oid
	Subdbid         pgtypes.Oid  `json:"subdbid"`         // subdbid
	Subname         pgtypes.Name `json:"subname"`         // subname
	Subowner        pgtypes.Oid  `json:"subowner"`        // subowner
	Subenabled      bool         `json:"subenabled"`      // subenabled
	Subconninfo     string       `json:"subconninfo"`     // subconninfo
	Subslotname     pgtypes.Name `json:"subslotname"`     // subslotname
	Subsynccommit   string       `json:"subsynccommit"`   // subsynccommit
	Subpublications StringSlice  `json:"subpublications"` // subpublications
}

// PgSubscriptionRel represents a row from 'pg_catalog.pg_subscription_rel'.
type PgSubscriptionRel struct {
	Tableoid   pgtypes.Oid   `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid   `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid   `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid   `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid   `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid   `json:"ctid"`       // ctid
	Srsubid    pgtypes.Oid   `json:"srsubid"`    // srsubid
	Srrelid    pgtypes.Oid   `json:"srrelid"`    // srrelid
	Srsubstate pgtypes.Char  `json:"srsubstate"` // srsubstate
	Srsublsn   pgtypes.PgLsn `json:"srsublsn"`   // srsublsn
}

// PgTable represents a row from 'pg_catalog.pg_tables'.
type PgTable struct {
	Schemaname  pgtypes.Name `json:"schemaname"`  // schemaname
	Tablename   pgtypes.Name `json:"tablename"`   // tablename
	Tableowner  pgtypes.Name `json:"tableowner"`  // tableowner
	Tablespace  pgtypes.Name `json:"tablespace"`  // tablespace
	Hasindexes  sql.NullBool `json:"hasindexes"`  // hasindexes
	Hasrules    sql.NullBool `json:"hasrules"`    // hasrules
	Hastriggers sql.NullBool `json:"hastriggers"` // hastriggers
	Rowsecurity sql.NullBool `json:"rowsecurity"` // rowsecurity
}

// PgTablespace represents a row from 'pg_catalog.pg_tablespace'.
type PgTablespace struct {
	Tableoid   pgtypes.Oid       `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid       `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid       `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid       `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid       `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid       `json:"ctid"`       // ctid
	Oid        pgtypes.Oid       `json:"oid"`        // oid
	Spcname    pgtypes.Name      `json:"spcname"`    // spcname
	Spcowner   pgtypes.Oid       `json:"spcowner"`   // spcowner
	Spcacl     []pgtypes.Aclitem `json:"spcacl"`     // spcacl
	Spcoptions []sql.NullString  `json:"spcoptions"` // spcoptions
}

// PgTimezoneAbbrev represents a row from 'pg_catalog.pg_timezone_abbrevs'.
type PgTimezoneAbbrev struct {
	Abbrev    sql.NullString `json:"abbrev"`     // abbrev
	UtcOffset []byte         `json:"utc_offset"` // utc_offset
	IsDst     sql.NullBool   `json:"is_dst"`     // is_dst
}

// PgTimezoneName represents a row from 'pg_catalog.pg_timezone_names'.
type PgTimezoneName struct {
	Name      sql.NullString `json:"name"`       // name
	Abbrev    sql.NullString `json:"abbrev"`     // abbrev
	UtcOffset []byte         `json:"utc_offset"` // utc_offset
	IsDst     sql.NullBool   `json:"is_dst"`     // is_dst
}

// PgTransform represents a row from 'pg_catalog.pg_transform'.
type PgTransform struct {
	Tableoid   pgtypes.Oid     `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid     `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid     `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid     `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid     `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid     `json:"ctid"`       // ctid
	Oid        pgtypes.Oid     `json:"oid"`        // oid
	Trftype    pgtypes.Oid     `json:"trftype"`    // trftype
	Trflang    pgtypes.Oid     `json:"trflang"`    // trflang
	Trffromsql pgtypes.Regproc `json:"trffromsql"` // trffromsql
	Trftosql   pgtypes.Regproc `json:"trftosql"`   // trftosql
}

// PgTrigger represents a row from 'pg_catalog.pg_trigger'.
type PgTrigger struct {
	Tableoid       pgtypes.Oid        `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid        `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid        `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid        `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid        `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid        `json:"ctid"`           // ctid
	Oid            pgtypes.Oid        `json:"oid"`            // oid
	Tgrelid        pgtypes.Oid        `json:"tgrelid"`        // tgrelid
	Tgparentid     pgtypes.Oid        `json:"tgparentid"`     // tgparentid
	Tgname         pgtypes.Name       `json:"tgname"`         // tgname
	Tgfoid         pgtypes.Oid        `json:"tgfoid"`         // tgfoid
	Tgtype         int16              `json:"tgtype"`         // tgtype
	Tgenabled      pgtypes.Char       `json:"tgenabled"`      // tgenabled
	Tgisinternal   bool               `json:"tgisinternal"`   // tgisinternal
	Tgconstrrelid  pgtypes.Oid        `json:"tgconstrrelid"`  // tgconstrrelid
	Tgconstrindid  pgtypes.Oid        `json:"tgconstrindid"`  // tgconstrindid
	Tgconstraint   pgtypes.Oid        `json:"tgconstraint"`   // tgconstraint
	Tgdeferrable   bool               `json:"tgdeferrable"`   // tgdeferrable
	Tginitdeferred bool               `json:"tginitdeferred"` // tginitdeferred
	Tgnargs        int16              `json:"tgnargs"`        // tgnargs
	Tgattr         pgtypes.Int2vector `json:"tgattr"`         // tgattr
	Tgargs         []byte             `json:"tgargs"`         // tgargs
	Tgqual         pgtypes.PgNodeTree `json:"tgqual"`         // tgqual
	Tgoldtable     pgtypes.Name       `json:"tgoldtable"`     // tgoldtable
	Tgnewtable     pgtypes.Name       `json:"tgnewtable"`     // tgnewtable
}

// PgTsConfig represents a row from 'pg_catalog.pg_ts_config'.
type PgTsConfig struct {
	Tableoid     pgtypes.Oid  `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid  `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid  `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid  `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid  `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid  `json:"ctid"`         // ctid
	Oid          pgtypes.Oid  `json:"oid"`          // oid
	Cfgname      pgtypes.Name `json:"cfgname"`      // cfgname
	Cfgnamespace pgtypes.Oid  `json:"cfgnamespace"` // cfgnamespace
	Cfgowner     pgtypes.Oid  `json:"cfgowner"`     // cfgowner
	Cfgparser    pgtypes.Oid  `json:"cfgparser"`    // cfgparser
}

// PgTsConfigMap represents a row from 'pg_catalog.pg_ts_config_map'.
type PgTsConfigMap struct {
	Tableoid     pgtypes.Oid `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid `json:"ctid"`         // ctid
	Mapcfg       pgtypes.Oid `json:"mapcfg"`       // mapcfg
	Maptokentype int         `json:"maptokentype"` // maptokentype
	Mapseqno     int         `json:"mapseqno"`     // mapseqno
	Mapdict      pgtypes.Oid `json:"mapdict"`      // mapdict
}

// PgTsDict represents a row from 'pg_catalog.pg_ts_dict'.
type PgTsDict struct {
	Tableoid       pgtypes.Oid    `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid    `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid    `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid    `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid    `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid    `json:"ctid"`           // ctid
	Oid            pgtypes.Oid    `json:"oid"`            // oid
	Dictname       pgtypes.Name   `json:"dictname"`       // dictname
	Dictnamespace  pgtypes.Oid    `json:"dictnamespace"`  // dictnamespace
	Dictowner      pgtypes.Oid    `json:"dictowner"`      // dictowner
	Dicttemplate   pgtypes.Oid    `json:"dicttemplate"`   // dicttemplate
	Dictinitoption sql.NullString `json:"dictinitoption"` // dictinitoption
}

// PgTsParser represents a row from 'pg_catalog.pg_ts_parser'.
type PgTsParser struct {
	Tableoid     pgtypes.Oid     `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid     `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid     `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid     `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid     `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid     `json:"ctid"`         // ctid
	Oid          pgtypes.Oid     `json:"oid"`          // oid
	Prsname      pgtypes.Name    `json:"prsname"`      // prsname
	Prsnamespace pgtypes.Oid     `json:"prsnamespace"` // prsnamespace
	Prsstart     pgtypes.Regproc `json:"prsstart"`     // prsstart
	Prstoken     pgtypes.Regproc `json:"prstoken"`     // prstoken
	Prsend       pgtypes.Regproc `json:"prsend"`       // prsend
	Prsheadline  pgtypes.Regproc `json:"prsheadline"`  // prsheadline
	Prslextype   pgtypes.Regproc `json:"prslextype"`   // prslextype
}

// PgTsTemplate represents a row from 'pg_catalog.pg_ts_template'.
type PgTsTemplate struct {
	Tableoid      pgtypes.Oid     `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid     `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid     `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid     `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid     `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid     `json:"ctid"`          // ctid
	Oid           pgtypes.Oid     `json:"oid"`           // oid
	Tmplname      pgtypes.Name    `json:"tmplname"`      // tmplname
	Tmplnamespace pgtypes.Oid     `json:"tmplnamespace"` // tmplnamespace
	Tmplinit      pgtypes.Regproc `json:"tmplinit"`      // tmplinit
	Tmpllexize    pgtypes.Regproc `json:"tmpllexize"`    // tmpllexize
}

// PgType represents a row from 'pg_catalog.pg_type'.
type PgType struct {
	Tableoid       pgtypes.Oid        `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid        `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid        `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid        `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid        `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid        `json:"ctid"`           // ctid
	Oid            pgtypes.Oid        `json:"oid"`            // oid
	Typname        pgtypes.Name       `json:"typname"`        // typname
	Typnamespace   pgtypes.Oid        `json:"typnamespace"`   // typnamespace
	Typowner       pgtypes.Oid        `json:"typowner"`       // typowner
	Typlen         int16              `json:"typlen"`         // typlen
	Typbyval       bool               `json:"typbyval"`       // typbyval
	Typtype        pgtypes.Char       `json:"typtype"`        // typtype
	Typcategory    pgtypes.Char       `json:"typcategory"`    // typcategory
	Typispreferred bool               `json:"typispreferred"` // typispreferred
	Typisdefined   bool               `json:"typisdefined"`   // typisdefined
	Typdelim       pgtypes.Char       `json:"typdelim"`       // typdelim
	Typrelid       pgtypes.Oid        `json:"typrelid"`       // typrelid
	Typelem        pgtypes.Oid        `json:"typelem"`        // typelem
	Typarray       pgtypes.Oid        `json:"typarray"`       // typarray
	Typinput       pgtypes.Regproc    `json:"typinput"`       // typinput
	Typoutput      pgtypes.Regproc    `json:"typoutput"`      // typoutput
	Typreceive     pgtypes.Regproc    `json:"typreceive"`     // typreceive
	Typsend        pgtypes.Regproc    `json:"typsend"`        // typsend
	Typmodin       pgtypes.Regproc    `json:"typmodin"`       // typmodin
	Typmodout      pgtypes.Regproc    `json:"typmodout"`      // typmodout
	Typanalyze     pgtypes.Regproc    `json:"typanalyze"`     // typanalyze
	Typalign       pgtypes.Char       `json:"typalign"`       // typalign
	Typstorage     pgtypes.Char       `json:"typstorage"`     // typstorage
	Typnotnull     bool               `json:"typnotnull"`     // typnotnull
	Typbasetype    pgtypes.Oid        `json:"typbasetype"`    // typbasetype
	Typtypmod      int                `json:"typtypmod"`      // typtypmod
	Typndims       int                `json:"typndims"`       // typndims
	Typcollation   pgtypes.Oid        `json:"typcollation"`   // typcollation
	Typdefaultbin  pgtypes.PgNodeTree `json:"typdefaultbin"`  // typdefaultbin
	Typdefault     sql.NullString     `json:"typdefault"`     // typdefault
	Typacl         []pgtypes.Aclitem  `json:"typacl"`         // typacl
}

// PgUser represents a row from 'pg_catalog.pg_user'.
type PgUser struct {
	Usename      pgtypes.Name     `json:"usename"`      // usename
	Usesysid     pgtypes.Oid      `json:"usesysid"`     // usesysid
	Usecreatedb  sql.NullBool     `json:"usecreatedb"`  // usecreatedb
	Usesuper     sql.NullBool     `json:"usesuper"`     // usesuper
	Userepl      sql.NullBool     `json:"userepl"`      // userepl
	Usebypassrls sql.NullBool     `json:"usebypassrls"` // usebypassrls
	Passwd       sql.NullString   `json:"passwd"`       // passwd
	Valuntil     sql.NullTime     `json:"valuntil"`     // valuntil
	Useconfig    []sql.NullString `json:"useconfig"`    // useconfig
}

// PgUserMapping represents a row from 'pg_catalog.pg_user_mappings'.
type PgUserMapping struct {
	Umid      pgtypes.Oid      `json:"umid"`      // umid
	Srvid     pgtypes.Oid      `json:"srvid"`     // srvid
	Srvname   pgtypes.Name     `json:"srvname"`   // srvname
	Umuser    pgtypes.Oid      `json:"umuser"`    // umuser
	Usename   pgtypes.Name     `json:"usename"`   // usename
	Umoptions []sql.NullString `json:"umoptions"` // umoptions
}

// PgUserMapping represents a row from 'pg_catalog.pg_user_mapping'.
type PgUserMapping struct {
	Tableoid  pgtypes.Oid      `json:"tableoid"`  // tableoid
	Cmax      pgtypes.Cid      `json:"cmax"`      // cmax
	Xmax      pgtypes.Xid      `json:"xmax"`      // xmax
	Cmin      pgtypes.Cid      `json:"cmin"`      // cmin
	Xmin      pgtypes.Xid      `json:"xmin"`      // xmin
	Ctid      pgtypes.Tid      `json:"ctid"`      // ctid
	Oid       pgtypes.Oid      `json:"oid"`       // oid
	Umuser    pgtypes.Oid      `json:"umuser"`    // umuser
	Umserver  pgtypes.Oid      `json:"umserver"`  // umserver
	Umoptions []sql.NullString `json:"umoptions"` // umoptions
}

// PgView represents a row from 'pg_catalog.pg_views'.
type PgView struct {
	Schemaname pgtypes.Name   `json:"schemaname"` // schemaname
	Viewname   pgtypes.Name   `json:"viewname"`   // viewname
	Viewowner  pgtypes.Name   `json:"viewowner"`  // viewowner
	Definition sql.NullString `json:"definition"` // definition
}

// PgAggregateByAggfnoid retrieves a row from 'pg_catalog.pg_aggregate' as a PgAggregate.
//
// Generated from index 'pg_aggregate_fnoid_index'.
func PgAggregateByAggfnoid(ctx context.Context, db DB, aggfnoid pgtypes.Regproc) (*PgAggregate, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, aggfnoid, aggkind, aggnumdirectargs, aggtransfn, aggfinalfn, aggcombinefn, aggserialfn, aggdeserialfn, aggmtransfn, aggminvtransfn, aggmfinalfn, aggfinalextra, aggmfinalextra, aggfinalmodify, aggmfinalmodify, aggsortop, aggtranstype, aggtransspace, aggmtranstype, aggmtransspace, agginitval, aggminitval ` +
		`FROM pg_catalog.pg_aggregate ` +
		`WHERE aggfnoid = $1`
	// run
	logf(sqlstr, aggfnoid)
	pa := PgAggregate{}
	if err := db.QueryRowContext(ctx, sqlstr, aggfnoid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Aggfnoid, &pa.Aggkind, &pa.Aggnumdirectargs, &pa.Aggtransfn, &pa.Aggfinalfn, &pa.Aggcombinefn, &pa.Aggserialfn, &pa.Aggdeserialfn, &pa.Aggmtransfn, &pa.Aggminvtransfn, &pa.Aggmfinalfn, &pa.Aggfinalextra, &pa.Aggmfinalextra, &pa.Aggfinalmodify, &pa.Aggmfinalmodify, &pa.Aggsortop, &pa.Aggtranstype, &pa.Aggtransspace, &pa.Aggmtranstype, &pa.Aggmtransspace, &pa.Agginitval, &pa.Aggminitval); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmByAmname retrieves a row from 'pg_catalog.pg_am' as a PgAm.
//
// Generated from index 'pg_am_name_index'.
func PgAmByAmname(ctx context.Context, db DB, amname pgtypes.Name) (*PgAm, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amname, amhandler, amtype ` +
		`FROM pg_catalog.pg_am ` +
		`WHERE amname = $1`
	// run
	logf(sqlstr, amname)
	pa := PgAm{}
	if err := db.QueryRowContext(ctx, sqlstr, amname).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amname, &pa.Amhandler, &pa.Amtype); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmByOid retrieves a row from 'pg_catalog.pg_am' as a PgAm.
//
// Generated from index 'pg_am_oid_index'.
func PgAmByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgAm, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amname, amhandler, amtype ` +
		`FROM pg_catalog.pg_am ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pa := PgAm{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amname, &pa.Amhandler, &pa.Amtype); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmopByAmopfamilyAmoplefttypeAmoprighttypeAmopstrategy retrieves a row from 'pg_catalog.pg_amop' as a PgAmop.
//
// Generated from index 'pg_amop_fam_strat_index'.
func PgAmopByAmopfamilyAmoplefttypeAmoprighttypeAmopstrategy(ctx context.Context, db DB, amopfamily, amoplefttype, amoprighttype pgtypes.Oid, amopstrategy int16) (*PgAmop, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amopfamily, amoplefttype, amoprighttype, amopstrategy, amoppurpose, amopopr, amopmethod, amopsortfamily ` +
		`FROM pg_catalog.pg_amop ` +
		`WHERE amopfamily = $1 AND amoplefttype = $2 AND amoprighttype = $3 AND amopstrategy = $4`
	// run
	logf(sqlstr, amopfamily, amoplefttype, amoprighttype, amopstrategy)
	pa := PgAmop{}
	if err := db.QueryRowContext(ctx, sqlstr, amopfamily, amoplefttype, amoprighttype, amopstrategy).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amopfamily, &pa.Amoplefttype, &pa.Amoprighttype, &pa.Amopstrategy, &pa.Amoppurpose, &pa.Amopopr, &pa.Amopmethod, &pa.Amopsortfamily); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmopByOid retrieves a row from 'pg_catalog.pg_amop' as a PgAmop.
//
// Generated from index 'pg_amop_oid_index'.
func PgAmopByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgAmop, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amopfamily, amoplefttype, amoprighttype, amopstrategy, amoppurpose, amopopr, amopmethod, amopsortfamily ` +
		`FROM pg_catalog.pg_amop ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pa := PgAmop{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amopfamily, &pa.Amoplefttype, &pa.Amoprighttype, &pa.Amopstrategy, &pa.Amoppurpose, &pa.Amopopr, &pa.Amopmethod, &pa.Amopsortfamily); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmopByAmopoprAmoppurposeAmopfamily retrieves a row from 'pg_catalog.pg_amop' as a PgAmop.
//
// Generated from index 'pg_amop_opr_fam_index'.
func PgAmopByAmopoprAmoppurposeAmopfamily(ctx context.Context, db DB, amopopr pgtypes.Oid, amoppurpose pgtypes.Char, amopfamily pgtypes.Oid) (*PgAmop, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amopfamily, amoplefttype, amoprighttype, amopstrategy, amoppurpose, amopopr, amopmethod, amopsortfamily ` +
		`FROM pg_catalog.pg_amop ` +
		`WHERE amopopr = $1 AND amoppurpose = $2 AND amopfamily = $3`
	// run
	logf(sqlstr, amopopr, amoppurpose, amopfamily)
	pa := PgAmop{}
	if err := db.QueryRowContext(ctx, sqlstr, amopopr, amoppurpose, amopfamily).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amopfamily, &pa.Amoplefttype, &pa.Amoprighttype, &pa.Amopstrategy, &pa.Amoppurpose, &pa.Amopopr, &pa.Amopmethod, &pa.Amopsortfamily); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmprocByAmprocfamilyAmproclefttypeAmprocrighttypeAmprocnum retrieves a row from 'pg_catalog.pg_amproc' as a PgAmproc.
//
// Generated from index 'pg_amproc_fam_proc_index'.
func PgAmprocByAmprocfamilyAmproclefttypeAmprocrighttypeAmprocnum(ctx context.Context, db DB, amprocfamily, amproclefttype, amprocrighttype pgtypes.Oid, amprocnum int16) (*PgAmproc, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amprocfamily, amproclefttype, amprocrighttype, amprocnum, amproc ` +
		`FROM pg_catalog.pg_amproc ` +
		`WHERE amprocfamily = $1 AND amproclefttype = $2 AND amprocrighttype = $3 AND amprocnum = $4`
	// run
	logf(sqlstr, amprocfamily, amproclefttype, amprocrighttype, amprocnum)
	pa := PgAmproc{}
	if err := db.QueryRowContext(ctx, sqlstr, amprocfamily, amproclefttype, amprocrighttype, amprocnum).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amprocfamily, &pa.Amproclefttype, &pa.Amprocrighttype, &pa.Amprocnum, &pa.Amproc); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmprocByOid retrieves a row from 'pg_catalog.pg_amproc' as a PgAmproc.
//
// Generated from index 'pg_amproc_oid_index'.
func PgAmprocByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgAmproc, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amprocfamily, amproclefttype, amprocrighttype, amprocnum, amproc ` +
		`FROM pg_catalog.pg_amproc ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pa := PgAmproc{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amprocfamily, &pa.Amproclefttype, &pa.Amprocrighttype, &pa.Amprocnum, &pa.Amproc); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAttrdefByAdrelidAdnum retrieves a row from 'pg_catalog.pg_attrdef' as a PgAttrdef.
//
// Generated from index 'pg_attrdef_adrelid_adnum_index'.
func PgAttrdefByAdrelidAdnum(ctx context.Context, db DB, adrelid pgtypes.Oid, adnum int16) (*PgAttrdef, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, adrelid, adnum, adbin ` +
		`FROM pg_catalog.pg_attrdef ` +
		`WHERE adrelid = $1 AND adnum = $2`
	// run
	logf(sqlstr, adrelid, adnum)
	pa := PgAttrdef{}
	if err := db.QueryRowContext(ctx, sqlstr, adrelid, adnum).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Adrelid, &pa.Adnum, &pa.Adbin); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAttrdefByOid retrieves a row from 'pg_catalog.pg_attrdef' as a PgAttrdef.
//
// Generated from index 'pg_attrdef_oid_index'.
func PgAttrdefByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgAttrdef, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, adrelid, adnum, adbin ` +
		`FROM pg_catalog.pg_attrdef ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pa := PgAttrdef{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Adrelid, &pa.Adnum, &pa.Adbin); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAttributeByAttrelidAttname retrieves a row from 'pg_catalog.pg_attribute' as a PgAttribute.
//
// Generated from index 'pg_attribute_relid_attnam_index'.
func PgAttributeByAttrelidAttname(ctx context.Context, db DB, attrelid pgtypes.Oid, attname pgtypes.Name) (*PgAttribute, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, attrelid, attname, atttypid, attstattarget, attlen, attnum, attndims, attcacheoff, atttypmod, attbyval, attstorage, attalign, attnotnull, atthasdef, atthasmissing, attidentity, attgenerated, attisdropped, attislocal, attinhcount, attcollation, attacl, attoptions, attfdwoptions, attmissingval ` +
		`FROM pg_catalog.pg_attribute ` +
		`WHERE attrelid = $1 AND attname = $2`
	// run
	logf(sqlstr, attrelid, attname)
	pa := PgAttribute{}
	if err := db.QueryRowContext(ctx, sqlstr, attrelid, attname).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Attrelid, &pa.Attname, &pa.Atttypid, &pa.Attstattarget, &pa.Attlen, &pa.Attnum, &pa.Attndims, &pa.Attcacheoff, &pa.Atttypmod, &pa.Attbyval, &pa.Attstorage, &pa.Attalign, &pa.Attnotnull, &pa.Atthasdef, &pa.Atthasmissing, &pa.Attidentity, &pa.Attgenerated, &pa.Attisdropped, &pa.Attislocal, &pa.Attinhcount, &pa.Attcollation, &pa.Attacl, &pa.Attoptions, &pa.Attfdwoptions, &pa.Attmissingval); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAttributeByAttrelidAttnum retrieves a row from 'pg_catalog.pg_attribute' as a PgAttribute.
//
// Generated from index 'pg_attribute_relid_attnum_index'.
func PgAttributeByAttrelidAttnum(ctx context.Context, db DB, attrelid pgtypes.Oid, attnum int16) (*PgAttribute, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, attrelid, attname, atttypid, attstattarget, attlen, attnum, attndims, attcacheoff, atttypmod, attbyval, attstorage, attalign, attnotnull, atthasdef, atthasmissing, attidentity, attgenerated, attisdropped, attislocal, attinhcount, attcollation, attacl, attoptions, attfdwoptions, attmissingval ` +
		`FROM pg_catalog.pg_attribute ` +
		`WHERE attrelid = $1 AND attnum = $2`
	// run
	logf(sqlstr, attrelid, attnum)
	pa := PgAttribute{}
	if err := db.QueryRowContext(ctx, sqlstr, attrelid, attnum).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Attrelid, &pa.Attname, &pa.Atttypid, &pa.Attstattarget, &pa.Attlen, &pa.Attnum, &pa.Attndims, &pa.Attcacheoff, &pa.Atttypmod, &pa.Attbyval, &pa.Attstorage, &pa.Attalign, &pa.Attnotnull, &pa.Atthasdef, &pa.Atthasmissing, &pa.Attidentity, &pa.Attgenerated, &pa.Attisdropped, &pa.Attislocal, &pa.Attinhcount, &pa.Attcollation, &pa.Attacl, &pa.Attoptions, &pa.Attfdwoptions, &pa.Attmissingval); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAuthMemberByMemberRoleid retrieves a row from 'pg_catalog.pg_auth_members' as a PgAuthMember.
//
// Generated from index 'pg_auth_members_member_role_index'.
func PgAuthMemberByMemberRoleid(ctx context.Context, db DB, member, roleid pgtypes.Oid) (*PgAuthMember, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, roleid, member, grantor, admin_option ` +
		`FROM pg_catalog.pg_auth_members ` +
		`WHERE member = $1 AND roleid = $2`
	// run
	logf(sqlstr, member, roleid)
	pam := PgAuthMember{}
	if err := db.QueryRowContext(ctx, sqlstr, member, roleid).Scan(&pam.Tableoid, &pam.Cmax, &pam.Xmax, &pam.Cmin, &pam.Xmin, &pam.Ctid, &pam.Roleid, &pam.Member, &pam.Grantor, &pam.AdminOption); err != nil {
		return nil, logerror(err)
	}
	return &pam, nil
}

// PgAuthMemberByRoleidMember retrieves a row from 'pg_catalog.pg_auth_members' as a PgAuthMember.
//
// Generated from index 'pg_auth_members_role_member_index'.
func PgAuthMemberByRoleidMember(ctx context.Context, db DB, roleid, member pgtypes.Oid) (*PgAuthMember, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, roleid, member, grantor, admin_option ` +
		`FROM pg_catalog.pg_auth_members ` +
		`WHERE roleid = $1 AND member = $2`
	// run
	logf(sqlstr, roleid, member)
	pam := PgAuthMember{}
	if err := db.QueryRowContext(ctx, sqlstr, roleid, member).Scan(&pam.Tableoid, &pam.Cmax, &pam.Xmax, &pam.Cmin, &pam.Xmin, &pam.Ctid, &pam.Roleid, &pam.Member, &pam.Grantor, &pam.AdminOption); err != nil {
		return nil, logerror(err)
	}
	return &pam, nil
}

// PgAuthidByOid retrieves a row from 'pg_catalog.pg_authid' as a PgAuthid.
//
// Generated from index 'pg_authid_oid_index'.
func PgAuthidByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgAuthid, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb, rolcanlogin, rolreplication, rolbypassrls, rolconnlimit, rolpassword, rolvaliduntil ` +
		`FROM pg_catalog.pg_authid ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pa := PgAuthid{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Rolname, &pa.Rolsuper, &pa.Rolinherit, &pa.Rolcreaterole, &pa.Rolcreatedb, &pa.Rolcanlogin, &pa.Rolreplication, &pa.Rolbypassrls, &pa.Rolconnlimit, &pa.Rolpassword, &pa.Rolvaliduntil); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAuthidByRolname retrieves a row from 'pg_catalog.pg_authid' as a PgAuthid.
//
// Generated from index 'pg_authid_rolname_index'.
func PgAuthidByRolname(ctx context.Context, db DB, rolname pgtypes.Name) (*PgAuthid, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb, rolcanlogin, rolreplication, rolbypassrls, rolconnlimit, rolpassword, rolvaliduntil ` +
		`FROM pg_catalog.pg_authid ` +
		`WHERE rolname = $1`
	// run
	logf(sqlstr, rolname)
	pa := PgAuthid{}
	if err := db.QueryRowContext(ctx, sqlstr, rolname).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Rolname, &pa.Rolsuper, &pa.Rolinherit, &pa.Rolcreaterole, &pa.Rolcreatedb, &pa.Rolcanlogin, &pa.Rolreplication, &pa.Rolbypassrls, &pa.Rolconnlimit, &pa.Rolpassword, &pa.Rolvaliduntil); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgCastByOid retrieves a row from 'pg_catalog.pg_cast' as a PgCast.
//
// Generated from index 'pg_cast_oid_index'.
func PgCastByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgCast, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, castsource, casttarget, castfunc, castcontext, castmethod ` +
		`FROM pg_catalog.pg_cast ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pc := PgCast{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Castsource, &pc.Casttarget, &pc.Castfunc, &pc.Castcontext, &pc.Castmethod); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgCastByCastsourceCasttarget retrieves a row from 'pg_catalog.pg_cast' as a PgCast.
//
// Generated from index 'pg_cast_source_target_index'.
func PgCastByCastsourceCasttarget(ctx context.Context, db DB, castsource, casttarget pgtypes.Oid) (*PgCast, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, castsource, casttarget, castfunc, castcontext, castmethod ` +
		`FROM pg_catalog.pg_cast ` +
		`WHERE castsource = $1 AND casttarget = $2`
	// run
	logf(sqlstr, castsource, casttarget)
	pc := PgCast{}
	if err := db.QueryRowContext(ctx, sqlstr, castsource, casttarget).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Castsource, &pc.Casttarget, &pc.Castfunc, &pc.Castcontext, &pc.Castmethod); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgClassByOid retrieves a row from 'pg_catalog.pg_class' as a PgClass.
//
// Generated from index 'pg_class_oid_index'.
func PgClassByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgClass, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, relname, relnamespace, reltype, reloftype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, relallvisible, reltoastrelid, relhasindex, relisshared, relpersistence, relkind, relnatts, relchecks, relhasrules, relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity, relispopulated, relreplident, relispartition, relrewrite, relfrozenxid, relminmxid, relacl, reloptions, relpartbound ` +
		`FROM pg_catalog.pg_class ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pc := PgClass{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Relname, &pc.Relnamespace, &pc.Reltype, &pc.Reloftype, &pc.Relowner, &pc.Relam, &pc.Relfilenode, &pc.Reltablespace, &pc.Relpages, &pc.Reltuples, &pc.Relallvisible, &pc.Reltoastrelid, &pc.Relhasindex, &pc.Relisshared, &pc.Relpersistence, &pc.Relkind, &pc.Relnatts, &pc.Relchecks, &pc.Relhasrules, &pc.Relhastriggers, &pc.Relhassubclass, &pc.Relrowsecurity, &pc.Relforcerowsecurity, &pc.Relispopulated, &pc.Relreplident, &pc.Relispartition, &pc.Relrewrite, &pc.Relfrozenxid, &pc.Relminmxid, &pc.Relacl, &pc.Reloptions, &pc.Relpartbound); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgClassByRelnameRelnamespace retrieves a row from 'pg_catalog.pg_class' as a PgClass.
//
// Generated from index 'pg_class_relname_nsp_index'.
func PgClassByRelnameRelnamespace(ctx context.Context, db DB, relname pgtypes.Name, relnamespace pgtypes.Oid) (*PgClass, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, relname, relnamespace, reltype, reloftype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, relallvisible, reltoastrelid, relhasindex, relisshared, relpersistence, relkind, relnatts, relchecks, relhasrules, relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity, relispopulated, relreplident, relispartition, relrewrite, relfrozenxid, relminmxid, relacl, reloptions, relpartbound ` +
		`FROM pg_catalog.pg_class ` +
		`WHERE relname = $1 AND relnamespace = $2`
	// run
	logf(sqlstr, relname, relnamespace)
	pc := PgClass{}
	if err := db.QueryRowContext(ctx, sqlstr, relname, relnamespace).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Relname, &pc.Relnamespace, &pc.Reltype, &pc.Reloftype, &pc.Relowner, &pc.Relam, &pc.Relfilenode, &pc.Reltablespace, &pc.Relpages, &pc.Reltuples, &pc.Relallvisible, &pc.Reltoastrelid, &pc.Relhasindex, &pc.Relisshared, &pc.Relpersistence, &pc.Relkind, &pc.Relnatts, &pc.Relchecks, &pc.Relhasrules, &pc.Relhastriggers, &pc.Relhassubclass, &pc.Relrowsecurity, &pc.Relforcerowsecurity, &pc.Relispopulated, &pc.Relreplident, &pc.Relispartition, &pc.Relrewrite, &pc.Relfrozenxid, &pc.Relminmxid, &pc.Relacl, &pc.Reloptions, &pc.Relpartbound); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgClassesByReltablespaceRelfilenode retrieves a row from 'pg_catalog.pg_class' as a PgClass.
//
// Generated from index 'pg_class_tblspc_relfilenode_index'.
func PgClassesByReltablespaceRelfilenode(ctx context.Context, db DB, reltablespace, relfilenode pgtypes.Oid) ([]*PgClass, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, relname, relnamespace, reltype, reloftype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, relallvisible, reltoastrelid, relhasindex, relisshared, relpersistence, relkind, relnatts, relchecks, relhasrules, relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity, relispopulated, relreplident, relispartition, relrewrite, relfrozenxid, relminmxid, relacl, reloptions, relpartbound ` +
		`FROM pg_catalog.pg_class ` +
		`WHERE reltablespace = $1 AND relfilenode = $2`
	// run
	logf(sqlstr, reltablespace, relfilenode)
	rows, err := db.QueryContext(ctx, sqlstr, reltablespace, relfilenode)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgClass
	for rows.Next() {
		pc := PgClass{}
		// scan
		if err := rows.Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Relname, &pc.Relnamespace, &pc.Reltype, &pc.Reloftype, &pc.Relowner, &pc.Relam, &pc.Relfilenode, &pc.Reltablespace, &pc.Relpages, &pc.Reltuples, &pc.Relallvisible, &pc.Reltoastrelid, &pc.Relhasindex, &pc.Relisshared, &pc.Relpersistence, &pc.Relkind, &pc.Relnatts, &pc.Relchecks, &pc.Relhasrules, &pc.Relhastriggers, &pc.Relhassubclass, &pc.Relrowsecurity, &pc.Relforcerowsecurity, &pc.Relispopulated, &pc.Relreplident, &pc.Relispartition, &pc.Relrewrite, &pc.Relfrozenxid, &pc.Relminmxid, &pc.Relacl, &pc.Reloptions, &pc.Relpartbound); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgCollationByCollnameCollencodingCollnamespace retrieves a row from 'pg_catalog.pg_collation' as a PgCollation.
//
// Generated from index 'pg_collation_name_enc_nsp_index'.
func PgCollationByCollnameCollencodingCollnamespace(ctx context.Context, db DB, collname pgtypes.Name, collencoding int, collnamespace pgtypes.Oid) (*PgCollation, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype, collversion ` +
		`FROM pg_catalog.pg_collation ` +
		`WHERE collname = $1 AND collencoding = $2 AND collnamespace = $3`
	// run
	logf(sqlstr, collname, collencoding, collnamespace)
	pc := PgCollation{}
	if err := db.QueryRowContext(ctx, sqlstr, collname, collencoding, collnamespace).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Collname, &pc.Collnamespace, &pc.Collowner, &pc.Collprovider, &pc.Collisdeterministic, &pc.Collencoding, &pc.Collcollate, &pc.Collctype, &pc.Collversion); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgCollationByOid retrieves a row from 'pg_catalog.pg_collation' as a PgCollation.
//
// Generated from index 'pg_collation_oid_index'.
func PgCollationByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgCollation, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype, collversion ` +
		`FROM pg_catalog.pg_collation ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pc := PgCollation{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Collname, &pc.Collnamespace, &pc.Collowner, &pc.Collprovider, &pc.Collisdeterministic, &pc.Collencoding, &pc.Collcollate, &pc.Collctype, &pc.Collversion); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgConstraintsByConnameConnamespace retrieves a row from 'pg_catalog.pg_constraint' as a PgConstraint.
//
// Generated from index 'pg_constraint_conname_nsp_index'.
func PgConstraintsByConnameConnamespace(ctx context.Context, db DB, conname pgtypes.Name, connamespace pgtypes.Oid) ([]*PgConstraint, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, contype, condeferrable, condeferred, convalidated, conrelid, contypid, conindid, conparentid, confrelid, confupdtype, confdeltype, confmatchtype, conislocal, coninhcount, connoinherit, conkey, confkey, conpfeqop, conppeqop, conffeqop, conexclop, conbin ` +
		`FROM pg_catalog.pg_constraint ` +
		`WHERE conname = $1 AND connamespace = $2`
	// run
	logf(sqlstr, conname, connamespace)
	rows, err := db.QueryContext(ctx, sqlstr, conname, connamespace)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgConstraint
	for rows.Next() {
		pc := PgConstraint{}
		// scan
		if err := rows.Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Contype, &pc.Condeferrable, &pc.Condeferred, &pc.Convalidated, &pc.Conrelid, &pc.Contypid, &pc.Conindid, &pc.Conparentid, &pc.Confrelid, &pc.Confupdtype, &pc.Confdeltype, &pc.Confmatchtype, &pc.Conislocal, &pc.Coninhcount, &pc.Connoinherit, &pc.Conkey, &pc.Confkey, &pc.Conpfeqop, &pc.Conppeqop, &pc.Conffeqop, &pc.Conexclop, &pc.Conbin); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgConstraintsByConparentid retrieves a row from 'pg_catalog.pg_constraint' as a PgConstraint.
//
// Generated from index 'pg_constraint_conparentid_index'.
func PgConstraintsByConparentid(ctx context.Context, db DB, conparentid pgtypes.Oid) ([]*PgConstraint, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, contype, condeferrable, condeferred, convalidated, conrelid, contypid, conindid, conparentid, confrelid, confupdtype, confdeltype, confmatchtype, conislocal, coninhcount, connoinherit, conkey, confkey, conpfeqop, conppeqop, conffeqop, conexclop, conbin ` +
		`FROM pg_catalog.pg_constraint ` +
		`WHERE conparentid = $1`
	// run
	logf(sqlstr, conparentid)
	rows, err := db.QueryContext(ctx, sqlstr, conparentid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgConstraint
	for rows.Next() {
		pc := PgConstraint{}
		// scan
		if err := rows.Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Contype, &pc.Condeferrable, &pc.Condeferred, &pc.Convalidated, &pc.Conrelid, &pc.Contypid, &pc.Conindid, &pc.Conparentid, &pc.Confrelid, &pc.Confupdtype, &pc.Confdeltype, &pc.Confmatchtype, &pc.Conislocal, &pc.Coninhcount, &pc.Connoinherit, &pc.Conkey, &pc.Confkey, &pc.Conpfeqop, &pc.Conppeqop, &pc.Conffeqop, &pc.Conexclop, &pc.Conbin); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgConstraintByConrelidContypidConname retrieves a row from 'pg_catalog.pg_constraint' as a PgConstraint.
//
// Generated from index 'pg_constraint_conrelid_contypid_conname_index'.
func PgConstraintByConrelidContypidConname(ctx context.Context, db DB, conrelid, contypid pgtypes.Oid, conname pgtypes.Name) (*PgConstraint, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, contype, condeferrable, condeferred, convalidated, conrelid, contypid, conindid, conparentid, confrelid, confupdtype, confdeltype, confmatchtype, conislocal, coninhcount, connoinherit, conkey, confkey, conpfeqop, conppeqop, conffeqop, conexclop, conbin ` +
		`FROM pg_catalog.pg_constraint ` +
		`WHERE conrelid = $1 AND contypid = $2 AND conname = $3`
	// run
	logf(sqlstr, conrelid, contypid, conname)
	pc := PgConstraint{}
	if err := db.QueryRowContext(ctx, sqlstr, conrelid, contypid, conname).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Contype, &pc.Condeferrable, &pc.Condeferred, &pc.Convalidated, &pc.Conrelid, &pc.Contypid, &pc.Conindid, &pc.Conparentid, &pc.Confrelid, &pc.Confupdtype, &pc.Confdeltype, &pc.Confmatchtype, &pc.Conislocal, &pc.Coninhcount, &pc.Connoinherit, &pc.Conkey, &pc.Confkey, &pc.Conpfeqop, &pc.Conppeqop, &pc.Conffeqop, &pc.Conexclop, &pc.Conbin); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgConstraintsByContypid retrieves a row from 'pg_catalog.pg_constraint' as a PgConstraint.
//
// Generated from index 'pg_constraint_contypid_index'.
func PgConstraintsByContypid(ctx context.Context, db DB, contypid pgtypes.Oid) ([]*PgConstraint, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, contype, condeferrable, condeferred, convalidated, conrelid, contypid, conindid, conparentid, confrelid, confupdtype, confdeltype, confmatchtype, conislocal, coninhcount, connoinherit, conkey, confkey, conpfeqop, conppeqop, conffeqop, conexclop, conbin ` +
		`FROM pg_catalog.pg_constraint ` +
		`WHERE contypid = $1`
	// run
	logf(sqlstr, contypid)
	rows, err := db.QueryContext(ctx, sqlstr, contypid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgConstraint
	for rows.Next() {
		pc := PgConstraint{}
		// scan
		if err := rows.Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Contype, &pc.Condeferrable, &pc.Condeferred, &pc.Convalidated, &pc.Conrelid, &pc.Contypid, &pc.Conindid, &pc.Conparentid, &pc.Confrelid, &pc.Confupdtype, &pc.Confdeltype, &pc.Confmatchtype, &pc.Conislocal, &pc.Coninhcount, &pc.Connoinherit, &pc.Conkey, &pc.Confkey, &pc.Conpfeqop, &pc.Conppeqop, &pc.Conffeqop, &pc.Conexclop, &pc.Conbin); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgConstraintByOid retrieves a row from 'pg_catalog.pg_constraint' as a PgConstraint.
//
// Generated from index 'pg_constraint_oid_index'.
func PgConstraintByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgConstraint, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, contype, condeferrable, condeferred, convalidated, conrelid, contypid, conindid, conparentid, confrelid, confupdtype, confdeltype, confmatchtype, conislocal, coninhcount, connoinherit, conkey, confkey, conpfeqop, conppeqop, conffeqop, conexclop, conbin ` +
		`FROM pg_catalog.pg_constraint ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pc := PgConstraint{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Contype, &pc.Condeferrable, &pc.Condeferred, &pc.Convalidated, &pc.Conrelid, &pc.Contypid, &pc.Conindid, &pc.Conparentid, &pc.Confrelid, &pc.Confupdtype, &pc.Confdeltype, &pc.Confmatchtype, &pc.Conislocal, &pc.Coninhcount, &pc.Connoinherit, &pc.Conkey, &pc.Confkey, &pc.Conpfeqop, &pc.Conppeqop, &pc.Conffeqop, &pc.Conexclop, &pc.Conbin); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgConversionByConnamespaceConforencodingContoencodingOid retrieves a row from 'pg_catalog.pg_conversion' as a PgConversion.
//
// Generated from index 'pg_conversion_default_index'.
func PgConversionByConnamespaceConforencodingContoencodingOid(ctx context.Context, db DB, connamespace pgtypes.Oid, conforencoding, contoencoding int, oid pgtypes.Oid) (*PgConversion, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, conowner, conforencoding, contoencoding, conproc, condefault ` +
		`FROM pg_catalog.pg_conversion ` +
		`WHERE connamespace = $1 AND conforencoding = $2 AND contoencoding = $3 AND oid = $4`
	// run
	logf(sqlstr, connamespace, conforencoding, contoencoding, oid)
	pc := PgConversion{}
	if err := db.QueryRowContext(ctx, sqlstr, connamespace, conforencoding, contoencoding, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Conowner, &pc.Conforencoding, &pc.Contoencoding, &pc.Conproc, &pc.Condefault); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgConversionByConnameConnamespace retrieves a row from 'pg_catalog.pg_conversion' as a PgConversion.
//
// Generated from index 'pg_conversion_name_nsp_index'.
func PgConversionByConnameConnamespace(ctx context.Context, db DB, conname pgtypes.Name, connamespace pgtypes.Oid) (*PgConversion, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, conowner, conforencoding, contoencoding, conproc, condefault ` +
		`FROM pg_catalog.pg_conversion ` +
		`WHERE conname = $1 AND connamespace = $2`
	// run
	logf(sqlstr, conname, connamespace)
	pc := PgConversion{}
	if err := db.QueryRowContext(ctx, sqlstr, conname, connamespace).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Conowner, &pc.Conforencoding, &pc.Contoencoding, &pc.Conproc, &pc.Condefault); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgConversionByOid retrieves a row from 'pg_catalog.pg_conversion' as a PgConversion.
//
// Generated from index 'pg_conversion_oid_index'.
func PgConversionByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgConversion, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, conowner, conforencoding, contoencoding, conproc, condefault ` +
		`FROM pg_catalog.pg_conversion ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pc := PgConversion{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Conowner, &pc.Conforencoding, &pc.Contoencoding, &pc.Conproc, &pc.Condefault); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgDatabaseByDatname retrieves a row from 'pg_catalog.pg_database' as a PgDatabase.
//
// Generated from index 'pg_database_datname_index'.
func PgDatabaseByDatname(ctx context.Context, db DB, datname pgtypes.Name) (*PgDatabase, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, datname, datdba, encoding, datcollate, datctype, datistemplate, datallowconn, datconnlimit, datlastsysoid, datfrozenxid, datminmxid, dattablespace, datacl ` +
		`FROM pg_catalog.pg_database ` +
		`WHERE datname = $1`
	// run
	logf(sqlstr, datname)
	pd := PgDatabase{}
	if err := db.QueryRowContext(ctx, sqlstr, datname).Scan(&pd.Tableoid, &pd.Cmax, &pd.Xmax, &pd.Cmin, &pd.Xmin, &pd.Ctid, &pd.Oid, &pd.Datname, &pd.Datdba, &pd.Encoding, &pd.Datcollate, &pd.Datctype, &pd.Datistemplate, &pd.Datallowconn, &pd.Datconnlimit, &pd.Datlastsysoid, &pd.Datfrozenxid, &pd.Datminmxid, &pd.Dattablespace, &pd.Datacl); err != nil {
		return nil, logerror(err)
	}
	return &pd, nil
}

// PgDatabaseByOid retrieves a row from 'pg_catalog.pg_database' as a PgDatabase.
//
// Generated from index 'pg_database_oid_index'.
func PgDatabaseByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgDatabase, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, datname, datdba, encoding, datcollate, datctype, datistemplate, datallowconn, datconnlimit, datlastsysoid, datfrozenxid, datminmxid, dattablespace, datacl ` +
		`FROM pg_catalog.pg_database ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pd := PgDatabase{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pd.Tableoid, &pd.Cmax, &pd.Xmax, &pd.Cmin, &pd.Xmin, &pd.Ctid, &pd.Oid, &pd.Datname, &pd.Datdba, &pd.Encoding, &pd.Datcollate, &pd.Datctype, &pd.Datistemplate, &pd.Datallowconn, &pd.Datconnlimit, &pd.Datlastsysoid, &pd.Datfrozenxid, &pd.Datminmxid, &pd.Dattablespace, &pd.Datacl); err != nil {
		return nil, logerror(err)
	}
	return &pd, nil
}

// PgDbRoleSettingBySetdatabaseSetrole retrieves a row from 'pg_catalog.pg_db_role_setting' as a PgDbRoleSetting.
//
// Generated from index 'pg_db_role_setting_databaseid_rol_index'.
func PgDbRoleSettingBySetdatabaseSetrole(ctx context.Context, db DB, setdatabase, setrole pgtypes.Oid) (*PgDbRoleSetting, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, setdatabase, setrole, setconfig ` +
		`FROM pg_catalog.pg_db_role_setting ` +
		`WHERE setdatabase = $1 AND setrole = $2`
	// run
	logf(sqlstr, setdatabase, setrole)
	pdrs := PgDbRoleSetting{}
	if err := db.QueryRowContext(ctx, sqlstr, setdatabase, setrole).Scan(&pdrs.Tableoid, &pdrs.Cmax, &pdrs.Xmax, &pdrs.Cmin, &pdrs.Xmin, &pdrs.Ctid, &pdrs.Setdatabase, &pdrs.Setrole, &pdrs.Setconfig); err != nil {
		return nil, logerror(err)
	}
	return &pdrs, nil
}

// PgDefaultACLByOid retrieves a row from 'pg_catalog.pg_default_acl' as a PgDefaultACL.
//
// Generated from index 'pg_default_acl_oid_index'.
func PgDefaultACLByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgDefaultACL, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, defaclrole, defaclnamespace, defaclobjtype, defaclacl ` +
		`FROM pg_catalog.pg_default_acl ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pda := PgDefaultACL{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pda.Tableoid, &pda.Cmax, &pda.Xmax, &pda.Cmin, &pda.Xmin, &pda.Ctid, &pda.Oid, &pda.Defaclrole, &pda.Defaclnamespace, &pda.Defaclobjtype, &pda.Defaclacl); err != nil {
		return nil, logerror(err)
	}
	return &pda, nil
}

// PgDefaultACLByDefaclroleDefaclnamespaceDefaclobjtype retrieves a row from 'pg_catalog.pg_default_acl' as a PgDefaultACL.
//
// Generated from index 'pg_default_acl_role_nsp_obj_index'.
func PgDefaultACLByDefaclroleDefaclnamespaceDefaclobjtype(ctx context.Context, db DB, defaclrole, defaclnamespace pgtypes.Oid, defaclobjtype pgtypes.Char) (*PgDefaultACL, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, defaclrole, defaclnamespace, defaclobjtype, defaclacl ` +
		`FROM pg_catalog.pg_default_acl ` +
		`WHERE defaclrole = $1 AND defaclnamespace = $2 AND defaclobjtype = $3`
	// run
	logf(sqlstr, defaclrole, defaclnamespace, defaclobjtype)
	pda := PgDefaultACL{}
	if err := db.QueryRowContext(ctx, sqlstr, defaclrole, defaclnamespace, defaclobjtype).Scan(&pda.Tableoid, &pda.Cmax, &pda.Xmax, &pda.Cmin, &pda.Xmin, &pda.Ctid, &pda.Oid, &pda.Defaclrole, &pda.Defaclnamespace, &pda.Defaclobjtype, &pda.Defaclacl); err != nil {
		return nil, logerror(err)
	}
	return &pda, nil
}

// PgDependsByClassidObjidObjsubid retrieves a row from 'pg_catalog.pg_depend' as a PgDepend.
//
// Generated from index 'pg_depend_depender_index'.
func PgDependsByClassidObjidObjsubid(ctx context.Context, db DB, classid, objid pgtypes.Oid, objsubid int) ([]*PgDepend, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, classid, objid, objsubid, refclassid, refobjid, refobjsubid, deptype ` +
		`FROM pg_catalog.pg_depend ` +
		`WHERE classid = $1 AND objid = $2 AND objsubid = $3`
	// run
	logf(sqlstr, classid, objid, objsubid)
	rows, err := db.QueryContext(ctx, sqlstr, classid, objid, objsubid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgDepend
	for rows.Next() {
		pd := PgDepend{}
		// scan
		if err := rows.Scan(&pd.Tableoid, &pd.Cmax, &pd.Xmax, &pd.Cmin, &pd.Xmin, &pd.Ctid, &pd.Classid, &pd.Objid, &pd.Objsubid, &pd.Refclassid, &pd.Refobjid, &pd.Refobjsubid, &pd.Deptype); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pd)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgDependsByRefclassidRefobjidRefobjsubid retrieves a row from 'pg_catalog.pg_depend' as a PgDepend.
//
// Generated from index 'pg_depend_reference_index'.
func PgDependsByRefclassidRefobjidRefobjsubid(ctx context.Context, db DB, refclassid, refobjid pgtypes.Oid, refobjsubid int) ([]*PgDepend, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, classid, objid, objsubid, refclassid, refobjid, refobjsubid, deptype ` +
		`FROM pg_catalog.pg_depend ` +
		`WHERE refclassid = $1 AND refobjid = $2 AND refobjsubid = $3`
	// run
	logf(sqlstr, refclassid, refobjid, refobjsubid)
	rows, err := db.QueryContext(ctx, sqlstr, refclassid, refobjid, refobjsubid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgDepend
	for rows.Next() {
		pd := PgDepend{}
		// scan
		if err := rows.Scan(&pd.Tableoid, &pd.Cmax, &pd.Xmax, &pd.Cmin, &pd.Xmin, &pd.Ctid, &pd.Classid, &pd.Objid, &pd.Objsubid, &pd.Refclassid, &pd.Refobjid, &pd.Refobjsubid, &pd.Deptype); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pd)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgDescriptionByObjoidClassoidObjsubid retrieves a row from 'pg_catalog.pg_description' as a PgDescription.
//
// Generated from index 'pg_description_o_c_o_index'.
func PgDescriptionByObjoidClassoidObjsubid(ctx context.Context, db DB, objoid, classoid pgtypes.Oid, objsubid int) (*PgDescription, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, objoid, classoid, objsubid, description ` +
		`FROM pg_catalog.pg_description ` +
		`WHERE objoid = $1 AND classoid = $2 AND objsubid = $3`
	// run
	logf(sqlstr, objoid, classoid, objsubid)
	pd := PgDescription{}
	if err := db.QueryRowContext(ctx, sqlstr, objoid, classoid, objsubid).Scan(&pd.Tableoid, &pd.Cmax, &pd.Xmax, &pd.Cmin, &pd.Xmin, &pd.Ctid, &pd.Objoid, &pd.Classoid, &pd.Objsubid, &pd.Description); err != nil {
		return nil, logerror(err)
	}
	return &pd, nil
}

// PgEnumByOid retrieves a row from 'pg_catalog.pg_enum' as a PgEnum.
//
// Generated from index 'pg_enum_oid_index'.
func PgEnumByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgEnum, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, enumtypid, enumsortorder, enumlabel ` +
		`FROM pg_catalog.pg_enum ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pe := PgEnum{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Ctid, &pe.Oid, &pe.Enumtypid, &pe.Enumsortorder, &pe.Enumlabel); err != nil {
		return nil, logerror(err)
	}
	return &pe, nil
}

// PgEnumByEnumtypidEnumlabel retrieves a row from 'pg_catalog.pg_enum' as a PgEnum.
//
// Generated from index 'pg_enum_typid_label_index'.
func PgEnumByEnumtypidEnumlabel(ctx context.Context, db DB, enumtypid pgtypes.Oid, enumlabel pgtypes.Name) (*PgEnum, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, enumtypid, enumsortorder, enumlabel ` +
		`FROM pg_catalog.pg_enum ` +
		`WHERE enumtypid = $1 AND enumlabel = $2`
	// run
	logf(sqlstr, enumtypid, enumlabel)
	pe := PgEnum{}
	if err := db.QueryRowContext(ctx, sqlstr, enumtypid, enumlabel).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Ctid, &pe.Oid, &pe.Enumtypid, &pe.Enumsortorder, &pe.Enumlabel); err != nil {
		return nil, logerror(err)
	}
	return &pe, nil
}

// PgEnumByEnumtypidEnumsortorder retrieves a row from 'pg_catalog.pg_enum' as a PgEnum.
//
// Generated from index 'pg_enum_typid_sortorder_index'.
func PgEnumByEnumtypidEnumsortorder(ctx context.Context, db DB, enumtypid pgtypes.Oid, enumsortorder float32) (*PgEnum, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, enumtypid, enumsortorder, enumlabel ` +
		`FROM pg_catalog.pg_enum ` +
		`WHERE enumtypid = $1 AND enumsortorder = $2`
	// run
	logf(sqlstr, enumtypid, enumsortorder)
	pe := PgEnum{}
	if err := db.QueryRowContext(ctx, sqlstr, enumtypid, enumsortorder).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Ctid, &pe.Oid, &pe.Enumtypid, &pe.Enumsortorder, &pe.Enumlabel); err != nil {
		return nil, logerror(err)
	}
	return &pe, nil
}

// PgEventTriggerByEvtname retrieves a row from 'pg_catalog.pg_event_trigger' as a PgEventTrigger.
//
// Generated from index 'pg_event_trigger_evtname_index'.
func PgEventTriggerByEvtname(ctx context.Context, db DB, evtname pgtypes.Name) (*PgEventTrigger, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, evtname, evtevent, evtowner, evtfoid, evtenabled, evttags ` +
		`FROM pg_catalog.pg_event_trigger ` +
		`WHERE evtname = $1`
	// run
	logf(sqlstr, evtname)
	pet := PgEventTrigger{}
	if err := db.QueryRowContext(ctx, sqlstr, evtname).Scan(&pet.Tableoid, &pet.Cmax, &pet.Xmax, &pet.Cmin, &pet.Xmin, &pet.Ctid, &pet.Oid, &pet.Evtname, &pet.Evtevent, &pet.Evtowner, &pet.Evtfoid, &pet.Evtenabled, &pet.Evttags); err != nil {
		return nil, logerror(err)
	}
	return &pet, nil
}

// PgEventTriggerByOid retrieves a row from 'pg_catalog.pg_event_trigger' as a PgEventTrigger.
//
// Generated from index 'pg_event_trigger_oid_index'.
func PgEventTriggerByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgEventTrigger, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, evtname, evtevent, evtowner, evtfoid, evtenabled, evttags ` +
		`FROM pg_catalog.pg_event_trigger ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pet := PgEventTrigger{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pet.Tableoid, &pet.Cmax, &pet.Xmax, &pet.Cmin, &pet.Xmin, &pet.Ctid, &pet.Oid, &pet.Evtname, &pet.Evtevent, &pet.Evtowner, &pet.Evtfoid, &pet.Evtenabled, &pet.Evttags); err != nil {
		return nil, logerror(err)
	}
	return &pet, nil
}

// PgExtensionByExtname retrieves a row from 'pg_catalog.pg_extension' as a PgExtension.
//
// Generated from index 'pg_extension_name_index'.
func PgExtensionByExtname(ctx context.Context, db DB, extname pgtypes.Name) (*PgExtension, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, extname, extowner, extnamespace, extrelocatable, extversion, extconfig, extcondition ` +
		`FROM pg_catalog.pg_extension ` +
		`WHERE extname = $1`
	// run
	logf(sqlstr, extname)
	pe := PgExtension{}
	if err := db.QueryRowContext(ctx, sqlstr, extname).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Ctid, &pe.Oid, &pe.Extname, &pe.Extowner, &pe.Extnamespace, &pe.Extrelocatable, &pe.Extversion, &pe.Extconfig, &pe.Extcondition); err != nil {
		return nil, logerror(err)
	}
	return &pe, nil
}

// PgExtensionByOid retrieves a row from 'pg_catalog.pg_extension' as a PgExtension.
//
// Generated from index 'pg_extension_oid_index'.
func PgExtensionByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgExtension, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, extname, extowner, extnamespace, extrelocatable, extversion, extconfig, extcondition ` +
		`FROM pg_catalog.pg_extension ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pe := PgExtension{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Ctid, &pe.Oid, &pe.Extname, &pe.Extowner, &pe.Extnamespace, &pe.Extrelocatable, &pe.Extversion, &pe.Extconfig, &pe.Extcondition); err != nil {
		return nil, logerror(err)
	}
	return &pe, nil
}

// PgForeignDataWrapperByFdwname retrieves a row from 'pg_catalog.pg_foreign_data_wrapper' as a PgForeignDataWrapper.
//
// Generated from index 'pg_foreign_data_wrapper_name_index'.
func PgForeignDataWrapperByFdwname(ctx context.Context, db DB, fdwname pgtypes.Name) (*PgForeignDataWrapper, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, fdwname, fdwowner, fdwhandler, fdwvalidator, fdwacl, fdwoptions ` +
		`FROM pg_catalog.pg_foreign_data_wrapper ` +
		`WHERE fdwname = $1`
	// run
	logf(sqlstr, fdwname)
	pfdw := PgForeignDataWrapper{}
	if err := db.QueryRowContext(ctx, sqlstr, fdwname).Scan(&pfdw.Tableoid, &pfdw.Cmax, &pfdw.Xmax, &pfdw.Cmin, &pfdw.Xmin, &pfdw.Ctid, &pfdw.Oid, &pfdw.Fdwname, &pfdw.Fdwowner, &pfdw.Fdwhandler, &pfdw.Fdwvalidator, &pfdw.Fdwacl, &pfdw.Fdwoptions); err != nil {
		return nil, logerror(err)
	}
	return &pfdw, nil
}

// PgForeignDataWrapperByOid retrieves a row from 'pg_catalog.pg_foreign_data_wrapper' as a PgForeignDataWrapper.
//
// Generated from index 'pg_foreign_data_wrapper_oid_index'.
func PgForeignDataWrapperByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgForeignDataWrapper, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, fdwname, fdwowner, fdwhandler, fdwvalidator, fdwacl, fdwoptions ` +
		`FROM pg_catalog.pg_foreign_data_wrapper ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pfdw := PgForeignDataWrapper{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pfdw.Tableoid, &pfdw.Cmax, &pfdw.Xmax, &pfdw.Cmin, &pfdw.Xmin, &pfdw.Ctid, &pfdw.Oid, &pfdw.Fdwname, &pfdw.Fdwowner, &pfdw.Fdwhandler, &pfdw.Fdwvalidator, &pfdw.Fdwacl, &pfdw.Fdwoptions); err != nil {
		return nil, logerror(err)
	}
	return &pfdw, nil
}

// PgForeignServerBySrvname retrieves a row from 'pg_catalog.pg_foreign_server' as a PgForeignServer.
//
// Generated from index 'pg_foreign_server_name_index'.
func PgForeignServerBySrvname(ctx context.Context, db DB, srvname pgtypes.Name) (*PgForeignServer, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, srvoptions ` +
		`FROM pg_catalog.pg_foreign_server ` +
		`WHERE srvname = $1`
	// run
	logf(sqlstr, srvname)
	pfs := PgForeignServer{}
	if err := db.QueryRowContext(ctx, sqlstr, srvname).Scan(&pfs.Tableoid, &pfs.Cmax, &pfs.Xmax, &pfs.Cmin, &pfs.Xmin, &pfs.Ctid, &pfs.Oid, &pfs.Srvname, &pfs.Srvowner, &pfs.Srvfdw, &pfs.Srvtype, &pfs.Srvversion, &pfs.Srvacl, &pfs.Srvoptions); err != nil {
		return nil, logerror(err)
	}
	return &pfs, nil
}

// PgForeignServerByOid retrieves a row from 'pg_catalog.pg_foreign_server' as a PgForeignServer.
//
// Generated from index 'pg_foreign_server_oid_index'.
func PgForeignServerByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgForeignServer, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, srvoptions ` +
		`FROM pg_catalog.pg_foreign_server ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pfs := PgForeignServer{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pfs.Tableoid, &pfs.Cmax, &pfs.Xmax, &pfs.Cmin, &pfs.Xmin, &pfs.Ctid, &pfs.Oid, &pfs.Srvname, &pfs.Srvowner, &pfs.Srvfdw, &pfs.Srvtype, &pfs.Srvversion, &pfs.Srvacl, &pfs.Srvoptions); err != nil {
		return nil, logerror(err)
	}
	return &pfs, nil
}

// PgForeignTableByFtrelid retrieves a row from 'pg_catalog.pg_foreign_table' as a PgForeignTable.
//
// Generated from index 'pg_foreign_table_relid_index'.
func PgForeignTableByFtrelid(ctx context.Context, db DB, ftrelid pgtypes.Oid) (*PgForeignTable, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, ftrelid, ftserver, ftoptions ` +
		`FROM pg_catalog.pg_foreign_table ` +
		`WHERE ftrelid = $1`
	// run
	logf(sqlstr, ftrelid)
	pft := PgForeignTable{}
	if err := db.QueryRowContext(ctx, sqlstr, ftrelid).Scan(&pft.Tableoid, &pft.Cmax, &pft.Xmax, &pft.Cmin, &pft.Xmin, &pft.Ctid, &pft.Ftrelid, &pft.Ftserver, &pft.Ftoptions); err != nil {
		return nil, logerror(err)
	}
	return &pft, nil
}

// PgIndexByIndexrelid retrieves a row from 'pg_catalog.pg_index' as a PgIndex.
//
// Generated from index 'pg_index_indexrelid_index'.
func PgIndexByIndexrelid(ctx context.Context, db DB, indexrelid pgtypes.Oid) (*PgIndex, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, indexrelid, indrelid, indnatts, indnkeyatts, indisunique, indisprimary, indisexclusion, indimmediate, indisclustered, indisvalid, indcheckxmin, indisready, indislive, indisreplident, indkey, indcollation, indclass, indoption, indexprs, indpred ` +
		`FROM pg_catalog.pg_index ` +
		`WHERE indexrelid = $1`
	// run
	logf(sqlstr, indexrelid)
	pi := PgIndex{}
	if err := db.QueryRowContext(ctx, sqlstr, indexrelid).Scan(&pi.Tableoid, &pi.Cmax, &pi.Xmax, &pi.Cmin, &pi.Xmin, &pi.Ctid, &pi.Indexrelid, &pi.Indrelid, &pi.Indnatts, &pi.Indnkeyatts, &pi.Indisunique, &pi.Indisprimary, &pi.Indisexclusion, &pi.Indimmediate, &pi.Indisclustered, &pi.Indisvalid, &pi.Indcheckxmin, &pi.Indisready, &pi.Indislive, &pi.Indisreplident, &pi.Indkey, &pi.Indcollation, &pi.Indclass, &pi.Indoption, &pi.Indexprs, &pi.Indpred); err != nil {
		return nil, logerror(err)
	}
	return &pi, nil
}

// PgIndicesByIndrelid retrieves a row from 'pg_catalog.pg_index' as a PgIndex.
//
// Generated from index 'pg_index_indrelid_index'.
func PgIndicesByIndrelid(ctx context.Context, db DB, indrelid pgtypes.Oid) ([]*PgIndex, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, indexrelid, indrelid, indnatts, indnkeyatts, indisunique, indisprimary, indisexclusion, indimmediate, indisclustered, indisvalid, indcheckxmin, indisready, indislive, indisreplident, indkey, indcollation, indclass, indoption, indexprs, indpred ` +
		`FROM pg_catalog.pg_index ` +
		`WHERE indrelid = $1`
	// run
	logf(sqlstr, indrelid)
	rows, err := db.QueryContext(ctx, sqlstr, indrelid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgIndex
	for rows.Next() {
		pi := PgIndex{}
		// scan
		if err := rows.Scan(&pi.Tableoid, &pi.Cmax, &pi.Xmax, &pi.Cmin, &pi.Xmin, &pi.Ctid, &pi.Indexrelid, &pi.Indrelid, &pi.Indnatts, &pi.Indnkeyatts, &pi.Indisunique, &pi.Indisprimary, &pi.Indisexclusion, &pi.Indimmediate, &pi.Indisclustered, &pi.Indisvalid, &pi.Indcheckxmin, &pi.Indisready, &pi.Indislive, &pi.Indisreplident, &pi.Indkey, &pi.Indcollation, &pi.Indclass, &pi.Indoption, &pi.Indexprs, &pi.Indpred); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pi)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgInheritsByInhparent retrieves a row from 'pg_catalog.pg_inherits' as a PgInherit.
//
// Generated from index 'pg_inherits_parent_index'.
func PgInheritsByInhparent(ctx context.Context, db DB, inhparent pgtypes.Oid) ([]*PgInherit, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, inhrelid, inhparent, inhseqno ` +
		`FROM pg_catalog.pg_inherits ` +
		`WHERE inhparent = $1`
	// run
	logf(sqlstr, inhparent)
	rows, err := db.QueryContext(ctx, sqlstr, inhparent)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgInherit
	for rows.Next() {
		pi := PgInherit{}
		// scan
		if err := rows.Scan(&pi.Tableoid, &pi.Cmax, &pi.Xmax, &pi.Cmin, &pi.Xmin, &pi.Ctid, &pi.Inhrelid, &pi.Inhparent, &pi.Inhseqno); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pi)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgInheritByInhrelidInhseqno retrieves a row from 'pg_catalog.pg_inherits' as a PgInherit.
//
// Generated from index 'pg_inherits_relid_seqno_index'.
func PgInheritByInhrelidInhseqno(ctx context.Context, db DB, inhrelid pgtypes.Oid, inhseqno int) (*PgInherit, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, inhrelid, inhparent, inhseqno ` +
		`FROM pg_catalog.pg_inherits ` +
		`WHERE inhrelid = $1 AND inhseqno = $2`
	// run
	logf(sqlstr, inhrelid, inhseqno)
	pi := PgInherit{}
	if err := db.QueryRowContext(ctx, sqlstr, inhrelid, inhseqno).Scan(&pi.Tableoid, &pi.Cmax, &pi.Xmax, &pi.Cmin, &pi.Xmin, &pi.Ctid, &pi.Inhrelid, &pi.Inhparent, &pi.Inhseqno); err != nil {
		return nil, logerror(err)
	}
	return &pi, nil
}

// PgInitPrivByObjoidClassoidObjsubid retrieves a row from 'pg_catalog.pg_init_privs' as a PgInitPriv.
//
// Generated from index 'pg_init_privs_o_c_o_index'.
func PgInitPrivByObjoidClassoidObjsubid(ctx context.Context, db DB, objoid, classoid pgtypes.Oid, objsubid int) (*PgInitPriv, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, objoid, classoid, objsubid, privtype, initprivs ` +
		`FROM pg_catalog.pg_init_privs ` +
		`WHERE objoid = $1 AND classoid = $2 AND objsubid = $3`
	// run
	logf(sqlstr, objoid, classoid, objsubid)
	pip := PgInitPriv{}
	if err := db.QueryRowContext(ctx, sqlstr, objoid, classoid, objsubid).Scan(&pip.Tableoid, &pip.Cmax, &pip.Xmax, &pip.Cmin, &pip.Xmin, &pip.Ctid, &pip.Objoid, &pip.Classoid, &pip.Objsubid, &pip.Privtype, &pip.Initprivs); err != nil {
		return nil, logerror(err)
	}
	return &pip, nil
}

// PgLanguageByLanname retrieves a row from 'pg_catalog.pg_language' as a PgLanguage.
//
// Generated from index 'pg_language_name_index'.
func PgLanguageByLanname(ctx context.Context, db DB, lanname pgtypes.Name) (*PgLanguage, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, lanname, lanowner, lanispl, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl ` +
		`FROM pg_catalog.pg_language ` +
		`WHERE lanname = $1`
	// run
	logf(sqlstr, lanname)
	pl := PgLanguage{}
	if err := db.QueryRowContext(ctx, sqlstr, lanname).Scan(&pl.Tableoid, &pl.Cmax, &pl.Xmax, &pl.Cmin, &pl.Xmin, &pl.Ctid, &pl.Oid, &pl.Lanname, &pl.Lanowner, &pl.Lanispl, &pl.Lanpltrusted, &pl.Lanplcallfoid, &pl.Laninline, &pl.Lanvalidator, &pl.Lanacl); err != nil {
		return nil, logerror(err)
	}
	return &pl, nil
}

// PgLanguageByOid retrieves a row from 'pg_catalog.pg_language' as a PgLanguage.
//
// Generated from index 'pg_language_oid_index'.
func PgLanguageByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgLanguage, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, lanname, lanowner, lanispl, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl ` +
		`FROM pg_catalog.pg_language ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pl := PgLanguage{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pl.Tableoid, &pl.Cmax, &pl.Xmax, &pl.Cmin, &pl.Xmin, &pl.Ctid, &pl.Oid, &pl.Lanname, &pl.Lanowner, &pl.Lanispl, &pl.Lanpltrusted, &pl.Lanplcallfoid, &pl.Laninline, &pl.Lanvalidator, &pl.Lanacl); err != nil {
		return nil, logerror(err)
	}
	return &pl, nil
}

// PgLargeobjectByLoidPageno retrieves a row from 'pg_catalog.pg_largeobject' as a PgLargeobject.
//
// Generated from index 'pg_largeobject_loid_pn_index'.
func PgLargeobjectByLoidPageno(ctx context.Context, db DB, loid pgtypes.Oid, pageno int) (*PgLargeobject, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, loid, pageno, data ` +
		`FROM pg_catalog.pg_largeobject ` +
		`WHERE loid = $1 AND pageno = $2`
	// run
	logf(sqlstr, loid, pageno)
	pl := PgLargeobject{}
	if err := db.QueryRowContext(ctx, sqlstr, loid, pageno).Scan(&pl.Tableoid, &pl.Cmax, &pl.Xmax, &pl.Cmin, &pl.Xmin, &pl.Ctid, &pl.Loid, &pl.Pageno, &pl.Data); err != nil {
		return nil, logerror(err)
	}
	return &pl, nil
}

// PgLargeobjectMetadatumByOid retrieves a row from 'pg_catalog.pg_largeobject_metadata' as a PgLargeobjectMetadatum.
//
// Generated from index 'pg_largeobject_metadata_oid_index'.
func PgLargeobjectMetadatumByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgLargeobjectMetadatum, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, lomowner, lomacl ` +
		`FROM pg_catalog.pg_largeobject_metadata ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	plm := PgLargeobjectMetadatum{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&plm.Tableoid, &plm.Cmax, &plm.Xmax, &plm.Cmin, &plm.Xmin, &plm.Ctid, &plm.Oid, &plm.Lomowner, &plm.Lomacl); err != nil {
		return nil, logerror(err)
	}
	return &plm, nil
}

// PgNamespaceByNspname retrieves a row from 'pg_catalog.pg_namespace' as a PgNamespace.
//
// Generated from index 'pg_namespace_nspname_index'.
func PgNamespaceByNspname(ctx context.Context, db DB, nspname pgtypes.Name) (*PgNamespace, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, nspname, nspowner, nspacl ` +
		`FROM pg_catalog.pg_namespace ` +
		`WHERE nspname = $1`
	// run
	logf(sqlstr, nspname)
	pn := PgNamespace{}
	if err := db.QueryRowContext(ctx, sqlstr, nspname).Scan(&pn.Tableoid, &pn.Cmax, &pn.Xmax, &pn.Cmin, &pn.Xmin, &pn.Ctid, &pn.Oid, &pn.Nspname, &pn.Nspowner, &pn.Nspacl); err != nil {
		return nil, logerror(err)
	}
	return &pn, nil
}

// PgNamespaceByOid retrieves a row from 'pg_catalog.pg_namespace' as a PgNamespace.
//
// Generated from index 'pg_namespace_oid_index'.
func PgNamespaceByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgNamespace, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, nspname, nspowner, nspacl ` +
		`FROM pg_catalog.pg_namespace ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pn := PgNamespace{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pn.Tableoid, &pn.Cmax, &pn.Xmax, &pn.Cmin, &pn.Xmin, &pn.Ctid, &pn.Oid, &pn.Nspname, &pn.Nspowner, &pn.Nspacl); err != nil {
		return nil, logerror(err)
	}
	return &pn, nil
}

// PgOpclassByOpcmethodOpcnameOpcnamespace retrieves a row from 'pg_catalog.pg_opclass' as a PgOpclass.
//
// Generated from index 'pg_opclass_am_name_nsp_index'.
func PgOpclassByOpcmethodOpcnameOpcnamespace(ctx context.Context, db DB, opcmethod pgtypes.Oid, opcname pgtypes.Name, opcnamespace pgtypes.Oid) (*PgOpclass, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, opcmethod, opcname, opcnamespace, opcowner, opcfamily, opcintype, opcdefault, opckeytype ` +
		`FROM pg_catalog.pg_opclass ` +
		`WHERE opcmethod = $1 AND opcname = $2 AND opcnamespace = $3`
	// run
	logf(sqlstr, opcmethod, opcname, opcnamespace)
	po := PgOpclass{}
	if err := db.QueryRowContext(ctx, sqlstr, opcmethod, opcname, opcnamespace).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Opcmethod, &po.Opcname, &po.Opcnamespace, &po.Opcowner, &po.Opcfamily, &po.Opcintype, &po.Opcdefault, &po.Opckeytype); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgOpclassByOid retrieves a row from 'pg_catalog.pg_opclass' as a PgOpclass.
//
// Generated from index 'pg_opclass_oid_index'.
func PgOpclassByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgOpclass, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, opcmethod, opcname, opcnamespace, opcowner, opcfamily, opcintype, opcdefault, opckeytype ` +
		`FROM pg_catalog.pg_opclass ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	po := PgOpclass{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Opcmethod, &po.Opcname, &po.Opcnamespace, &po.Opcowner, &po.Opcfamily, &po.Opcintype, &po.Opcdefault, &po.Opckeytype); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgOperatorByOid retrieves a row from 'pg_catalog.pg_operator' as a PgOperator.
//
// Generated from index 'pg_operator_oid_index'.
func PgOperatorByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgOperator, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, oprname, oprnamespace, oprowner, oprkind, oprcanmerge, oprcanhash, oprleft, oprright, oprresult, oprcom, oprnegate, oprcode, oprrest, oprjoin ` +
		`FROM pg_catalog.pg_operator ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	po := PgOperator{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Oprname, &po.Oprnamespace, &po.Oprowner, &po.Oprkind, &po.Oprcanmerge, &po.Oprcanhash, &po.Oprleft, &po.Oprright, &po.Oprresult, &po.Oprcom, &po.Oprnegate, &po.Oprcode, &po.Oprrest, &po.Oprjoin); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgOperatorByOprnameOprleftOprrightOprnamespace retrieves a row from 'pg_catalog.pg_operator' as a PgOperator.
//
// Generated from index 'pg_operator_oprname_l_r_n_index'.
func PgOperatorByOprnameOprleftOprrightOprnamespace(ctx context.Context, db DB, oprname pgtypes.Name, oprleft, oprright, oprnamespace pgtypes.Oid) (*PgOperator, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, oprname, oprnamespace, oprowner, oprkind, oprcanmerge, oprcanhash, oprleft, oprright, oprresult, oprcom, oprnegate, oprcode, oprrest, oprjoin ` +
		`FROM pg_catalog.pg_operator ` +
		`WHERE oprname = $1 AND oprleft = $2 AND oprright = $3 AND oprnamespace = $4`
	// run
	logf(sqlstr, oprname, oprleft, oprright, oprnamespace)
	po := PgOperator{}
	if err := db.QueryRowContext(ctx, sqlstr, oprname, oprleft, oprright, oprnamespace).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Oprname, &po.Oprnamespace, &po.Oprowner, &po.Oprkind, &po.Oprcanmerge, &po.Oprcanhash, &po.Oprleft, &po.Oprright, &po.Oprresult, &po.Oprcom, &po.Oprnegate, &po.Oprcode, &po.Oprrest, &po.Oprjoin); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgOpfamilyByOpfmethodOpfnameOpfnamespace retrieves a row from 'pg_catalog.pg_opfamily' as a PgOpfamily.
//
// Generated from index 'pg_opfamily_am_name_nsp_index'.
func PgOpfamilyByOpfmethodOpfnameOpfnamespace(ctx context.Context, db DB, opfmethod pgtypes.Oid, opfname pgtypes.Name, opfnamespace pgtypes.Oid) (*PgOpfamily, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, opfmethod, opfname, opfnamespace, opfowner ` +
		`FROM pg_catalog.pg_opfamily ` +
		`WHERE opfmethod = $1 AND opfname = $2 AND opfnamespace = $3`
	// run
	logf(sqlstr, opfmethod, opfname, opfnamespace)
	po := PgOpfamily{}
	if err := db.QueryRowContext(ctx, sqlstr, opfmethod, opfname, opfnamespace).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Opfmethod, &po.Opfname, &po.Opfnamespace, &po.Opfowner); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgOpfamilyByOid retrieves a row from 'pg_catalog.pg_opfamily' as a PgOpfamily.
//
// Generated from index 'pg_opfamily_oid_index'.
func PgOpfamilyByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgOpfamily, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, opfmethod, opfname, opfnamespace, opfowner ` +
		`FROM pg_catalog.pg_opfamily ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	po := PgOpfamily{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Opfmethod, &po.Opfname, &po.Opfnamespace, &po.Opfowner); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgPartitionedTableByPartrelid retrieves a row from 'pg_catalog.pg_partitioned_table' as a PgPartitionedTable.
//
// Generated from index 'pg_partitioned_table_partrelid_index'.
func PgPartitionedTableByPartrelid(ctx context.Context, db DB, partrelid pgtypes.Oid) (*PgPartitionedTable, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, partrelid, partstrat, partnatts, partdefid, partattrs, partclass, partcollation, partexprs ` +
		`FROM pg_catalog.pg_partitioned_table ` +
		`WHERE partrelid = $1`
	// run
	logf(sqlstr, partrelid)
	ppt := PgPartitionedTable{}
	if err := db.QueryRowContext(ctx, sqlstr, partrelid).Scan(&ppt.Tableoid, &ppt.Cmax, &ppt.Xmax, &ppt.Cmin, &ppt.Xmin, &ppt.Ctid, &ppt.Partrelid, &ppt.Partstrat, &ppt.Partnatts, &ppt.Partdefid, &ppt.Partattrs, &ppt.Partclass, &ppt.Partcollation, &ppt.Partexprs); err != nil {
		return nil, logerror(err)
	}
	return &ppt, nil
}

// PgPolicyByOid retrieves a row from 'pg_catalog.pg_policy' as a PgPolicy.
//
// Generated from index 'pg_policy_oid_index'.
func PgPolicyByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgPolicy, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, polname, polrelid, polcmd, polpermissive, polroles, polqual, polwithcheck ` +
		`FROM pg_catalog.pg_policy ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pp := PgPolicy{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Polname, &pp.Polrelid, &pp.Polcmd, &pp.Polpermissive, &pp.Polroles, &pp.Polqual, &pp.Polwithcheck); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgPolicyByPolrelidPolname retrieves a row from 'pg_catalog.pg_policy' as a PgPolicy.
//
// Generated from index 'pg_policy_polrelid_polname_index'.
func PgPolicyByPolrelidPolname(ctx context.Context, db DB, polrelid pgtypes.Oid, polname pgtypes.Name) (*PgPolicy, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, polname, polrelid, polcmd, polpermissive, polroles, polqual, polwithcheck ` +
		`FROM pg_catalog.pg_policy ` +
		`WHERE polrelid = $1 AND polname = $2`
	// run
	logf(sqlstr, polrelid, polname)
	pp := PgPolicy{}
	if err := db.QueryRowContext(ctx, sqlstr, polrelid, polname).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Polname, &pp.Polrelid, &pp.Polcmd, &pp.Polpermissive, &pp.Polroles, &pp.Polqual, &pp.Polwithcheck); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgProcByOid retrieves a row from 'pg_catalog.pg_proc' as a PgProc.
//
// Generated from index 'pg_proc_oid_index'.
func PgProcByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgProc, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, proname, pronamespace, proowner, prolang, procost, prorows, provariadic, prosupport, prokind, prosecdef, proleakproof, proisstrict, proretset, provolatile, proparallel, pronargs, pronargdefaults, prorettype, proargtypes, proallargtypes, proargmodes, proargnames, proargdefaults, protrftypes, prosrc, probin, proconfig, proacl ` +
		`FROM pg_catalog.pg_proc ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pp := PgProc{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Proname, &pp.Pronamespace, &pp.Proowner, &pp.Prolang, &pp.Procost, &pp.Prorows, &pp.Provariadic, &pp.Prosupport, &pp.Prokind, &pp.Prosecdef, &pp.Proleakproof, &pp.Proisstrict, &pp.Proretset, &pp.Provolatile, &pp.Proparallel, &pp.Pronargs, &pp.Pronargdefaults, &pp.Prorettype, &pp.Proargtypes, &pp.Proallargtypes, &pp.Proargmodes, &pp.Proargnames, &pp.Proargdefaults, &pp.Protrftypes, &pp.Prosrc, &pp.Probin, &pp.Proconfig, &pp.Proacl); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgProcByPronameProargtypesPronamespace retrieves a row from 'pg_catalog.pg_proc' as a PgProc.
//
// Generated from index 'pg_proc_proname_args_nsp_index'.
func PgProcByPronameProargtypesPronamespace(ctx context.Context, db DB, proname pgtypes.Name, proargtypes pgtypes.Oidvector, pronamespace pgtypes.Oid) (*PgProc, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, proname, pronamespace, proowner, prolang, procost, prorows, provariadic, prosupport, prokind, prosecdef, proleakproof, proisstrict, proretset, provolatile, proparallel, pronargs, pronargdefaults, prorettype, proargtypes, proallargtypes, proargmodes, proargnames, proargdefaults, protrftypes, prosrc, probin, proconfig, proacl ` +
		`FROM pg_catalog.pg_proc ` +
		`WHERE proname = $1 AND proargtypes = $2 AND pronamespace = $3`
	// run
	logf(sqlstr, proname, proargtypes, pronamespace)
	pp := PgProc{}
	if err := db.QueryRowContext(ctx, sqlstr, proname, proargtypes, pronamespace).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Proname, &pp.Pronamespace, &pp.Proowner, &pp.Prolang, &pp.Procost, &pp.Prorows, &pp.Provariadic, &pp.Prosupport, &pp.Prokind, &pp.Prosecdef, &pp.Proleakproof, &pp.Proisstrict, &pp.Proretset, &pp.Provolatile, &pp.Proparallel, &pp.Pronargs, &pp.Pronargdefaults, &pp.Prorettype, &pp.Proargtypes, &pp.Proallargtypes, &pp.Proargmodes, &pp.Proargnames, &pp.Proargdefaults, &pp.Protrftypes, &pp.Prosrc, &pp.Probin, &pp.Proconfig, &pp.Proacl); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgPublicationByOid retrieves a row from 'pg_catalog.pg_publication' as a PgPublication.
//
// Generated from index 'pg_publication_oid_index'.
func PgPublicationByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgPublication, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, pubname, pubowner, puballtables, pubinsert, pubupdate, pubdelete, pubtruncate, pubviaroot ` +
		`FROM pg_catalog.pg_publication ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pp := PgPublication{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Pubname, &pp.Pubowner, &pp.Puballtables, &pp.Pubinsert, &pp.Pubupdate, &pp.Pubdelete, &pp.Pubtruncate, &pp.Pubviaroot); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgPublicationByPubname retrieves a row from 'pg_catalog.pg_publication' as a PgPublication.
//
// Generated from index 'pg_publication_pubname_index'.
func PgPublicationByPubname(ctx context.Context, db DB, pubname pgtypes.Name) (*PgPublication, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, pubname, pubowner, puballtables, pubinsert, pubupdate, pubdelete, pubtruncate, pubviaroot ` +
		`FROM pg_catalog.pg_publication ` +
		`WHERE pubname = $1`
	// run
	logf(sqlstr, pubname)
	pp := PgPublication{}
	if err := db.QueryRowContext(ctx, sqlstr, pubname).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Pubname, &pp.Pubowner, &pp.Puballtables, &pp.Pubinsert, &pp.Pubupdate, &pp.Pubdelete, &pp.Pubtruncate, &pp.Pubviaroot); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgPublicationRelByOid retrieves a row from 'pg_catalog.pg_publication_rel' as a PgPublicationRel.
//
// Generated from index 'pg_publication_rel_oid_index'.
func PgPublicationRelByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgPublicationRel, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, prpubid, prrelid ` +
		`FROM pg_catalog.pg_publication_rel ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ppr := PgPublicationRel{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ppr.Tableoid, &ppr.Cmax, &ppr.Xmax, &ppr.Cmin, &ppr.Xmin, &ppr.Ctid, &ppr.Oid, &ppr.Prpubid, &ppr.Prrelid); err != nil {
		return nil, logerror(err)
	}
	return &ppr, nil
}

// PgPublicationRelByPrrelidPrpubid retrieves a row from 'pg_catalog.pg_publication_rel' as a PgPublicationRel.
//
// Generated from index 'pg_publication_rel_prrelid_prpubid_index'.
func PgPublicationRelByPrrelidPrpubid(ctx context.Context, db DB, prrelid, prpubid pgtypes.Oid) (*PgPublicationRel, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, prpubid, prrelid ` +
		`FROM pg_catalog.pg_publication_rel ` +
		`WHERE prrelid = $1 AND prpubid = $2`
	// run
	logf(sqlstr, prrelid, prpubid)
	ppr := PgPublicationRel{}
	if err := db.QueryRowContext(ctx, sqlstr, prrelid, prpubid).Scan(&ppr.Tableoid, &ppr.Cmax, &ppr.Xmax, &ppr.Cmin, &ppr.Xmin, &ppr.Ctid, &ppr.Oid, &ppr.Prpubid, &ppr.Prrelid); err != nil {
		return nil, logerror(err)
	}
	return &ppr, nil
}

// PgRangeByRngtypid retrieves a row from 'pg_catalog.pg_range' as a PgRange.
//
// Generated from index 'pg_range_rngtypid_index'.
func PgRangeByRngtypid(ctx context.Context, db DB, rngtypid pgtypes.Oid) (*PgRange, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, rngtypid, rngsubtype, rngcollation, rngsubopc, rngcanonical, rngsubdiff ` +
		`FROM pg_catalog.pg_range ` +
		`WHERE rngtypid = $1`
	// run
	logf(sqlstr, rngtypid)
	pr := PgRange{}
	if err := db.QueryRowContext(ctx, sqlstr, rngtypid).Scan(&pr.Tableoid, &pr.Cmax, &pr.Xmax, &pr.Cmin, &pr.Xmin, &pr.Ctid, &pr.Rngtypid, &pr.Rngsubtype, &pr.Rngcollation, &pr.Rngsubopc, &pr.Rngcanonical, &pr.Rngsubdiff); err != nil {
		return nil, logerror(err)
	}
	return &pr, nil
}

// PgReplicationOriginByRoident retrieves a row from 'pg_catalog.pg_replication_origin' as a PgReplicationOrigin.
//
// Generated from index 'pg_replication_origin_roiident_index'.
func PgReplicationOriginByRoident(ctx context.Context, db DB, roident pgtypes.Oid) (*PgReplicationOrigin, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, roident, roname ` +
		`FROM pg_catalog.pg_replication_origin ` +
		`WHERE roident = $1`
	// run
	logf(sqlstr, roident)
	pro := PgReplicationOrigin{}
	if err := db.QueryRowContext(ctx, sqlstr, roident).Scan(&pro.Tableoid, &pro.Cmax, &pro.Xmax, &pro.Cmin, &pro.Xmin, &pro.Ctid, &pro.Roident, &pro.Roname); err != nil {
		return nil, logerror(err)
	}
	return &pro, nil
}

// PgReplicationOriginByRoname retrieves a row from 'pg_catalog.pg_replication_origin' as a PgReplicationOrigin.
//
// Generated from index 'pg_replication_origin_roname_index'.
func PgReplicationOriginByRoname(ctx context.Context, db DB, roname string) (*PgReplicationOrigin, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, roident, roname ` +
		`FROM pg_catalog.pg_replication_origin ` +
		`WHERE roname = $1`
	// run
	logf(sqlstr, roname)
	pro := PgReplicationOrigin{}
	if err := db.QueryRowContext(ctx, sqlstr, roname).Scan(&pro.Tableoid, &pro.Cmax, &pro.Xmax, &pro.Cmin, &pro.Xmin, &pro.Ctid, &pro.Roident, &pro.Roname); err != nil {
		return nil, logerror(err)
	}
	return &pro, nil
}

// PgRewriteByOid retrieves a row from 'pg_catalog.pg_rewrite' as a PgRewrite.
//
// Generated from index 'pg_rewrite_oid_index'.
func PgRewriteByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgRewrite, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, rulename, ev_class, ev_type, ev_enabled, is_instead, ev_qual, ev_action ` +
		`FROM pg_catalog.pg_rewrite ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pr := PgRewrite{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pr.Tableoid, &pr.Cmax, &pr.Xmax, &pr.Cmin, &pr.Xmin, &pr.Ctid, &pr.Oid, &pr.Rulename, &pr.EvClass, &pr.EvType, &pr.EvEnabled, &pr.IsInstead, &pr.EvQual, &pr.EvAction); err != nil {
		return nil, logerror(err)
	}
	return &pr, nil
}

// PgRewriteByEvClassRulename retrieves a row from 'pg_catalog.pg_rewrite' as a PgRewrite.
//
// Generated from index 'pg_rewrite_rel_rulename_index'.
func PgRewriteByEvClassRulename(ctx context.Context, db DB, evClass pgtypes.Oid, rulename pgtypes.Name) (*PgRewrite, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, rulename, ev_class, ev_type, ev_enabled, is_instead, ev_qual, ev_action ` +
		`FROM pg_catalog.pg_rewrite ` +
		`WHERE ev_class = $1 AND rulename = $2`
	// run
	logf(sqlstr, evClass, rulename)
	pr := PgRewrite{}
	if err := db.QueryRowContext(ctx, sqlstr, evClass, rulename).Scan(&pr.Tableoid, &pr.Cmax, &pr.Xmax, &pr.Cmin, &pr.Xmin, &pr.Ctid, &pr.Oid, &pr.Rulename, &pr.EvClass, &pr.EvType, &pr.EvEnabled, &pr.IsInstead, &pr.EvQual, &pr.EvAction); err != nil {
		return nil, logerror(err)
	}
	return &pr, nil
}

// PgSeclabelByObjoidClassoidObjsubidProvider retrieves a row from 'pg_catalog.pg_seclabel' as a PgSeclabel.
//
// Generated from index 'pg_seclabel_object_index'.
func PgSeclabelByObjoidClassoidObjsubidProvider(ctx context.Context, db DB, objoid, classoid pgtypes.Oid, objsubid int, provider string) (*PgSeclabel, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, objoid, classoid, objsubid, provider, label ` +
		`FROM pg_catalog.pg_seclabel ` +
		`WHERE objoid = $1 AND classoid = $2 AND objsubid = $3 AND provider = $4`
	// run
	logf(sqlstr, objoid, classoid, objsubid, provider)
	ps := PgSeclabel{}
	if err := db.QueryRowContext(ctx, sqlstr, objoid, classoid, objsubid, provider).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Objoid, &ps.Classoid, &ps.Objsubid, &ps.Provider, &ps.Label); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgSequenceBySeqrelid retrieves a row from 'pg_catalog.pg_sequence' as a PgSequence.
//
// Generated from index 'pg_sequence_seqrelid_index'.
func PgSequenceBySeqrelid(ctx context.Context, db DB, seqrelid pgtypes.Oid) (*PgSequence, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, seqrelid, seqtypid, seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle ` +
		`FROM pg_catalog.pg_sequence ` +
		`WHERE seqrelid = $1`
	// run
	logf(sqlstr, seqrelid)
	ps := PgSequence{}
	if err := db.QueryRowContext(ctx, sqlstr, seqrelid).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Seqrelid, &ps.Seqtypid, &ps.Seqstart, &ps.Seqincrement, &ps.Seqmax, &ps.Seqmin, &ps.Seqcache, &ps.Seqcycle); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgShdependsByDbidClassidObjidObjsubid retrieves a row from 'pg_catalog.pg_shdepend' as a PgShdepend.
//
// Generated from index 'pg_shdepend_depender_index'.
func PgShdependsByDbidClassidObjidObjsubid(ctx context.Context, db DB, dbid, classid, objid pgtypes.Oid, objsubid int) ([]*PgShdepend, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, dbid, classid, objid, objsubid, refclassid, refobjid, deptype ` +
		`FROM pg_catalog.pg_shdepend ` +
		`WHERE dbid = $1 AND classid = $2 AND objid = $3 AND objsubid = $4`
	// run
	logf(sqlstr, dbid, classid, objid, objsubid)
	rows, err := db.QueryContext(ctx, sqlstr, dbid, classid, objid, objsubid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgShdepend
	for rows.Next() {
		ps := PgShdepend{}
		// scan
		if err := rows.Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Dbid, &ps.Classid, &ps.Objid, &ps.Objsubid, &ps.Refclassid, &ps.Refobjid, &ps.Deptype); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ps)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgShdependsByRefclassidRefobjid retrieves a row from 'pg_catalog.pg_shdepend' as a PgShdepend.
//
// Generated from index 'pg_shdepend_reference_index'.
func PgShdependsByRefclassidRefobjid(ctx context.Context, db DB, refclassid, refobjid pgtypes.Oid) ([]*PgShdepend, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, dbid, classid, objid, objsubid, refclassid, refobjid, deptype ` +
		`FROM pg_catalog.pg_shdepend ` +
		`WHERE refclassid = $1 AND refobjid = $2`
	// run
	logf(sqlstr, refclassid, refobjid)
	rows, err := db.QueryContext(ctx, sqlstr, refclassid, refobjid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgShdepend
	for rows.Next() {
		ps := PgShdepend{}
		// scan
		if err := rows.Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Dbid, &ps.Classid, &ps.Objid, &ps.Objsubid, &ps.Refclassid, &ps.Refobjid, &ps.Deptype); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ps)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgShdescriptionByObjoidClassoid retrieves a row from 'pg_catalog.pg_shdescription' as a PgShdescription.
//
// Generated from index 'pg_shdescription_o_c_index'.
func PgShdescriptionByObjoidClassoid(ctx context.Context, db DB, objoid, classoid pgtypes.Oid) (*PgShdescription, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, objoid, classoid, description ` +
		`FROM pg_catalog.pg_shdescription ` +
		`WHERE objoid = $1 AND classoid = $2`
	// run
	logf(sqlstr, objoid, classoid)
	ps := PgShdescription{}
	if err := db.QueryRowContext(ctx, sqlstr, objoid, classoid).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Objoid, &ps.Classoid, &ps.Description); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgShseclabelByObjoidClassoidProvider retrieves a row from 'pg_catalog.pg_shseclabel' as a PgShseclabel.
//
// Generated from index 'pg_shseclabel_object_index'.
func PgShseclabelByObjoidClassoidProvider(ctx context.Context, db DB, objoid, classoid pgtypes.Oid, provider string) (*PgShseclabel, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, objoid, classoid, provider, label ` +
		`FROM pg_catalog.pg_shseclabel ` +
		`WHERE objoid = $1 AND classoid = $2 AND provider = $3`
	// run
	logf(sqlstr, objoid, classoid, provider)
	ps := PgShseclabel{}
	if err := db.QueryRowContext(ctx, sqlstr, objoid, classoid, provider).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Objoid, &ps.Classoid, &ps.Provider, &ps.Label); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgStatisticByStarelidStaattnumStainherit retrieves a row from 'pg_catalog.pg_statistic' as a PgStatistic.
//
// Generated from index 'pg_statistic_relid_att_inh_index'.
func PgStatisticByStarelidStaattnumStainherit(ctx context.Context, db DB, starelid pgtypes.Oid, staattnum int16, stainherit bool) (*PgStatistic, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, starelid, staattnum, stainherit, stanullfrac, stawidth, stadistinct, stakind1, stakind2, stakind3, stakind4, stakind5, staop1, staop2, staop3, staop4, staop5, stacoll1, stacoll2, stacoll3, stacoll4, stacoll5, stanumbers1, stanumbers2, stanumbers3, stanumbers4, stanumbers5, stavalues1, stavalues2, stavalues3, stavalues4, stavalues5 ` +
		`FROM pg_catalog.pg_statistic ` +
		`WHERE starelid = $1 AND staattnum = $2 AND stainherit = $3`
	// run
	logf(sqlstr, starelid, staattnum, stainherit)
	ps := PgStatistic{}
	if err := db.QueryRowContext(ctx, sqlstr, starelid, staattnum, stainherit).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Starelid, &ps.Staattnum, &ps.Stainherit, &ps.Stanullfrac, &ps.Stawidth, &ps.Stadistinct, &ps.Stakind1, &ps.Stakind2, &ps.Stakind3, &ps.Stakind4, &ps.Stakind5, &ps.Staop1, &ps.Staop2, &ps.Staop3, &ps.Staop4, &ps.Staop5, &ps.Stacoll1, &ps.Stacoll2, &ps.Stacoll3, &ps.Stacoll4, &ps.Stacoll5, &ps.Stanumbers1, &ps.Stanumbers2, &ps.Stanumbers3, &ps.Stanumbers4, &ps.Stanumbers5, &ps.Stavalues1, &ps.Stavalues2, &ps.Stavalues3, &ps.Stavalues4, &ps.Stavalues5); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgStatisticExtByStxnameStxnamespace retrieves a row from 'pg_catalog.pg_statistic_ext' as a PgStatisticExt.
//
// Generated from index 'pg_statistic_ext_name_index'.
func PgStatisticExtByStxnameStxnamespace(ctx context.Context, db DB, stxname pgtypes.Name, stxnamespace pgtypes.Oid) (*PgStatisticExt, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, stxrelid, stxname, stxnamespace, stxowner, stxstattarget, stxkeys, stxkind ` +
		`FROM pg_catalog.pg_statistic_ext ` +
		`WHERE stxname = $1 AND stxnamespace = $2`
	// run
	logf(sqlstr, stxname, stxnamespace)
	pse := PgStatisticExt{}
	if err := db.QueryRowContext(ctx, sqlstr, stxname, stxnamespace).Scan(&pse.Tableoid, &pse.Cmax, &pse.Xmax, &pse.Cmin, &pse.Xmin, &pse.Ctid, &pse.Oid, &pse.Stxrelid, &pse.Stxname, &pse.Stxnamespace, &pse.Stxowner, &pse.Stxstattarget, &pse.Stxkeys, &pse.Stxkind); err != nil {
		return nil, logerror(err)
	}
	return &pse, nil
}

// PgStatisticExtByOid retrieves a row from 'pg_catalog.pg_statistic_ext' as a PgStatisticExt.
//
// Generated from index 'pg_statistic_ext_oid_index'.
func PgStatisticExtByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgStatisticExt, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, stxrelid, stxname, stxnamespace, stxowner, stxstattarget, stxkeys, stxkind ` +
		`FROM pg_catalog.pg_statistic_ext ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pse := PgStatisticExt{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pse.Tableoid, &pse.Cmax, &pse.Xmax, &pse.Cmin, &pse.Xmin, &pse.Ctid, &pse.Oid, &pse.Stxrelid, &pse.Stxname, &pse.Stxnamespace, &pse.Stxowner, &pse.Stxstattarget, &pse.Stxkeys, &pse.Stxkind); err != nil {
		return nil, logerror(err)
	}
	return &pse, nil
}

// PgStatisticExtsByStxrelid retrieves a row from 'pg_catalog.pg_statistic_ext' as a PgStatisticExt.
//
// Generated from index 'pg_statistic_ext_relid_index'.
func PgStatisticExtsByStxrelid(ctx context.Context, db DB, stxrelid pgtypes.Oid) ([]*PgStatisticExt, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, stxrelid, stxname, stxnamespace, stxowner, stxstattarget, stxkeys, stxkind ` +
		`FROM pg_catalog.pg_statistic_ext ` +
		`WHERE stxrelid = $1`
	// run
	logf(sqlstr, stxrelid)
	rows, err := db.QueryContext(ctx, sqlstr, stxrelid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgStatisticExt
	for rows.Next() {
		pse := PgStatisticExt{}
		// scan
		if err := rows.Scan(&pse.Tableoid, &pse.Cmax, &pse.Xmax, &pse.Cmin, &pse.Xmin, &pse.Ctid, &pse.Oid, &pse.Stxrelid, &pse.Stxname, &pse.Stxnamespace, &pse.Stxowner, &pse.Stxstattarget, &pse.Stxkeys, &pse.Stxkind); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pse)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgStatisticExtDatumByStxoid retrieves a row from 'pg_catalog.pg_statistic_ext_data' as a PgStatisticExtDatum.
//
// Generated from index 'pg_statistic_ext_data_stxoid_index'.
func PgStatisticExtDatumByStxoid(ctx context.Context, db DB, stxoid pgtypes.Oid) (*PgStatisticExtDatum, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, stxoid, stxdndistinct, stxddependencies, stxdmcv ` +
		`FROM pg_catalog.pg_statistic_ext_data ` +
		`WHERE stxoid = $1`
	// run
	logf(sqlstr, stxoid)
	psed := PgStatisticExtDatum{}
	if err := db.QueryRowContext(ctx, sqlstr, stxoid).Scan(&psed.Tableoid, &psed.Cmax, &psed.Xmax, &psed.Cmin, &psed.Xmin, &psed.Ctid, &psed.Stxoid, &psed.Stxdndistinct, &psed.Stxddependencies, &psed.Stxdmcv); err != nil {
		return nil, logerror(err)
	}
	return &psed, nil
}

// PgSubscriptionByOid retrieves a row from 'pg_catalog.pg_subscription' as a PgSubscription.
//
// Generated from index 'pg_subscription_oid_index'.
func PgSubscriptionByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgSubscription, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, subdbid, subname, subowner, subenabled, subconninfo, subslotname, subsynccommit, subpublications ` +
		`FROM pg_catalog.pg_subscription ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ps := PgSubscription{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Oid, &ps.Subdbid, &ps.Subname, &ps.Subowner, &ps.Subenabled, &ps.Subconninfo, &ps.Subslotname, &ps.Subsynccommit, &ps.Subpublications); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgSubscriptionBySubdbidSubname retrieves a row from 'pg_catalog.pg_subscription' as a PgSubscription.
//
// Generated from index 'pg_subscription_subname_index'.
func PgSubscriptionBySubdbidSubname(ctx context.Context, db DB, subdbid pgtypes.Oid, subname pgtypes.Name) (*PgSubscription, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, subdbid, subname, subowner, subenabled, subconninfo, subslotname, subsynccommit, subpublications ` +
		`FROM pg_catalog.pg_subscription ` +
		`WHERE subdbid = $1 AND subname = $2`
	// run
	logf(sqlstr, subdbid, subname)
	ps := PgSubscription{}
	if err := db.QueryRowContext(ctx, sqlstr, subdbid, subname).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Oid, &ps.Subdbid, &ps.Subname, &ps.Subowner, &ps.Subenabled, &ps.Subconninfo, &ps.Subslotname, &ps.Subsynccommit, &ps.Subpublications); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgSubscriptionRelBySrrelidSrsubid retrieves a row from 'pg_catalog.pg_subscription_rel' as a PgSubscriptionRel.
//
// Generated from index 'pg_subscription_rel_srrelid_srsubid_index'.
func PgSubscriptionRelBySrrelidSrsubid(ctx context.Context, db DB, srrelid, srsubid pgtypes.Oid) (*PgSubscriptionRel, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, srsubid, srrelid, srsubstate, srsublsn ` +
		`FROM pg_catalog.pg_subscription_rel ` +
		`WHERE srrelid = $1 AND srsubid = $2`
	// run
	logf(sqlstr, srrelid, srsubid)
	psr := PgSubscriptionRel{}
	if err := db.QueryRowContext(ctx, sqlstr, srrelid, srsubid).Scan(&psr.Tableoid, &psr.Cmax, &psr.Xmax, &psr.Cmin, &psr.Xmin, &psr.Ctid, &psr.Srsubid, &psr.Srrelid, &psr.Srsubstate, &psr.Srsublsn); err != nil {
		return nil, logerror(err)
	}
	return &psr, nil
}

// PgTablespaceByOid retrieves a row from 'pg_catalog.pg_tablespace' as a PgTablespace.
//
// Generated from index 'pg_tablespace_oid_index'.
func PgTablespaceByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTablespace, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, spcname, spcowner, spcacl, spcoptions ` +
		`FROM pg_catalog.pg_tablespace ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pt := PgTablespace{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Spcname, &pt.Spcowner, &pt.Spcacl, &pt.Spcoptions); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTablespaceBySpcname retrieves a row from 'pg_catalog.pg_tablespace' as a PgTablespace.
//
// Generated from index 'pg_tablespace_spcname_index'.
func PgTablespaceBySpcname(ctx context.Context, db DB, spcname pgtypes.Name) (*PgTablespace, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, spcname, spcowner, spcacl, spcoptions ` +
		`FROM pg_catalog.pg_tablespace ` +
		`WHERE spcname = $1`
	// run
	logf(sqlstr, spcname)
	pt := PgTablespace{}
	if err := db.QueryRowContext(ctx, sqlstr, spcname).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Spcname, &pt.Spcowner, &pt.Spcacl, &pt.Spcoptions); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTransformByOid retrieves a row from 'pg_catalog.pg_transform' as a PgTransform.
//
// Generated from index 'pg_transform_oid_index'.
func PgTransformByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTransform, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, trftype, trflang, trffromsql, trftosql ` +
		`FROM pg_catalog.pg_transform ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pt := PgTransform{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Trftype, &pt.Trflang, &pt.Trffromsql, &pt.Trftosql); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTransformByTrftypeTrflang retrieves a row from 'pg_catalog.pg_transform' as a PgTransform.
//
// Generated from index 'pg_transform_type_lang_index'.
func PgTransformByTrftypeTrflang(ctx context.Context, db DB, trftype, trflang pgtypes.Oid) (*PgTransform, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, trftype, trflang, trffromsql, trftosql ` +
		`FROM pg_catalog.pg_transform ` +
		`WHERE trftype = $1 AND trflang = $2`
	// run
	logf(sqlstr, trftype, trflang)
	pt := PgTransform{}
	if err := db.QueryRowContext(ctx, sqlstr, trftype, trflang).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Trftype, &pt.Trflang, &pt.Trffromsql, &pt.Trftosql); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTriggerByOid retrieves a row from 'pg_catalog.pg_trigger' as a PgTrigger.
//
// Generated from index 'pg_trigger_oid_index'.
func PgTriggerByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTrigger, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, tgrelid, tgparentid, tgname, tgfoid, tgtype, tgenabled, tgisinternal, tgconstrrelid, tgconstrindid, tgconstraint, tgdeferrable, tginitdeferred, tgnargs, tgattr, tgargs, tgqual, tgoldtable, tgnewtable ` +
		`FROM pg_catalog.pg_trigger ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pt := PgTrigger{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Tgrelid, &pt.Tgparentid, &pt.Tgname, &pt.Tgfoid, &pt.Tgtype, &pt.Tgenabled, &pt.Tgisinternal, &pt.Tgconstrrelid, &pt.Tgconstrindid, &pt.Tgconstraint, &pt.Tgdeferrable, &pt.Tginitdeferred, &pt.Tgnargs, &pt.Tgattr, &pt.Tgargs, &pt.Tgqual, &pt.Tgoldtable, &pt.Tgnewtable); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTriggersByTgconstraint retrieves a row from 'pg_catalog.pg_trigger' as a PgTrigger.
//
// Generated from index 'pg_trigger_tgconstraint_index'.
func PgTriggersByTgconstraint(ctx context.Context, db DB, tgconstraint pgtypes.Oid) ([]*PgTrigger, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, tgrelid, tgparentid, tgname, tgfoid, tgtype, tgenabled, tgisinternal, tgconstrrelid, tgconstrindid, tgconstraint, tgdeferrable, tginitdeferred, tgnargs, tgattr, tgargs, tgqual, tgoldtable, tgnewtable ` +
		`FROM pg_catalog.pg_trigger ` +
		`WHERE tgconstraint = $1`
	// run
	logf(sqlstr, tgconstraint)
	rows, err := db.QueryContext(ctx, sqlstr, tgconstraint)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgTrigger
	for rows.Next() {
		pt := PgTrigger{}
		// scan
		if err := rows.Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Tgrelid, &pt.Tgparentid, &pt.Tgname, &pt.Tgfoid, &pt.Tgtype, &pt.Tgenabled, &pt.Tgisinternal, &pt.Tgconstrrelid, &pt.Tgconstrindid, &pt.Tgconstraint, &pt.Tgdeferrable, &pt.Tginitdeferred, &pt.Tgnargs, &pt.Tgattr, &pt.Tgargs, &pt.Tgqual, &pt.Tgoldtable, &pt.Tgnewtable); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgTriggerByTgrelidTgname retrieves a row from 'pg_catalog.pg_trigger' as a PgTrigger.
//
// Generated from index 'pg_trigger_tgrelid_tgname_index'.
func PgTriggerByTgrelidTgname(ctx context.Context, db DB, tgrelid pgtypes.Oid, tgname pgtypes.Name) (*PgTrigger, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, tgrelid, tgparentid, tgname, tgfoid, tgtype, tgenabled, tgisinternal, tgconstrrelid, tgconstrindid, tgconstraint, tgdeferrable, tginitdeferred, tgnargs, tgattr, tgargs, tgqual, tgoldtable, tgnewtable ` +
		`FROM pg_catalog.pg_trigger ` +
		`WHERE tgrelid = $1 AND tgname = $2`
	// run
	logf(sqlstr, tgrelid, tgname)
	pt := PgTrigger{}
	if err := db.QueryRowContext(ctx, sqlstr, tgrelid, tgname).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Tgrelid, &pt.Tgparentid, &pt.Tgname, &pt.Tgfoid, &pt.Tgtype, &pt.Tgenabled, &pt.Tgisinternal, &pt.Tgconstrrelid, &pt.Tgconstrindid, &pt.Tgconstraint, &pt.Tgdeferrable, &pt.Tginitdeferred, &pt.Tgnargs, &pt.Tgattr, &pt.Tgargs, &pt.Tgqual, &pt.Tgoldtable, &pt.Tgnewtable); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTsConfigByCfgnameCfgnamespace retrieves a row from 'pg_catalog.pg_ts_config' as a PgTsConfig.
//
// Generated from index 'pg_ts_config_cfgname_index'.
func PgTsConfigByCfgnameCfgnamespace(ctx context.Context, db DB, cfgname pgtypes.Name, cfgnamespace pgtypes.Oid) (*PgTsConfig, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, cfgname, cfgnamespace, cfgowner, cfgparser ` +
		`FROM pg_catalog.pg_ts_config ` +
		`WHERE cfgname = $1 AND cfgnamespace = $2`
	// run
	logf(sqlstr, cfgname, cfgnamespace)
	ptc := PgTsConfig{}
	if err := db.QueryRowContext(ctx, sqlstr, cfgname, cfgnamespace).Scan(&ptc.Tableoid, &ptc.Cmax, &ptc.Xmax, &ptc.Cmin, &ptc.Xmin, &ptc.Ctid, &ptc.Oid, &ptc.Cfgname, &ptc.Cfgnamespace, &ptc.Cfgowner, &ptc.Cfgparser); err != nil {
		return nil, logerror(err)
	}
	return &ptc, nil
}

// PgTsConfigByOid retrieves a row from 'pg_catalog.pg_ts_config' as a PgTsConfig.
//
// Generated from index 'pg_ts_config_oid_index'.
func PgTsConfigByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTsConfig, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, cfgname, cfgnamespace, cfgowner, cfgparser ` +
		`FROM pg_catalog.pg_ts_config ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ptc := PgTsConfig{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ptc.Tableoid, &ptc.Cmax, &ptc.Xmax, &ptc.Cmin, &ptc.Xmin, &ptc.Ctid, &ptc.Oid, &ptc.Cfgname, &ptc.Cfgnamespace, &ptc.Cfgowner, &ptc.Cfgparser); err != nil {
		return nil, logerror(err)
	}
	return &ptc, nil
}

// PgTsConfigMapByMapcfgMaptokentypeMapseqno retrieves a row from 'pg_catalog.pg_ts_config_map' as a PgTsConfigMap.
//
// Generated from index 'pg_ts_config_map_index'.
func PgTsConfigMapByMapcfgMaptokentypeMapseqno(ctx context.Context, db DB, mapcfg pgtypes.Oid, maptokentype, mapseqno int) (*PgTsConfigMap, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, mapcfg, maptokentype, mapseqno, mapdict ` +
		`FROM pg_catalog.pg_ts_config_map ` +
		`WHERE mapcfg = $1 AND maptokentype = $2 AND mapseqno = $3`
	// run
	logf(sqlstr, mapcfg, maptokentype, mapseqno)
	ptcm := PgTsConfigMap{}
	if err := db.QueryRowContext(ctx, sqlstr, mapcfg, maptokentype, mapseqno).Scan(&ptcm.Tableoid, &ptcm.Cmax, &ptcm.Xmax, &ptcm.Cmin, &ptcm.Xmin, &ptcm.Ctid, &ptcm.Mapcfg, &ptcm.Maptokentype, &ptcm.Mapseqno, &ptcm.Mapdict); err != nil {
		return nil, logerror(err)
	}
	return &ptcm, nil
}

// PgTsDictByDictnameDictnamespace retrieves a row from 'pg_catalog.pg_ts_dict' as a PgTsDict.
//
// Generated from index 'pg_ts_dict_dictname_index'.
func PgTsDictByDictnameDictnamespace(ctx context.Context, db DB, dictname pgtypes.Name, dictnamespace pgtypes.Oid) (*PgTsDict, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption ` +
		`FROM pg_catalog.pg_ts_dict ` +
		`WHERE dictname = $1 AND dictnamespace = $2`
	// run
	logf(sqlstr, dictname, dictnamespace)
	ptd := PgTsDict{}
	if err := db.QueryRowContext(ctx, sqlstr, dictname, dictnamespace).Scan(&ptd.Tableoid, &ptd.Cmax, &ptd.Xmax, &ptd.Cmin, &ptd.Xmin, &ptd.Ctid, &ptd.Oid, &ptd.Dictname, &ptd.Dictnamespace, &ptd.Dictowner, &ptd.Dicttemplate, &ptd.Dictinitoption); err != nil {
		return nil, logerror(err)
	}
	return &ptd, nil
}

// PgTsDictByOid retrieves a row from 'pg_catalog.pg_ts_dict' as a PgTsDict.
//
// Generated from index 'pg_ts_dict_oid_index'.
func PgTsDictByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTsDict, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption ` +
		`FROM pg_catalog.pg_ts_dict ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ptd := PgTsDict{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ptd.Tableoid, &ptd.Cmax, &ptd.Xmax, &ptd.Cmin, &ptd.Xmin, &ptd.Ctid, &ptd.Oid, &ptd.Dictname, &ptd.Dictnamespace, &ptd.Dictowner, &ptd.Dicttemplate, &ptd.Dictinitoption); err != nil {
		return nil, logerror(err)
	}
	return &ptd, nil
}

// PgTsParserByOid retrieves a row from 'pg_catalog.pg_ts_parser' as a PgTsParser.
//
// Generated from index 'pg_ts_parser_oid_index'.
func PgTsParserByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTsParser, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, prsname, prsnamespace, prsstart, prstoken, prsend, prsheadline, prslextype ` +
		`FROM pg_catalog.pg_ts_parser ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ptp := PgTsParser{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ptp.Tableoid, &ptp.Cmax, &ptp.Xmax, &ptp.Cmin, &ptp.Xmin, &ptp.Ctid, &ptp.Oid, &ptp.Prsname, &ptp.Prsnamespace, &ptp.Prsstart, &ptp.Prstoken, &ptp.Prsend, &ptp.Prsheadline, &ptp.Prslextype); err != nil {
		return nil, logerror(err)
	}
	return &ptp, nil
}

// PgTsParserByPrsnamePrsnamespace retrieves a row from 'pg_catalog.pg_ts_parser' as a PgTsParser.
//
// Generated from index 'pg_ts_parser_prsname_index'.
func PgTsParserByPrsnamePrsnamespace(ctx context.Context, db DB, prsname pgtypes.Name, prsnamespace pgtypes.Oid) (*PgTsParser, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, prsname, prsnamespace, prsstart, prstoken, prsend, prsheadline, prslextype ` +
		`FROM pg_catalog.pg_ts_parser ` +
		`WHERE prsname = $1 AND prsnamespace = $2`
	// run
	logf(sqlstr, prsname, prsnamespace)
	ptp := PgTsParser{}
	if err := db.QueryRowContext(ctx, sqlstr, prsname, prsnamespace).Scan(&ptp.Tableoid, &ptp.Cmax, &ptp.Xmax, &ptp.Cmin, &ptp.Xmin, &ptp.Ctid, &ptp.Oid, &ptp.Prsname, &ptp.Prsnamespace, &ptp.Prsstart, &ptp.Prstoken, &ptp.Prsend, &ptp.Prsheadline, &ptp.Prslextype); err != nil {
		return nil, logerror(err)
	}
	return &ptp, nil
}

// PgTsTemplateByOid retrieves a row from 'pg_catalog.pg_ts_template' as a PgTsTemplate.
//
// Generated from index 'pg_ts_template_oid_index'.
func PgTsTemplateByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTsTemplate, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, tmplname, tmplnamespace, tmplinit, tmpllexize ` +
		`FROM pg_catalog.pg_ts_template ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ptt := PgTsTemplate{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ptt.Tableoid, &ptt.Cmax, &ptt.Xmax, &ptt.Cmin, &ptt.Xmin, &ptt.Ctid, &ptt.Oid, &ptt.Tmplname, &ptt.Tmplnamespace, &ptt.Tmplinit, &ptt.Tmpllexize); err != nil {
		return nil, logerror(err)
	}
	return &ptt, nil
}

// PgTsTemplateByTmplnameTmplnamespace retrieves a row from 'pg_catalog.pg_ts_template' as a PgTsTemplate.
//
// Generated from index 'pg_ts_template_tmplname_index'.
func PgTsTemplateByTmplnameTmplnamespace(ctx context.Context, db DB, tmplname pgtypes.Name, tmplnamespace pgtypes.Oid) (*PgTsTemplate, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, tmplname, tmplnamespace, tmplinit, tmpllexize ` +
		`FROM pg_catalog.pg_ts_template ` +
		`WHERE tmplname = $1 AND tmplnamespace = $2`
	// run
	logf(sqlstr, tmplname, tmplnamespace)
	ptt := PgTsTemplate{}
	if err := db.QueryRowContext(ctx, sqlstr, tmplname, tmplnamespace).Scan(&ptt.Tableoid, &ptt.Cmax, &ptt.Xmax, &ptt.Cmin, &ptt.Xmin, &ptt.Ctid, &ptt.Oid, &ptt.Tmplname, &ptt.Tmplnamespace, &ptt.Tmplinit, &ptt.Tmpllexize); err != nil {
		return nil, logerror(err)
	}
	return &ptt, nil
}

// PgTypeByOid retrieves a row from 'pg_catalog.pg_type' as a PgType.
//
// Generated from index 'pg_type_oid_index'.
func PgTypeByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgType, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, typname, typnamespace, typowner, typlen, typbyval, typtype, typcategory, typispreferred, typisdefined, typdelim, typrelid, typelem, typarray, typinput, typoutput, typreceive, typsend, typmodin, typmodout, typanalyze, typalign, typstorage, typnotnull, typbasetype, typtypmod, typndims, typcollation, typdefaultbin, typdefault, typacl ` +
		`FROM pg_catalog.pg_type ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pt := PgType{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Typname, &pt.Typnamespace, &pt.Typowner, &pt.Typlen, &pt.Typbyval, &pt.Typtype, &pt.Typcategory, &pt.Typispreferred, &pt.Typisdefined, &pt.Typdelim, &pt.Typrelid, &pt.Typelem, &pt.Typarray, &pt.Typinput, &pt.Typoutput, &pt.Typreceive, &pt.Typsend, &pt.Typmodin, &pt.Typmodout, &pt.Typanalyze, &pt.Typalign, &pt.Typstorage, &pt.Typnotnull, &pt.Typbasetype, &pt.Typtypmod, &pt.Typndims, &pt.Typcollation, &pt.Typdefaultbin, &pt.Typdefault, &pt.Typacl); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTypeByTypnameTypnamespace retrieves a row from 'pg_catalog.pg_type' as a PgType.
//
// Generated from index 'pg_type_typname_nsp_index'.
func PgTypeByTypnameTypnamespace(ctx context.Context, db DB, typname pgtypes.Name, typnamespace pgtypes.Oid) (*PgType, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, typname, typnamespace, typowner, typlen, typbyval, typtype, typcategory, typispreferred, typisdefined, typdelim, typrelid, typelem, typarray, typinput, typoutput, typreceive, typsend, typmodin, typmodout, typanalyze, typalign, typstorage, typnotnull, typbasetype, typtypmod, typndims, typcollation, typdefaultbin, typdefault, typacl ` +
		`FROM pg_catalog.pg_type ` +
		`WHERE typname = $1 AND typnamespace = $2`
	// run
	logf(sqlstr, typname, typnamespace)
	pt := PgType{}
	if err := db.QueryRowContext(ctx, sqlstr, typname, typnamespace).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Typname, &pt.Typnamespace, &pt.Typowner, &pt.Typlen, &pt.Typbyval, &pt.Typtype, &pt.Typcategory, &pt.Typispreferred, &pt.Typisdefined, &pt.Typdelim, &pt.Typrelid, &pt.Typelem, &pt.Typarray, &pt.Typinput, &pt.Typoutput, &pt.Typreceive, &pt.Typsend, &pt.Typmodin, &pt.Typmodout, &pt.Typanalyze, &pt.Typalign, &pt.Typstorage, &pt.Typnotnull, &pt.Typbasetype, &pt.Typtypmod, &pt.Typndims, &pt.Typcollation, &pt.Typdefaultbin, &pt.Typdefault, &pt.Typacl); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgUserMappingByOid retrieves a row from 'pg_catalog.pg_user_mapping' as a PgUserMapping.
//
// Generated from index 'pg_user_mapping_oid_index'.
func PgUserMappingByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgUserMapping, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, umuser, umserver, umoptions ` +
		`FROM pg_catalog.pg_user_mapping ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pum := PgUserMapping{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pum.Tableoid, &pum.Cmax, &pum.Xmax, &pum.Cmin, &pum.Xmin, &pum.Ctid, &pum.Oid, &pum.Umuser, &pum.Umserver, &pum.Umoptions); err != nil {
		return nil, logerror(err)
	}
	return &pum, nil
}

// PgUserMappingByUmuserUmserver retrieves a row from 'pg_catalog.pg_user_mapping' as a PgUserMapping.
//
// Generated from index 'pg_user_mapping_user_server_index'.
func PgUserMappingByUmuserUmserver(ctx context.Context, db DB, umuser, umserver pgtypes.Oid) (*PgUserMapping, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, umuser, umserver, umoptions ` +
		`FROM pg_catalog.pg_user_mapping ` +
		`WHERE umuser = $1 AND umserver = $2`
	// run
	logf(sqlstr, umuser, umserver)
	pum := PgUserMapping{}
	if err := db.QueryRowContext(ctx, sqlstr, umuser, umserver).Scan(&pum.Tableoid, &pum.Cmax, &pum.Xmax, &pum.Cmin, &pum.Xmin, &pum.Ctid, &pum.Oid, &pum.Umuser, &pum.Umserver, &pum.Umoptions); err != nil {
		return nil, logerror(err)
	}
	return &pum, nil
}

// ASCII calls the stored procedure 'pg_catalog.ascii(text) integer' on db.
func ASCII(ctx context.Context, db DB, v0 string) (int, error) {
	// call pg_catalog.ascii
	const sqlstr = `SELECT pg_catalog.ascii($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Abbrev calls the stored procedure 'pg_catalog.abbrev(cidr, inet) text' on db.
func Abbrev(ctx context.Context, db DB, v0 pgtypes.Cidr, v1 string) (string, error) {
	// call pg_catalog.abbrev
	const sqlstr = `SELECT pg_catalog.abbrev($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Abs calls the stored procedure 'pg_catalog.abs(bigint, smallint, integer, real, double precision, numeric) numeric' on db.
func Abs(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 float32, v4, v5 float64) (float64, error) {
	// call pg_catalog.abs
	const sqlstr = `SELECT pg_catalog.abs($1, $2, $3, $4, $5, $6)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Aclcontains calls the stored procedure 'pg_catalog.aclcontains(aclitem[], aclitem) boolean' on db.
func Aclcontains(ctx context.Context, db DB, v0 []pgtypes.Aclitem, v1 pgtypes.Aclitem) (bool, error) {
	// call pg_catalog.aclcontains
	const sqlstr = `SELECT pg_catalog.aclcontains($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Acldefault calls the stored procedure 'pg_catalog.acldefault("char", oid) aclitem[]' on db.
func Acldefault(ctx context.Context, db DB, v0 pgtypes.Char, v1 pgtypes.Oid) ([]pgtypes.Aclitem, error) {
	// call pg_catalog.acldefault
	const sqlstr = `SELECT pg_catalog.acldefault($1, $2)`
	// run
	var ret []pgtypes.Aclitem
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Aclexplode calls the stored procedure 'pg_catalog.aclexplode(aclitem[]) SETOF record' on db.
func Aclexplode(ctx context.Context, db DB, v0 []pgtypes.Aclitem) ([]pgtypes.Record, error) {
	// call pg_catalog.aclexplode
	const sqlstr = `SELECT pg_catalog.aclexplode($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Aclinsert calls the stored procedure 'pg_catalog.aclinsert(aclitem[], aclitem) aclitem[]' on db.
func Aclinsert(ctx context.Context, db DB, v0 []pgtypes.Aclitem, v1 pgtypes.Aclitem) ([]pgtypes.Aclitem, error) {
	// call pg_catalog.aclinsert
	const sqlstr = `SELECT pg_catalog.aclinsert($1, $2)`
	// run
	var ret []pgtypes.Aclitem
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Aclitemeq calls the stored procedure 'pg_catalog.aclitemeq(aclitem, aclitem) boolean' on db.
func Aclitemeq(ctx context.Context, db DB, v0, v1 pgtypes.Aclitem) (bool, error) {
	// call pg_catalog.aclitemeq
	const sqlstr = `SELECT pg_catalog.aclitemeq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Aclitemin calls the stored procedure 'pg_catalog.aclitemin(cstring) aclitem' on db.
func Aclitemin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Aclitem, error) {
	// call pg_catalog.aclitemin
	const sqlstr = `SELECT pg_catalog.aclitemin($1)`
	// run
	var ret pgtypes.Aclitem
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Aclitem{}, logerror(err)
	}
	return ret, nil
}

// Aclitemout calls the stored procedure 'pg_catalog.aclitemout(aclitem) cstring' on db.
func Aclitemout(ctx context.Context, db DB, v0 pgtypes.Aclitem) (pgtypes.Cstring, error) {
	// call pg_catalog.aclitemout
	const sqlstr = `SELECT pg_catalog.aclitemout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Aclremove calls the stored procedure 'pg_catalog.aclremove(aclitem[], aclitem) aclitem[]' on db.
func Aclremove(ctx context.Context, db DB, v0 []pgtypes.Aclitem, v1 pgtypes.Aclitem) ([]pgtypes.Aclitem, error) {
	// call pg_catalog.aclremove
	const sqlstr = `SELECT pg_catalog.aclremove($1, $2)`
	// run
	var ret []pgtypes.Aclitem
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Acos calls the stored procedure 'pg_catalog.acos(double precision) double precision' on db.
func Acos(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.acos
	const sqlstr = `SELECT pg_catalog.acos($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Acosd calls the stored procedure 'pg_catalog.acosd(double precision) double precision' on db.
func Acosd(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.acosd
	const sqlstr = `SELECT pg_catalog.acosd($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Acosh calls the stored procedure 'pg_catalog.acosh(double precision) double precision' on db.
func Acosh(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.acosh
	const sqlstr = `SELECT pg_catalog.acosh($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Age calls the stored procedure 'pg_catalog.age(xid, timestamp without time zone, timestamp with time zone, timestamp without time zone, timestamp without time zone, timestamp with time zone, timestamp with time zone) interval' on db.
func Age(ctx context.Context, db DB, v0 pgtypes.Xid, v1, v2, v3, v4, v5, v6 time.Time) ([]byte, error) {
	// call pg_catalog.age
	const sqlstr = `SELECT pg_catalog.age($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Amvalidate calls the stored procedure 'pg_catalog.amvalidate(oid) boolean' on db.
func Amvalidate(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.amvalidate
	const sqlstr = `SELECT pg_catalog.amvalidate($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// AnyIn calls the stored procedure 'pg_catalog.any_in(cstring) "any"' on db.
func AnyIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Any, error) {
	// call pg_catalog.any_in
	const sqlstr = `SELECT pg_catalog.any_in($1)`
	// run
	var ret pgtypes.Any
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Any{}, logerror(err)
	}
	return ret, nil
}

// AnyOut calls the stored procedure 'pg_catalog.any_out("any") cstring' on db.
func AnyOut(ctx context.Context, db DB, v0 pgtypes.Any) (pgtypes.Cstring, error) {
	// call pg_catalog.any_out
	const sqlstr = `SELECT pg_catalog.any_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// AnyarrayIn calls the stored procedure 'pg_catalog.anyarray_in(cstring) anyarray' on db.
func AnyarrayIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Anyarray, error) {
	// call pg_catalog.anyarray_in
	const sqlstr = `SELECT pg_catalog.anyarray_in($1)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// AnyarrayOut calls the stored procedure 'pg_catalog.anyarray_out(anyarray) cstring' on db.
func AnyarrayOut(ctx context.Context, db DB, v0 pgtypes.Anyarray) (pgtypes.Cstring, error) {
	// call pg_catalog.anyarray_out
	const sqlstr = `SELECT pg_catalog.anyarray_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// AnyarrayRecv calls the stored procedure 'pg_catalog.anyarray_recv(internal) anyarray' on db.
func AnyarrayRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Anyarray, error) {
	// call pg_catalog.anyarray_recv
	const sqlstr = `SELECT pg_catalog.anyarray_recv($1)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// AnyarraySend calls the stored procedure 'pg_catalog.anyarray_send(anyarray) bytea' on db.
func AnyarraySend(ctx context.Context, db DB, v0 pgtypes.Anyarray) ([]byte, error) {
	// call pg_catalog.anyarray_send
	const sqlstr = `SELECT pg_catalog.anyarray_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// AnycompatibleIn calls the stored procedure 'pg_catalog.anycompatible_in(cstring) anycompatible' on db.
func AnycompatibleIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Anycompatible, error) {
	// call pg_catalog.anycompatible_in
	const sqlstr = `SELECT pg_catalog.anycompatible_in($1)`
	// run
	var ret pgtypes.Anycompatible
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anycompatible{}, logerror(err)
	}
	return ret, nil
}

// AnycompatibleOut calls the stored procedure 'pg_catalog.anycompatible_out(anycompatible) cstring' on db.
func AnycompatibleOut(ctx context.Context, db DB, v0 pgtypes.Anycompatible) (pgtypes.Cstring, error) {
	// call pg_catalog.anycompatible_out
	const sqlstr = `SELECT pg_catalog.anycompatible_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// AnycompatiblearrayIn calls the stored procedure 'pg_catalog.anycompatiblearray_in(cstring) anycompatiblearray' on db.
func AnycompatiblearrayIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Anycompatiblearray, error) {
	// call pg_catalog.anycompatiblearray_in
	const sqlstr = `SELECT pg_catalog.anycompatiblearray_in($1)`
	// run
	var ret pgtypes.Anycompatiblearray
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anycompatiblearray{}, logerror(err)
	}
	return ret, nil
}

// AnycompatiblearrayOut calls the stored procedure 'pg_catalog.anycompatiblearray_out(anycompatiblearray) cstring' on db.
func AnycompatiblearrayOut(ctx context.Context, db DB, v0 pgtypes.Anycompatiblearray) (pgtypes.Cstring, error) {
	// call pg_catalog.anycompatiblearray_out
	const sqlstr = `SELECT pg_catalog.anycompatiblearray_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// AnycompatiblearrayRecv calls the stored procedure 'pg_catalog.anycompatiblearray_recv(internal) anycompatiblearray' on db.
func AnycompatiblearrayRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Anycompatiblearray, error) {
	// call pg_catalog.anycompatiblearray_recv
	const sqlstr = `SELECT pg_catalog.anycompatiblearray_recv($1)`
	// run
	var ret pgtypes.Anycompatiblearray
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anycompatiblearray{}, logerror(err)
	}
	return ret, nil
}

// AnycompatiblearraySend calls the stored procedure 'pg_catalog.anycompatiblearray_send(anycompatiblearray) bytea' on db.
func AnycompatiblearraySend(ctx context.Context, db DB, v0 pgtypes.Anycompatiblearray) ([]byte, error) {
	// call pg_catalog.anycompatiblearray_send
	const sqlstr = `SELECT pg_catalog.anycompatiblearray_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// AnycompatiblenonarrayIn calls the stored procedure 'pg_catalog.anycompatiblenonarray_in(cstring) anycompatiblenonarray' on db.
func AnycompatiblenonarrayIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Anycompatiblenonarray, error) {
	// call pg_catalog.anycompatiblenonarray_in
	const sqlstr = `SELECT pg_catalog.anycompatiblenonarray_in($1)`
	// run
	var ret pgtypes.Anycompatiblenonarray
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anycompatiblenonarray{}, logerror(err)
	}
	return ret, nil
}

// AnycompatiblenonarrayOut calls the stored procedure 'pg_catalog.anycompatiblenonarray_out(anycompatiblenonarray) cstring' on db.
func AnycompatiblenonarrayOut(ctx context.Context, db DB, v0 pgtypes.Anycompatiblenonarray) (pgtypes.Cstring, error) {
	// call pg_catalog.anycompatiblenonarray_out
	const sqlstr = `SELECT pg_catalog.anycompatiblenonarray_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// AnycompatiblerangeIn calls the stored procedure 'pg_catalog.anycompatiblerange_in(cstring, oid, integer) anycompatiblerange' on db.
func AnycompatiblerangeIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (pgtypes.Anycompatiblerange, error) {
	// call pg_catalog.anycompatiblerange_in
	const sqlstr = `SELECT pg_catalog.anycompatiblerange_in($1, $2, $3)`
	// run
	var ret pgtypes.Anycompatiblerange
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Anycompatiblerange{}, logerror(err)
	}
	return ret, nil
}

// AnycompatiblerangeOut calls the stored procedure 'pg_catalog.anycompatiblerange_out(anycompatiblerange) cstring' on db.
func AnycompatiblerangeOut(ctx context.Context, db DB, v0 pgtypes.Anycompatiblerange) (pgtypes.Cstring, error) {
	// call pg_catalog.anycompatiblerange_out
	const sqlstr = `SELECT pg_catalog.anycompatiblerange_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// AnyelementIn calls the stored procedure 'pg_catalog.anyelement_in(cstring) anyelement' on db.
func AnyelementIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Anyelement, error) {
	// call pg_catalog.anyelement_in
	const sqlstr = `SELECT pg_catalog.anyelement_in($1)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// AnyelementOut calls the stored procedure 'pg_catalog.anyelement_out(anyelement) cstring' on db.
func AnyelementOut(ctx context.Context, db DB, v0 pgtypes.Anyelement) (pgtypes.Cstring, error) {
	// call pg_catalog.anyelement_out
	const sqlstr = `SELECT pg_catalog.anyelement_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// AnyenumIn calls the stored procedure 'pg_catalog.anyenum_in(cstring) anyenum' on db.
func AnyenumIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Anyenum, error) {
	// call pg_catalog.anyenum_in
	const sqlstr = `SELECT pg_catalog.anyenum_in($1)`
	// run
	var ret pgtypes.Anyenum
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return ret, nil
}

// AnyenumOut calls the stored procedure 'pg_catalog.anyenum_out(anyenum) cstring' on db.
func AnyenumOut(ctx context.Context, db DB, v0 pgtypes.Anyenum) (pgtypes.Cstring, error) {
	// call pg_catalog.anyenum_out
	const sqlstr = `SELECT pg_catalog.anyenum_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// AnynonarrayIn calls the stored procedure 'pg_catalog.anynonarray_in(cstring) anynonarray' on db.
func AnynonarrayIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Anynonarray, error) {
	// call pg_catalog.anynonarray_in
	const sqlstr = `SELECT pg_catalog.anynonarray_in($1)`
	// run
	var ret pgtypes.Anynonarray
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anynonarray{}, logerror(err)
	}
	return ret, nil
}

// AnynonarrayOut calls the stored procedure 'pg_catalog.anynonarray_out(anynonarray) cstring' on db.
func AnynonarrayOut(ctx context.Context, db DB, v0 pgtypes.Anynonarray) (pgtypes.Cstring, error) {
	// call pg_catalog.anynonarray_out
	const sqlstr = `SELECT pg_catalog.anynonarray_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// AnyrangeIn calls the stored procedure 'pg_catalog.anyrange_in(cstring, oid, integer) anyrange' on db.
func AnyrangeIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (pgtypes.Anyrange, error) {
	// call pg_catalog.anyrange_in
	const sqlstr = `SELECT pg_catalog.anyrange_in($1, $2, $3)`
	// run
	var ret pgtypes.Anyrange
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return ret, nil
}

// AnyrangeOut calls the stored procedure 'pg_catalog.anyrange_out(anyrange) cstring' on db.
func AnyrangeOut(ctx context.Context, db DB, v0 pgtypes.Anyrange) (pgtypes.Cstring, error) {
	// call pg_catalog.anyrange_out
	const sqlstr = `SELECT pg_catalog.anyrange_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Anytextcat calls the stored procedure 'pg_catalog.anytextcat(anynonarray, text) text' on db.
func Anytextcat(ctx context.Context, db DB, v0 pgtypes.Anynonarray, v1 string) (string, error) {
	// call pg_catalog.anytextcat
	const sqlstr = `SELECT pg_catalog.anytextcat($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Area calls the stored procedure 'pg_catalog.area(path, box, circle) double precision' on db.
func Area(ctx context.Context, db DB, v0 pgtypes.Path, v1 pgtypes.Box, v2 pgtypes.Circle) (float64, error) {
	// call pg_catalog.area
	const sqlstr = `SELECT pg_catalog.area($1, $2, $3)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Areajoinsel calls the stored procedure 'pg_catalog.areajoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Areajoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.areajoinsel
	const sqlstr = `SELECT pg_catalog.areajoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Areasel calls the stored procedure 'pg_catalog.areasel(internal, oid, internal, integer) double precision' on db.
func Areasel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.areasel
	const sqlstr = `SELECT pg_catalog.areasel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// ArrayAgg calls the stored procedure 'pg_catalog.array_agg(anyarray, anynonarray) anyarray' on db.
func ArrayAgg(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 pgtypes.Anynonarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_agg
	const sqlstr = `SELECT pg_catalog.array_agg($1, $2)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayAggArrayFinalfn calls the stored procedure 'pg_catalog.array_agg_array_finalfn(internal, anyarray) anyarray' on db.
func ArrayAggArrayFinalfn(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Anyarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_agg_array_finalfn
	const sqlstr = `SELECT pg_catalog.array_agg_array_finalfn($1, $2)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayAggArrayTransfn calls the stored procedure 'pg_catalog.array_agg_array_transfn(internal, anyarray) internal' on db.
func ArrayAggArrayTransfn(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Anyarray) (pgtypes.Internal, error) {
	// call pg_catalog.array_agg_array_transfn
	const sqlstr = `SELECT pg_catalog.array_agg_array_transfn($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// ArrayAggFinalfn calls the stored procedure 'pg_catalog.array_agg_finalfn(internal, anynonarray) anyarray' on db.
func ArrayAggFinalfn(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Anynonarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_agg_finalfn
	const sqlstr = `SELECT pg_catalog.array_agg_finalfn($1, $2)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayAggTransfn calls the stored procedure 'pg_catalog.array_agg_transfn(internal, anynonarray) internal' on db.
func ArrayAggTransfn(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Anynonarray) (pgtypes.Internal, error) {
	// call pg_catalog.array_agg_transfn
	const sqlstr = `SELECT pg_catalog.array_agg_transfn($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// ArrayAppend calls the stored procedure 'pg_catalog.array_append(anyarray, anyelement) anyarray' on db.
func ArrayAppend(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 pgtypes.Anyelement) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_append
	const sqlstr = `SELECT pg_catalog.array_append($1, $2)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayCat calls the stored procedure 'pg_catalog.array_cat(anyarray, anyarray) anyarray' on db.
func ArrayCat(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_cat
	const sqlstr = `SELECT pg_catalog.array_cat($1, $2)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayDims calls the stored procedure 'pg_catalog.array_dims(anyarray) text' on db.
func ArrayDims(ctx context.Context, db DB, v0 pgtypes.Anyarray) (string, error) {
	// call pg_catalog.array_dims
	const sqlstr = `SELECT pg_catalog.array_dims($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// ArrayEq calls the stored procedure 'pg_catalog.array_eq(anyarray, anyarray) boolean' on db.
func ArrayEq(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_eq
	const sqlstr = `SELECT pg_catalog.array_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// ArrayFill calls the stored procedure 'pg_catalog.array_fill(anyelement, integer[], anyelement, integer[], integer[]) anyarray' on db.
func ArrayFill(ctx context.Context, db DB, v0 pgtypes.Anyelement, v1 []int, v2 pgtypes.Anyelement, v3, v4 []int) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_fill
	const sqlstr = `SELECT pg_catalog.array_fill($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayGe calls the stored procedure 'pg_catalog.array_ge(anyarray, anyarray) boolean' on db.
func ArrayGe(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_ge
	const sqlstr = `SELECT pg_catalog.array_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// ArrayGt calls the stored procedure 'pg_catalog.array_gt(anyarray, anyarray) boolean' on db.
func ArrayGt(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_gt
	const sqlstr = `SELECT pg_catalog.array_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// ArrayIn calls the stored procedure 'pg_catalog.array_in(cstring, oid, integer) anyarray' on db.
func ArrayIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_in
	const sqlstr = `SELECT pg_catalog.array_in($1, $2, $3)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayLarger calls the stored procedure 'pg_catalog.array_larger(anyarray, anyarray) anyarray' on db.
func ArrayLarger(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_larger
	const sqlstr = `SELECT pg_catalog.array_larger($1, $2)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayLe calls the stored procedure 'pg_catalog.array_le(anyarray, anyarray) boolean' on db.
func ArrayLe(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_le
	const sqlstr = `SELECT pg_catalog.array_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// ArrayLength calls the stored procedure 'pg_catalog.array_length(anyarray, integer) integer' on db.
func ArrayLength(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 int) (int, error) {
	// call pg_catalog.array_length
	const sqlstr = `SELECT pg_catalog.array_length($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// ArrayLower calls the stored procedure 'pg_catalog.array_lower(anyarray, integer) integer' on db.
func ArrayLower(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 int) (int, error) {
	// call pg_catalog.array_lower
	const sqlstr = `SELECT pg_catalog.array_lower($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// ArrayLt calls the stored procedure 'pg_catalog.array_lt(anyarray, anyarray) boolean' on db.
func ArrayLt(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_lt
	const sqlstr = `SELECT pg_catalog.array_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// ArrayNdims calls the stored procedure 'pg_catalog.array_ndims(anyarray) integer' on db.
func ArrayNdims(ctx context.Context, db DB, v0 pgtypes.Anyarray) (int, error) {
	// call pg_catalog.array_ndims
	const sqlstr = `SELECT pg_catalog.array_ndims($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// ArrayNe calls the stored procedure 'pg_catalog.array_ne(anyarray, anyarray) boolean' on db.
func ArrayNe(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_ne
	const sqlstr = `SELECT pg_catalog.array_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// ArrayOut calls the stored procedure 'pg_catalog.array_out(anyarray) cstring' on db.
func ArrayOut(ctx context.Context, db DB, v0 pgtypes.Anyarray) (pgtypes.Cstring, error) {
	// call pg_catalog.array_out
	const sqlstr = `SELECT pg_catalog.array_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// ArrayPosition calls the stored procedure 'pg_catalog.array_position(anyarray, anyelement, anyarray, anyelement, integer) integer' on db.
func ArrayPosition(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 pgtypes.Anyelement, v2 pgtypes.Anyarray, v3 pgtypes.Anyelement, v4 int) (int, error) {
	// call pg_catalog.array_position
	const sqlstr = `SELECT pg_catalog.array_position($1, $2, $3, $4, $5)`
	// run
	var ret int
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// ArrayPositions calls the stored procedure 'pg_catalog.array_positions(anyarray, anyelement) integer[]' on db.
func ArrayPositions(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 pgtypes.Anyelement) ([]int, error) {
	// call pg_catalog.array_positions
	const sqlstr = `SELECT pg_catalog.array_positions($1, $2)`
	// run
	var ret []int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// ArrayPrepend calls the stored procedure 'pg_catalog.array_prepend(anyelement, anyarray) anyarray' on db.
func ArrayPrepend(ctx context.Context, db DB, v0 pgtypes.Anyelement, v1 pgtypes.Anyarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_prepend
	const sqlstr = `SELECT pg_catalog.array_prepend($1, $2)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayRecv calls the stored procedure 'pg_catalog.array_recv(internal, oid, integer) anyarray' on db.
func ArrayRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_recv
	const sqlstr = `SELECT pg_catalog.array_recv($1, $2, $3)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayRemove calls the stored procedure 'pg_catalog.array_remove(anyarray, anyelement) anyarray' on db.
func ArrayRemove(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 pgtypes.Anyelement) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_remove
	const sqlstr = `SELECT pg_catalog.array_remove($1, $2)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayReplace calls the stored procedure 'pg_catalog.array_replace(anyarray, anyelement, anyelement) anyarray' on db.
func ArrayReplace(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1, v2 pgtypes.Anyelement) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_replace
	const sqlstr = `SELECT pg_catalog.array_replace($1, $2, $3)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArraySend calls the stored procedure 'pg_catalog.array_send(anyarray) bytea' on db.
func ArraySend(ctx context.Context, db DB, v0 pgtypes.Anyarray) ([]byte, error) {
	// call pg_catalog.array_send
	const sqlstr = `SELECT pg_catalog.array_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// ArraySmaller calls the stored procedure 'pg_catalog.array_smaller(anyarray, anyarray) anyarray' on db.
func ArraySmaller(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_smaller
	const sqlstr = `SELECT pg_catalog.array_smaller($1, $2)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// ArrayToJSON calls the stored procedure 'pg_catalog.array_to_json(anyarray, anyarray, boolean) json' on db.
func ArrayToJSON(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray, v2 bool) ([]byte, error) {
	// call pg_catalog.array_to_json
	const sqlstr = `SELECT pg_catalog.array_to_json($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// ArrayToString calls the stored procedure 'pg_catalog.array_to_string(anyarray, text, anyarray, text, text) text' on db.
func ArrayToString(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 string, v2 pgtypes.Anyarray, v3, v4 string) (string, error) {
	// call pg_catalog.array_to_string
	const sqlstr = `SELECT pg_catalog.array_to_string($1, $2, $3, $4, $5)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// ArrayToTsvector calls the stored procedure 'pg_catalog.array_to_tsvector(text[]) tsvector' on db.
func ArrayToTsvector(ctx context.Context, db DB, v0 StringSlice) (pgtypes.Tsvector, error) {
	// call pg_catalog.array_to_tsvector
	const sqlstr = `SELECT pg_catalog.array_to_tsvector($1)`
	// run
	var ret pgtypes.Tsvector
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return ret, nil
}

// ArrayTypanalyze calls the stored procedure 'pg_catalog.array_typanalyze(internal) boolean' on db.
func ArrayTypanalyze(ctx context.Context, db DB, v0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.array_typanalyze
	const sqlstr = `SELECT pg_catalog.array_typanalyze($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// ArrayUnnestSupport calls the stored procedure 'pg_catalog.array_unnest_support(internal) internal' on db.
func ArrayUnnestSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.array_unnest_support
	const sqlstr = `SELECT pg_catalog.array_unnest_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// ArrayUpper calls the stored procedure 'pg_catalog.array_upper(anyarray, integer) integer' on db.
func ArrayUpper(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 int) (int, error) {
	// call pg_catalog.array_upper
	const sqlstr = `SELECT pg_catalog.array_upper($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Arraycontained calls the stored procedure 'pg_catalog.arraycontained(anyarray, anyarray) boolean' on db.
func Arraycontained(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.arraycontained
	const sqlstr = `SELECT pg_catalog.arraycontained($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Arraycontains calls the stored procedure 'pg_catalog.arraycontains(anyarray, anyarray) boolean' on db.
func Arraycontains(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.arraycontains
	const sqlstr = `SELECT pg_catalog.arraycontains($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Arraycontjoinsel calls the stored procedure 'pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Arraycontjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.arraycontjoinsel
	const sqlstr = `SELECT pg_catalog.arraycontjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Arraycontsel calls the stored procedure 'pg_catalog.arraycontsel(internal, oid, internal, integer) double precision' on db.
func Arraycontsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.arraycontsel
	const sqlstr = `SELECT pg_catalog.arraycontsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Arrayoverlap calls the stored procedure 'pg_catalog.arrayoverlap(anyarray, anyarray) boolean' on db.
func Arrayoverlap(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.arrayoverlap
	const sqlstr = `SELECT pg_catalog.arrayoverlap($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Asin calls the stored procedure 'pg_catalog.asin(double precision) double precision' on db.
func Asin(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.asin
	const sqlstr = `SELECT pg_catalog.asin($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Asind calls the stored procedure 'pg_catalog.asind(double precision) double precision' on db.
func Asind(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.asind
	const sqlstr = `SELECT pg_catalog.asind($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Asinh calls the stored procedure 'pg_catalog.asinh(double precision) double precision' on db.
func Asinh(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.asinh
	const sqlstr = `SELECT pg_catalog.asinh($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Atan calls the stored procedure 'pg_catalog.atan(double precision) double precision' on db.
func Atan(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.atan
	const sqlstr = `SELECT pg_catalog.atan($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Atan2 calls the stored procedure 'pg_catalog.atan2(double precision, double precision) double precision' on db.
func Atan2(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.atan2
	const sqlstr = `SELECT pg_catalog.atan2($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Atan2d calls the stored procedure 'pg_catalog.atan2d(double precision, double precision) double precision' on db.
func Atan2d(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.atan2d
	const sqlstr = `SELECT pg_catalog.atan2d($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Atand calls the stored procedure 'pg_catalog.atand(double precision) double precision' on db.
func Atand(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.atand
	const sqlstr = `SELECT pg_catalog.atand($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Atanh calls the stored procedure 'pg_catalog.atanh(double precision) double precision' on db.
func Atanh(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.atanh
	const sqlstr = `SELECT pg_catalog.atanh($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Avg calls the stored procedure 'pg_catalog.avg(bigint, smallint, integer, real, double precision, interval, numeric) interval' on db.
func Avg(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 float32, v4 float64, v5 []byte, v6 float64) ([]byte, error) {
	// call pg_catalog.avg
	const sqlstr = `SELECT pg_catalog.avg($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Bernoulli calls the stored procedure 'pg_catalog.bernoulli(internal) tsm_handler' on db.
func Bernoulli(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.TsmHandler, error) {
	// call pg_catalog.bernoulli
	const sqlstr = `SELECT pg_catalog.bernoulli($1)`
	// run
	var ret pgtypes.TsmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.TsmHandler{}, logerror(err)
	}
	return ret, nil
}

// Big5ToEucTw calls the stored procedure 'pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer) void' on db.
func Big5ToEucTw(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.big5_to_euc_tw
	const sqlstr = `SELECT pg_catalog.big5_to_euc_tw($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Big5ToMic calls the stored procedure 'pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer) void' on db.
func Big5ToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.big5_to_mic
	const sqlstr = `SELECT pg_catalog.big5_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Big5ToUTF8 calls the stored procedure 'pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func Big5ToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.big5_to_utf8
	const sqlstr = `SELECT pg_catalog.big5_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeCreateEmptyExtension calls the stored procedure 'pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid[], text[], text[]) void' on db.
func BinaryUpgradeCreateEmptyExtension(ctx context.Context, db DB, v0, v1 string, v2 bool, v3 string, v4 []pgtypes.Oid, v5, v6 StringSlice) error {
	// call pg_catalog.binary_upgrade_create_empty_extension
	const sqlstr = `SELECT pg_catalog.binary_upgrade_create_empty_extension($1, $2, $3, $4, $5, $6, $7)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetMissingValue calls the stored procedure 'pg_catalog.binary_upgrade_set_missing_value(oid, text, text) void' on db.
func BinaryUpgradeSetMissingValue(ctx context.Context, db DB, v0 pgtypes.Oid, v1, v2 string) error {
	// call pg_catalog.binary_upgrade_set_missing_value
	const sqlstr = `SELECT pg_catalog.binary_upgrade_set_missing_value($1, $2, $3)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextArrayPgTypeOid calls the stored procedure 'pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid) void' on db.
func BinaryUpgradeSetNextArrayPgTypeOid(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_array_pg_type_oid
	const sqlstr = `SELECT pg_catalog.binary_upgrade_set_next_array_pg_type_oid($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextHeapPgClassOid calls the stored procedure 'pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid) void' on db.
func BinaryUpgradeSetNextHeapPgClassOid(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_heap_pg_class_oid
	const sqlstr = `SELECT pg_catalog.binary_upgrade_set_next_heap_pg_class_oid($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextIndexPgClassOid calls the stored procedure 'pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid) void' on db.
func BinaryUpgradeSetNextIndexPgClassOid(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_index_pg_class_oid
	const sqlstr = `SELECT pg_catalog.binary_upgrade_set_next_index_pg_class_oid($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextPgAuthidOid calls the stored procedure 'pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid) void' on db.
func BinaryUpgradeSetNextPgAuthidOid(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_pg_authid_oid
	const sqlstr = `SELECT pg_catalog.binary_upgrade_set_next_pg_authid_oid($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextPgEnumOid calls the stored procedure 'pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid) void' on db.
func BinaryUpgradeSetNextPgEnumOid(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_pg_enum_oid
	const sqlstr = `SELECT pg_catalog.binary_upgrade_set_next_pg_enum_oid($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextPgTypeOid calls the stored procedure 'pg_catalog.binary_upgrade_set_next_pg_type_oid(oid) void' on db.
func BinaryUpgradeSetNextPgTypeOid(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_pg_type_oid
	const sqlstr = `SELECT pg_catalog.binary_upgrade_set_next_pg_type_oid($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextToastPgClassOid calls the stored procedure 'pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid) void' on db.
func BinaryUpgradeSetNextToastPgClassOid(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_toast_pg_class_oid
	const sqlstr = `SELECT pg_catalog.binary_upgrade_set_next_toast_pg_class_oid($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextToastPgTypeOid calls the stored procedure 'pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid) void' on db.
func BinaryUpgradeSetNextToastPgTypeOid(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_toast_pg_type_oid
	const sqlstr = `SELECT pg_catalog.binary_upgrade_set_next_toast_pg_type_oid($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetRecordInitPrivs calls the stored procedure 'pg_catalog.binary_upgrade_set_record_init_privs(boolean) void' on db.
func BinaryUpgradeSetRecordInitPrivs(ctx context.Context, db DB, v0 bool) error {
	// call pg_catalog.binary_upgrade_set_record_init_privs
	const sqlstr = `SELECT pg_catalog.binary_upgrade_set_record_init_privs($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Bit calls the stored procedure 'pg_catalog.bit(bigint, integer, integer, integer, bit, integer, boolean) bit' on db.
func Bit(ctx context.Context, db DB, v0 int64, v1, v2, v3 int, v4 uint8, v5 int, v6 bool) (uint8, error) {
	// call pg_catalog.bit
	const sqlstr = `SELECT pg_catalog.bit($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// BitAnd calls the stored procedure 'pg_catalog.bit_and(bigint, smallint, integer, bit) bit' on db.
func BitAnd(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 uint8) (uint8, error) {
	// call pg_catalog.bit_and
	const sqlstr = `SELECT pg_catalog.bit_and($1, $2, $3, $4)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// BitIn calls the stored procedure 'pg_catalog.bit_in(cstring, oid, integer) bit' on db.
func BitIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (uint8, error) {
	// call pg_catalog.bit_in
	const sqlstr = `SELECT pg_catalog.bit_in($1, $2, $3)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// BitLength calls the stored procedure 'pg_catalog.bit_length(bytea, text, bit) integer' on db.
func BitLength(ctx context.Context, db DB, v0 []byte, v1 string, v2 uint8) (int, error) {
	// call pg_catalog.bit_length
	const sqlstr = `SELECT pg_catalog.bit_length($1, $2, $3)`
	// run
	var ret int
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// BitOr calls the stored procedure 'pg_catalog.bit_or(bigint, smallint, integer, bit) bit' on db.
func BitOr(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 uint8) (uint8, error) {
	// call pg_catalog.bit_or
	const sqlstr = `SELECT pg_catalog.bit_or($1, $2, $3, $4)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// BitOut calls the stored procedure 'pg_catalog.bit_out(bit) cstring' on db.
func BitOut(ctx context.Context, db DB, v0 uint8) (pgtypes.Cstring, error) {
	// call pg_catalog.bit_out
	const sqlstr = `SELECT pg_catalog.bit_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// BitRecv calls the stored procedure 'pg_catalog.bit_recv(internal, oid, integer) bit' on db.
func BitRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (uint8, error) {
	// call pg_catalog.bit_recv
	const sqlstr = `SELECT pg_catalog.bit_recv($1, $2, $3)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// BitSend calls the stored procedure 'pg_catalog.bit_send(bit) bytea' on db.
func BitSend(ctx context.Context, db DB, v0 uint8) ([]byte, error) {
	// call pg_catalog.bit_send
	const sqlstr = `SELECT pg_catalog.bit_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Bitand calls the stored procedure 'pg_catalog.bitand(bit, bit) bit' on db.
func Bitand(ctx context.Context, db DB, v0, v1 uint8) (uint8, error) {
	// call pg_catalog.bitand
	const sqlstr = `SELECT pg_catalog.bitand($1, $2)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Bitcat calls the stored procedure 'pg_catalog.bitcat(bit varying, bit varying) bit varying' on db.
func Bitcat(ctx context.Context, db DB, v0, v1 []byte) ([]byte, error) {
	// call pg_catalog.bitcat
	const sqlstr = `SELECT pg_catalog.bitcat($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Bitcmp calls the stored procedure 'pg_catalog.bitcmp(bit, bit) integer' on db.
func Bitcmp(ctx context.Context, db DB, v0, v1 uint8) (int, error) {
	// call pg_catalog.bitcmp
	const sqlstr = `SELECT pg_catalog.bitcmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Biteq calls the stored procedure 'pg_catalog.biteq(bit, bit) boolean' on db.
func Biteq(ctx context.Context, db DB, v0, v1 uint8) (bool, error) {
	// call pg_catalog.biteq
	const sqlstr = `SELECT pg_catalog.biteq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bitge calls the stored procedure 'pg_catalog.bitge(bit, bit) boolean' on db.
func Bitge(ctx context.Context, db DB, v0, v1 uint8) (bool, error) {
	// call pg_catalog.bitge
	const sqlstr = `SELECT pg_catalog.bitge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bitgt calls the stored procedure 'pg_catalog.bitgt(bit, bit) boolean' on db.
func Bitgt(ctx context.Context, db DB, v0, v1 uint8) (bool, error) {
	// call pg_catalog.bitgt
	const sqlstr = `SELECT pg_catalog.bitgt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bitle calls the stored procedure 'pg_catalog.bitle(bit, bit) boolean' on db.
func Bitle(ctx context.Context, db DB, v0, v1 uint8) (bool, error) {
	// call pg_catalog.bitle
	const sqlstr = `SELECT pg_catalog.bitle($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bitlt calls the stored procedure 'pg_catalog.bitlt(bit, bit) boolean' on db.
func Bitlt(ctx context.Context, db DB, v0, v1 uint8) (bool, error) {
	// call pg_catalog.bitlt
	const sqlstr = `SELECT pg_catalog.bitlt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bitne calls the stored procedure 'pg_catalog.bitne(bit, bit) boolean' on db.
func Bitne(ctx context.Context, db DB, v0, v1 uint8) (bool, error) {
	// call pg_catalog.bitne
	const sqlstr = `SELECT pg_catalog.bitne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bitnot calls the stored procedure 'pg_catalog.bitnot(bit) bit' on db.
func Bitnot(ctx context.Context, db DB, v0 uint8) (uint8, error) {
	// call pg_catalog.bitnot
	const sqlstr = `SELECT pg_catalog.bitnot($1)`
	// run
	var ret uint8
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Bitor calls the stored procedure 'pg_catalog.bitor(bit, bit) bit' on db.
func Bitor(ctx context.Context, db DB, v0, v1 uint8) (uint8, error) {
	// call pg_catalog.bitor
	const sqlstr = `SELECT pg_catalog.bitor($1, $2)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Bitshiftleft calls the stored procedure 'pg_catalog.bitshiftleft(bit, integer) bit' on db.
func Bitshiftleft(ctx context.Context, db DB, v0 uint8, v1 int) (uint8, error) {
	// call pg_catalog.bitshiftleft
	const sqlstr = `SELECT pg_catalog.bitshiftleft($1, $2)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Bitshiftright calls the stored procedure 'pg_catalog.bitshiftright(bit, integer) bit' on db.
func Bitshiftright(ctx context.Context, db DB, v0 uint8, v1 int) (uint8, error) {
	// call pg_catalog.bitshiftright
	const sqlstr = `SELECT pg_catalog.bitshiftright($1, $2)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Bittypmodin calls the stored procedure 'pg_catalog.bittypmodin(cstring[]) integer' on db.
func Bittypmodin(ctx context.Context, db DB, v0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.bittypmodin
	const sqlstr = `SELECT pg_catalog.bittypmodin($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Bittypmodout calls the stored procedure 'pg_catalog.bittypmodout(integer) cstring' on db.
func Bittypmodout(ctx context.Context, db DB, v0 int) (pgtypes.Cstring, error) {
	// call pg_catalog.bittypmodout
	const sqlstr = `SELECT pg_catalog.bittypmodout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Bitxor calls the stored procedure 'pg_catalog.bitxor(bit, bit) bit' on db.
func Bitxor(ctx context.Context, db DB, v0, v1 uint8) (uint8, error) {
	// call pg_catalog.bitxor
	const sqlstr = `SELECT pg_catalog.bitxor($1, $2)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Bool calls the stored procedure 'pg_catalog.bool(integer, jsonb) boolean' on db.
func Bool(ctx context.Context, db DB, v0 int, v1 []byte) (bool, error) {
	// call pg_catalog.bool
	const sqlstr = `SELECT pg_catalog.bool($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoolAccum calls the stored procedure 'pg_catalog.bool_accum(internal, boolean) internal' on db.
func BoolAccum(ctx context.Context, db DB, v0 pgtypes.Internal, v1 bool) (pgtypes.Internal, error) {
	// call pg_catalog.bool_accum
	const sqlstr = `SELECT pg_catalog.bool_accum($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// BoolAccumInv calls the stored procedure 'pg_catalog.bool_accum_inv(internal, boolean) internal' on db.
func BoolAccumInv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 bool) (pgtypes.Internal, error) {
	// call pg_catalog.bool_accum_inv
	const sqlstr = `SELECT pg_catalog.bool_accum_inv($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// BoolAlltrue calls the stored procedure 'pg_catalog.bool_alltrue(internal) boolean' on db.
func BoolAlltrue(ctx context.Context, db DB, v0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.bool_alltrue
	const sqlstr = `SELECT pg_catalog.bool_alltrue($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoolAnd calls the stored procedure 'pg_catalog.bool_and(boolean) boolean' on db.
func BoolAnd(ctx context.Context, db DB, v0 bool) (bool, error) {
	// call pg_catalog.bool_and
	const sqlstr = `SELECT pg_catalog.bool_and($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoolAnytrue calls the stored procedure 'pg_catalog.bool_anytrue(internal) boolean' on db.
func BoolAnytrue(ctx context.Context, db DB, v0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.bool_anytrue
	const sqlstr = `SELECT pg_catalog.bool_anytrue($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoolOr calls the stored procedure 'pg_catalog.bool_or(boolean) boolean' on db.
func BoolOr(ctx context.Context, db DB, v0 bool) (bool, error) {
	// call pg_catalog.bool_or
	const sqlstr = `SELECT pg_catalog.bool_or($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoolandStatefunc calls the stored procedure 'pg_catalog.booland_statefunc(boolean, boolean) boolean' on db.
func BoolandStatefunc(ctx context.Context, db DB, v0, v1 bool) (bool, error) {
	// call pg_catalog.booland_statefunc
	const sqlstr = `SELECT pg_catalog.booland_statefunc($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Booleq calls the stored procedure 'pg_catalog.booleq(boolean, boolean) boolean' on db.
func Booleq(ctx context.Context, db DB, v0, v1 bool) (bool, error) {
	// call pg_catalog.booleq
	const sqlstr = `SELECT pg_catalog.booleq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Boolge calls the stored procedure 'pg_catalog.boolge(boolean, boolean) boolean' on db.
func Boolge(ctx context.Context, db DB, v0, v1 bool) (bool, error) {
	// call pg_catalog.boolge
	const sqlstr = `SELECT pg_catalog.boolge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Boolgt calls the stored procedure 'pg_catalog.boolgt(boolean, boolean) boolean' on db.
func Boolgt(ctx context.Context, db DB, v0, v1 bool) (bool, error) {
	// call pg_catalog.boolgt
	const sqlstr = `SELECT pg_catalog.boolgt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Boolin calls the stored procedure 'pg_catalog.boolin(cstring) boolean' on db.
func Boolin(ctx context.Context, db DB, v0 pgtypes.Cstring) (bool, error) {
	// call pg_catalog.boolin
	const sqlstr = `SELECT pg_catalog.boolin($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Boolle calls the stored procedure 'pg_catalog.boolle(boolean, boolean) boolean' on db.
func Boolle(ctx context.Context, db DB, v0, v1 bool) (bool, error) {
	// call pg_catalog.boolle
	const sqlstr = `SELECT pg_catalog.boolle($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Boollt calls the stored procedure 'pg_catalog.boollt(boolean, boolean) boolean' on db.
func Boollt(ctx context.Context, db DB, v0, v1 bool) (bool, error) {
	// call pg_catalog.boollt
	const sqlstr = `SELECT pg_catalog.boollt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Boolne calls the stored procedure 'pg_catalog.boolne(boolean, boolean) boolean' on db.
func Boolne(ctx context.Context, db DB, v0, v1 bool) (bool, error) {
	// call pg_catalog.boolne
	const sqlstr = `SELECT pg_catalog.boolne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoolorStatefunc calls the stored procedure 'pg_catalog.boolor_statefunc(boolean, boolean) boolean' on db.
func BoolorStatefunc(ctx context.Context, db DB, v0, v1 bool) (bool, error) {
	// call pg_catalog.boolor_statefunc
	const sqlstr = `SELECT pg_catalog.boolor_statefunc($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Boolout calls the stored procedure 'pg_catalog.boolout(boolean) cstring' on db.
func Boolout(ctx context.Context, db DB, v0 bool) (pgtypes.Cstring, error) {
	// call pg_catalog.boolout
	const sqlstr = `SELECT pg_catalog.boolout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Boolrecv calls the stored procedure 'pg_catalog.boolrecv(internal) boolean' on db.
func Boolrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.boolrecv
	const sqlstr = `SELECT pg_catalog.boolrecv($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Boolsend calls the stored procedure 'pg_catalog.boolsend(boolean) bytea' on db.
func Boolsend(ctx context.Context, db DB, v0 bool) ([]byte, error) {
	// call pg_catalog.boolsend
	const sqlstr = `SELECT pg_catalog.boolsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// BoundBox calls the stored procedure 'pg_catalog.bound_box(box, box) box' on db.
func BoundBox(ctx context.Context, db DB, v0, v1 pgtypes.Box) (pgtypes.Box, error) {
	// call pg_catalog.bound_box
	const sqlstr = `SELECT pg_catalog.bound_box($1, $2)`
	// run
	var ret pgtypes.Box
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return ret, nil
}

// Box calls the stored procedure 'pg_catalog.box(point, polygon, circle, point, point) box' on db.
func Box(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Polygon, v2 pgtypes.Circle, v3, v4 pgtypes.Point) (pgtypes.Box, error) {
	// call pg_catalog.box
	const sqlstr = `SELECT pg_catalog.box($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Box
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return ret, nil
}

// BoxAbove calls the stored procedure 'pg_catalog.box_above(box, box) boolean' on db.
func BoxAbove(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_above
	const sqlstr = `SELECT pg_catalog.box_above($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxAboveEq calls the stored procedure 'pg_catalog.box_above_eq(box, box) boolean' on db.
func BoxAboveEq(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_above_eq
	const sqlstr = `SELECT pg_catalog.box_above_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxAdd calls the stored procedure 'pg_catalog.box_add(box, point) box' on db.
func BoxAdd(ctx context.Context, db DB, v0 pgtypes.Box, v1 pgtypes.Point) (pgtypes.Box, error) {
	// call pg_catalog.box_add
	const sqlstr = `SELECT pg_catalog.box_add($1, $2)`
	// run
	var ret pgtypes.Box
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return ret, nil
}

// BoxBelow calls the stored procedure 'pg_catalog.box_below(box, box) boolean' on db.
func BoxBelow(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_below
	const sqlstr = `SELECT pg_catalog.box_below($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxBelowEq calls the stored procedure 'pg_catalog.box_below_eq(box, box) boolean' on db.
func BoxBelowEq(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_below_eq
	const sqlstr = `SELECT pg_catalog.box_below_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxCenter calls the stored procedure 'pg_catalog.box_center(box) point' on db.
func BoxCenter(ctx context.Context, db DB, v0 pgtypes.Box) (pgtypes.Point, error) {
	// call pg_catalog.box_center
	const sqlstr = `SELECT pg_catalog.box_center($1)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// BoxContain calls the stored procedure 'pg_catalog.box_contain(box, box) boolean' on db.
func BoxContain(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_contain
	const sqlstr = `SELECT pg_catalog.box_contain($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxContainPt calls the stored procedure 'pg_catalog.box_contain_pt(box, point) boolean' on db.
func BoxContainPt(ctx context.Context, db DB, v0 pgtypes.Box, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.box_contain_pt
	const sqlstr = `SELECT pg_catalog.box_contain_pt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxContained calls the stored procedure 'pg_catalog.box_contained(box, box) boolean' on db.
func BoxContained(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_contained
	const sqlstr = `SELECT pg_catalog.box_contained($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxDistance calls the stored procedure 'pg_catalog.box_distance(box, box) double precision' on db.
func BoxDistance(ctx context.Context, db DB, v0, v1 pgtypes.Box) (float64, error) {
	// call pg_catalog.box_distance
	const sqlstr = `SELECT pg_catalog.box_distance($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// BoxDiv calls the stored procedure 'pg_catalog.box_div(box, point) box' on db.
func BoxDiv(ctx context.Context, db DB, v0 pgtypes.Box, v1 pgtypes.Point) (pgtypes.Box, error) {
	// call pg_catalog.box_div
	const sqlstr = `SELECT pg_catalog.box_div($1, $2)`
	// run
	var ret pgtypes.Box
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return ret, nil
}

// BoxEq calls the stored procedure 'pg_catalog.box_eq(box, box) boolean' on db.
func BoxEq(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_eq
	const sqlstr = `SELECT pg_catalog.box_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxGe calls the stored procedure 'pg_catalog.box_ge(box, box) boolean' on db.
func BoxGe(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_ge
	const sqlstr = `SELECT pg_catalog.box_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxGt calls the stored procedure 'pg_catalog.box_gt(box, box) boolean' on db.
func BoxGt(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_gt
	const sqlstr = `SELECT pg_catalog.box_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxIn calls the stored procedure 'pg_catalog.box_in(cstring) box' on db.
func BoxIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Box, error) {
	// call pg_catalog.box_in
	const sqlstr = `SELECT pg_catalog.box_in($1)`
	// run
	var ret pgtypes.Box
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return ret, nil
}

// BoxIntersect calls the stored procedure 'pg_catalog.box_intersect(box, box) box' on db.
func BoxIntersect(ctx context.Context, db DB, v0, v1 pgtypes.Box) (pgtypes.Box, error) {
	// call pg_catalog.box_intersect
	const sqlstr = `SELECT pg_catalog.box_intersect($1, $2)`
	// run
	var ret pgtypes.Box
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return ret, nil
}

// BoxLe calls the stored procedure 'pg_catalog.box_le(box, box) boolean' on db.
func BoxLe(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_le
	const sqlstr = `SELECT pg_catalog.box_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxLeft calls the stored procedure 'pg_catalog.box_left(box, box) boolean' on db.
func BoxLeft(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_left
	const sqlstr = `SELECT pg_catalog.box_left($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxLt calls the stored procedure 'pg_catalog.box_lt(box, box) boolean' on db.
func BoxLt(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_lt
	const sqlstr = `SELECT pg_catalog.box_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxMul calls the stored procedure 'pg_catalog.box_mul(box, point) box' on db.
func BoxMul(ctx context.Context, db DB, v0 pgtypes.Box, v1 pgtypes.Point) (pgtypes.Box, error) {
	// call pg_catalog.box_mul
	const sqlstr = `SELECT pg_catalog.box_mul($1, $2)`
	// run
	var ret pgtypes.Box
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return ret, nil
}

// BoxOut calls the stored procedure 'pg_catalog.box_out(box) cstring' on db.
func BoxOut(ctx context.Context, db DB, v0 pgtypes.Box) (pgtypes.Cstring, error) {
	// call pg_catalog.box_out
	const sqlstr = `SELECT pg_catalog.box_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// BoxOverabove calls the stored procedure 'pg_catalog.box_overabove(box, box) boolean' on db.
func BoxOverabove(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_overabove
	const sqlstr = `SELECT pg_catalog.box_overabove($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxOverbelow calls the stored procedure 'pg_catalog.box_overbelow(box, box) boolean' on db.
func BoxOverbelow(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_overbelow
	const sqlstr = `SELECT pg_catalog.box_overbelow($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxOverlap calls the stored procedure 'pg_catalog.box_overlap(box, box) boolean' on db.
func BoxOverlap(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_overlap
	const sqlstr = `SELECT pg_catalog.box_overlap($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxOverleft calls the stored procedure 'pg_catalog.box_overleft(box, box) boolean' on db.
func BoxOverleft(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_overleft
	const sqlstr = `SELECT pg_catalog.box_overleft($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxOverright calls the stored procedure 'pg_catalog.box_overright(box, box) boolean' on db.
func BoxOverright(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_overright
	const sqlstr = `SELECT pg_catalog.box_overright($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxRecv calls the stored procedure 'pg_catalog.box_recv(internal) box' on db.
func BoxRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Box, error) {
	// call pg_catalog.box_recv
	const sqlstr = `SELECT pg_catalog.box_recv($1)`
	// run
	var ret pgtypes.Box
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return ret, nil
}

// BoxRight calls the stored procedure 'pg_catalog.box_right(box, box) boolean' on db.
func BoxRight(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_right
	const sqlstr = `SELECT pg_catalog.box_right($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxSame calls the stored procedure 'pg_catalog.box_same(box, box) boolean' on db.
func BoxSame(ctx context.Context, db DB, v0, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_same
	const sqlstr = `SELECT pg_catalog.box_same($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BoxSend calls the stored procedure 'pg_catalog.box_send(box) bytea' on db.
func BoxSend(ctx context.Context, db DB, v0 pgtypes.Box) ([]byte, error) {
	// call pg_catalog.box_send
	const sqlstr = `SELECT pg_catalog.box_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// BoxSub calls the stored procedure 'pg_catalog.box_sub(box, point) box' on db.
func BoxSub(ctx context.Context, db DB, v0 pgtypes.Box, v1 pgtypes.Point) (pgtypes.Box, error) {
	// call pg_catalog.box_sub
	const sqlstr = `SELECT pg_catalog.box_sub($1, $2)`
	// run
	var ret pgtypes.Box
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return ret, nil
}

// Bpchar calls the stored procedure 'pg_catalog.bpchar("char", name, character, integer, boolean) character' on db.
func Bpchar(ctx context.Context, db DB, v0 pgtypes.Char, v1 pgtypes.Name, v2 string, v3 int, v4 bool) (string, error) {
	// call pg_catalog.bpchar
	const sqlstr = `SELECT pg_catalog.bpchar($1, $2, $3, $4, $5)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// BpcharLarger calls the stored procedure 'pg_catalog.bpchar_larger(character, character) character' on db.
func BpcharLarger(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.bpchar_larger
	const sqlstr = `SELECT pg_catalog.bpchar_larger($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// BpcharPatternGe calls the stored procedure 'pg_catalog.bpchar_pattern_ge(character, character) boolean' on db.
func BpcharPatternGe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpchar_pattern_ge
	const sqlstr = `SELECT pg_catalog.bpchar_pattern_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BpcharPatternGt calls the stored procedure 'pg_catalog.bpchar_pattern_gt(character, character) boolean' on db.
func BpcharPatternGt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpchar_pattern_gt
	const sqlstr = `SELECT pg_catalog.bpchar_pattern_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BpcharPatternLe calls the stored procedure 'pg_catalog.bpchar_pattern_le(character, character) boolean' on db.
func BpcharPatternLe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpchar_pattern_le
	const sqlstr = `SELECT pg_catalog.bpchar_pattern_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BpcharPatternLt calls the stored procedure 'pg_catalog.bpchar_pattern_lt(character, character) boolean' on db.
func BpcharPatternLt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpchar_pattern_lt
	const sqlstr = `SELECT pg_catalog.bpchar_pattern_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BpcharSmaller calls the stored procedure 'pg_catalog.bpchar_smaller(character, character) character' on db.
func BpcharSmaller(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.bpchar_smaller
	const sqlstr = `SELECT pg_catalog.bpchar_smaller($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// BpcharSortsupport calls the stored procedure 'pg_catalog.bpchar_sortsupport(internal) void' on db.
func BpcharSortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.bpchar_sortsupport
	const sqlstr = `SELECT pg_catalog.bpchar_sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Bpcharcmp calls the stored procedure 'pg_catalog.bpcharcmp(character, character) integer' on db.
func Bpcharcmp(ctx context.Context, db DB, v0, v1 string) (int, error) {
	// call pg_catalog.bpcharcmp
	const sqlstr = `SELECT pg_catalog.bpcharcmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Bpchareq calls the stored procedure 'pg_catalog.bpchareq(character, character) boolean' on db.
func Bpchareq(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpchareq
	const sqlstr = `SELECT pg_catalog.bpchareq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharge calls the stored procedure 'pg_catalog.bpcharge(character, character) boolean' on db.
func Bpcharge(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpcharge
	const sqlstr = `SELECT pg_catalog.bpcharge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpchargt calls the stored procedure 'pg_catalog.bpchargt(character, character) boolean' on db.
func Bpchargt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpchargt
	const sqlstr = `SELECT pg_catalog.bpchargt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpchariclike calls the stored procedure 'pg_catalog.bpchariclike(character, text) boolean' on db.
func Bpchariclike(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpchariclike
	const sqlstr = `SELECT pg_catalog.bpchariclike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharicnlike calls the stored procedure 'pg_catalog.bpcharicnlike(character, text) boolean' on db.
func Bpcharicnlike(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpcharicnlike
	const sqlstr = `SELECT pg_catalog.bpcharicnlike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharicregexeq calls the stored procedure 'pg_catalog.bpcharicregexeq(character, text) boolean' on db.
func Bpcharicregexeq(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpcharicregexeq
	const sqlstr = `SELECT pg_catalog.bpcharicregexeq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharicregexne calls the stored procedure 'pg_catalog.bpcharicregexne(character, text) boolean' on db.
func Bpcharicregexne(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpcharicregexne
	const sqlstr = `SELECT pg_catalog.bpcharicregexne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharin calls the stored procedure 'pg_catalog.bpcharin(cstring, oid, integer) character' on db.
func Bpcharin(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (string, error) {
	// call pg_catalog.bpcharin
	const sqlstr = `SELECT pg_catalog.bpcharin($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Bpcharle calls the stored procedure 'pg_catalog.bpcharle(character, character) boolean' on db.
func Bpcharle(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpcharle
	const sqlstr = `SELECT pg_catalog.bpcharle($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharlike calls the stored procedure 'pg_catalog.bpcharlike(character, text) boolean' on db.
func Bpcharlike(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpcharlike
	const sqlstr = `SELECT pg_catalog.bpcharlike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharlt calls the stored procedure 'pg_catalog.bpcharlt(character, character) boolean' on db.
func Bpcharlt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpcharlt
	const sqlstr = `SELECT pg_catalog.bpcharlt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharne calls the stored procedure 'pg_catalog.bpcharne(character, character) boolean' on db.
func Bpcharne(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpcharne
	const sqlstr = `SELECT pg_catalog.bpcharne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharnlike calls the stored procedure 'pg_catalog.bpcharnlike(character, text) boolean' on db.
func Bpcharnlike(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpcharnlike
	const sqlstr = `SELECT pg_catalog.bpcharnlike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharout calls the stored procedure 'pg_catalog.bpcharout(character) cstring' on db.
func Bpcharout(ctx context.Context, db DB, v0 string) (pgtypes.Cstring, error) {
	// call pg_catalog.bpcharout
	const sqlstr = `SELECT pg_catalog.bpcharout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Bpcharrecv calls the stored procedure 'pg_catalog.bpcharrecv(internal, oid, integer) character' on db.
func Bpcharrecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (string, error) {
	// call pg_catalog.bpcharrecv
	const sqlstr = `SELECT pg_catalog.bpcharrecv($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Bpcharregexeq calls the stored procedure 'pg_catalog.bpcharregexeq(character, text) boolean' on db.
func Bpcharregexeq(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpcharregexeq
	const sqlstr = `SELECT pg_catalog.bpcharregexeq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharregexne calls the stored procedure 'pg_catalog.bpcharregexne(character, text) boolean' on db.
func Bpcharregexne(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.bpcharregexne
	const sqlstr = `SELECT pg_catalog.bpcharregexne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bpcharsend calls the stored procedure 'pg_catalog.bpcharsend(character) bytea' on db.
func Bpcharsend(ctx context.Context, db DB, v0 string) ([]byte, error) {
	// call pg_catalog.bpcharsend
	const sqlstr = `SELECT pg_catalog.bpcharsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Bpchartypmodin calls the stored procedure 'pg_catalog.bpchartypmodin(cstring[]) integer' on db.
func Bpchartypmodin(ctx context.Context, db DB, v0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.bpchartypmodin
	const sqlstr = `SELECT pg_catalog.bpchartypmodin($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Bpchartypmodout calls the stored procedure 'pg_catalog.bpchartypmodout(integer) cstring' on db.
func Bpchartypmodout(ctx context.Context, db DB, v0 int) (pgtypes.Cstring, error) {
	// call pg_catalog.bpchartypmodout
	const sqlstr = `SELECT pg_catalog.bpchartypmodout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// BrinDesummarizeRange calls the stored procedure 'pg_catalog.brin_desummarize_range(regclass, bigint) void' on db.
func BrinDesummarizeRange(ctx context.Context, db DB, v0 pgtypes.Regclass, v1 int64) error {
	// call pg_catalog.brin_desummarize_range
	const sqlstr = `SELECT pg_catalog.brin_desummarize_range($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// BrinInclusionAddValue calls the stored procedure 'pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal) boolean' on db.
func BrinInclusionAddValue(ctx context.Context, db DB, v0, v1, v2, v3 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_inclusion_add_value
	const sqlstr = `SELECT pg_catalog.brin_inclusion_add_value($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BrinInclusionConsistent calls the stored procedure 'pg_catalog.brin_inclusion_consistent(internal, internal, internal) boolean' on db.
func BrinInclusionConsistent(ctx context.Context, db DB, v0, v1, v2 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_inclusion_consistent
	const sqlstr = `SELECT pg_catalog.brin_inclusion_consistent($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BrinInclusionOpcinfo calls the stored procedure 'pg_catalog.brin_inclusion_opcinfo(internal) internal' on db.
func BrinInclusionOpcinfo(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.brin_inclusion_opcinfo
	const sqlstr = `SELECT pg_catalog.brin_inclusion_opcinfo($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// BrinInclusionUnion calls the stored procedure 'pg_catalog.brin_inclusion_union(internal, internal, internal) boolean' on db.
func BrinInclusionUnion(ctx context.Context, db DB, v0, v1, v2 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_inclusion_union
	const sqlstr = `SELECT pg_catalog.brin_inclusion_union($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BrinMinmaxAddValue calls the stored procedure 'pg_catalog.brin_minmax_add_value(internal, internal, internal, internal) boolean' on db.
func BrinMinmaxAddValue(ctx context.Context, db DB, v0, v1, v2, v3 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_minmax_add_value
	const sqlstr = `SELECT pg_catalog.brin_minmax_add_value($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BrinMinmaxConsistent calls the stored procedure 'pg_catalog.brin_minmax_consistent(internal, internal, internal) boolean' on db.
func BrinMinmaxConsistent(ctx context.Context, db DB, v0, v1, v2 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_minmax_consistent
	const sqlstr = `SELECT pg_catalog.brin_minmax_consistent($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BrinMinmaxOpcinfo calls the stored procedure 'pg_catalog.brin_minmax_opcinfo(internal) internal' on db.
func BrinMinmaxOpcinfo(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.brin_minmax_opcinfo
	const sqlstr = `SELECT pg_catalog.brin_minmax_opcinfo($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// BrinMinmaxUnion calls the stored procedure 'pg_catalog.brin_minmax_union(internal, internal, internal) boolean' on db.
func BrinMinmaxUnion(ctx context.Context, db DB, v0, v1, v2 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_minmax_union
	const sqlstr = `SELECT pg_catalog.brin_minmax_union($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// BrinSummarizeNewValues calls the stored procedure 'pg_catalog.brin_summarize_new_values(regclass) integer' on db.
func BrinSummarizeNewValues(ctx context.Context, db DB, v0 pgtypes.Regclass) (int, error) {
	// call pg_catalog.brin_summarize_new_values
	const sqlstr = `SELECT pg_catalog.brin_summarize_new_values($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// BrinSummarizeRange calls the stored procedure 'pg_catalog.brin_summarize_range(regclass, bigint) integer' on db.
func BrinSummarizeRange(ctx context.Context, db DB, v0 pgtypes.Regclass, v1 int64) (int, error) {
	// call pg_catalog.brin_summarize_range
	const sqlstr = `SELECT pg_catalog.brin_summarize_range($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Brinhandler calls the stored procedure 'pg_catalog.brinhandler(internal) index_am_handler' on db.
func Brinhandler(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.brinhandler
	const sqlstr = `SELECT pg_catalog.brinhandler($1)`
	// run
	var ret pgtypes.IndexAmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return ret, nil
}

// Broadcast calls the stored procedure 'pg_catalog.broadcast(inet) inet' on db.
func Broadcast(ctx context.Context, db DB, v0 string) (string, error) {
	// call pg_catalog.broadcast
	const sqlstr = `SELECT pg_catalog.broadcast($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Btarraycmp calls the stored procedure 'pg_catalog.btarraycmp(anyarray, anyarray) integer' on db.
func Btarraycmp(ctx context.Context, db DB, v0, v1 pgtypes.Anyarray) (int, error) {
	// call pg_catalog.btarraycmp
	const sqlstr = `SELECT pg_catalog.btarraycmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btboolcmp calls the stored procedure 'pg_catalog.btboolcmp(boolean, boolean) integer' on db.
func Btboolcmp(ctx context.Context, db DB, v0, v1 bool) (int, error) {
	// call pg_catalog.btboolcmp
	const sqlstr = `SELECT pg_catalog.btboolcmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// BtbpcharPatternCmp calls the stored procedure 'pg_catalog.btbpchar_pattern_cmp(character, character) integer' on db.
func BtbpcharPatternCmp(ctx context.Context, db DB, v0, v1 string) (int, error) {
	// call pg_catalog.btbpchar_pattern_cmp
	const sqlstr = `SELECT pg_catalog.btbpchar_pattern_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// BtbpcharPatternSortsupport calls the stored procedure 'pg_catalog.btbpchar_pattern_sortsupport(internal) void' on db.
func BtbpcharPatternSortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.btbpchar_pattern_sortsupport
	const sqlstr = `SELECT pg_catalog.btbpchar_pattern_sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Btcharcmp calls the stored procedure 'pg_catalog.btcharcmp("char", "char") integer' on db.
func Btcharcmp(ctx context.Context, db DB, v0, v1 pgtypes.Char) (int, error) {
	// call pg_catalog.btcharcmp
	const sqlstr = `SELECT pg_catalog.btcharcmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btequalimage calls the stored procedure 'pg_catalog.btequalimage(oid) boolean' on db.
func Btequalimage(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.btequalimage
	const sqlstr = `SELECT pg_catalog.btequalimage($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Btfloat48cmp calls the stored procedure 'pg_catalog.btfloat48cmp(real, double precision) integer' on db.
func Btfloat48cmp(ctx context.Context, db DB, v0 float32, v1 float64) (int, error) {
	// call pg_catalog.btfloat48cmp
	const sqlstr = `SELECT pg_catalog.btfloat48cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btfloat4cmp calls the stored procedure 'pg_catalog.btfloat4cmp(real, real) integer' on db.
func Btfloat4cmp(ctx context.Context, db DB, v0, v1 float32) (int, error) {
	// call pg_catalog.btfloat4cmp
	const sqlstr = `SELECT pg_catalog.btfloat4cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btfloat4sortsupport calls the stored procedure 'pg_catalog.btfloat4sortsupport(internal) void' on db.
func Btfloat4sortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.btfloat4sortsupport
	const sqlstr = `SELECT pg_catalog.btfloat4sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Btfloat84cmp calls the stored procedure 'pg_catalog.btfloat84cmp(double precision, real) integer' on db.
func Btfloat84cmp(ctx context.Context, db DB, v0 float64, v1 float32) (int, error) {
	// call pg_catalog.btfloat84cmp
	const sqlstr = `SELECT pg_catalog.btfloat84cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btfloat8cmp calls the stored procedure 'pg_catalog.btfloat8cmp(double precision, double precision) integer' on db.
func Btfloat8cmp(ctx context.Context, db DB, v0, v1 float64) (int, error) {
	// call pg_catalog.btfloat8cmp
	const sqlstr = `SELECT pg_catalog.btfloat8cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btfloat8sortsupport calls the stored procedure 'pg_catalog.btfloat8sortsupport(internal) void' on db.
func Btfloat8sortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.btfloat8sortsupport
	const sqlstr = `SELECT pg_catalog.btfloat8sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Bthandler calls the stored procedure 'pg_catalog.bthandler(internal) index_am_handler' on db.
func Bthandler(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.bthandler
	const sqlstr = `SELECT pg_catalog.bthandler($1)`
	// run
	var ret pgtypes.IndexAmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return ret, nil
}

// Btint24cmp calls the stored procedure 'pg_catalog.btint24cmp(smallint, integer) integer' on db.
func Btint24cmp(ctx context.Context, db DB, v0 int16, v1 int) (int, error) {
	// call pg_catalog.btint24cmp
	const sqlstr = `SELECT pg_catalog.btint24cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btint28cmp calls the stored procedure 'pg_catalog.btint28cmp(smallint, bigint) integer' on db.
func Btint28cmp(ctx context.Context, db DB, v0 int16, v1 int64) (int, error) {
	// call pg_catalog.btint28cmp
	const sqlstr = `SELECT pg_catalog.btint28cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btint2cmp calls the stored procedure 'pg_catalog.btint2cmp(smallint, smallint) integer' on db.
func Btint2cmp(ctx context.Context, db DB, v0, v1 int16) (int, error) {
	// call pg_catalog.btint2cmp
	const sqlstr = `SELECT pg_catalog.btint2cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btint2sortsupport calls the stored procedure 'pg_catalog.btint2sortsupport(internal) void' on db.
func Btint2sortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.btint2sortsupport
	const sqlstr = `SELECT pg_catalog.btint2sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Btint42cmp calls the stored procedure 'pg_catalog.btint42cmp(integer, smallint) integer' on db.
func Btint42cmp(ctx context.Context, db DB, v0 int, v1 int16) (int, error) {
	// call pg_catalog.btint42cmp
	const sqlstr = `SELECT pg_catalog.btint42cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btint48cmp calls the stored procedure 'pg_catalog.btint48cmp(integer, bigint) integer' on db.
func Btint48cmp(ctx context.Context, db DB, v0 int, v1 int64) (int, error) {
	// call pg_catalog.btint48cmp
	const sqlstr = `SELECT pg_catalog.btint48cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btint4cmp calls the stored procedure 'pg_catalog.btint4cmp(integer, integer) integer' on db.
func Btint4cmp(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.btint4cmp
	const sqlstr = `SELECT pg_catalog.btint4cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btint4sortsupport calls the stored procedure 'pg_catalog.btint4sortsupport(internal) void' on db.
func Btint4sortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.btint4sortsupport
	const sqlstr = `SELECT pg_catalog.btint4sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Btint82cmp calls the stored procedure 'pg_catalog.btint82cmp(bigint, smallint) integer' on db.
func Btint82cmp(ctx context.Context, db DB, v0 int64, v1 int16) (int, error) {
	// call pg_catalog.btint82cmp
	const sqlstr = `SELECT pg_catalog.btint82cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btint84cmp calls the stored procedure 'pg_catalog.btint84cmp(bigint, integer) integer' on db.
func Btint84cmp(ctx context.Context, db DB, v0 int64, v1 int) (int, error) {
	// call pg_catalog.btint84cmp
	const sqlstr = `SELECT pg_catalog.btint84cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btint8cmp calls the stored procedure 'pg_catalog.btint8cmp(bigint, bigint) integer' on db.
func Btint8cmp(ctx context.Context, db DB, v0, v1 int64) (int, error) {
	// call pg_catalog.btint8cmp
	const sqlstr = `SELECT pg_catalog.btint8cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btint8sortsupport calls the stored procedure 'pg_catalog.btint8sortsupport(internal) void' on db.
func Btint8sortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.btint8sortsupport
	const sqlstr = `SELECT pg_catalog.btint8sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Btnamecmp calls the stored procedure 'pg_catalog.btnamecmp(name, name) integer' on db.
func Btnamecmp(ctx context.Context, db DB, v0, v1 pgtypes.Name) (int, error) {
	// call pg_catalog.btnamecmp
	const sqlstr = `SELECT pg_catalog.btnamecmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btnamesortsupport calls the stored procedure 'pg_catalog.btnamesortsupport(internal) void' on db.
func Btnamesortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.btnamesortsupport
	const sqlstr = `SELECT pg_catalog.btnamesortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Btnametextcmp calls the stored procedure 'pg_catalog.btnametextcmp(name, text) integer' on db.
func Btnametextcmp(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (int, error) {
	// call pg_catalog.btnametextcmp
	const sqlstr = `SELECT pg_catalog.btnametextcmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btoidcmp calls the stored procedure 'pg_catalog.btoidcmp(oid, oid) integer' on db.
func Btoidcmp(ctx context.Context, db DB, v0, v1 pgtypes.Oid) (int, error) {
	// call pg_catalog.btoidcmp
	const sqlstr = `SELECT pg_catalog.btoidcmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btoidsortsupport calls the stored procedure 'pg_catalog.btoidsortsupport(internal) void' on db.
func Btoidsortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.btoidsortsupport
	const sqlstr = `SELECT pg_catalog.btoidsortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Btoidvectorcmp calls the stored procedure 'pg_catalog.btoidvectorcmp(oidvector, oidvector) integer' on db.
func Btoidvectorcmp(ctx context.Context, db DB, v0, v1 pgtypes.Oidvector) (int, error) {
	// call pg_catalog.btoidvectorcmp
	const sqlstr = `SELECT pg_catalog.btoidvectorcmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btrecordcmp calls the stored procedure 'pg_catalog.btrecordcmp(record, record) integer' on db.
func Btrecordcmp(ctx context.Context, db DB, v0, v1 pgtypes.Record) (int, error) {
	// call pg_catalog.btrecordcmp
	const sqlstr = `SELECT pg_catalog.btrecordcmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btrecordimagecmp calls the stored procedure 'pg_catalog.btrecordimagecmp(record, record) integer' on db.
func Btrecordimagecmp(ctx context.Context, db DB, v0, v1 pgtypes.Record) (int, error) {
	// call pg_catalog.btrecordimagecmp
	const sqlstr = `SELECT pg_catalog.btrecordimagecmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btrim calls the stored procedure 'pg_catalog.btrim(text, bytea, bytea, text, text) bytea' on db.
func Btrim(ctx context.Context, db DB, v0 string, v1, v2 []byte, v3, v4 string) ([]byte, error) {
	// call pg_catalog.btrim
	const sqlstr = `SELECT pg_catalog.btrim($1, $2, $3, $4, $5)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// BttextPatternCmp calls the stored procedure 'pg_catalog.bttext_pattern_cmp(text, text) integer' on db.
func BttextPatternCmp(ctx context.Context, db DB, v0, v1 string) (int, error) {
	// call pg_catalog.bttext_pattern_cmp
	const sqlstr = `SELECT pg_catalog.bttext_pattern_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// BttextPatternSortsupport calls the stored procedure 'pg_catalog.bttext_pattern_sortsupport(internal) void' on db.
func BttextPatternSortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.bttext_pattern_sortsupport
	const sqlstr = `SELECT pg_catalog.bttext_pattern_sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Bttextcmp calls the stored procedure 'pg_catalog.bttextcmp(text, text) integer' on db.
func Bttextcmp(ctx context.Context, db DB, v0, v1 string) (int, error) {
	// call pg_catalog.bttextcmp
	const sqlstr = `SELECT pg_catalog.bttextcmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Bttextnamecmp calls the stored procedure 'pg_catalog.bttextnamecmp(text, name) integer' on db.
func Bttextnamecmp(ctx context.Context, db DB, v0 string, v1 pgtypes.Name) (int, error) {
	// call pg_catalog.bttextnamecmp
	const sqlstr = `SELECT pg_catalog.bttextnamecmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Bttextsortsupport calls the stored procedure 'pg_catalog.bttextsortsupport(internal) void' on db.
func Bttextsortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.bttextsortsupport
	const sqlstr = `SELECT pg_catalog.bttextsortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Bttidcmp calls the stored procedure 'pg_catalog.bttidcmp(tid, tid) integer' on db.
func Bttidcmp(ctx context.Context, db DB, v0, v1 pgtypes.Tid) (int, error) {
	// call pg_catalog.bttidcmp
	const sqlstr = `SELECT pg_catalog.bttidcmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Btvarstrequalimage calls the stored procedure 'pg_catalog.btvarstrequalimage(oid) boolean' on db.
func Btvarstrequalimage(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.btvarstrequalimage
	const sqlstr = `SELECT pg_catalog.btvarstrequalimage($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// ByteaSortsupport calls the stored procedure 'pg_catalog.bytea_sortsupport(internal) void' on db.
func ByteaSortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.bytea_sortsupport
	const sqlstr = `SELECT pg_catalog.bytea_sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// ByteaStringAggFinalfn calls the stored procedure 'pg_catalog.bytea_string_agg_finalfn(internal) bytea' on db.
func ByteaStringAggFinalfn(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.bytea_string_agg_finalfn
	const sqlstr = `SELECT pg_catalog.bytea_string_agg_finalfn($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// ByteaStringAggTransfn calls the stored procedure 'pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea) internal' on db.
func ByteaStringAggTransfn(ctx context.Context, db DB, v0 pgtypes.Internal, v1, v2 []byte) (pgtypes.Internal, error) {
	// call pg_catalog.bytea_string_agg_transfn
	const sqlstr = `SELECT pg_catalog.bytea_string_agg_transfn($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Byteacat calls the stored procedure 'pg_catalog.byteacat(bytea, bytea) bytea' on db.
func Byteacat(ctx context.Context, db DB, v0, v1 []byte) ([]byte, error) {
	// call pg_catalog.byteacat
	const sqlstr = `SELECT pg_catalog.byteacat($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Byteacmp calls the stored procedure 'pg_catalog.byteacmp(bytea, bytea) integer' on db.
func Byteacmp(ctx context.Context, db DB, v0, v1 []byte) (int, error) {
	// call pg_catalog.byteacmp
	const sqlstr = `SELECT pg_catalog.byteacmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Byteaeq calls the stored procedure 'pg_catalog.byteaeq(bytea, bytea) boolean' on db.
func Byteaeq(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.byteaeq
	const sqlstr = `SELECT pg_catalog.byteaeq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Byteage calls the stored procedure 'pg_catalog.byteage(bytea, bytea) boolean' on db.
func Byteage(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.byteage
	const sqlstr = `SELECT pg_catalog.byteage($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Byteagt calls the stored procedure 'pg_catalog.byteagt(bytea, bytea) boolean' on db.
func Byteagt(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.byteagt
	const sqlstr = `SELECT pg_catalog.byteagt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Byteain calls the stored procedure 'pg_catalog.byteain(cstring) bytea' on db.
func Byteain(ctx context.Context, db DB, v0 pgtypes.Cstring) ([]byte, error) {
	// call pg_catalog.byteain
	const sqlstr = `SELECT pg_catalog.byteain($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Byteale calls the stored procedure 'pg_catalog.byteale(bytea, bytea) boolean' on db.
func Byteale(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.byteale
	const sqlstr = `SELECT pg_catalog.byteale($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bytealike calls the stored procedure 'pg_catalog.bytealike(bytea, bytea) boolean' on db.
func Bytealike(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.bytealike
	const sqlstr = `SELECT pg_catalog.bytealike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Bytealt calls the stored procedure 'pg_catalog.bytealt(bytea, bytea) boolean' on db.
func Bytealt(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.bytealt
	const sqlstr = `SELECT pg_catalog.bytealt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Byteane calls the stored procedure 'pg_catalog.byteane(bytea, bytea) boolean' on db.
func Byteane(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.byteane
	const sqlstr = `SELECT pg_catalog.byteane($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Byteanlike calls the stored procedure 'pg_catalog.byteanlike(bytea, bytea) boolean' on db.
func Byteanlike(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.byteanlike
	const sqlstr = `SELECT pg_catalog.byteanlike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Byteaout calls the stored procedure 'pg_catalog.byteaout(bytea) cstring' on db.
func Byteaout(ctx context.Context, db DB, v0 []byte) (pgtypes.Cstring, error) {
	// call pg_catalog.byteaout
	const sqlstr = `SELECT pg_catalog.byteaout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Bytearecv calls the stored procedure 'pg_catalog.bytearecv(internal) bytea' on db.
func Bytearecv(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.bytearecv
	const sqlstr = `SELECT pg_catalog.bytearecv($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Byteasend calls the stored procedure 'pg_catalog.byteasend(bytea) bytea' on db.
func Byteasend(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.byteasend
	const sqlstr = `SELECT pg_catalog.byteasend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Cardinality calls the stored procedure 'pg_catalog.cardinality(anyarray) integer' on db.
func Cardinality(ctx context.Context, db DB, v0 pgtypes.Anyarray) (int, error) {
	// call pg_catalog.cardinality
	const sqlstr = `SELECT pg_catalog.cardinality($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// CashCmp calls the stored procedure 'pg_catalog.cash_cmp(money, money) integer' on db.
func CashCmp(ctx context.Context, db DB, v0, v1 string) (int, error) {
	// call pg_catalog.cash_cmp
	const sqlstr = `SELECT pg_catalog.cash_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// CashDivCash calls the stored procedure 'pg_catalog.cash_div_cash(money, money) double precision' on db.
func CashDivCash(ctx context.Context, db DB, v0, v1 string) (float64, error) {
	// call pg_catalog.cash_div_cash
	const sqlstr = `SELECT pg_catalog.cash_div_cash($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// CashDivFlt4 calls the stored procedure 'pg_catalog.cash_div_flt4(money, real) money' on db.
func CashDivFlt4(ctx context.Context, db DB, v0 string, v1 float32) (string, error) {
	// call pg_catalog.cash_div_flt4
	const sqlstr = `SELECT pg_catalog.cash_div_flt4($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashDivFlt8 calls the stored procedure 'pg_catalog.cash_div_flt8(money, double precision) money' on db.
func CashDivFlt8(ctx context.Context, db DB, v0 string, v1 float64) (string, error) {
	// call pg_catalog.cash_div_flt8
	const sqlstr = `SELECT pg_catalog.cash_div_flt8($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashDivInt2 calls the stored procedure 'pg_catalog.cash_div_int2(money, smallint) money' on db.
func CashDivInt2(ctx context.Context, db DB, v0 string, v1 int16) (string, error) {
	// call pg_catalog.cash_div_int2
	const sqlstr = `SELECT pg_catalog.cash_div_int2($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashDivInt4 calls the stored procedure 'pg_catalog.cash_div_int4(money, integer) money' on db.
func CashDivInt4(ctx context.Context, db DB, v0 string, v1 int) (string, error) {
	// call pg_catalog.cash_div_int4
	const sqlstr = `SELECT pg_catalog.cash_div_int4($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashDivInt8 calls the stored procedure 'pg_catalog.cash_div_int8(money, bigint) money' on db.
func CashDivInt8(ctx context.Context, db DB, v0 string, v1 int64) (string, error) {
	// call pg_catalog.cash_div_int8
	const sqlstr = `SELECT pg_catalog.cash_div_int8($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashEq calls the stored procedure 'pg_catalog.cash_eq(money, money) boolean' on db.
func CashEq(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.cash_eq
	const sqlstr = `SELECT pg_catalog.cash_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CashGe calls the stored procedure 'pg_catalog.cash_ge(money, money) boolean' on db.
func CashGe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.cash_ge
	const sqlstr = `SELECT pg_catalog.cash_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CashGt calls the stored procedure 'pg_catalog.cash_gt(money, money) boolean' on db.
func CashGt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.cash_gt
	const sqlstr = `SELECT pg_catalog.cash_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CashIn calls the stored procedure 'pg_catalog.cash_in(cstring) money' on db.
func CashIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (string, error) {
	// call pg_catalog.cash_in
	const sqlstr = `SELECT pg_catalog.cash_in($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashLe calls the stored procedure 'pg_catalog.cash_le(money, money) boolean' on db.
func CashLe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.cash_le
	const sqlstr = `SELECT pg_catalog.cash_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CashLt calls the stored procedure 'pg_catalog.cash_lt(money, money) boolean' on db.
func CashLt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.cash_lt
	const sqlstr = `SELECT pg_catalog.cash_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CashMi calls the stored procedure 'pg_catalog.cash_mi(money, money) money' on db.
func CashMi(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.cash_mi
	const sqlstr = `SELECT pg_catalog.cash_mi($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashMulFlt4 calls the stored procedure 'pg_catalog.cash_mul_flt4(money, real) money' on db.
func CashMulFlt4(ctx context.Context, db DB, v0 string, v1 float32) (string, error) {
	// call pg_catalog.cash_mul_flt4
	const sqlstr = `SELECT pg_catalog.cash_mul_flt4($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashMulFlt8 calls the stored procedure 'pg_catalog.cash_mul_flt8(money, double precision) money' on db.
func CashMulFlt8(ctx context.Context, db DB, v0 string, v1 float64) (string, error) {
	// call pg_catalog.cash_mul_flt8
	const sqlstr = `SELECT pg_catalog.cash_mul_flt8($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashMulInt2 calls the stored procedure 'pg_catalog.cash_mul_int2(money, smallint) money' on db.
func CashMulInt2(ctx context.Context, db DB, v0 string, v1 int16) (string, error) {
	// call pg_catalog.cash_mul_int2
	const sqlstr = `SELECT pg_catalog.cash_mul_int2($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashMulInt4 calls the stored procedure 'pg_catalog.cash_mul_int4(money, integer) money' on db.
func CashMulInt4(ctx context.Context, db DB, v0 string, v1 int) (string, error) {
	// call pg_catalog.cash_mul_int4
	const sqlstr = `SELECT pg_catalog.cash_mul_int4($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashMulInt8 calls the stored procedure 'pg_catalog.cash_mul_int8(money, bigint) money' on db.
func CashMulInt8(ctx context.Context, db DB, v0 string, v1 int64) (string, error) {
	// call pg_catalog.cash_mul_int8
	const sqlstr = `SELECT pg_catalog.cash_mul_int8($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashNe calls the stored procedure 'pg_catalog.cash_ne(money, money) boolean' on db.
func CashNe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.cash_ne
	const sqlstr = `SELECT pg_catalog.cash_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CashOut calls the stored procedure 'pg_catalog.cash_out(money) cstring' on db.
func CashOut(ctx context.Context, db DB, v0 string) (pgtypes.Cstring, error) {
	// call pg_catalog.cash_out
	const sqlstr = `SELECT pg_catalog.cash_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// CashPl calls the stored procedure 'pg_catalog.cash_pl(money, money) money' on db.
func CashPl(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.cash_pl
	const sqlstr = `SELECT pg_catalog.cash_pl($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashRecv calls the stored procedure 'pg_catalog.cash_recv(internal) money' on db.
func CashRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (string, error) {
	// call pg_catalog.cash_recv
	const sqlstr = `SELECT pg_catalog.cash_recv($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CashSend calls the stored procedure 'pg_catalog.cash_send(money) bytea' on db.
func CashSend(ctx context.Context, db DB, v0 string) ([]byte, error) {
	// call pg_catalog.cash_send
	const sqlstr = `SELECT pg_catalog.cash_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// CashWords calls the stored procedure 'pg_catalog.cash_words(money) text' on db.
func CashWords(ctx context.Context, db DB, v0 string) (string, error) {
	// call pg_catalog.cash_words
	const sqlstr = `SELECT pg_catalog.cash_words($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Cashlarger calls the stored procedure 'pg_catalog.cashlarger(money, money) money' on db.
func Cashlarger(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.cashlarger
	const sqlstr = `SELECT pg_catalog.cashlarger($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Cashsmaller calls the stored procedure 'pg_catalog.cashsmaller(money, money) money' on db.
func Cashsmaller(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.cashsmaller
	const sqlstr = `SELECT pg_catalog.cashsmaller($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Cbrt calls the stored procedure 'pg_catalog.cbrt(double precision) double precision' on db.
func Cbrt(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.cbrt
	const sqlstr = `SELECT pg_catalog.cbrt($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Ceil calls the stored procedure 'pg_catalog.ceil(double precision, numeric) numeric' on db.
func Ceil(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.ceil
	const sqlstr = `SELECT pg_catalog.ceil($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Ceiling calls the stored procedure 'pg_catalog.ceiling(double precision, numeric) numeric' on db.
func Ceiling(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.ceiling
	const sqlstr = `SELECT pg_catalog.ceiling($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Center calls the stored procedure 'pg_catalog.center(box, circle) point' on db.
func Center(ctx context.Context, db DB, v0 pgtypes.Box, v1 pgtypes.Circle) (pgtypes.Point, error) {
	// call pg_catalog.center
	const sqlstr = `SELECT pg_catalog.center($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// Char calls the stored procedure 'pg_catalog.char(integer, text) "char"' on db.
func Char(ctx context.Context, db DB, v0 int, v1 string) (pgtypes.Char, error) {
	// call pg_catalog.char
	const sqlstr = `SELECT pg_catalog.char($1, $2)`
	// run
	var ret pgtypes.Char
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return ret, nil
}

// CharLength calls the stored procedure 'pg_catalog.char_length(text, character) integer' on db.
func CharLength(ctx context.Context, db DB, v0, v1 string) (int, error) {
	// call pg_catalog.char_length
	const sqlstr = `SELECT pg_catalog.char_length($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// CharacterLength calls the stored procedure 'pg_catalog.character_length(text, character) integer' on db.
func CharacterLength(ctx context.Context, db DB, v0, v1 string) (int, error) {
	// call pg_catalog.character_length
	const sqlstr = `SELECT pg_catalog.character_length($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Chareq calls the stored procedure 'pg_catalog.chareq("char", "char") boolean' on db.
func Chareq(ctx context.Context, db DB, v0, v1 pgtypes.Char) (bool, error) {
	// call pg_catalog.chareq
	const sqlstr = `SELECT pg_catalog.chareq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Charge calls the stored procedure 'pg_catalog.charge("char", "char") boolean' on db.
func Charge(ctx context.Context, db DB, v0, v1 pgtypes.Char) (bool, error) {
	// call pg_catalog.charge
	const sqlstr = `SELECT pg_catalog.charge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Chargt calls the stored procedure 'pg_catalog.chargt("char", "char") boolean' on db.
func Chargt(ctx context.Context, db DB, v0, v1 pgtypes.Char) (bool, error) {
	// call pg_catalog.chargt
	const sqlstr = `SELECT pg_catalog.chargt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Charin calls the stored procedure 'pg_catalog.charin(cstring) "char"' on db.
func Charin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Char, error) {
	// call pg_catalog.charin
	const sqlstr = `SELECT pg_catalog.charin($1)`
	// run
	var ret pgtypes.Char
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return ret, nil
}

// Charle calls the stored procedure 'pg_catalog.charle("char", "char") boolean' on db.
func Charle(ctx context.Context, db DB, v0, v1 pgtypes.Char) (bool, error) {
	// call pg_catalog.charle
	const sqlstr = `SELECT pg_catalog.charle($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Charlt calls the stored procedure 'pg_catalog.charlt("char", "char") boolean' on db.
func Charlt(ctx context.Context, db DB, v0, v1 pgtypes.Char) (bool, error) {
	// call pg_catalog.charlt
	const sqlstr = `SELECT pg_catalog.charlt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Charne calls the stored procedure 'pg_catalog.charne("char", "char") boolean' on db.
func Charne(ctx context.Context, db DB, v0, v1 pgtypes.Char) (bool, error) {
	// call pg_catalog.charne
	const sqlstr = `SELECT pg_catalog.charne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Charout calls the stored procedure 'pg_catalog.charout("char") cstring' on db.
func Charout(ctx context.Context, db DB, v0 pgtypes.Char) (pgtypes.Cstring, error) {
	// call pg_catalog.charout
	const sqlstr = `SELECT pg_catalog.charout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Charrecv calls the stored procedure 'pg_catalog.charrecv(internal) "char"' on db.
func Charrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Char, error) {
	// call pg_catalog.charrecv
	const sqlstr = `SELECT pg_catalog.charrecv($1)`
	// run
	var ret pgtypes.Char
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return ret, nil
}

// Charsend calls the stored procedure 'pg_catalog.charsend("char") bytea' on db.
func Charsend(ctx context.Context, db DB, v0 pgtypes.Char) ([]byte, error) {
	// call pg_catalog.charsend
	const sqlstr = `SELECT pg_catalog.charsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Chr calls the stored procedure 'pg_catalog.chr(integer) text' on db.
func Chr(ctx context.Context, db DB, v0 int) (string, error) {
	// call pg_catalog.chr
	const sqlstr = `SELECT pg_catalog.chr($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Cideq calls the stored procedure 'pg_catalog.cideq(cid, cid) boolean' on db.
func Cideq(ctx context.Context, db DB, v0, v1 pgtypes.Cid) (bool, error) {
	// call pg_catalog.cideq
	const sqlstr = `SELECT pg_catalog.cideq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Cidin calls the stored procedure 'pg_catalog.cidin(cstring) cid' on db.
func Cidin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Cid, error) {
	// call pg_catalog.cidin
	const sqlstr = `SELECT pg_catalog.cidin($1)`
	// run
	var ret pgtypes.Cid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cid{}, logerror(err)
	}
	return ret, nil
}

// Cidout calls the stored procedure 'pg_catalog.cidout(cid) cstring' on db.
func Cidout(ctx context.Context, db DB, v0 pgtypes.Cid) (pgtypes.Cstring, error) {
	// call pg_catalog.cidout
	const sqlstr = `SELECT pg_catalog.cidout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Cidr calls the stored procedure 'pg_catalog.cidr(inet) cidr' on db.
func Cidr(ctx context.Context, db DB, v0 string) (pgtypes.Cidr, error) {
	// call pg_catalog.cidr
	const sqlstr = `SELECT pg_catalog.cidr($1)`
	// run
	var ret pgtypes.Cidr
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cidr{}, logerror(err)
	}
	return ret, nil
}

// CidrIn calls the stored procedure 'pg_catalog.cidr_in(cstring) cidr' on db.
func CidrIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Cidr, error) {
	// call pg_catalog.cidr_in
	const sqlstr = `SELECT pg_catalog.cidr_in($1)`
	// run
	var ret pgtypes.Cidr
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cidr{}, logerror(err)
	}
	return ret, nil
}

// CidrOut calls the stored procedure 'pg_catalog.cidr_out(cidr) cstring' on db.
func CidrOut(ctx context.Context, db DB, v0 pgtypes.Cidr) (pgtypes.Cstring, error) {
	// call pg_catalog.cidr_out
	const sqlstr = `SELECT pg_catalog.cidr_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// CidrRecv calls the stored procedure 'pg_catalog.cidr_recv(internal) cidr' on db.
func CidrRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Cidr, error) {
	// call pg_catalog.cidr_recv
	const sqlstr = `SELECT pg_catalog.cidr_recv($1)`
	// run
	var ret pgtypes.Cidr
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cidr{}, logerror(err)
	}
	return ret, nil
}

// CidrSend calls the stored procedure 'pg_catalog.cidr_send(cidr) bytea' on db.
func CidrSend(ctx context.Context, db DB, v0 pgtypes.Cidr) ([]byte, error) {
	// call pg_catalog.cidr_send
	const sqlstr = `SELECT pg_catalog.cidr_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Cidrecv calls the stored procedure 'pg_catalog.cidrecv(internal) cid' on db.
func Cidrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Cid, error) {
	// call pg_catalog.cidrecv
	const sqlstr = `SELECT pg_catalog.cidrecv($1)`
	// run
	var ret pgtypes.Cid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cid{}, logerror(err)
	}
	return ret, nil
}

// Cidsend calls the stored procedure 'pg_catalog.cidsend(cid) bytea' on db.
func Cidsend(ctx context.Context, db DB, v0 pgtypes.Cid) ([]byte, error) {
	// call pg_catalog.cidsend
	const sqlstr = `SELECT pg_catalog.cidsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Circle calls the stored procedure 'pg_catalog.circle(box, polygon, point, double precision) circle' on db.
func Circle(ctx context.Context, db DB, v0 pgtypes.Box, v1 pgtypes.Polygon, v2 pgtypes.Point, v3 float64) (pgtypes.Circle, error) {
	// call pg_catalog.circle
	const sqlstr = `SELECT pg_catalog.circle($1, $2, $3, $4)`
	// run
	var ret pgtypes.Circle
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return ret, nil
}

// CircleAbove calls the stored procedure 'pg_catalog.circle_above(circle, circle) boolean' on db.
func CircleAbove(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_above
	const sqlstr = `SELECT pg_catalog.circle_above($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleAddPt calls the stored procedure 'pg_catalog.circle_add_pt(circle, point) circle' on db.
func CircleAddPt(ctx context.Context, db DB, v0 pgtypes.Circle, v1 pgtypes.Point) (pgtypes.Circle, error) {
	// call pg_catalog.circle_add_pt
	const sqlstr = `SELECT pg_catalog.circle_add_pt($1, $2)`
	// run
	var ret pgtypes.Circle
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return ret, nil
}

// CircleBelow calls the stored procedure 'pg_catalog.circle_below(circle, circle) boolean' on db.
func CircleBelow(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_below
	const sqlstr = `SELECT pg_catalog.circle_below($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleCenter calls the stored procedure 'pg_catalog.circle_center(circle) point' on db.
func CircleCenter(ctx context.Context, db DB, v0 pgtypes.Circle) (pgtypes.Point, error) {
	// call pg_catalog.circle_center
	const sqlstr = `SELECT pg_catalog.circle_center($1)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// CircleContain calls the stored procedure 'pg_catalog.circle_contain(circle, circle) boolean' on db.
func CircleContain(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_contain
	const sqlstr = `SELECT pg_catalog.circle_contain($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleContainPt calls the stored procedure 'pg_catalog.circle_contain_pt(circle, point) boolean' on db.
func CircleContainPt(ctx context.Context, db DB, v0 pgtypes.Circle, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.circle_contain_pt
	const sqlstr = `SELECT pg_catalog.circle_contain_pt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleContained calls the stored procedure 'pg_catalog.circle_contained(circle, circle) boolean' on db.
func CircleContained(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_contained
	const sqlstr = `SELECT pg_catalog.circle_contained($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleDistance calls the stored procedure 'pg_catalog.circle_distance(circle, circle) double precision' on db.
func CircleDistance(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (float64, error) {
	// call pg_catalog.circle_distance
	const sqlstr = `SELECT pg_catalog.circle_distance($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// CircleDivPt calls the stored procedure 'pg_catalog.circle_div_pt(circle, point) circle' on db.
func CircleDivPt(ctx context.Context, db DB, v0 pgtypes.Circle, v1 pgtypes.Point) (pgtypes.Circle, error) {
	// call pg_catalog.circle_div_pt
	const sqlstr = `SELECT pg_catalog.circle_div_pt($1, $2)`
	// run
	var ret pgtypes.Circle
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return ret, nil
}

// CircleEq calls the stored procedure 'pg_catalog.circle_eq(circle, circle) boolean' on db.
func CircleEq(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_eq
	const sqlstr = `SELECT pg_catalog.circle_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleGe calls the stored procedure 'pg_catalog.circle_ge(circle, circle) boolean' on db.
func CircleGe(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_ge
	const sqlstr = `SELECT pg_catalog.circle_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleGt calls the stored procedure 'pg_catalog.circle_gt(circle, circle) boolean' on db.
func CircleGt(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_gt
	const sqlstr = `SELECT pg_catalog.circle_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleIn calls the stored procedure 'pg_catalog.circle_in(cstring) circle' on db.
func CircleIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Circle, error) {
	// call pg_catalog.circle_in
	const sqlstr = `SELECT pg_catalog.circle_in($1)`
	// run
	var ret pgtypes.Circle
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return ret, nil
}

// CircleLe calls the stored procedure 'pg_catalog.circle_le(circle, circle) boolean' on db.
func CircleLe(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_le
	const sqlstr = `SELECT pg_catalog.circle_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleLeft calls the stored procedure 'pg_catalog.circle_left(circle, circle) boolean' on db.
func CircleLeft(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_left
	const sqlstr = `SELECT pg_catalog.circle_left($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleLt calls the stored procedure 'pg_catalog.circle_lt(circle, circle) boolean' on db.
func CircleLt(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_lt
	const sqlstr = `SELECT pg_catalog.circle_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleMulPt calls the stored procedure 'pg_catalog.circle_mul_pt(circle, point) circle' on db.
func CircleMulPt(ctx context.Context, db DB, v0 pgtypes.Circle, v1 pgtypes.Point) (pgtypes.Circle, error) {
	// call pg_catalog.circle_mul_pt
	const sqlstr = `SELECT pg_catalog.circle_mul_pt($1, $2)`
	// run
	var ret pgtypes.Circle
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return ret, nil
}

// CircleNe calls the stored procedure 'pg_catalog.circle_ne(circle, circle) boolean' on db.
func CircleNe(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_ne
	const sqlstr = `SELECT pg_catalog.circle_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleOut calls the stored procedure 'pg_catalog.circle_out(circle) cstring' on db.
func CircleOut(ctx context.Context, db DB, v0 pgtypes.Circle) (pgtypes.Cstring, error) {
	// call pg_catalog.circle_out
	const sqlstr = `SELECT pg_catalog.circle_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// CircleOverabove calls the stored procedure 'pg_catalog.circle_overabove(circle, circle) boolean' on db.
func CircleOverabove(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_overabove
	const sqlstr = `SELECT pg_catalog.circle_overabove($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleOverbelow calls the stored procedure 'pg_catalog.circle_overbelow(circle, circle) boolean' on db.
func CircleOverbelow(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_overbelow
	const sqlstr = `SELECT pg_catalog.circle_overbelow($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleOverlap calls the stored procedure 'pg_catalog.circle_overlap(circle, circle) boolean' on db.
func CircleOverlap(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_overlap
	const sqlstr = `SELECT pg_catalog.circle_overlap($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleOverleft calls the stored procedure 'pg_catalog.circle_overleft(circle, circle) boolean' on db.
func CircleOverleft(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_overleft
	const sqlstr = `SELECT pg_catalog.circle_overleft($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleOverright calls the stored procedure 'pg_catalog.circle_overright(circle, circle) boolean' on db.
func CircleOverright(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_overright
	const sqlstr = `SELECT pg_catalog.circle_overright($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleRecv calls the stored procedure 'pg_catalog.circle_recv(internal) circle' on db.
func CircleRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Circle, error) {
	// call pg_catalog.circle_recv
	const sqlstr = `SELECT pg_catalog.circle_recv($1)`
	// run
	var ret pgtypes.Circle
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return ret, nil
}

// CircleRight calls the stored procedure 'pg_catalog.circle_right(circle, circle) boolean' on db.
func CircleRight(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_right
	const sqlstr = `SELECT pg_catalog.circle_right($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleSame calls the stored procedure 'pg_catalog.circle_same(circle, circle) boolean' on db.
func CircleSame(ctx context.Context, db DB, v0, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_same
	const sqlstr = `SELECT pg_catalog.circle_same($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// CircleSend calls the stored procedure 'pg_catalog.circle_send(circle) bytea' on db.
func CircleSend(ctx context.Context, db DB, v0 pgtypes.Circle) ([]byte, error) {
	// call pg_catalog.circle_send
	const sqlstr = `SELECT pg_catalog.circle_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// CircleSubPt calls the stored procedure 'pg_catalog.circle_sub_pt(circle, point) circle' on db.
func CircleSubPt(ctx context.Context, db DB, v0 pgtypes.Circle, v1 pgtypes.Point) (pgtypes.Circle, error) {
	// call pg_catalog.circle_sub_pt
	const sqlstr = `SELECT pg_catalog.circle_sub_pt($1, $2)`
	// run
	var ret pgtypes.Circle
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return ret, nil
}

// ClockTimestamp calls the stored procedure 'pg_catalog.clock_timestamp() timestamp with time zone' on db.
func ClockTimestamp(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.clock_timestamp
	const sqlstr = `SELECT pg_catalog.clock_timestamp()`
	// run
	var ret time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// CloseLb calls the stored procedure 'pg_catalog.close_lb(line, box) point' on db.
func CloseLb(ctx context.Context, db DB, v0 pgtypes.Line, v1 pgtypes.Box) (pgtypes.Point, error) {
	// call pg_catalog.close_lb
	const sqlstr = `SELECT pg_catalog.close_lb($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// CloseLs calls the stored procedure 'pg_catalog.close_ls(line, lseg) point' on db.
func CloseLs(ctx context.Context, db DB, v0 pgtypes.Line, v1 pgtypes.Lseg) (pgtypes.Point, error) {
	// call pg_catalog.close_ls
	const sqlstr = `SELECT pg_catalog.close_ls($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// CloseLseg calls the stored procedure 'pg_catalog.close_lseg(lseg, lseg) point' on db.
func CloseLseg(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (pgtypes.Point, error) {
	// call pg_catalog.close_lseg
	const sqlstr = `SELECT pg_catalog.close_lseg($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// ClosePb calls the stored procedure 'pg_catalog.close_pb(point, box) point' on db.
func ClosePb(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Box) (pgtypes.Point, error) {
	// call pg_catalog.close_pb
	const sqlstr = `SELECT pg_catalog.close_pb($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// ClosePl calls the stored procedure 'pg_catalog.close_pl(point, line) point' on db.
func ClosePl(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Line) (pgtypes.Point, error) {
	// call pg_catalog.close_pl
	const sqlstr = `SELECT pg_catalog.close_pl($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// ClosePs calls the stored procedure 'pg_catalog.close_ps(point, lseg) point' on db.
func ClosePs(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Lseg) (pgtypes.Point, error) {
	// call pg_catalog.close_ps
	const sqlstr = `SELECT pg_catalog.close_ps($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// CloseSb calls the stored procedure 'pg_catalog.close_sb(lseg, box) point' on db.
func CloseSb(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Box) (pgtypes.Point, error) {
	// call pg_catalog.close_sb
	const sqlstr = `SELECT pg_catalog.close_sb($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// CloseSl calls the stored procedure 'pg_catalog.close_sl(lseg, line) point' on db.
func CloseSl(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Line) (pgtypes.Point, error) {
	// call pg_catalog.close_sl
	const sqlstr = `SELECT pg_catalog.close_sl($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// ColDescription calls the stored procedure 'pg_catalog.col_description(oid, integer) text' on db.
func ColDescription(ctx context.Context, db DB, v0 pgtypes.Oid, v1 int) (string, error) {
	// call pg_catalog.col_description
	const sqlstr = `SELECT pg_catalog.col_description($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Concat calls the stored procedure 'pg_catalog.concat("any") text' on db.
func Concat(ctx context.Context, db DB, v0 pgtypes.Any) (string, error) {
	// call pg_catalog.concat
	const sqlstr = `SELECT pg_catalog.concat($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// ConcatWs calls the stored procedure 'pg_catalog.concat_ws(text, "any") text' on db.
func ConcatWs(ctx context.Context, db DB, v0 string, v1 pgtypes.Any) (string, error) {
	// call pg_catalog.concat_ws
	const sqlstr = `SELECT pg_catalog.concat_ws($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Contjoinsel calls the stored procedure 'pg_catalog.contjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Contjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.contjoinsel
	const sqlstr = `SELECT pg_catalog.contjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Contsel calls the stored procedure 'pg_catalog.contsel(internal, oid, internal, integer) double precision' on db.
func Contsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.contsel
	const sqlstr = `SELECT pg_catalog.contsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Convert calls the stored procedure 'pg_catalog.convert(bytea, name, name) bytea' on db.
func Convert(ctx context.Context, db DB, v0 []byte, v1, v2 pgtypes.Name) ([]byte, error) {
	// call pg_catalog.convert
	const sqlstr = `SELECT pg_catalog.convert($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// ConvertFrom calls the stored procedure 'pg_catalog.convert_from(bytea, name) text' on db.
func ConvertFrom(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Name) (string, error) {
	// call pg_catalog.convert_from
	const sqlstr = `SELECT pg_catalog.convert_from($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// ConvertTo calls the stored procedure 'pg_catalog.convert_to(text, name) bytea' on db.
func ConvertTo(ctx context.Context, db DB, v0 string, v1 pgtypes.Name) ([]byte, error) {
	// call pg_catalog.convert_to
	const sqlstr = `SELECT pg_catalog.convert_to($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Corr calls the stored procedure 'pg_catalog.corr(double precision, double precision) double precision' on db.
func Corr(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.corr
	const sqlstr = `SELECT pg_catalog.corr($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Cos calls the stored procedure 'pg_catalog.cos(double precision) double precision' on db.
func Cos(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.cos
	const sqlstr = `SELECT pg_catalog.cos($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Cosd calls the stored procedure 'pg_catalog.cosd(double precision) double precision' on db.
func Cosd(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.cosd
	const sqlstr = `SELECT pg_catalog.cosd($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Cosh calls the stored procedure 'pg_catalog.cosh(double precision) double precision' on db.
func Cosh(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.cosh
	const sqlstr = `SELECT pg_catalog.cosh($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Cot calls the stored procedure 'pg_catalog.cot(double precision) double precision' on db.
func Cot(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.cot
	const sqlstr = `SELECT pg_catalog.cot($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Cotd calls the stored procedure 'pg_catalog.cotd(double precision) double precision' on db.
func Cotd(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.cotd
	const sqlstr = `SELECT pg_catalog.cotd($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Count calls the stored procedure 'pg_catalog.count("any") bigint' on db.
func Count(ctx context.Context, db DB, v0 pgtypes.Any) (int64, error) {
	// call pg_catalog.count
	const sqlstr = `SELECT pg_catalog.count($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// CovarPop calls the stored procedure 'pg_catalog.covar_pop(double precision, double precision) double precision' on db.
func CovarPop(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.covar_pop
	const sqlstr = `SELECT pg_catalog.covar_pop($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// CovarSamp calls the stored procedure 'pg_catalog.covar_samp(double precision, double precision) double precision' on db.
func CovarSamp(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.covar_samp
	const sqlstr = `SELECT pg_catalog.covar_samp($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// CstringIn calls the stored procedure 'pg_catalog.cstring_in(cstring) cstring' on db.
func CstringIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Cstring, error) {
	// call pg_catalog.cstring_in
	const sqlstr = `SELECT pg_catalog.cstring_in($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// CstringOut calls the stored procedure 'pg_catalog.cstring_out(cstring) cstring' on db.
func CstringOut(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Cstring, error) {
	// call pg_catalog.cstring_out
	const sqlstr = `SELECT pg_catalog.cstring_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// CstringRecv calls the stored procedure 'pg_catalog.cstring_recv(internal) cstring' on db.
func CstringRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Cstring, error) {
	// call pg_catalog.cstring_recv
	const sqlstr = `SELECT pg_catalog.cstring_recv($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// CstringSend calls the stored procedure 'pg_catalog.cstring_send(cstring) bytea' on db.
func CstringSend(ctx context.Context, db DB, v0 pgtypes.Cstring) ([]byte, error) {
	// call pg_catalog.cstring_send
	const sqlstr = `SELECT pg_catalog.cstring_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// CumeDist calls the stored procedure 'pg_catalog.cume_dist("any") double precision' on db.
func CumeDist(ctx context.Context, db DB, v0 pgtypes.Any) (float64, error) {
	// call pg_catalog.cume_dist
	const sqlstr = `SELECT pg_catalog.cume_dist($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// CumeDistFinal calls the stored procedure 'pg_catalog.cume_dist_final(internal, "any") double precision' on db.
func CumeDistFinal(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Any) (float64, error) {
	// call pg_catalog.cume_dist_final
	const sqlstr = `SELECT pg_catalog.cume_dist_final($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// CurrentDatabase calls the stored procedure 'pg_catalog.current_database() name' on db.
func CurrentDatabase(ctx context.Context, db DB) (pgtypes.Name, error) {
	// call pg_catalog.current_database
	const sqlstr = `SELECT pg_catalog.current_database()`
	// run
	var ret pgtypes.Name
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// CurrentQuery calls the stored procedure 'pg_catalog.current_query() text' on db.
func CurrentQuery(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.current_query
	const sqlstr = `SELECT pg_catalog.current_query()`
	// run
	var ret string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CurrentSchema calls the stored procedure 'pg_catalog.current_schema() name' on db.
func CurrentSchema(ctx context.Context, db DB) (pgtypes.Name, error) {
	// call pg_catalog.current_schema
	const sqlstr = `SELECT pg_catalog.current_schema()`
	// run
	var ret pgtypes.Name
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// CurrentSchemas calls the stored procedure 'pg_catalog.current_schemas(boolean) name[]' on db.
func CurrentSchemas(ctx context.Context, db DB, v0 bool) ([]pgtypes.Name, error) {
	// call pg_catalog.current_schemas
	const sqlstr = `SELECT pg_catalog.current_schemas($1)`
	// run
	var ret []pgtypes.Name
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// CurrentSetting calls the stored procedure 'pg_catalog.current_setting(text, text, boolean) text' on db.
func CurrentSetting(ctx context.Context, db DB, v0, v1 string, v2 bool) (string, error) {
	// call pg_catalog.current_setting
	const sqlstr = `SELECT pg_catalog.current_setting($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// CurrentUser calls the stored procedure 'pg_catalog.current_user() name' on db.
func CurrentUser(ctx context.Context, db DB) (pgtypes.Name, error) {
	// call pg_catalog.current_user
	const sqlstr = `SELECT pg_catalog.current_user()`
	// run
	var ret pgtypes.Name
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// Currtid calls the stored procedure 'pg_catalog.currtid(oid, tid) tid' on db.
func Currtid(ctx context.Context, db DB, v0 pgtypes.Oid, v1 pgtypes.Tid) (pgtypes.Tid, error) {
	// call pg_catalog.currtid
	const sqlstr = `SELECT pg_catalog.currtid($1, $2)`
	// run
	var ret pgtypes.Tid
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Tid{}, logerror(err)
	}
	return ret, nil
}

// Currtid2 calls the stored procedure 'pg_catalog.currtid2(text, tid) tid' on db.
func Currtid2(ctx context.Context, db DB, v0 string, v1 pgtypes.Tid) (pgtypes.Tid, error) {
	// call pg_catalog.currtid2
	const sqlstr = `SELECT pg_catalog.currtid2($1, $2)`
	// run
	var ret pgtypes.Tid
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Tid{}, logerror(err)
	}
	return ret, nil
}

// Currval calls the stored procedure 'pg_catalog.currval(regclass) bigint' on db.
func Currval(ctx context.Context, db DB, v0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.currval
	const sqlstr = `SELECT pg_catalog.currval($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// CursorToXML calls the stored procedure 'pg_catalog.cursor_to_xml(refcursor, integer, boolean, boolean, text) xml' on db.
func CursorToXML(ctx context.Context, db DB, v0 pgtypes.Refcursor, v1 int, v2, v3 bool, v4 string) ([]byte, error) {
	// call pg_catalog.cursor_to_xml
	const sqlstr = `SELECT pg_catalog.cursor_to_xml($1, $2, $3, $4, $5)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// CursorToXmlschema calls the stored procedure 'pg_catalog.cursor_to_xmlschema(refcursor, boolean, boolean, text) xml' on db.
func CursorToXmlschema(ctx context.Context, db DB, v0 pgtypes.Refcursor, v1, v2 bool, v3 string) ([]byte, error) {
	// call pg_catalog.cursor_to_xmlschema
	const sqlstr = `SELECT pg_catalog.cursor_to_xmlschema($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// DatabaseToXML calls the stored procedure 'pg_catalog.database_to_xml(boolean, boolean, text) xml' on db.
func DatabaseToXML(ctx context.Context, db DB, v0, v1 bool, v2 string) ([]byte, error) {
	// call pg_catalog.database_to_xml
	const sqlstr = `SELECT pg_catalog.database_to_xml($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// DatabaseToXMLAndXmlschema calls the stored procedure 'pg_catalog.database_to_xml_and_xmlschema(boolean, boolean, text) xml' on db.
func DatabaseToXMLAndXmlschema(ctx context.Context, db DB, v0, v1 bool, v2 string) ([]byte, error) {
	// call pg_catalog.database_to_xml_and_xmlschema
	const sqlstr = `SELECT pg_catalog.database_to_xml_and_xmlschema($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// DatabaseToXmlschema calls the stored procedure 'pg_catalog.database_to_xmlschema(boolean, boolean, text) xml' on db.
func DatabaseToXmlschema(ctx context.Context, db DB, v0, v1 bool, v2 string) ([]byte, error) {
	// call pg_catalog.database_to_xmlschema
	const sqlstr = `SELECT pg_catalog.database_to_xmlschema($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Date calls the stored procedure 'pg_catalog.date(timestamp without time zone, timestamp with time zone) date' on db.
func Date(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.date
	const sqlstr = `SELECT pg_catalog.date($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// DateCmp calls the stored procedure 'pg_catalog.date_cmp(date, date) integer' on db.
func DateCmp(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.date_cmp
	const sqlstr = `SELECT pg_catalog.date_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// DateCmpTimestamp calls the stored procedure 'pg_catalog.date_cmp_timestamp(date, timestamp without time zone) integer' on db.
func DateCmpTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.date_cmp_timestamp
	const sqlstr = `SELECT pg_catalog.date_cmp_timestamp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// DateCmpTimestamptz calls the stored procedure 'pg_catalog.date_cmp_timestamptz(date, timestamp with time zone) integer' on db.
func DateCmpTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.date_cmp_timestamptz
	const sqlstr = `SELECT pg_catalog.date_cmp_timestamptz($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// DateEq calls the stored procedure 'pg_catalog.date_eq(date, date) boolean' on db.
func DateEq(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_eq
	const sqlstr = `SELECT pg_catalog.date_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateEqTimestamp calls the stored procedure 'pg_catalog.date_eq_timestamp(date, timestamp without time zone) boolean' on db.
func DateEqTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_eq_timestamp
	const sqlstr = `SELECT pg_catalog.date_eq_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateEqTimestamptz calls the stored procedure 'pg_catalog.date_eq_timestamptz(date, timestamp with time zone) boolean' on db.
func DateEqTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_eq_timestamptz
	const sqlstr = `SELECT pg_catalog.date_eq_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateGe calls the stored procedure 'pg_catalog.date_ge(date, date) boolean' on db.
func DateGe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_ge
	const sqlstr = `SELECT pg_catalog.date_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateGeTimestamp calls the stored procedure 'pg_catalog.date_ge_timestamp(date, timestamp without time zone) boolean' on db.
func DateGeTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_ge_timestamp
	const sqlstr = `SELECT pg_catalog.date_ge_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateGeTimestamptz calls the stored procedure 'pg_catalog.date_ge_timestamptz(date, timestamp with time zone) boolean' on db.
func DateGeTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_ge_timestamptz
	const sqlstr = `SELECT pg_catalog.date_ge_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateGt calls the stored procedure 'pg_catalog.date_gt(date, date) boolean' on db.
func DateGt(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_gt
	const sqlstr = `SELECT pg_catalog.date_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateGtTimestamp calls the stored procedure 'pg_catalog.date_gt_timestamp(date, timestamp without time zone) boolean' on db.
func DateGtTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_gt_timestamp
	const sqlstr = `SELECT pg_catalog.date_gt_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateGtTimestamptz calls the stored procedure 'pg_catalog.date_gt_timestamptz(date, timestamp with time zone) boolean' on db.
func DateGtTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_gt_timestamptz
	const sqlstr = `SELECT pg_catalog.date_gt_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateIn calls the stored procedure 'pg_catalog.date_in(cstring) date' on db.
func DateIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (time.Time, error) {
	// call pg_catalog.date_in
	const sqlstr = `SELECT pg_catalog.date_in($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// DateLarger calls the stored procedure 'pg_catalog.date_larger(date, date) date' on db.
func DateLarger(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.date_larger
	const sqlstr = `SELECT pg_catalog.date_larger($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// DateLe calls the stored procedure 'pg_catalog.date_le(date, date) boolean' on db.
func DateLe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_le
	const sqlstr = `SELECT pg_catalog.date_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateLeTimestamp calls the stored procedure 'pg_catalog.date_le_timestamp(date, timestamp without time zone) boolean' on db.
func DateLeTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_le_timestamp
	const sqlstr = `SELECT pg_catalog.date_le_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateLeTimestamptz calls the stored procedure 'pg_catalog.date_le_timestamptz(date, timestamp with time zone) boolean' on db.
func DateLeTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_le_timestamptz
	const sqlstr = `SELECT pg_catalog.date_le_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateLt calls the stored procedure 'pg_catalog.date_lt(date, date) boolean' on db.
func DateLt(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_lt
	const sqlstr = `SELECT pg_catalog.date_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateLtTimestamp calls the stored procedure 'pg_catalog.date_lt_timestamp(date, timestamp without time zone) boolean' on db.
func DateLtTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_lt_timestamp
	const sqlstr = `SELECT pg_catalog.date_lt_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateLtTimestamptz calls the stored procedure 'pg_catalog.date_lt_timestamptz(date, timestamp with time zone) boolean' on db.
func DateLtTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_lt_timestamptz
	const sqlstr = `SELECT pg_catalog.date_lt_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateMi calls the stored procedure 'pg_catalog.date_mi(date, date) integer' on db.
func DateMi(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.date_mi
	const sqlstr = `SELECT pg_catalog.date_mi($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// DateMiInterval calls the stored procedure 'pg_catalog.date_mi_interval(date, interval) timestamp without time zone' on db.
func DateMiInterval(ctx context.Context, db DB, v0 time.Time, v1 []byte) (time.Time, error) {
	// call pg_catalog.date_mi_interval
	const sqlstr = `SELECT pg_catalog.date_mi_interval($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// DateMii calls the stored procedure 'pg_catalog.date_mii(date, integer) date' on db.
func DateMii(ctx context.Context, db DB, v0 time.Time, v1 int) (time.Time, error) {
	// call pg_catalog.date_mii
	const sqlstr = `SELECT pg_catalog.date_mii($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// DateNe calls the stored procedure 'pg_catalog.date_ne(date, date) boolean' on db.
func DateNe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_ne
	const sqlstr = `SELECT pg_catalog.date_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateNeTimestamp calls the stored procedure 'pg_catalog.date_ne_timestamp(date, timestamp without time zone) boolean' on db.
func DateNeTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_ne_timestamp
	const sqlstr = `SELECT pg_catalog.date_ne_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateNeTimestamptz calls the stored procedure 'pg_catalog.date_ne_timestamptz(date, timestamp with time zone) boolean' on db.
func DateNeTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.date_ne_timestamptz
	const sqlstr = `SELECT pg_catalog.date_ne_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// DateOut calls the stored procedure 'pg_catalog.date_out(date) cstring' on db.
func DateOut(ctx context.Context, db DB, v0 time.Time) (pgtypes.Cstring, error) {
	// call pg_catalog.date_out
	const sqlstr = `SELECT pg_catalog.date_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// DatePart calls the stored procedure 'pg_catalog.date_part(text, date, text, time without time zone, text, timestamp without time zone, text, timestamp with time zone, text, interval, text, time with time zone) double precision' on db.
func DatePart(ctx context.Context, db DB, v0 string, v1 time.Time, v2 string, v3 time.Time, v4 string, v5 time.Time, v6 string, v7 time.Time, v8 string, v9 []byte, v10 string, v11 time.Time) (float64, error) {
	// call pg_catalog.date_part
	const sqlstr = `SELECT pg_catalog.date_part($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DatePlInterval calls the stored procedure 'pg_catalog.date_pl_interval(date, interval) timestamp without time zone' on db.
func DatePlInterval(ctx context.Context, db DB, v0 time.Time, v1 []byte) (time.Time, error) {
	// call pg_catalog.date_pl_interval
	const sqlstr = `SELECT pg_catalog.date_pl_interval($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// DatePli calls the stored procedure 'pg_catalog.date_pli(date, integer) date' on db.
func DatePli(ctx context.Context, db DB, v0 time.Time, v1 int) (time.Time, error) {
	// call pg_catalog.date_pli
	const sqlstr = `SELECT pg_catalog.date_pli($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// DateRecv calls the stored procedure 'pg_catalog.date_recv(internal) date' on db.
func DateRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (time.Time, error) {
	// call pg_catalog.date_recv
	const sqlstr = `SELECT pg_catalog.date_recv($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// DateSend calls the stored procedure 'pg_catalog.date_send(date) bytea' on db.
func DateSend(ctx context.Context, db DB, v0 time.Time) ([]byte, error) {
	// call pg_catalog.date_send
	const sqlstr = `SELECT pg_catalog.date_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// DateSmaller calls the stored procedure 'pg_catalog.date_smaller(date, date) date' on db.
func DateSmaller(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.date_smaller
	const sqlstr = `SELECT pg_catalog.date_smaller($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// DateSortsupport calls the stored procedure 'pg_catalog.date_sortsupport(internal) void' on db.
func DateSortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.date_sortsupport
	const sqlstr = `SELECT pg_catalog.date_sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// DateTrunc calls the stored procedure 'pg_catalog.date_trunc(text, timestamp without time zone, text, timestamp with time zone, text, interval, text, timestamp with time zone, text) timestamp without time zone' on db.
func DateTrunc(ctx context.Context, db DB, v0 string, v1 time.Time, v2 string, v3 time.Time, v4 string, v5 []byte, v6 string, v7 time.Time, v8 string) (time.Time, error) {
	// call pg_catalog.date_trunc
	const sqlstr = `SELECT pg_catalog.date_trunc($1, $2, $3, $4, $5, $6, $7, $8, $9)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// Daterange calls the stored procedure 'pg_catalog.daterange(date, date, date, date, text) daterange' on db.
func Daterange(ctx context.Context, db DB, v0, v1, v2, v3 time.Time, v4 string) (pgtypes.Daterange, error) {
	// call pg_catalog.daterange
	const sqlstr = `SELECT pg_catalog.daterange($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Daterange
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Daterange{}, logerror(err)
	}
	return ret, nil
}

// DaterangeCanonical calls the stored procedure 'pg_catalog.daterange_canonical(daterange) daterange' on db.
func DaterangeCanonical(ctx context.Context, db DB, v0 pgtypes.Daterange) (pgtypes.Daterange, error) {
	// call pg_catalog.daterange_canonical
	const sqlstr = `SELECT pg_catalog.daterange_canonical($1)`
	// run
	var ret pgtypes.Daterange
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Daterange{}, logerror(err)
	}
	return ret, nil
}

// DaterangeSubdiff calls the stored procedure 'pg_catalog.daterange_subdiff(date, date) double precision' on db.
func DaterangeSubdiff(ctx context.Context, db DB, v0, v1 time.Time) (float64, error) {
	// call pg_catalog.daterange_subdiff
	const sqlstr = `SELECT pg_catalog.daterange_subdiff($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DatetimePl calls the stored procedure 'pg_catalog.datetime_pl(date, time without time zone) timestamp without time zone' on db.
func DatetimePl(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.datetime_pl
	const sqlstr = `SELECT pg_catalog.datetime_pl($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// DatetimetzPl calls the stored procedure 'pg_catalog.datetimetz_pl(date, time with time zone) timestamp with time zone' on db.
func DatetimetzPl(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.datetimetz_pl
	const sqlstr = `SELECT pg_catalog.datetimetz_pl($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// Dcbrt calls the stored procedure 'pg_catalog.dcbrt(double precision) double precision' on db.
func Dcbrt(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.dcbrt
	const sqlstr = `SELECT pg_catalog.dcbrt($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Decode calls the stored procedure 'pg_catalog.decode(text, text) bytea' on db.
func Decode(ctx context.Context, db DB, v0, v1 string) ([]byte, error) {
	// call pg_catalog.decode
	const sqlstr = `SELECT pg_catalog.decode($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Degrees calls the stored procedure 'pg_catalog.degrees(double precision) double precision' on db.
func Degrees(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.degrees
	const sqlstr = `SELECT pg_catalog.degrees($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DenseRank calls the stored procedure 'pg_catalog.dense_rank("any") bigint' on db.
func DenseRank(ctx context.Context, db DB, v0 pgtypes.Any) (int64, error) {
	// call pg_catalog.dense_rank
	const sqlstr = `SELECT pg_catalog.dense_rank($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// DenseRankFinal calls the stored procedure 'pg_catalog.dense_rank_final(internal, "any") bigint' on db.
func DenseRankFinal(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Any) (int64, error) {
	// call pg_catalog.dense_rank_final
	const sqlstr = `SELECT pg_catalog.dense_rank_final($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Dexp calls the stored procedure 'pg_catalog.dexp(double precision) double precision' on db.
func Dexp(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.dexp
	const sqlstr = `SELECT pg_catalog.dexp($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Diagonal calls the stored procedure 'pg_catalog.diagonal(box) lseg' on db.
func Diagonal(ctx context.Context, db DB, v0 pgtypes.Box) (pgtypes.Lseg, error) {
	// call pg_catalog.diagonal
	const sqlstr = `SELECT pg_catalog.diagonal($1)`
	// run
	var ret pgtypes.Lseg
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Lseg{}, logerror(err)
	}
	return ret, nil
}

// Diameter calls the stored procedure 'pg_catalog.diameter(circle) double precision' on db.
func Diameter(ctx context.Context, db DB, v0 pgtypes.Circle) (float64, error) {
	// call pg_catalog.diameter
	const sqlstr = `SELECT pg_catalog.diameter($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DispellInit calls the stored procedure 'pg_catalog.dispell_init(internal) internal' on db.
func DispellInit(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dispell_init
	const sqlstr = `SELECT pg_catalog.dispell_init($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// DispellLexize calls the stored procedure 'pg_catalog.dispell_lexize(internal, internal, internal, internal) internal' on db.
func DispellLexize(ctx context.Context, db DB, v0, v1, v2, v3 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dispell_lexize
	const sqlstr = `SELECT pg_catalog.dispell_lexize($1, $2, $3, $4)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// DistBl calls the stored procedure 'pg_catalog.dist_bl(box, line) double precision' on db.
func DistBl(ctx context.Context, db DB, v0 pgtypes.Box, v1 pgtypes.Line) (float64, error) {
	// call pg_catalog.dist_bl
	const sqlstr = `SELECT pg_catalog.dist_bl($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistBp calls the stored procedure 'pg_catalog.dist_bp(box, point) double precision' on db.
func DistBp(ctx context.Context, db DB, v0 pgtypes.Box, v1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_bp
	const sqlstr = `SELECT pg_catalog.dist_bp($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistBs calls the stored procedure 'pg_catalog.dist_bs(box, lseg) double precision' on db.
func DistBs(ctx context.Context, db DB, v0 pgtypes.Box, v1 pgtypes.Lseg) (float64, error) {
	// call pg_catalog.dist_bs
	const sqlstr = `SELECT pg_catalog.dist_bs($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistCpoint calls the stored procedure 'pg_catalog.dist_cpoint(circle, point) double precision' on db.
func DistCpoint(ctx context.Context, db DB, v0 pgtypes.Circle, v1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_cpoint
	const sqlstr = `SELECT pg_catalog.dist_cpoint($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistCpoly calls the stored procedure 'pg_catalog.dist_cpoly(circle, polygon) double precision' on db.
func DistCpoly(ctx context.Context, db DB, v0 pgtypes.Circle, v1 pgtypes.Polygon) (float64, error) {
	// call pg_catalog.dist_cpoly
	const sqlstr = `SELECT pg_catalog.dist_cpoly($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistLb calls the stored procedure 'pg_catalog.dist_lb(line, box) double precision' on db.
func DistLb(ctx context.Context, db DB, v0 pgtypes.Line, v1 pgtypes.Box) (float64, error) {
	// call pg_catalog.dist_lb
	const sqlstr = `SELECT pg_catalog.dist_lb($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistLp calls the stored procedure 'pg_catalog.dist_lp(line, point) double precision' on db.
func DistLp(ctx context.Context, db DB, v0 pgtypes.Line, v1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_lp
	const sqlstr = `SELECT pg_catalog.dist_lp($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistLs calls the stored procedure 'pg_catalog.dist_ls(line, lseg) double precision' on db.
func DistLs(ctx context.Context, db DB, v0 pgtypes.Line, v1 pgtypes.Lseg) (float64, error) {
	// call pg_catalog.dist_ls
	const sqlstr = `SELECT pg_catalog.dist_ls($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistPathp calls the stored procedure 'pg_catalog.dist_pathp(path, point) double precision' on db.
func DistPathp(ctx context.Context, db DB, v0 pgtypes.Path, v1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_pathp
	const sqlstr = `SELECT pg_catalog.dist_pathp($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistPb calls the stored procedure 'pg_catalog.dist_pb(point, box) double precision' on db.
func DistPb(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Box) (float64, error) {
	// call pg_catalog.dist_pb
	const sqlstr = `SELECT pg_catalog.dist_pb($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistPc calls the stored procedure 'pg_catalog.dist_pc(point, circle) double precision' on db.
func DistPc(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Circle) (float64, error) {
	// call pg_catalog.dist_pc
	const sqlstr = `SELECT pg_catalog.dist_pc($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistPl calls the stored procedure 'pg_catalog.dist_pl(point, line) double precision' on db.
func DistPl(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Line) (float64, error) {
	// call pg_catalog.dist_pl
	const sqlstr = `SELECT pg_catalog.dist_pl($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistPolyc calls the stored procedure 'pg_catalog.dist_polyc(polygon, circle) double precision' on db.
func DistPolyc(ctx context.Context, db DB, v0 pgtypes.Polygon, v1 pgtypes.Circle) (float64, error) {
	// call pg_catalog.dist_polyc
	const sqlstr = `SELECT pg_catalog.dist_polyc($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistPolyp calls the stored procedure 'pg_catalog.dist_polyp(polygon, point) double precision' on db.
func DistPolyp(ctx context.Context, db DB, v0 pgtypes.Polygon, v1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_polyp
	const sqlstr = `SELECT pg_catalog.dist_polyp($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistPpath calls the stored procedure 'pg_catalog.dist_ppath(point, path) double precision' on db.
func DistPpath(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Path) (float64, error) {
	// call pg_catalog.dist_ppath
	const sqlstr = `SELECT pg_catalog.dist_ppath($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistPpoly calls the stored procedure 'pg_catalog.dist_ppoly(point, polygon) double precision' on db.
func DistPpoly(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Polygon) (float64, error) {
	// call pg_catalog.dist_ppoly
	const sqlstr = `SELECT pg_catalog.dist_ppoly($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistPs calls the stored procedure 'pg_catalog.dist_ps(point, lseg) double precision' on db.
func DistPs(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Lseg) (float64, error) {
	// call pg_catalog.dist_ps
	const sqlstr = `SELECT pg_catalog.dist_ps($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistSb calls the stored procedure 'pg_catalog.dist_sb(lseg, box) double precision' on db.
func DistSb(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Box) (float64, error) {
	// call pg_catalog.dist_sb
	const sqlstr = `SELECT pg_catalog.dist_sb($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistSl calls the stored procedure 'pg_catalog.dist_sl(lseg, line) double precision' on db.
func DistSl(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Line) (float64, error) {
	// call pg_catalog.dist_sl
	const sqlstr = `SELECT pg_catalog.dist_sl($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DistSp calls the stored procedure 'pg_catalog.dist_sp(lseg, point) double precision' on db.
func DistSp(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_sp
	const sqlstr = `SELECT pg_catalog.dist_sp($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Div calls the stored procedure 'pg_catalog.div(numeric, numeric) numeric' on db.
func Div(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.div
	const sqlstr = `SELECT pg_catalog.div($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Dlog1 calls the stored procedure 'pg_catalog.dlog1(double precision) double precision' on db.
func Dlog1(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.dlog1
	const sqlstr = `SELECT pg_catalog.dlog1($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Dlog10 calls the stored procedure 'pg_catalog.dlog10(double precision) double precision' on db.
func Dlog10(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.dlog10
	const sqlstr = `SELECT pg_catalog.dlog10($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DomainIn calls the stored procedure 'pg_catalog.domain_in(cstring, oid, integer) "any"' on db.
func DomainIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (pgtypes.Any, error) {
	// call pg_catalog.domain_in
	const sqlstr = `SELECT pg_catalog.domain_in($1, $2, $3)`
	// run
	var ret pgtypes.Any
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Any{}, logerror(err)
	}
	return ret, nil
}

// DomainRecv calls the stored procedure 'pg_catalog.domain_recv(internal, oid, integer) "any"' on db.
func DomainRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (pgtypes.Any, error) {
	// call pg_catalog.domain_recv
	const sqlstr = `SELECT pg_catalog.domain_recv($1, $2, $3)`
	// run
	var ret pgtypes.Any
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Any{}, logerror(err)
	}
	return ret, nil
}

// Dpow calls the stored procedure 'pg_catalog.dpow(double precision, double precision) double precision' on db.
func Dpow(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.dpow
	const sqlstr = `SELECT pg_catalog.dpow($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Dround calls the stored procedure 'pg_catalog.dround(double precision) double precision' on db.
func Dround(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.dround
	const sqlstr = `SELECT pg_catalog.dround($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DsimpleInit calls the stored procedure 'pg_catalog.dsimple_init(internal) internal' on db.
func DsimpleInit(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsimple_init
	const sqlstr = `SELECT pg_catalog.dsimple_init($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// DsimpleLexize calls the stored procedure 'pg_catalog.dsimple_lexize(internal, internal, internal, internal) internal' on db.
func DsimpleLexize(ctx context.Context, db DB, v0, v1, v2, v3 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsimple_lexize
	const sqlstr = `SELECT pg_catalog.dsimple_lexize($1, $2, $3, $4)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// DsnowballInit calls the stored procedure 'pg_catalog.dsnowball_init(internal) internal' on db.
func DsnowballInit(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsnowball_init
	const sqlstr = `SELECT pg_catalog.dsnowball_init($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// DsnowballLexize calls the stored procedure 'pg_catalog.dsnowball_lexize(internal, internal, internal, internal) internal' on db.
func DsnowballLexize(ctx context.Context, db DB, v0, v1, v2, v3 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsnowball_lexize
	const sqlstr = `SELECT pg_catalog.dsnowball_lexize($1, $2, $3, $4)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Dsqrt calls the stored procedure 'pg_catalog.dsqrt(double precision) double precision' on db.
func Dsqrt(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.dsqrt
	const sqlstr = `SELECT pg_catalog.dsqrt($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// DsynonymInit calls the stored procedure 'pg_catalog.dsynonym_init(internal) internal' on db.
func DsynonymInit(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsynonym_init
	const sqlstr = `SELECT pg_catalog.dsynonym_init($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// DsynonymLexize calls the stored procedure 'pg_catalog.dsynonym_lexize(internal, internal, internal, internal) internal' on db.
func DsynonymLexize(ctx context.Context, db DB, v0, v1, v2, v3 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsynonym_lexize
	const sqlstr = `SELECT pg_catalog.dsynonym_lexize($1, $2, $3, $4)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Dtrunc calls the stored procedure 'pg_catalog.dtrunc(double precision) double precision' on db.
func Dtrunc(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.dtrunc
	const sqlstr = `SELECT pg_catalog.dtrunc($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// ElemContainedByRange calls the stored procedure 'pg_catalog.elem_contained_by_range(anyelement, anyrange) boolean' on db.
func ElemContainedByRange(ctx context.Context, db DB, v0 pgtypes.Anyelement, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.elem_contained_by_range
	const sqlstr = `SELECT pg_catalog.elem_contained_by_range($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Encode calls the stored procedure 'pg_catalog.encode(bytea, text) text' on db.
func Encode(ctx context.Context, db DB, v0 []byte, v1 string) (string, error) {
	// call pg_catalog.encode
	const sqlstr = `SELECT pg_catalog.encode($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// EnumCmp calls the stored procedure 'pg_catalog.enum_cmp(anyenum, anyenum) integer' on db.
func EnumCmp(ctx context.Context, db DB, v0, v1 pgtypes.Anyenum) (int, error) {
	// call pg_catalog.enum_cmp
	const sqlstr = `SELECT pg_catalog.enum_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// EnumEq calls the stored procedure 'pg_catalog.enum_eq(anyenum, anyenum) boolean' on db.
func EnumEq(ctx context.Context, db DB, v0, v1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_eq
	const sqlstr = `SELECT pg_catalog.enum_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// EnumFirst calls the stored procedure 'pg_catalog.enum_first(anyenum) anyenum' on db.
func EnumFirst(ctx context.Context, db DB, v0 pgtypes.Anyenum) (pgtypes.Anyenum, error) {
	// call pg_catalog.enum_first
	const sqlstr = `SELECT pg_catalog.enum_first($1)`
	// run
	var ret pgtypes.Anyenum
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return ret, nil
}

// EnumGe calls the stored procedure 'pg_catalog.enum_ge(anyenum, anyenum) boolean' on db.
func EnumGe(ctx context.Context, db DB, v0, v1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_ge
	const sqlstr = `SELECT pg_catalog.enum_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// EnumGt calls the stored procedure 'pg_catalog.enum_gt(anyenum, anyenum) boolean' on db.
func EnumGt(ctx context.Context, db DB, v0, v1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_gt
	const sqlstr = `SELECT pg_catalog.enum_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// EnumIn calls the stored procedure 'pg_catalog.enum_in(cstring, oid) anyenum' on db.
func EnumIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid) (pgtypes.Anyenum, error) {
	// call pg_catalog.enum_in
	const sqlstr = `SELECT pg_catalog.enum_in($1, $2)`
	// run
	var ret pgtypes.Anyenum
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return ret, nil
}

// EnumLarger calls the stored procedure 'pg_catalog.enum_larger(anyenum, anyenum) anyenum' on db.
func EnumLarger(ctx context.Context, db DB, v0, v1 pgtypes.Anyenum) (pgtypes.Anyenum, error) {
	// call pg_catalog.enum_larger
	const sqlstr = `SELECT pg_catalog.enum_larger($1, $2)`
	// run
	var ret pgtypes.Anyenum
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return ret, nil
}

// EnumLast calls the stored procedure 'pg_catalog.enum_last(anyenum) anyenum' on db.
func EnumLast(ctx context.Context, db DB, v0 pgtypes.Anyenum) (pgtypes.Anyenum, error) {
	// call pg_catalog.enum_last
	const sqlstr = `SELECT pg_catalog.enum_last($1)`
	// run
	var ret pgtypes.Anyenum
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return ret, nil
}

// EnumLe calls the stored procedure 'pg_catalog.enum_le(anyenum, anyenum) boolean' on db.
func EnumLe(ctx context.Context, db DB, v0, v1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_le
	const sqlstr = `SELECT pg_catalog.enum_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// EnumLt calls the stored procedure 'pg_catalog.enum_lt(anyenum, anyenum) boolean' on db.
func EnumLt(ctx context.Context, db DB, v0, v1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_lt
	const sqlstr = `SELECT pg_catalog.enum_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// EnumNe calls the stored procedure 'pg_catalog.enum_ne(anyenum, anyenum) boolean' on db.
func EnumNe(ctx context.Context, db DB, v0, v1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_ne
	const sqlstr = `SELECT pg_catalog.enum_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// EnumOut calls the stored procedure 'pg_catalog.enum_out(anyenum) cstring' on db.
func EnumOut(ctx context.Context, db DB, v0 pgtypes.Anyenum) (pgtypes.Cstring, error) {
	// call pg_catalog.enum_out
	const sqlstr = `SELECT pg_catalog.enum_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// EnumRange calls the stored procedure 'pg_catalog.enum_range(anyenum, anyenum, anyenum) anyarray' on db.
func EnumRange(ctx context.Context, db DB, v0, v1, v2 pgtypes.Anyenum) (pgtypes.Anyarray, error) {
	// call pg_catalog.enum_range
	const sqlstr = `SELECT pg_catalog.enum_range($1, $2, $3)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// EnumRecv calls the stored procedure 'pg_catalog.enum_recv(internal, oid) anyenum' on db.
func EnumRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid) (pgtypes.Anyenum, error) {
	// call pg_catalog.enum_recv
	const sqlstr = `SELECT pg_catalog.enum_recv($1, $2)`
	// run
	var ret pgtypes.Anyenum
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return ret, nil
}

// EnumSend calls the stored procedure 'pg_catalog.enum_send(anyenum) bytea' on db.
func EnumSend(ctx context.Context, db DB, v0 pgtypes.Anyenum) ([]byte, error) {
	// call pg_catalog.enum_send
	const sqlstr = `SELECT pg_catalog.enum_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// EnumSmaller calls the stored procedure 'pg_catalog.enum_smaller(anyenum, anyenum) anyenum' on db.
func EnumSmaller(ctx context.Context, db DB, v0, v1 pgtypes.Anyenum) (pgtypes.Anyenum, error) {
	// call pg_catalog.enum_smaller
	const sqlstr = `SELECT pg_catalog.enum_smaller($1, $2)`
	// run
	var ret pgtypes.Anyenum
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return ret, nil
}

// Eqjoinsel calls the stored procedure 'pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Eqjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.eqjoinsel
	const sqlstr = `SELECT pg_catalog.eqjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Eqsel calls the stored procedure 'pg_catalog.eqsel(internal, oid, internal, integer) double precision' on db.
func Eqsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.eqsel
	const sqlstr = `SELECT pg_catalog.eqsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// EucCnToMic calls the stored procedure 'pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer) void' on db.
func EucCnToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_cn_to_mic
	const sqlstr = `SELECT pg_catalog.euc_cn_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EucCnToUTF8 calls the stored procedure 'pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func EucCnToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_cn_to_utf8
	const sqlstr = `SELECT pg_catalog.euc_cn_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EucJis2004ToShiftJis2004 calls the stored procedure 'pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer) void' on db.
func EucJis2004ToShiftJis2004(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_jis_2004_to_shift_jis_2004
	const sqlstr = `SELECT pg_catalog.euc_jis_2004_to_shift_jis_2004($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EucJis2004ToUTF8 calls the stored procedure 'pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func EucJis2004ToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_jis_2004_to_utf8
	const sqlstr = `SELECT pg_catalog.euc_jis_2004_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EucJpToMic calls the stored procedure 'pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer) void' on db.
func EucJpToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_jp_to_mic
	const sqlstr = `SELECT pg_catalog.euc_jp_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EucJpToSjis calls the stored procedure 'pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer) void' on db.
func EucJpToSjis(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_jp_to_sjis
	const sqlstr = `SELECT pg_catalog.euc_jp_to_sjis($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EucJpToUTF8 calls the stored procedure 'pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func EucJpToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_jp_to_utf8
	const sqlstr = `SELECT pg_catalog.euc_jp_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EucKrToMic calls the stored procedure 'pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer) void' on db.
func EucKrToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_kr_to_mic
	const sqlstr = `SELECT pg_catalog.euc_kr_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EucKrToUTF8 calls the stored procedure 'pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func EucKrToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_kr_to_utf8
	const sqlstr = `SELECT pg_catalog.euc_kr_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EucTwToBig5 calls the stored procedure 'pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer) void' on db.
func EucTwToBig5(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_tw_to_big5
	const sqlstr = `SELECT pg_catalog.euc_tw_to_big5($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EucTwToMic calls the stored procedure 'pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer) void' on db.
func EucTwToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_tw_to_mic
	const sqlstr = `SELECT pg_catalog.euc_tw_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EucTwToUTF8 calls the stored procedure 'pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func EucTwToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.euc_tw_to_utf8
	const sqlstr = `SELECT pg_catalog.euc_tw_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// EventTriggerIn calls the stored procedure 'pg_catalog.event_trigger_in(cstring) event_trigger' on db.
func EventTriggerIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.EventTrigger, error) {
	// call pg_catalog.event_trigger_in
	const sqlstr = `SELECT pg_catalog.event_trigger_in($1)`
	// run
	var ret pgtypes.EventTrigger
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.EventTrigger{}, logerror(err)
	}
	return ret, nil
}

// EventTriggerOut calls the stored procedure 'pg_catalog.event_trigger_out(event_trigger) cstring' on db.
func EventTriggerOut(ctx context.Context, db DB, v0 pgtypes.EventTrigger) (pgtypes.Cstring, error) {
	// call pg_catalog.event_trigger_out
	const sqlstr = `SELECT pg_catalog.event_trigger_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Every calls the stored procedure 'pg_catalog.every(boolean) boolean' on db.
func Every(ctx context.Context, db DB, v0 bool) (bool, error) {
	// call pg_catalog.every
	const sqlstr = `SELECT pg_catalog.every($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Exp calls the stored procedure 'pg_catalog.exp(double precision, numeric) numeric' on db.
func Exp(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.exp
	const sqlstr = `SELECT pg_catalog.exp($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Factorial calls the stored procedure 'pg_catalog.factorial(bigint) numeric' on db.
func Factorial(ctx context.Context, db DB, v0 int64) (float64, error) {
	// call pg_catalog.factorial
	const sqlstr = `SELECT pg_catalog.factorial($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Family calls the stored procedure 'pg_catalog.family(inet) integer' on db.
func Family(ctx context.Context, db DB, v0 string) (int, error) {
	// call pg_catalog.family
	const sqlstr = `SELECT pg_catalog.family($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// FdwHandlerIn calls the stored procedure 'pg_catalog.fdw_handler_in(cstring) fdw_handler' on db.
func FdwHandlerIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.FdwHandler, error) {
	// call pg_catalog.fdw_handler_in
	const sqlstr = `SELECT pg_catalog.fdw_handler_in($1)`
	// run
	var ret pgtypes.FdwHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.FdwHandler{}, logerror(err)
	}
	return ret, nil
}

// FdwHandlerOut calls the stored procedure 'pg_catalog.fdw_handler_out(fdw_handler) cstring' on db.
func FdwHandlerOut(ctx context.Context, db DB, v0 pgtypes.FdwHandler) (pgtypes.Cstring, error) {
	// call pg_catalog.fdw_handler_out
	const sqlstr = `SELECT pg_catalog.fdw_handler_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// FirstValue calls the stored procedure 'pg_catalog.first_value(anyelement) anyelement' on db.
func FirstValue(ctx context.Context, db DB, v0 pgtypes.Anyelement) (pgtypes.Anyelement, error) {
	// call pg_catalog.first_value
	const sqlstr = `SELECT pg_catalog.first_value($1)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// Float4 calls the stored procedure 'pg_catalog.float4(bigint, smallint, integer, double precision, numeric, jsonb) real' on db.
func Float4(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3, v4 float64, v5 []byte) (float32, error) {
	// call pg_catalog.float4
	const sqlstr = `SELECT pg_catalog.float4($1, $2, $3, $4, $5, $6)`
	// run
	var ret float32
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float48div calls the stored procedure 'pg_catalog.float48div(real, double precision) double precision' on db.
func Float48div(ctx context.Context, db DB, v0 float32, v1 float64) (float64, error) {
	// call pg_catalog.float48div
	const sqlstr = `SELECT pg_catalog.float48div($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float48eq calls the stored procedure 'pg_catalog.float48eq(real, double precision) boolean' on db.
func Float48eq(ctx context.Context, db DB, v0 float32, v1 float64) (bool, error) {
	// call pg_catalog.float48eq
	const sqlstr = `SELECT pg_catalog.float48eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float48ge calls the stored procedure 'pg_catalog.float48ge(real, double precision) boolean' on db.
func Float48ge(ctx context.Context, db DB, v0 float32, v1 float64) (bool, error) {
	// call pg_catalog.float48ge
	const sqlstr = `SELECT pg_catalog.float48ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float48gt calls the stored procedure 'pg_catalog.float48gt(real, double precision) boolean' on db.
func Float48gt(ctx context.Context, db DB, v0 float32, v1 float64) (bool, error) {
	// call pg_catalog.float48gt
	const sqlstr = `SELECT pg_catalog.float48gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float48le calls the stored procedure 'pg_catalog.float48le(real, double precision) boolean' on db.
func Float48le(ctx context.Context, db DB, v0 float32, v1 float64) (bool, error) {
	// call pg_catalog.float48le
	const sqlstr = `SELECT pg_catalog.float48le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float48lt calls the stored procedure 'pg_catalog.float48lt(real, double precision) boolean' on db.
func Float48lt(ctx context.Context, db DB, v0 float32, v1 float64) (bool, error) {
	// call pg_catalog.float48lt
	const sqlstr = `SELECT pg_catalog.float48lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float48mi calls the stored procedure 'pg_catalog.float48mi(real, double precision) double precision' on db.
func Float48mi(ctx context.Context, db DB, v0 float32, v1 float64) (float64, error) {
	// call pg_catalog.float48mi
	const sqlstr = `SELECT pg_catalog.float48mi($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float48mul calls the stored procedure 'pg_catalog.float48mul(real, double precision) double precision' on db.
func Float48mul(ctx context.Context, db DB, v0 float32, v1 float64) (float64, error) {
	// call pg_catalog.float48mul
	const sqlstr = `SELECT pg_catalog.float48mul($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float48ne calls the stored procedure 'pg_catalog.float48ne(real, double precision) boolean' on db.
func Float48ne(ctx context.Context, db DB, v0 float32, v1 float64) (bool, error) {
	// call pg_catalog.float48ne
	const sqlstr = `SELECT pg_catalog.float48ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float48pl calls the stored procedure 'pg_catalog.float48pl(real, double precision) double precision' on db.
func Float48pl(ctx context.Context, db DB, v0 float32, v1 float64) (float64, error) {
	// call pg_catalog.float48pl
	const sqlstr = `SELECT pg_catalog.float48pl($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float4Accum calls the stored procedure 'pg_catalog.float4_accum(double precision[], real) double precision[]' on db.
func Float4Accum(ctx context.Context, db DB, v0 []float64, v1 float32) ([]float64, error) {
	// call pg_catalog.float4_accum
	const sqlstr = `SELECT pg_catalog.float4_accum($1, $2)`
	// run
	var ret []float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Float4abs calls the stored procedure 'pg_catalog.float4abs(real) real' on db.
func Float4abs(ctx context.Context, db DB, v0 float32) (float32, error) {
	// call pg_catalog.float4abs
	const sqlstr = `SELECT pg_catalog.float4abs($1)`
	// run
	var ret float32
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float4div calls the stored procedure 'pg_catalog.float4div(real, real) real' on db.
func Float4div(ctx context.Context, db DB, v0, v1 float32) (float32, error) {
	// call pg_catalog.float4div
	const sqlstr = `SELECT pg_catalog.float4div($1, $2)`
	// run
	var ret float32
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float4eq calls the stored procedure 'pg_catalog.float4eq(real, real) boolean' on db.
func Float4eq(ctx context.Context, db DB, v0, v1 float32) (bool, error) {
	// call pg_catalog.float4eq
	const sqlstr = `SELECT pg_catalog.float4eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float4ge calls the stored procedure 'pg_catalog.float4ge(real, real) boolean' on db.
func Float4ge(ctx context.Context, db DB, v0, v1 float32) (bool, error) {
	// call pg_catalog.float4ge
	const sqlstr = `SELECT pg_catalog.float4ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float4gt calls the stored procedure 'pg_catalog.float4gt(real, real) boolean' on db.
func Float4gt(ctx context.Context, db DB, v0, v1 float32) (bool, error) {
	// call pg_catalog.float4gt
	const sqlstr = `SELECT pg_catalog.float4gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float4in calls the stored procedure 'pg_catalog.float4in(cstring) real' on db.
func Float4in(ctx context.Context, db DB, v0 pgtypes.Cstring) (float32, error) {
	// call pg_catalog.float4in
	const sqlstr = `SELECT pg_catalog.float4in($1)`
	// run
	var ret float32
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float4larger calls the stored procedure 'pg_catalog.float4larger(real, real) real' on db.
func Float4larger(ctx context.Context, db DB, v0, v1 float32) (float32, error) {
	// call pg_catalog.float4larger
	const sqlstr = `SELECT pg_catalog.float4larger($1, $2)`
	// run
	var ret float32
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float4le calls the stored procedure 'pg_catalog.float4le(real, real) boolean' on db.
func Float4le(ctx context.Context, db DB, v0, v1 float32) (bool, error) {
	// call pg_catalog.float4le
	const sqlstr = `SELECT pg_catalog.float4le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float4lt calls the stored procedure 'pg_catalog.float4lt(real, real) boolean' on db.
func Float4lt(ctx context.Context, db DB, v0, v1 float32) (bool, error) {
	// call pg_catalog.float4lt
	const sqlstr = `SELECT pg_catalog.float4lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float4mi calls the stored procedure 'pg_catalog.float4mi(real, real) real' on db.
func Float4mi(ctx context.Context, db DB, v0, v1 float32) (float32, error) {
	// call pg_catalog.float4mi
	const sqlstr = `SELECT pg_catalog.float4mi($1, $2)`
	// run
	var ret float32
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float4mul calls the stored procedure 'pg_catalog.float4mul(real, real) real' on db.
func Float4mul(ctx context.Context, db DB, v0, v1 float32) (float32, error) {
	// call pg_catalog.float4mul
	const sqlstr = `SELECT pg_catalog.float4mul($1, $2)`
	// run
	var ret float32
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float4ne calls the stored procedure 'pg_catalog.float4ne(real, real) boolean' on db.
func Float4ne(ctx context.Context, db DB, v0, v1 float32) (bool, error) {
	// call pg_catalog.float4ne
	const sqlstr = `SELECT pg_catalog.float4ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float4out calls the stored procedure 'pg_catalog.float4out(real) cstring' on db.
func Float4out(ctx context.Context, db DB, v0 float32) (pgtypes.Cstring, error) {
	// call pg_catalog.float4out
	const sqlstr = `SELECT pg_catalog.float4out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Float4pl calls the stored procedure 'pg_catalog.float4pl(real, real) real' on db.
func Float4pl(ctx context.Context, db DB, v0, v1 float32) (float32, error) {
	// call pg_catalog.float4pl
	const sqlstr = `SELECT pg_catalog.float4pl($1, $2)`
	// run
	var ret float32
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float4recv calls the stored procedure 'pg_catalog.float4recv(internal) real' on db.
func Float4recv(ctx context.Context, db DB, v0 pgtypes.Internal) (float32, error) {
	// call pg_catalog.float4recv
	const sqlstr = `SELECT pg_catalog.float4recv($1)`
	// run
	var ret float32
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float4send calls the stored procedure 'pg_catalog.float4send(real) bytea' on db.
func Float4send(ctx context.Context, db DB, v0 float32) ([]byte, error) {
	// call pg_catalog.float4send
	const sqlstr = `SELECT pg_catalog.float4send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Float4smaller calls the stored procedure 'pg_catalog.float4smaller(real, real) real' on db.
func Float4smaller(ctx context.Context, db DB, v0, v1 float32) (float32, error) {
	// call pg_catalog.float4smaller
	const sqlstr = `SELECT pg_catalog.float4smaller($1, $2)`
	// run
	var ret float32
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float4um calls the stored procedure 'pg_catalog.float4um(real) real' on db.
func Float4um(ctx context.Context, db DB, v0 float32) (float32, error) {
	// call pg_catalog.float4um
	const sqlstr = `SELECT pg_catalog.float4um($1)`
	// run
	var ret float32
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float4up calls the stored procedure 'pg_catalog.float4up(real) real' on db.
func Float4up(ctx context.Context, db DB, v0 float32) (float32, error) {
	// call pg_catalog.float4up
	const sqlstr = `SELECT pg_catalog.float4up($1)`
	// run
	var ret float32
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8 calls the stored procedure 'pg_catalog.float8(bigint, smallint, integer, real, numeric, jsonb) double precision' on db.
func Float8(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 float32, v4 float64, v5 []byte) (float64, error) {
	// call pg_catalog.float8
	const sqlstr = `SELECT pg_catalog.float8($1, $2, $3, $4, $5, $6)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float84div calls the stored procedure 'pg_catalog.float84div(double precision, real) double precision' on db.
func Float84div(ctx context.Context, db DB, v0 float64, v1 float32) (float64, error) {
	// call pg_catalog.float84div
	const sqlstr = `SELECT pg_catalog.float84div($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float84eq calls the stored procedure 'pg_catalog.float84eq(double precision, real) boolean' on db.
func Float84eq(ctx context.Context, db DB, v0 float64, v1 float32) (bool, error) {
	// call pg_catalog.float84eq
	const sqlstr = `SELECT pg_catalog.float84eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float84ge calls the stored procedure 'pg_catalog.float84ge(double precision, real) boolean' on db.
func Float84ge(ctx context.Context, db DB, v0 float64, v1 float32) (bool, error) {
	// call pg_catalog.float84ge
	const sqlstr = `SELECT pg_catalog.float84ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float84gt calls the stored procedure 'pg_catalog.float84gt(double precision, real) boolean' on db.
func Float84gt(ctx context.Context, db DB, v0 float64, v1 float32) (bool, error) {
	// call pg_catalog.float84gt
	const sqlstr = `SELECT pg_catalog.float84gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float84le calls the stored procedure 'pg_catalog.float84le(double precision, real) boolean' on db.
func Float84le(ctx context.Context, db DB, v0 float64, v1 float32) (bool, error) {
	// call pg_catalog.float84le
	const sqlstr = `SELECT pg_catalog.float84le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float84lt calls the stored procedure 'pg_catalog.float84lt(double precision, real) boolean' on db.
func Float84lt(ctx context.Context, db DB, v0 float64, v1 float32) (bool, error) {
	// call pg_catalog.float84lt
	const sqlstr = `SELECT pg_catalog.float84lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float84mi calls the stored procedure 'pg_catalog.float84mi(double precision, real) double precision' on db.
func Float84mi(ctx context.Context, db DB, v0 float64, v1 float32) (float64, error) {
	// call pg_catalog.float84mi
	const sqlstr = `SELECT pg_catalog.float84mi($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float84mul calls the stored procedure 'pg_catalog.float84mul(double precision, real) double precision' on db.
func Float84mul(ctx context.Context, db DB, v0 float64, v1 float32) (float64, error) {
	// call pg_catalog.float84mul
	const sqlstr = `SELECT pg_catalog.float84mul($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float84ne calls the stored procedure 'pg_catalog.float84ne(double precision, real) boolean' on db.
func Float84ne(ctx context.Context, db DB, v0 float64, v1 float32) (bool, error) {
	// call pg_catalog.float84ne
	const sqlstr = `SELECT pg_catalog.float84ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float84pl calls the stored procedure 'pg_catalog.float84pl(double precision, real) double precision' on db.
func Float84pl(ctx context.Context, db DB, v0 float64, v1 float32) (float64, error) {
	// call pg_catalog.float84pl
	const sqlstr = `SELECT pg_catalog.float84pl($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8Accum calls the stored procedure 'pg_catalog.float8_accum(double precision[], double precision) double precision[]' on db.
func Float8Accum(ctx context.Context, db DB, v0 []float64, v1 float64) ([]float64, error) {
	// call pg_catalog.float8_accum
	const sqlstr = `SELECT pg_catalog.float8_accum($1, $2)`
	// run
	var ret []float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Float8Avg calls the stored procedure 'pg_catalog.float8_avg(double precision[]) double precision' on db.
func Float8Avg(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_avg
	const sqlstr = `SELECT pg_catalog.float8_avg($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8Combine calls the stored procedure 'pg_catalog.float8_combine(double precision[], double precision[]) double precision[]' on db.
func Float8Combine(ctx context.Context, db DB, v0, v1 []float64) ([]float64, error) {
	// call pg_catalog.float8_combine
	const sqlstr = `SELECT pg_catalog.float8_combine($1, $2)`
	// run
	var ret []float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Float8Corr calls the stored procedure 'pg_catalog.float8_corr(double precision[]) double precision' on db.
func Float8Corr(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_corr
	const sqlstr = `SELECT pg_catalog.float8_corr($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8CovarPop calls the stored procedure 'pg_catalog.float8_covar_pop(double precision[]) double precision' on db.
func Float8CovarPop(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_covar_pop
	const sqlstr = `SELECT pg_catalog.float8_covar_pop($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8CovarSamp calls the stored procedure 'pg_catalog.float8_covar_samp(double precision[]) double precision' on db.
func Float8CovarSamp(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_covar_samp
	const sqlstr = `SELECT pg_catalog.float8_covar_samp($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8RegrAccum calls the stored procedure 'pg_catalog.float8_regr_accum(double precision[], double precision, double precision) double precision[]' on db.
func Float8RegrAccum(ctx context.Context, db DB, v0 []float64, v1, v2 float64) ([]float64, error) {
	// call pg_catalog.float8_regr_accum
	const sqlstr = `SELECT pg_catalog.float8_regr_accum($1, $2, $3)`
	// run
	var ret []float64
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Float8RegrAvgx calls the stored procedure 'pg_catalog.float8_regr_avgx(double precision[]) double precision' on db.
func Float8RegrAvgx(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_avgx
	const sqlstr = `SELECT pg_catalog.float8_regr_avgx($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8RegrAvgy calls the stored procedure 'pg_catalog.float8_regr_avgy(double precision[]) double precision' on db.
func Float8RegrAvgy(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_avgy
	const sqlstr = `SELECT pg_catalog.float8_regr_avgy($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8RegrCombine calls the stored procedure 'pg_catalog.float8_regr_combine(double precision[], double precision[]) double precision[]' on db.
func Float8RegrCombine(ctx context.Context, db DB, v0, v1 []float64) ([]float64, error) {
	// call pg_catalog.float8_regr_combine
	const sqlstr = `SELECT pg_catalog.float8_regr_combine($1, $2)`
	// run
	var ret []float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Float8RegrIntercept calls the stored procedure 'pg_catalog.float8_regr_intercept(double precision[]) double precision' on db.
func Float8RegrIntercept(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_intercept
	const sqlstr = `SELECT pg_catalog.float8_regr_intercept($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8RegrR2 calls the stored procedure 'pg_catalog.float8_regr_r2(double precision[]) double precision' on db.
func Float8RegrR2(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_r2
	const sqlstr = `SELECT pg_catalog.float8_regr_r2($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8RegrSlope calls the stored procedure 'pg_catalog.float8_regr_slope(double precision[]) double precision' on db.
func Float8RegrSlope(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_slope
	const sqlstr = `SELECT pg_catalog.float8_regr_slope($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8RegrSxx calls the stored procedure 'pg_catalog.float8_regr_sxx(double precision[]) double precision' on db.
func Float8RegrSxx(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_sxx
	const sqlstr = `SELECT pg_catalog.float8_regr_sxx($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8RegrSxy calls the stored procedure 'pg_catalog.float8_regr_sxy(double precision[]) double precision' on db.
func Float8RegrSxy(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_sxy
	const sqlstr = `SELECT pg_catalog.float8_regr_sxy($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8RegrSyy calls the stored procedure 'pg_catalog.float8_regr_syy(double precision[]) double precision' on db.
func Float8RegrSyy(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_syy
	const sqlstr = `SELECT pg_catalog.float8_regr_syy($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8StddevPop calls the stored procedure 'pg_catalog.float8_stddev_pop(double precision[]) double precision' on db.
func Float8StddevPop(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_stddev_pop
	const sqlstr = `SELECT pg_catalog.float8_stddev_pop($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8StddevSamp calls the stored procedure 'pg_catalog.float8_stddev_samp(double precision[]) double precision' on db.
func Float8StddevSamp(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_stddev_samp
	const sqlstr = `SELECT pg_catalog.float8_stddev_samp($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8VarPop calls the stored procedure 'pg_catalog.float8_var_pop(double precision[]) double precision' on db.
func Float8VarPop(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_var_pop
	const sqlstr = `SELECT pg_catalog.float8_var_pop($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8VarSamp calls the stored procedure 'pg_catalog.float8_var_samp(double precision[]) double precision' on db.
func Float8VarSamp(ctx context.Context, db DB, v0 []float64) (float64, error) {
	// call pg_catalog.float8_var_samp
	const sqlstr = `SELECT pg_catalog.float8_var_samp($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8abs calls the stored procedure 'pg_catalog.float8abs(double precision) double precision' on db.
func Float8abs(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.float8abs
	const sqlstr = `SELECT pg_catalog.float8abs($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8div calls the stored procedure 'pg_catalog.float8div(double precision, double precision) double precision' on db.
func Float8div(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.float8div
	const sqlstr = `SELECT pg_catalog.float8div($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8eq calls the stored procedure 'pg_catalog.float8eq(double precision, double precision) boolean' on db.
func Float8eq(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.float8eq
	const sqlstr = `SELECT pg_catalog.float8eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float8ge calls the stored procedure 'pg_catalog.float8ge(double precision, double precision) boolean' on db.
func Float8ge(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.float8ge
	const sqlstr = `SELECT pg_catalog.float8ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float8gt calls the stored procedure 'pg_catalog.float8gt(double precision, double precision) boolean' on db.
func Float8gt(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.float8gt
	const sqlstr = `SELECT pg_catalog.float8gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float8in calls the stored procedure 'pg_catalog.float8in(cstring) double precision' on db.
func Float8in(ctx context.Context, db DB, v0 pgtypes.Cstring) (float64, error) {
	// call pg_catalog.float8in
	const sqlstr = `SELECT pg_catalog.float8in($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8larger calls the stored procedure 'pg_catalog.float8larger(double precision, double precision) double precision' on db.
func Float8larger(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.float8larger
	const sqlstr = `SELECT pg_catalog.float8larger($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8le calls the stored procedure 'pg_catalog.float8le(double precision, double precision) boolean' on db.
func Float8le(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.float8le
	const sqlstr = `SELECT pg_catalog.float8le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float8lt calls the stored procedure 'pg_catalog.float8lt(double precision, double precision) boolean' on db.
func Float8lt(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.float8lt
	const sqlstr = `SELECT pg_catalog.float8lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float8mi calls the stored procedure 'pg_catalog.float8mi(double precision, double precision) double precision' on db.
func Float8mi(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.float8mi
	const sqlstr = `SELECT pg_catalog.float8mi($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8mul calls the stored procedure 'pg_catalog.float8mul(double precision, double precision) double precision' on db.
func Float8mul(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.float8mul
	const sqlstr = `SELECT pg_catalog.float8mul($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8ne calls the stored procedure 'pg_catalog.float8ne(double precision, double precision) boolean' on db.
func Float8ne(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.float8ne
	const sqlstr = `SELECT pg_catalog.float8ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Float8out calls the stored procedure 'pg_catalog.float8out(double precision) cstring' on db.
func Float8out(ctx context.Context, db DB, v0 float64) (pgtypes.Cstring, error) {
	// call pg_catalog.float8out
	const sqlstr = `SELECT pg_catalog.float8out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Float8pl calls the stored procedure 'pg_catalog.float8pl(double precision, double precision) double precision' on db.
func Float8pl(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.float8pl
	const sqlstr = `SELECT pg_catalog.float8pl($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8recv calls the stored procedure 'pg_catalog.float8recv(internal) double precision' on db.
func Float8recv(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.float8recv
	const sqlstr = `SELECT pg_catalog.float8recv($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8send calls the stored procedure 'pg_catalog.float8send(double precision) bytea' on db.
func Float8send(ctx context.Context, db DB, v0 float64) ([]byte, error) {
	// call pg_catalog.float8send
	const sqlstr = `SELECT pg_catalog.float8send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Float8smaller calls the stored procedure 'pg_catalog.float8smaller(double precision, double precision) double precision' on db.
func Float8smaller(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.float8smaller
	const sqlstr = `SELECT pg_catalog.float8smaller($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8um calls the stored procedure 'pg_catalog.float8um(double precision) double precision' on db.
func Float8um(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.float8um
	const sqlstr = `SELECT pg_catalog.float8um($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Float8up calls the stored procedure 'pg_catalog.float8up(double precision) double precision' on db.
func Float8up(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.float8up
	const sqlstr = `SELECT pg_catalog.float8up($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Floor calls the stored procedure 'pg_catalog.floor(double precision, numeric) numeric' on db.
func Floor(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.floor
	const sqlstr = `SELECT pg_catalog.floor($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Flt4MulCash calls the stored procedure 'pg_catalog.flt4_mul_cash(real, money) money' on db.
func Flt4MulCash(ctx context.Context, db DB, v0 float32, v1 string) (string, error) {
	// call pg_catalog.flt4_mul_cash
	const sqlstr = `SELECT pg_catalog.flt4_mul_cash($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Flt8MulCash calls the stored procedure 'pg_catalog.flt8_mul_cash(double precision, money) money' on db.
func Flt8MulCash(ctx context.Context, db DB, v0 float64, v1 string) (string, error) {
	// call pg_catalog.flt8_mul_cash
	const sqlstr = `SELECT pg_catalog.flt8_mul_cash($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// FmgrCValidator calls the stored procedure 'pg_catalog.fmgr_c_validator(oid) void' on db.
func FmgrCValidator(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.fmgr_c_validator
	const sqlstr = `SELECT pg_catalog.fmgr_c_validator($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// FmgrInternalValidator calls the stored procedure 'pg_catalog.fmgr_internal_validator(oid) void' on db.
func FmgrInternalValidator(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.fmgr_internal_validator
	const sqlstr = `SELECT pg_catalog.fmgr_internal_validator($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// FmgrSQLValidator calls the stored procedure 'pg_catalog.fmgr_sql_validator(oid) void' on db.
func FmgrSQLValidator(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.fmgr_sql_validator
	const sqlstr = `SELECT pg_catalog.fmgr_sql_validator($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Format calls the stored procedure 'pg_catalog.format(text, text, "any") text' on db.
func Format(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Any) (string, error) {
	// call pg_catalog.format
	const sqlstr = `SELECT pg_catalog.format($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// FormatType calls the stored procedure 'pg_catalog.format_type(oid, integer) text' on db.
func FormatType(ctx context.Context, db DB, v0 pgtypes.Oid, v1 int) (string, error) {
	// call pg_catalog.format_type
	const sqlstr = `SELECT pg_catalog.format_type($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Gb18030ToUTF8 calls the stored procedure 'pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func Gb18030ToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.gb18030_to_utf8
	const sqlstr = `SELECT pg_catalog.gb18030_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// GbkToUTF8 calls the stored procedure 'pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func GbkToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.gbk_to_utf8
	const sqlstr = `SELECT pg_catalog.gbk_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Gcd calls the stored procedure 'pg_catalog.gcd(bigint, bigint, integer, integer, numeric, numeric) numeric' on db.
func Gcd(ctx context.Context, db DB, v0, v1 int64, v2, v3 int, v4, v5 float64) (float64, error) {
	// call pg_catalog.gcd
	const sqlstr = `SELECT pg_catalog.gcd($1, $2, $3, $4, $5, $6)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// GenRandomUUID calls the stored procedure 'pg_catalog.gen_random_uuid() uuid' on db.
func GenRandomUUID(ctx context.Context, db DB) (uuid.UUID, error) {
	// call pg_catalog.gen_random_uuid
	const sqlstr = `SELECT pg_catalog.gen_random_uuid()`
	// run
	var ret uuid.UUID
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return uuid.UUID{}, logerror(err)
	}
	return ret, nil
}

// GenerateSeries calls the stored procedure 'pg_catalog.generate_series(bigint, bigint, integer, integer, numeric, numeric, bigint, bigint, bigint, integer, integer, integer, timestamp without time zone, timestamp without time zone, interval, timestamp with time zone, timestamp with time zone, interval, numeric, numeric, numeric) SETOF timestamp with time zone' on db.
func GenerateSeries(ctx context.Context, db DB, v0, v1 int64, v2, v3 int, v4, v5 float64, v6, v7, v8 int64, v9, v10, v11 int, v12, v13 time.Time, v14 []byte, v15, v16 time.Time, v17 []byte, v18, v19, v20 float64) ([]time.Time, error) {
	// call pg_catalog.generate_series
	const sqlstr = `SELECT pg_catalog.generate_series($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)`
	// run
	var ret []time.Time
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// GenerateSeriesInt4Support calls the stored procedure 'pg_catalog.generate_series_int4_support(internal) internal' on db.
func GenerateSeriesInt4Support(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.generate_series_int4_support
	const sqlstr = `SELECT pg_catalog.generate_series_int4_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GenerateSeriesInt8Support calls the stored procedure 'pg_catalog.generate_series_int8_support(internal) internal' on db.
func GenerateSeriesInt8Support(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.generate_series_int8_support
	const sqlstr = `SELECT pg_catalog.generate_series_int8_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GenerateSubscripts calls the stored procedure 'pg_catalog.generate_subscripts(anyarray, integer, anyarray, integer, boolean) SETOF integer' on db.
func GenerateSubscripts(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 int, v2 pgtypes.Anyarray, v3 int, v4 bool) ([]int, error) {
	// call pg_catalog.generate_subscripts
	const sqlstr = `SELECT pg_catalog.generate_subscripts($1, $2, $3, $4, $5)`
	// run
	var ret []int
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// GetBit calls the stored procedure 'pg_catalog.get_bit(bytea, bigint, bit, integer) integer' on db.
func GetBit(ctx context.Context, db DB, v0 []byte, v1 int64, v2 uint8, v3 int) (int, error) {
	// call pg_catalog.get_bit
	const sqlstr = `SELECT pg_catalog.get_bit($1, $2, $3, $4)`
	// run
	var ret int
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// GetByte calls the stored procedure 'pg_catalog.get_byte(bytea, integer) integer' on db.
func GetByte(ctx context.Context, db DB, v0 []byte, v1 int) (int, error) {
	// call pg_catalog.get_byte
	const sqlstr = `SELECT pg_catalog.get_byte($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// GetCurrentTsConfig calls the stored procedure 'pg_catalog.get_current_ts_config() regconfig' on db.
func GetCurrentTsConfig(ctx context.Context, db DB) (pgtypes.Regconfig, error) {
	// call pg_catalog.get_current_ts_config
	const sqlstr = `SELECT pg_catalog.get_current_ts_config()`
	// run
	var ret pgtypes.Regconfig
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Regconfig{}, logerror(err)
	}
	return ret, nil
}

// Getdatabaseencoding calls the stored procedure 'pg_catalog.getdatabaseencoding() name' on db.
func Getdatabaseencoding(ctx context.Context, db DB) (pgtypes.Name, error) {
	// call pg_catalog.getdatabaseencoding
	const sqlstr = `SELECT pg_catalog.getdatabaseencoding()`
	// run
	var ret pgtypes.Name
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// Getpgusername calls the stored procedure 'pg_catalog.getpgusername() name' on db.
func Getpgusername(ctx context.Context, db DB) (pgtypes.Name, error) {
	// call pg_catalog.getpgusername
	const sqlstr = `SELECT pg_catalog.getpgusername()`
	// run
	var ret pgtypes.Name
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// GinCleanPendingList calls the stored procedure 'pg_catalog.gin_clean_pending_list(regclass) bigint' on db.
func GinCleanPendingList(ctx context.Context, db DB, v0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.gin_clean_pending_list
	const sqlstr = `SELECT pg_catalog.gin_clean_pending_list($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// GinCmpPrefix calls the stored procedure 'pg_catalog.gin_cmp_prefix(text, text, smallint, internal) integer' on db.
func GinCmpPrefix(ctx context.Context, db DB, v0, v1 string, v2 int16, v3 pgtypes.Internal) (int, error) {
	// call pg_catalog.gin_cmp_prefix
	const sqlstr = `SELECT pg_catalog.gin_cmp_prefix($1, $2, $3, $4)`
	// run
	var ret int
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// GinCmpTslexeme calls the stored procedure 'pg_catalog.gin_cmp_tslexeme(text, text) integer' on db.
func GinCmpTslexeme(ctx context.Context, db DB, v0, v1 string) (int, error) {
	// call pg_catalog.gin_cmp_tslexeme
	const sqlstr = `SELECT pg_catalog.gin_cmp_tslexeme($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// GinCompareJsonb calls the stored procedure 'pg_catalog.gin_compare_jsonb(text, text) integer' on db.
func GinCompareJsonb(ctx context.Context, db DB, v0, v1 string) (int, error) {
	// call pg_catalog.gin_compare_jsonb
	const sqlstr = `SELECT pg_catalog.gin_compare_jsonb($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// GinConsistentJsonb calls the stored procedure 'pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal, internal) boolean' on db.
func GinConsistentJsonb(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int16, v2 []byte, v3 int, v4, v5, v6, v7 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gin_consistent_jsonb
	const sqlstr = `SELECT pg_catalog.gin_consistent_jsonb($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// GinConsistentJsonbPath calls the stored procedure 'pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal, internal) boolean' on db.
func GinConsistentJsonbPath(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int16, v2 []byte, v3 int, v4, v5, v6, v7 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gin_consistent_jsonb_path
	const sqlstr = `SELECT pg_catalog.gin_consistent_jsonb_path($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// GinExtractJsonb calls the stored procedure 'pg_catalog.gin_extract_jsonb(jsonb, internal, internal) internal' on db.
func GinExtractJsonb(ctx context.Context, db DB, v0 []byte, v1, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_jsonb
	const sqlstr = `SELECT pg_catalog.gin_extract_jsonb($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GinExtractJsonbPath calls the stored procedure 'pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal) internal' on db.
func GinExtractJsonbPath(ctx context.Context, db DB, v0 []byte, v1, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_jsonb_path
	const sqlstr = `SELECT pg_catalog.gin_extract_jsonb_path($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GinExtractJsonbQuery calls the stored procedure 'pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal) internal' on db.
func GinExtractJsonbQuery(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Internal, v2 int16, v3, v4, v5, v6 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_jsonb_query
	const sqlstr = `SELECT pg_catalog.gin_extract_jsonb_query($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GinExtractJsonbQueryPath calls the stored procedure 'pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal) internal' on db.
func GinExtractJsonbQueryPath(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Internal, v2 int16, v3, v4, v5, v6 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_jsonb_query_path
	const sqlstr = `SELECT pg_catalog.gin_extract_jsonb_query_path($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GinExtractTsquery calls the stored procedure 'pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, tsvector, internal, smallint, internal, internal, internal, internal, tsquery, internal, smallint, internal, internal, internal, internal) internal' on db.
func GinExtractTsquery(ctx context.Context, db DB, v0 pgtypes.Tsquery, v1 pgtypes.Internal, v2 int16, v3, v4 pgtypes.Internal, v5 pgtypes.Tsvector, v6 pgtypes.Internal, v7 int16, v8, v9, v10, v11 pgtypes.Internal, v12 pgtypes.Tsquery, v13 pgtypes.Internal, v14 int16, v15, v16, v17, v18 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_tsquery
	const sqlstr = `SELECT pg_catalog.gin_extract_tsquery($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GinExtractTsvector calls the stored procedure 'pg_catalog.gin_extract_tsvector(tsvector, internal, tsvector, internal, internal) internal' on db.
func GinExtractTsvector(ctx context.Context, db DB, v0 pgtypes.Tsvector, v1 pgtypes.Internal, v2 pgtypes.Tsvector, v3, v4 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_tsvector
	const sqlstr = `SELECT pg_catalog.gin_extract_tsvector($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GinTriconsistentJsonb calls the stored procedure 'pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal) "char"' on db.
func GinTriconsistentJsonb(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int16, v2 []byte, v3 int, v4, v5, v6 pgtypes.Internal) (pgtypes.Char, error) {
	// call pg_catalog.gin_triconsistent_jsonb
	const sqlstr = `SELECT pg_catalog.gin_triconsistent_jsonb($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret pgtypes.Char
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return ret, nil
}

// GinTriconsistentJsonbPath calls the stored procedure 'pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal) "char"' on db.
func GinTriconsistentJsonbPath(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int16, v2 []byte, v3 int, v4, v5, v6 pgtypes.Internal) (pgtypes.Char, error) {
	// call pg_catalog.gin_triconsistent_jsonb_path
	const sqlstr = `SELECT pg_catalog.gin_triconsistent_jsonb_path($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret pgtypes.Char
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return ret, nil
}

// GinTsqueryConsistent calls the stored procedure 'pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal, smallint, tsvector, integer, internal, internal, internal, internal, internal, smallint, tsquery, integer, internal, internal, internal, internal) boolean' on db.
func GinTsqueryConsistent(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int16, v2 pgtypes.Tsquery, v3 int, v4, v5, v6 pgtypes.Internal, v7 int16, v8 pgtypes.Tsvector, v9 int, v10, v11, v12, v13, v14 pgtypes.Internal, v15 int16, v16 pgtypes.Tsquery, v17 int, v18, v19, v20, v21 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gin_tsquery_consistent
	const sqlstr = `SELECT pg_catalog.gin_tsquery_consistent($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// GinTsqueryTriconsistent calls the stored procedure 'pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal) "char"' on db.
func GinTsqueryTriconsistent(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int16, v2 pgtypes.Tsvector, v3 int, v4, v5, v6 pgtypes.Internal) (pgtypes.Char, error) {
	// call pg_catalog.gin_tsquery_triconsistent
	const sqlstr = `SELECT pg_catalog.gin_tsquery_triconsistent($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret pgtypes.Char
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return ret, nil
}

// Ginarrayconsistent calls the stored procedure 'pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal, internal) boolean' on db.
func Ginarrayconsistent(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int16, v2 pgtypes.Anyarray, v3 int, v4, v5, v6, v7 pgtypes.Internal) (bool, error) {
	// call pg_catalog.ginarrayconsistent
	const sqlstr = `SELECT pg_catalog.ginarrayconsistent($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Ginarrayextract calls the stored procedure 'pg_catalog.ginarrayextract(anyarray, internal, anyarray, internal, internal) internal' on db.
func Ginarrayextract(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 pgtypes.Internal, v2 pgtypes.Anyarray, v3, v4 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.ginarrayextract
	const sqlstr = `SELECT pg_catalog.ginarrayextract($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Ginarraytriconsistent calls the stored procedure 'pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal) "char"' on db.
func Ginarraytriconsistent(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int16, v2 pgtypes.Anyarray, v3 int, v4, v5, v6 pgtypes.Internal) (pgtypes.Char, error) {
	// call pg_catalog.ginarraytriconsistent
	const sqlstr = `SELECT pg_catalog.ginarraytriconsistent($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret pgtypes.Char
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return ret, nil
}

// Ginhandler calls the stored procedure 'pg_catalog.ginhandler(internal) index_am_handler' on db.
func Ginhandler(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.ginhandler
	const sqlstr = `SELECT pg_catalog.ginhandler($1)`
	// run
	var ret pgtypes.IndexAmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return ret, nil
}

// Ginqueryarrayextract calls the stored procedure 'pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal) internal' on db.
func Ginqueryarrayextract(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 pgtypes.Internal, v2 int16, v3, v4, v5, v6 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.ginqueryarrayextract
	const sqlstr = `SELECT pg_catalog.ginqueryarrayextract($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GistBoxConsistent calls the stored procedure 'pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal) boolean' on db.
func GistBoxConsistent(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Box, v2 int16, v3 pgtypes.Oid, v4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gist_box_consistent
	const sqlstr = `SELECT pg_catalog.gist_box_consistent($1, $2, $3, $4, $5)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// GistBoxDistance calls the stored procedure 'pg_catalog.gist_box_distance(internal, box, smallint, oid, internal) double precision' on db.
func GistBoxDistance(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Box, v2 int16, v3 pgtypes.Oid, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.gist_box_distance
	const sqlstr = `SELECT pg_catalog.gist_box_distance($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// GistBoxPenalty calls the stored procedure 'pg_catalog.gist_box_penalty(internal, internal, internal) internal' on db.
func GistBoxPenalty(ctx context.Context, db DB, v0, v1, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_box_penalty
	const sqlstr = `SELECT pg_catalog.gist_box_penalty($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GistBoxPicksplit calls the stored procedure 'pg_catalog.gist_box_picksplit(internal, internal) internal' on db.
func GistBoxPicksplit(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_box_picksplit
	const sqlstr = `SELECT pg_catalog.gist_box_picksplit($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GistBoxSame calls the stored procedure 'pg_catalog.gist_box_same(box, box, internal) internal' on db.
func GistBoxSame(ctx context.Context, db DB, v0, v1 pgtypes.Box, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_box_same
	const sqlstr = `SELECT pg_catalog.gist_box_same($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GistBoxUnion calls the stored procedure 'pg_catalog.gist_box_union(internal, internal) box' on db.
func GistBoxUnion(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Box, error) {
	// call pg_catalog.gist_box_union
	const sqlstr = `SELECT pg_catalog.gist_box_union($1, $2)`
	// run
	var ret pgtypes.Box
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return ret, nil
}

// GistCircleCompress calls the stored procedure 'pg_catalog.gist_circle_compress(internal) internal' on db.
func GistCircleCompress(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_circle_compress
	const sqlstr = `SELECT pg_catalog.gist_circle_compress($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GistCircleConsistent calls the stored procedure 'pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal) boolean' on db.
func GistCircleConsistent(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Circle, v2 int16, v3 pgtypes.Oid, v4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gist_circle_consistent
	const sqlstr = `SELECT pg_catalog.gist_circle_consistent($1, $2, $3, $4, $5)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// GistCircleDistance calls the stored procedure 'pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal) double precision' on db.
func GistCircleDistance(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Circle, v2 int16, v3 pgtypes.Oid, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.gist_circle_distance
	const sqlstr = `SELECT pg_catalog.gist_circle_distance($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// GistPointCompress calls the stored procedure 'pg_catalog.gist_point_compress(internal) internal' on db.
func GistPointCompress(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_point_compress
	const sqlstr = `SELECT pg_catalog.gist_point_compress($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GistPointConsistent calls the stored procedure 'pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal) boolean' on db.
func GistPointConsistent(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Point, v2 int16, v3 pgtypes.Oid, v4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gist_point_consistent
	const sqlstr = `SELECT pg_catalog.gist_point_consistent($1, $2, $3, $4, $5)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// GistPointDistance calls the stored procedure 'pg_catalog.gist_point_distance(internal, point, smallint, oid, internal) double precision' on db.
func GistPointDistance(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Point, v2 int16, v3 pgtypes.Oid, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.gist_point_distance
	const sqlstr = `SELECT pg_catalog.gist_point_distance($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// GistPointFetch calls the stored procedure 'pg_catalog.gist_point_fetch(internal) internal' on db.
func GistPointFetch(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_point_fetch
	const sqlstr = `SELECT pg_catalog.gist_point_fetch($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GistPolyCompress calls the stored procedure 'pg_catalog.gist_poly_compress(internal) internal' on db.
func GistPolyCompress(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_poly_compress
	const sqlstr = `SELECT pg_catalog.gist_poly_compress($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GistPolyConsistent calls the stored procedure 'pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal) boolean' on db.
func GistPolyConsistent(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Polygon, v2 int16, v3 pgtypes.Oid, v4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gist_poly_consistent
	const sqlstr = `SELECT pg_catalog.gist_poly_consistent($1, $2, $3, $4, $5)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// GistPolyDistance calls the stored procedure 'pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal) double precision' on db.
func GistPolyDistance(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Polygon, v2 int16, v3 pgtypes.Oid, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.gist_poly_distance
	const sqlstr = `SELECT pg_catalog.gist_poly_distance($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Gisthandler calls the stored procedure 'pg_catalog.gisthandler(internal) index_am_handler' on db.
func Gisthandler(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.gisthandler
	const sqlstr = `SELECT pg_catalog.gisthandler($1)`
	// run
	var ret pgtypes.IndexAmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return ret, nil
}

// GtsqueryCompress calls the stored procedure 'pg_catalog.gtsquery_compress(internal) internal' on db.
func GtsqueryCompress(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsquery_compress
	const sqlstr = `SELECT pg_catalog.gtsquery_compress($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GtsqueryConsistent calls the stored procedure 'pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal, internal, tsquery, smallint, oid, internal) boolean' on db.
func GtsqueryConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal, v2 int, v3 pgtypes.Oid, v4, v5 pgtypes.Internal, v6 pgtypes.Tsquery, v7 int16, v8 pgtypes.Oid, v9 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gtsquery_consistent
	const sqlstr = `SELECT pg_catalog.gtsquery_consistent($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// GtsqueryPenalty calls the stored procedure 'pg_catalog.gtsquery_penalty(internal, internal, internal) internal' on db.
func GtsqueryPenalty(ctx context.Context, db DB, v0, v1, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsquery_penalty
	const sqlstr = `SELECT pg_catalog.gtsquery_penalty($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GtsqueryPicksplit calls the stored procedure 'pg_catalog.gtsquery_picksplit(internal, internal) internal' on db.
func GtsqueryPicksplit(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsquery_picksplit
	const sqlstr = `SELECT pg_catalog.gtsquery_picksplit($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GtsquerySame calls the stored procedure 'pg_catalog.gtsquery_same(bigint, bigint, internal) internal' on db.
func GtsquerySame(ctx context.Context, db DB, v0, v1 int64, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsquery_same
	const sqlstr = `SELECT pg_catalog.gtsquery_same($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GtsqueryUnion calls the stored procedure 'pg_catalog.gtsquery_union(internal, internal) bigint' on db.
func GtsqueryUnion(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (int64, error) {
	// call pg_catalog.gtsquery_union
	const sqlstr = `SELECT pg_catalog.gtsquery_union($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// GtsvectorCompress calls the stored procedure 'pg_catalog.gtsvector_compress(internal) internal' on db.
func GtsvectorCompress(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsvector_compress
	const sqlstr = `SELECT pg_catalog.gtsvector_compress($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GtsvectorConsistent calls the stored procedure 'pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal, internal, gtsvector, integer, oid, internal) boolean' on db.
func GtsvectorConsistent(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Tsvector, v2 int16, v3 pgtypes.Oid, v4, v5 pgtypes.Internal, v6 pgtypes.Gtsvector, v7 int, v8 pgtypes.Oid, v9 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gtsvector_consistent
	const sqlstr = `SELECT pg_catalog.gtsvector_consistent($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// GtsvectorDecompress calls the stored procedure 'pg_catalog.gtsvector_decompress(internal) internal' on db.
func GtsvectorDecompress(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsvector_decompress
	const sqlstr = `SELECT pg_catalog.gtsvector_decompress($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GtsvectorOptions calls the stored procedure 'pg_catalog.gtsvector_options(internal) void' on db.
func GtsvectorOptions(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.gtsvector_options
	const sqlstr = `SELECT pg_catalog.gtsvector_options($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// GtsvectorPenalty calls the stored procedure 'pg_catalog.gtsvector_penalty(internal, internal, internal) internal' on db.
func GtsvectorPenalty(ctx context.Context, db DB, v0, v1, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsvector_penalty
	const sqlstr = `SELECT pg_catalog.gtsvector_penalty($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GtsvectorPicksplit calls the stored procedure 'pg_catalog.gtsvector_picksplit(internal, internal) internal' on db.
func GtsvectorPicksplit(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsvector_picksplit
	const sqlstr = `SELECT pg_catalog.gtsvector_picksplit($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GtsvectorSame calls the stored procedure 'pg_catalog.gtsvector_same(gtsvector, gtsvector, internal) internal' on db.
func GtsvectorSame(ctx context.Context, db DB, v0, v1 pgtypes.Gtsvector, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsvector_same
	const sqlstr = `SELECT pg_catalog.gtsvector_same($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// GtsvectorUnion calls the stored procedure 'pg_catalog.gtsvector_union(internal, internal) gtsvector' on db.
func GtsvectorUnion(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Gtsvector, error) {
	// call pg_catalog.gtsvector_union
	const sqlstr = `SELECT pg_catalog.gtsvector_union($1, $2)`
	// run
	var ret pgtypes.Gtsvector
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Gtsvector{}, logerror(err)
	}
	return ret, nil
}

// Gtsvectorin calls the stored procedure 'pg_catalog.gtsvectorin(cstring) gtsvector' on db.
func Gtsvectorin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Gtsvector, error) {
	// call pg_catalog.gtsvectorin
	const sqlstr = `SELECT pg_catalog.gtsvectorin($1)`
	// run
	var ret pgtypes.Gtsvector
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Gtsvector{}, logerror(err)
	}
	return ret, nil
}

// Gtsvectorout calls the stored procedure 'pg_catalog.gtsvectorout(gtsvector) cstring' on db.
func Gtsvectorout(ctx context.Context, db DB, v0 pgtypes.Gtsvector) (pgtypes.Cstring, error) {
	// call pg_catalog.gtsvectorout
	const sqlstr = `SELECT pg_catalog.gtsvectorout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// HasAnyColumnPrivilege calls the stored procedure 'pg_catalog.has_any_column_privilege(text, text, oid, text, name, text, text, name, oid, text, oid, text, text, oid, oid, text) boolean' on db.
func HasAnyColumnPrivilege(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string, v4 pgtypes.Name, v5, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.has_any_column_privilege
	const sqlstr = `SELECT pg_catalog.has_any_column_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HasColumnPrivilege calls the stored procedure 'pg_catalog.has_column_privilege(text, smallint, text, text, text, text, oid, smallint, text, oid, text, text, name, text, smallint, text, name, text, text, text, name, oid, smallint, text, name, oid, text, text, oid, text, smallint, text, oid, text, text, text, oid, oid, smallint, text, oid, oid, text, text) boolean' on db.
func HasColumnPrivilege(ctx context.Context, db DB, v0 string, v1 int16, v2, v3, v4, v5 string, v6 pgtypes.Oid, v7 int16, v8 string, v9 pgtypes.Oid, v10, v11 string, v12 pgtypes.Name, v13 string, v14 int16, v15 string, v16 pgtypes.Name, v17, v18, v19 string, v20 pgtypes.Name, v21 pgtypes.Oid, v22 int16, v23 string, v24 pgtypes.Name, v25 pgtypes.Oid, v26, v27 string, v28 pgtypes.Oid, v29 string, v30 int16, v31 string, v32 pgtypes.Oid, v33, v34, v35 string, v36, v37 pgtypes.Oid, v38 int16, v39 string, v40, v41 pgtypes.Oid, v42, v43 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT pg_catalog.has_column_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HasDatabasePrivilege calls the stored procedure 'pg_catalog.has_database_privilege(text, text, oid, text, name, text, text, name, oid, text, oid, text, text, oid, oid, text) boolean' on db.
func HasDatabasePrivilege(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string, v4 pgtypes.Name, v5, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.has_database_privilege
	const sqlstr = `SELECT pg_catalog.has_database_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HasForeignDataWrapperPrivilege calls the stored procedure 'pg_catalog.has_foreign_data_wrapper_privilege(text, text, oid, text, name, text, text, name, oid, text, oid, text, text, oid, oid, text) boolean' on db.
func HasForeignDataWrapperPrivilege(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string, v4 pgtypes.Name, v5, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.has_foreign_data_wrapper_privilege
	const sqlstr = `SELECT pg_catalog.has_foreign_data_wrapper_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HasFunctionPrivilege calls the stored procedure 'pg_catalog.has_function_privilege(text, text, oid, text, name, text, text, name, oid, text, oid, text, text, oid, oid, text) boolean' on db.
func HasFunctionPrivilege(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string, v4 pgtypes.Name, v5, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.has_function_privilege
	const sqlstr = `SELECT pg_catalog.has_function_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HasLanguagePrivilege calls the stored procedure 'pg_catalog.has_language_privilege(text, text, oid, text, name, text, text, name, oid, text, oid, text, text, oid, oid, text) boolean' on db.
func HasLanguagePrivilege(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string, v4 pgtypes.Name, v5, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.has_language_privilege
	const sqlstr = `SELECT pg_catalog.has_language_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HasSchemaPrivilege calls the stored procedure 'pg_catalog.has_schema_privilege(text, text, oid, text, name, text, text, name, oid, text, oid, text, text, oid, oid, text) boolean' on db.
func HasSchemaPrivilege(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string, v4 pgtypes.Name, v5, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.has_schema_privilege
	const sqlstr = `SELECT pg_catalog.has_schema_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HasSequencePrivilege calls the stored procedure 'pg_catalog.has_sequence_privilege(text, text, oid, text, name, text, text, name, oid, text, oid, text, text, oid, oid, text) boolean' on db.
func HasSequencePrivilege(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string, v4 pgtypes.Name, v5, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.has_sequence_privilege
	const sqlstr = `SELECT pg_catalog.has_sequence_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HasServerPrivilege calls the stored procedure 'pg_catalog.has_server_privilege(text, text, oid, text, name, text, text, name, oid, text, oid, text, text, oid, oid, text) boolean' on db.
func HasServerPrivilege(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string, v4 pgtypes.Name, v5, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.has_server_privilege
	const sqlstr = `SELECT pg_catalog.has_server_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HasTablePrivilege calls the stored procedure 'pg_catalog.has_table_privilege(text, text, oid, text, name, text, text, name, oid, text, oid, text, text, oid, oid, text) boolean' on db.
func HasTablePrivilege(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string, v4 pgtypes.Name, v5, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.has_table_privilege
	const sqlstr = `SELECT pg_catalog.has_table_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HasTablespacePrivilege calls the stored procedure 'pg_catalog.has_tablespace_privilege(text, text, oid, text, name, text, text, name, oid, text, oid, text, text, oid, oid, text) boolean' on db.
func HasTablespacePrivilege(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string, v4 pgtypes.Name, v5, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.has_tablespace_privilege
	const sqlstr = `SELECT pg_catalog.has_tablespace_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HasTypePrivilege calls the stored procedure 'pg_catalog.has_type_privilege(text, text, oid, text, name, text, text, name, oid, text, oid, text, text, oid, oid, text) boolean' on db.
func HasTypePrivilege(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string, v4 pgtypes.Name, v5, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.has_type_privilege
	const sqlstr = `SELECT pg_catalog.has_type_privilege($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// HashAclitem calls the stored procedure 'pg_catalog.hash_aclitem(aclitem) integer' on db.
func HashAclitem(ctx context.Context, db DB, v0 pgtypes.Aclitem) (int, error) {
	// call pg_catalog.hash_aclitem
	const sqlstr = `SELECT pg_catalog.hash_aclitem($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// HashAclitemExtended calls the stored procedure 'pg_catalog.hash_aclitem_extended(aclitem, bigint) bigint' on db.
func HashAclitemExtended(ctx context.Context, db DB, v0 pgtypes.Aclitem, v1 int64) (int64, error) {
	// call pg_catalog.hash_aclitem_extended
	const sqlstr = `SELECT pg_catalog.hash_aclitem_extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// HashArray calls the stored procedure 'pg_catalog.hash_array(anyarray) integer' on db.
func HashArray(ctx context.Context, db DB, v0 pgtypes.Anyarray) (int, error) {
	// call pg_catalog.hash_array
	const sqlstr = `SELECT pg_catalog.hash_array($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// HashArrayExtended calls the stored procedure 'pg_catalog.hash_array_extended(anyarray, bigint) bigint' on db.
func HashArrayExtended(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 int64) (int64, error) {
	// call pg_catalog.hash_array_extended
	const sqlstr = `SELECT pg_catalog.hash_array_extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// HashNumeric calls the stored procedure 'pg_catalog.hash_numeric(numeric) integer' on db.
func HashNumeric(ctx context.Context, db DB, v0 float64) (int, error) {
	// call pg_catalog.hash_numeric
	const sqlstr = `SELECT pg_catalog.hash_numeric($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// HashNumericExtended calls the stored procedure 'pg_catalog.hash_numeric_extended(numeric, bigint) bigint' on db.
func HashNumericExtended(ctx context.Context, db DB, v0 float64, v1 int64) (int64, error) {
	// call pg_catalog.hash_numeric_extended
	const sqlstr = `SELECT pg_catalog.hash_numeric_extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// HashRange calls the stored procedure 'pg_catalog.hash_range(anyrange) integer' on db.
func HashRange(ctx context.Context, db DB, v0 pgtypes.Anyrange) (int, error) {
	// call pg_catalog.hash_range
	const sqlstr = `SELECT pg_catalog.hash_range($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// HashRangeExtended calls the stored procedure 'pg_catalog.hash_range_extended(anyrange, bigint) bigint' on db.
func HashRangeExtended(ctx context.Context, db DB, v0 pgtypes.Anyrange, v1 int64) (int64, error) {
	// call pg_catalog.hash_range_extended
	const sqlstr = `SELECT pg_catalog.hash_range_extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashbpchar calls the stored procedure 'pg_catalog.hashbpchar(character) integer' on db.
func Hashbpchar(ctx context.Context, db DB, v0 string) (int, error) {
	// call pg_catalog.hashbpchar
	const sqlstr = `SELECT pg_catalog.hashbpchar($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashbpcharextended calls the stored procedure 'pg_catalog.hashbpcharextended(character, bigint) bigint' on db.
func Hashbpcharextended(ctx context.Context, db DB, v0 string, v1 int64) (int64, error) {
	// call pg_catalog.hashbpcharextended
	const sqlstr = `SELECT pg_catalog.hashbpcharextended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashchar calls the stored procedure 'pg_catalog.hashchar("char") integer' on db.
func Hashchar(ctx context.Context, db DB, v0 pgtypes.Char) (int, error) {
	// call pg_catalog.hashchar
	const sqlstr = `SELECT pg_catalog.hashchar($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashcharextended calls the stored procedure 'pg_catalog.hashcharextended("char", bigint) bigint' on db.
func Hashcharextended(ctx context.Context, db DB, v0 pgtypes.Char, v1 int64) (int64, error) {
	// call pg_catalog.hashcharextended
	const sqlstr = `SELECT pg_catalog.hashcharextended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashenum calls the stored procedure 'pg_catalog.hashenum(anyenum) integer' on db.
func Hashenum(ctx context.Context, db DB, v0 pgtypes.Anyenum) (int, error) {
	// call pg_catalog.hashenum
	const sqlstr = `SELECT pg_catalog.hashenum($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashenumextended calls the stored procedure 'pg_catalog.hashenumextended(anyenum, bigint) bigint' on db.
func Hashenumextended(ctx context.Context, db DB, v0 pgtypes.Anyenum, v1 int64) (int64, error) {
	// call pg_catalog.hashenumextended
	const sqlstr = `SELECT pg_catalog.hashenumextended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashfloat4 calls the stored procedure 'pg_catalog.hashfloat4(real) integer' on db.
func Hashfloat4(ctx context.Context, db DB, v0 float32) (int, error) {
	// call pg_catalog.hashfloat4
	const sqlstr = `SELECT pg_catalog.hashfloat4($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashfloat4extended calls the stored procedure 'pg_catalog.hashfloat4extended(real, bigint) bigint' on db.
func Hashfloat4extended(ctx context.Context, db DB, v0 float32, v1 int64) (int64, error) {
	// call pg_catalog.hashfloat4extended
	const sqlstr = `SELECT pg_catalog.hashfloat4extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashfloat8 calls the stored procedure 'pg_catalog.hashfloat8(double precision) integer' on db.
func Hashfloat8(ctx context.Context, db DB, v0 float64) (int, error) {
	// call pg_catalog.hashfloat8
	const sqlstr = `SELECT pg_catalog.hashfloat8($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashfloat8extended calls the stored procedure 'pg_catalog.hashfloat8extended(double precision, bigint) bigint' on db.
func Hashfloat8extended(ctx context.Context, db DB, v0 float64, v1 int64) (int64, error) {
	// call pg_catalog.hashfloat8extended
	const sqlstr = `SELECT pg_catalog.hashfloat8extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashhandler calls the stored procedure 'pg_catalog.hashhandler(internal) index_am_handler' on db.
func Hashhandler(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.hashhandler
	const sqlstr = `SELECT pg_catalog.hashhandler($1)`
	// run
	var ret pgtypes.IndexAmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return ret, nil
}

// Hashinet calls the stored procedure 'pg_catalog.hashinet(inet) integer' on db.
func Hashinet(ctx context.Context, db DB, v0 string) (int, error) {
	// call pg_catalog.hashinet
	const sqlstr = `SELECT pg_catalog.hashinet($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashinetextended calls the stored procedure 'pg_catalog.hashinetextended(inet, bigint) bigint' on db.
func Hashinetextended(ctx context.Context, db DB, v0 string, v1 int64) (int64, error) {
	// call pg_catalog.hashinetextended
	const sqlstr = `SELECT pg_catalog.hashinetextended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashint2 calls the stored procedure 'pg_catalog.hashint2(smallint) integer' on db.
func Hashint2(ctx context.Context, db DB, v0 int16) (int, error) {
	// call pg_catalog.hashint2
	const sqlstr = `SELECT pg_catalog.hashint2($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashint2extended calls the stored procedure 'pg_catalog.hashint2extended(smallint, bigint) bigint' on db.
func Hashint2extended(ctx context.Context, db DB, v0 int16, v1 int64) (int64, error) {
	// call pg_catalog.hashint2extended
	const sqlstr = `SELECT pg_catalog.hashint2extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashint4 calls the stored procedure 'pg_catalog.hashint4(integer) integer' on db.
func Hashint4(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.hashint4
	const sqlstr = `SELECT pg_catalog.hashint4($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashint4extended calls the stored procedure 'pg_catalog.hashint4extended(integer, bigint) bigint' on db.
func Hashint4extended(ctx context.Context, db DB, v0 int, v1 int64) (int64, error) {
	// call pg_catalog.hashint4extended
	const sqlstr = `SELECT pg_catalog.hashint4extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashint8 calls the stored procedure 'pg_catalog.hashint8(bigint) integer' on db.
func Hashint8(ctx context.Context, db DB, v0 int64) (int, error) {
	// call pg_catalog.hashint8
	const sqlstr = `SELECT pg_catalog.hashint8($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashint8extended calls the stored procedure 'pg_catalog.hashint8extended(bigint, bigint) bigint' on db.
func Hashint8extended(ctx context.Context, db DB, v0, v1 int64) (int64, error) {
	// call pg_catalog.hashint8extended
	const sqlstr = `SELECT pg_catalog.hashint8extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashmacaddr calls the stored procedure 'pg_catalog.hashmacaddr(macaddr) integer' on db.
func Hashmacaddr(ctx context.Context, db DB, v0 pgtypes.Macaddr) (int, error) {
	// call pg_catalog.hashmacaddr
	const sqlstr = `SELECT pg_catalog.hashmacaddr($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashmacaddr8 calls the stored procedure 'pg_catalog.hashmacaddr8(macaddr8) integer' on db.
func Hashmacaddr8(ctx context.Context, db DB, v0 pgtypes.Macaddr8) (int, error) {
	// call pg_catalog.hashmacaddr8
	const sqlstr = `SELECT pg_catalog.hashmacaddr8($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashmacaddr8extended calls the stored procedure 'pg_catalog.hashmacaddr8extended(macaddr8, bigint) bigint' on db.
func Hashmacaddr8extended(ctx context.Context, db DB, v0 pgtypes.Macaddr8, v1 int64) (int64, error) {
	// call pg_catalog.hashmacaddr8extended
	const sqlstr = `SELECT pg_catalog.hashmacaddr8extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashmacaddrextended calls the stored procedure 'pg_catalog.hashmacaddrextended(macaddr, bigint) bigint' on db.
func Hashmacaddrextended(ctx context.Context, db DB, v0 pgtypes.Macaddr, v1 int64) (int64, error) {
	// call pg_catalog.hashmacaddrextended
	const sqlstr = `SELECT pg_catalog.hashmacaddrextended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashname calls the stored procedure 'pg_catalog.hashname(name) integer' on db.
func Hashname(ctx context.Context, db DB, v0 pgtypes.Name) (int, error) {
	// call pg_catalog.hashname
	const sqlstr = `SELECT pg_catalog.hashname($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashnameextended calls the stored procedure 'pg_catalog.hashnameextended(name, bigint) bigint' on db.
func Hashnameextended(ctx context.Context, db DB, v0 pgtypes.Name, v1 int64) (int64, error) {
	// call pg_catalog.hashnameextended
	const sqlstr = `SELECT pg_catalog.hashnameextended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashoid calls the stored procedure 'pg_catalog.hashoid(oid) integer' on db.
func Hashoid(ctx context.Context, db DB, v0 pgtypes.Oid) (int, error) {
	// call pg_catalog.hashoid
	const sqlstr = `SELECT pg_catalog.hashoid($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashoidextended calls the stored procedure 'pg_catalog.hashoidextended(oid, bigint) bigint' on db.
func Hashoidextended(ctx context.Context, db DB, v0 pgtypes.Oid, v1 int64) (int64, error) {
	// call pg_catalog.hashoidextended
	const sqlstr = `SELECT pg_catalog.hashoidextended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashoidvector calls the stored procedure 'pg_catalog.hashoidvector(oidvector) integer' on db.
func Hashoidvector(ctx context.Context, db DB, v0 pgtypes.Oidvector) (int, error) {
	// call pg_catalog.hashoidvector
	const sqlstr = `SELECT pg_catalog.hashoidvector($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashoidvectorextended calls the stored procedure 'pg_catalog.hashoidvectorextended(oidvector, bigint) bigint' on db.
func Hashoidvectorextended(ctx context.Context, db DB, v0 pgtypes.Oidvector, v1 int64) (int64, error) {
	// call pg_catalog.hashoidvectorextended
	const sqlstr = `SELECT pg_catalog.hashoidvectorextended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashtext calls the stored procedure 'pg_catalog.hashtext(text) integer' on db.
func Hashtext(ctx context.Context, db DB, v0 string) (int, error) {
	// call pg_catalog.hashtext
	const sqlstr = `SELECT pg_catalog.hashtext($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashtextextended calls the stored procedure 'pg_catalog.hashtextextended(text, bigint) bigint' on db.
func Hashtextextended(ctx context.Context, db DB, v0 string, v1 int64) (int64, error) {
	// call pg_catalog.hashtextextended
	const sqlstr = `SELECT pg_catalog.hashtextextended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashtid calls the stored procedure 'pg_catalog.hashtid(tid) integer' on db.
func Hashtid(ctx context.Context, db DB, v0 pgtypes.Tid) (int, error) {
	// call pg_catalog.hashtid
	const sqlstr = `SELECT pg_catalog.hashtid($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashtidextended calls the stored procedure 'pg_catalog.hashtidextended(tid, bigint) bigint' on db.
func Hashtidextended(ctx context.Context, db DB, v0 pgtypes.Tid, v1 int64) (int64, error) {
	// call pg_catalog.hashtidextended
	const sqlstr = `SELECT pg_catalog.hashtidextended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashvarlena calls the stored procedure 'pg_catalog.hashvarlena(internal) integer' on db.
func Hashvarlena(ctx context.Context, db DB, v0 pgtypes.Internal) (int, error) {
	// call pg_catalog.hashvarlena
	const sqlstr = `SELECT pg_catalog.hashvarlena($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Hashvarlenaextended calls the stored procedure 'pg_catalog.hashvarlenaextended(internal, bigint) bigint' on db.
func Hashvarlenaextended(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int64) (int64, error) {
	// call pg_catalog.hashvarlenaextended
	const sqlstr = `SELECT pg_catalog.hashvarlenaextended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// HeapTableamHandler calls the stored procedure 'pg_catalog.heap_tableam_handler(internal) table_am_handler' on db.
func HeapTableamHandler(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.TableAmHandler, error) {
	// call pg_catalog.heap_tableam_handler
	const sqlstr = `SELECT pg_catalog.heap_tableam_handler($1)`
	// run
	var ret pgtypes.TableAmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.TableAmHandler{}, logerror(err)
	}
	return ret, nil
}

// Height calls the stored procedure 'pg_catalog.height(box) double precision' on db.
func Height(ctx context.Context, db DB, v0 pgtypes.Box) (float64, error) {
	// call pg_catalog.height
	const sqlstr = `SELECT pg_catalog.height($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Host calls the stored procedure 'pg_catalog.host(inet) text' on db.
func Host(ctx context.Context, db DB, v0 string) (string, error) {
	// call pg_catalog.host
	const sqlstr = `SELECT pg_catalog.host($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Hostmask calls the stored procedure 'pg_catalog.hostmask(inet) inet' on db.
func Hostmask(ctx context.Context, db DB, v0 string) (string, error) {
	// call pg_catalog.hostmask
	const sqlstr = `SELECT pg_catalog.hostmask($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Iclikejoinsel calls the stored procedure 'pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Iclikejoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.iclikejoinsel
	const sqlstr = `SELECT pg_catalog.iclikejoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Iclikesel calls the stored procedure 'pg_catalog.iclikesel(internal, oid, internal, integer) double precision' on db.
func Iclikesel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.iclikesel
	const sqlstr = `SELECT pg_catalog.iclikesel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Icnlikejoinsel calls the stored procedure 'pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Icnlikejoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.icnlikejoinsel
	const sqlstr = `SELECT pg_catalog.icnlikejoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Icnlikesel calls the stored procedure 'pg_catalog.icnlikesel(internal, oid, internal, integer) double precision' on db.
func Icnlikesel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.icnlikesel
	const sqlstr = `SELECT pg_catalog.icnlikesel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Icregexeqjoinsel calls the stored procedure 'pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Icregexeqjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.icregexeqjoinsel
	const sqlstr = `SELECT pg_catalog.icregexeqjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Icregexeqsel calls the stored procedure 'pg_catalog.icregexeqsel(internal, oid, internal, integer) double precision' on db.
func Icregexeqsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.icregexeqsel
	const sqlstr = `SELECT pg_catalog.icregexeqsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Icregexnejoinsel calls the stored procedure 'pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Icregexnejoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.icregexnejoinsel
	const sqlstr = `SELECT pg_catalog.icregexnejoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Icregexnesel calls the stored procedure 'pg_catalog.icregexnesel(internal, oid, internal, integer) double precision' on db.
func Icregexnesel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.icregexnesel
	const sqlstr = `SELECT pg_catalog.icregexnesel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// InRange calls the stored procedure 'pg_catalog.in_range(bigint, bigint, bigint, boolean, boolean, smallint, smallint, bigint, boolean, boolean, smallint, smallint, smallint, boolean, boolean, smallint, smallint, integer, boolean, boolean, integer, integer, bigint, boolean, boolean, integer, integer, smallint, boolean, boolean, integer, integer, integer, boolean, boolean, real, real, double precision, boolean, boolean, double precision, double precision, double precision, boolean, boolean, date, date, interval, boolean, boolean, time without time zone, time without time zone, interval, boolean, boolean, timestamp without time zone, timestamp without time zone, interval, boolean, boolean, timestamp with time zone, timestamp with time zone, interval, boolean, boolean, interval, interval, interval, boolean, boolean, time with time zone, time with time zone, interval, boolean, boolean, numeric, numeric, numeric, boolean, boolean) boolean' on db.
func InRange(ctx context.Context, db DB, v0, v1, v2 int64, v3, v4 bool, v5, v6 int16, v7 int64, v8, v9 bool, v10, v11, v12 int16, v13, v14 bool, v15, v16 int16, v17 int, v18, v19 bool, v20, v21 int, v22 int64, v23, v24 bool, v25, v26 int, v27 int16, v28, v29 bool, v30, v31, v32 int, v33, v34 bool, v35, v36 float32, v37 float64, v38, v39 bool, v40, v41, v42 float64, v43, v44 bool, v45, v46 time.Time, v47 []byte, v48, v49 bool, v50, v51 time.Time, v52 []byte, v53, v54 bool, v55, v56 time.Time, v57 []byte, v58, v59 bool, v60, v61 time.Time, v62 []byte, v63, v64 bool, v65, v66, v67 []byte, v68, v69 bool, v70, v71 time.Time, v72 []byte, v73, v74 bool, v75, v76, v77 float64, v78, v79 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT pg_catalog.in_range($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $70, $71, $72, $73, $74, $75, $76, $77, $78, $79, $80)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// IndexAmHandlerIn calls the stored procedure 'pg_catalog.index_am_handler_in(cstring) index_am_handler' on db.
func IndexAmHandlerIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.index_am_handler_in
	const sqlstr = `SELECT pg_catalog.index_am_handler_in($1)`
	// run
	var ret pgtypes.IndexAmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return ret, nil
}

// IndexAmHandlerOut calls the stored procedure 'pg_catalog.index_am_handler_out(index_am_handler) cstring' on db.
func IndexAmHandlerOut(ctx context.Context, db DB, v0 pgtypes.IndexAmHandler) (pgtypes.Cstring, error) {
	// call pg_catalog.index_am_handler_out
	const sqlstr = `SELECT pg_catalog.index_am_handler_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// InetClientAddr calls the stored procedure 'pg_catalog.inet_client_addr() inet' on db.
func InetClientAddr(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.inet_client_addr
	const sqlstr = `SELECT pg_catalog.inet_client_addr()`
	// run
	var ret string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// InetClientPort calls the stored procedure 'pg_catalog.inet_client_port() integer' on db.
func InetClientPort(ctx context.Context, db DB) (int, error) {
	// call pg_catalog.inet_client_port
	const sqlstr = `SELECT pg_catalog.inet_client_port()`
	// run
	var ret int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// InetGistCompress calls the stored procedure 'pg_catalog.inet_gist_compress(internal) internal' on db.
func InetGistCompress(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.inet_gist_compress
	const sqlstr = `SELECT pg_catalog.inet_gist_compress($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// InetGistConsistent calls the stored procedure 'pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal) boolean' on db.
func InetGistConsistent(ctx context.Context, db DB, v0 pgtypes.Internal, v1 string, v2 int16, v3 pgtypes.Oid, v4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.inet_gist_consistent
	const sqlstr = `SELECT pg_catalog.inet_gist_consistent($1, $2, $3, $4, $5)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// InetGistFetch calls the stored procedure 'pg_catalog.inet_gist_fetch(internal) internal' on db.
func InetGistFetch(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.inet_gist_fetch
	const sqlstr = `SELECT pg_catalog.inet_gist_fetch($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// InetGistPenalty calls the stored procedure 'pg_catalog.inet_gist_penalty(internal, internal, internal) internal' on db.
func InetGistPenalty(ctx context.Context, db DB, v0, v1, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.inet_gist_penalty
	const sqlstr = `SELECT pg_catalog.inet_gist_penalty($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// InetGistPicksplit calls the stored procedure 'pg_catalog.inet_gist_picksplit(internal, internal) internal' on db.
func InetGistPicksplit(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.inet_gist_picksplit
	const sqlstr = `SELECT pg_catalog.inet_gist_picksplit($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// InetGistSame calls the stored procedure 'pg_catalog.inet_gist_same(inet, inet, internal) internal' on db.
func InetGistSame(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.inet_gist_same
	const sqlstr = `SELECT pg_catalog.inet_gist_same($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// InetGistUnion calls the stored procedure 'pg_catalog.inet_gist_union(internal, internal) inet' on db.
func InetGistUnion(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (string, error) {
	// call pg_catalog.inet_gist_union
	const sqlstr = `SELECT pg_catalog.inet_gist_union($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// InetIn calls the stored procedure 'pg_catalog.inet_in(cstring) inet' on db.
func InetIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (string, error) {
	// call pg_catalog.inet_in
	const sqlstr = `SELECT pg_catalog.inet_in($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// InetMerge calls the stored procedure 'pg_catalog.inet_merge(inet, inet) cidr' on db.
func InetMerge(ctx context.Context, db DB, v0, v1 string) (pgtypes.Cidr, error) {
	// call pg_catalog.inet_merge
	const sqlstr = `SELECT pg_catalog.inet_merge($1, $2)`
	// run
	var ret pgtypes.Cidr
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Cidr{}, logerror(err)
	}
	return ret, nil
}

// InetOut calls the stored procedure 'pg_catalog.inet_out(inet) cstring' on db.
func InetOut(ctx context.Context, db DB, v0 string) (pgtypes.Cstring, error) {
	// call pg_catalog.inet_out
	const sqlstr = `SELECT pg_catalog.inet_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// InetRecv calls the stored procedure 'pg_catalog.inet_recv(internal) inet' on db.
func InetRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (string, error) {
	// call pg_catalog.inet_recv
	const sqlstr = `SELECT pg_catalog.inet_recv($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// InetSameFamily calls the stored procedure 'pg_catalog.inet_same_family(inet, inet) boolean' on db.
func InetSameFamily(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.inet_same_family
	const sqlstr = `SELECT pg_catalog.inet_same_family($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// InetSend calls the stored procedure 'pg_catalog.inet_send(inet) bytea' on db.
func InetSend(ctx context.Context, db DB, v0 string) ([]byte, error) {
	// call pg_catalog.inet_send
	const sqlstr = `SELECT pg_catalog.inet_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// InetServerAddr calls the stored procedure 'pg_catalog.inet_server_addr() inet' on db.
func InetServerAddr(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.inet_server_addr
	const sqlstr = `SELECT pg_catalog.inet_server_addr()`
	// run
	var ret string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// InetServerPort calls the stored procedure 'pg_catalog.inet_server_port() integer' on db.
func InetServerPort(ctx context.Context, db DB) (int, error) {
	// call pg_catalog.inet_server_port
	const sqlstr = `SELECT pg_catalog.inet_server_port()`
	// run
	var ret int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// InetSpgChoose calls the stored procedure 'pg_catalog.inet_spg_choose(internal, internal) void' on db.
func InetSpgChoose(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.inet_spg_choose
	const sqlstr = `SELECT pg_catalog.inet_spg_choose($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// InetSpgConfig calls the stored procedure 'pg_catalog.inet_spg_config(internal, internal) void' on db.
func InetSpgConfig(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.inet_spg_config
	const sqlstr = `SELECT pg_catalog.inet_spg_config($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// InetSpgInnerConsistent calls the stored procedure 'pg_catalog.inet_spg_inner_consistent(internal, internal) void' on db.
func InetSpgInnerConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.inet_spg_inner_consistent
	const sqlstr = `SELECT pg_catalog.inet_spg_inner_consistent($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// InetSpgLeafConsistent calls the stored procedure 'pg_catalog.inet_spg_leaf_consistent(internal, internal) boolean' on db.
func InetSpgLeafConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (bool, error) {
	// call pg_catalog.inet_spg_leaf_consistent
	const sqlstr = `SELECT pg_catalog.inet_spg_leaf_consistent($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// InetSpgPicksplit calls the stored procedure 'pg_catalog.inet_spg_picksplit(internal, internal) void' on db.
func InetSpgPicksplit(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.inet_spg_picksplit
	const sqlstr = `SELECT pg_catalog.inet_spg_picksplit($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Inetand calls the stored procedure 'pg_catalog.inetand(inet, inet) inet' on db.
func Inetand(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.inetand
	const sqlstr = `SELECT pg_catalog.inetand($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Inetmi calls the stored procedure 'pg_catalog.inetmi(inet, inet) bigint' on db.
func Inetmi(ctx context.Context, db DB, v0, v1 string) (int64, error) {
	// call pg_catalog.inetmi
	const sqlstr = `SELECT pg_catalog.inetmi($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// InetmiInt8 calls the stored procedure 'pg_catalog.inetmi_int8(inet, bigint) inet' on db.
func InetmiInt8(ctx context.Context, db DB, v0 string, v1 int64) (string, error) {
	// call pg_catalog.inetmi_int8
	const sqlstr = `SELECT pg_catalog.inetmi_int8($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Inetnot calls the stored procedure 'pg_catalog.inetnot(inet) inet' on db.
func Inetnot(ctx context.Context, db DB, v0 string) (string, error) {
	// call pg_catalog.inetnot
	const sqlstr = `SELECT pg_catalog.inetnot($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Inetor calls the stored procedure 'pg_catalog.inetor(inet, inet) inet' on db.
func Inetor(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.inetor
	const sqlstr = `SELECT pg_catalog.inetor($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Inetpl calls the stored procedure 'pg_catalog.inetpl(inet, bigint) inet' on db.
func Inetpl(ctx context.Context, db DB, v0 string, v1 int64) (string, error) {
	// call pg_catalog.inetpl
	const sqlstr = `SELECT pg_catalog.inetpl($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Initcap calls the stored procedure 'pg_catalog.initcap(text) text' on db.
func Initcap(ctx context.Context, db DB, v0 string) (string, error) {
	// call pg_catalog.initcap
	const sqlstr = `SELECT pg_catalog.initcap($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Int2 calls the stored procedure 'pg_catalog.int2(bigint, integer, real, double precision, numeric, jsonb) smallint' on db.
func Int2(ctx context.Context, db DB, v0 int64, v1 int, v2 float32, v3, v4 float64, v5 []byte) (int16, error) {
	// call pg_catalog.int2
	const sqlstr = `SELECT pg_catalog.int2($1, $2, $3, $4, $5, $6)`
	// run
	var ret int16
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int24div calls the stored procedure 'pg_catalog.int24div(smallint, integer) integer' on db.
func Int24div(ctx context.Context, db DB, v0 int16, v1 int) (int, error) {
	// call pg_catalog.int24div
	const sqlstr = `SELECT pg_catalog.int24div($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int24eq calls the stored procedure 'pg_catalog.int24eq(smallint, integer) boolean' on db.
func Int24eq(ctx context.Context, db DB, v0 int16, v1 int) (bool, error) {
	// call pg_catalog.int24eq
	const sqlstr = `SELECT pg_catalog.int24eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int24ge calls the stored procedure 'pg_catalog.int24ge(smallint, integer) boolean' on db.
func Int24ge(ctx context.Context, db DB, v0 int16, v1 int) (bool, error) {
	// call pg_catalog.int24ge
	const sqlstr = `SELECT pg_catalog.int24ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int24gt calls the stored procedure 'pg_catalog.int24gt(smallint, integer) boolean' on db.
func Int24gt(ctx context.Context, db DB, v0 int16, v1 int) (bool, error) {
	// call pg_catalog.int24gt
	const sqlstr = `SELECT pg_catalog.int24gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int24le calls the stored procedure 'pg_catalog.int24le(smallint, integer) boolean' on db.
func Int24le(ctx context.Context, db DB, v0 int16, v1 int) (bool, error) {
	// call pg_catalog.int24le
	const sqlstr = `SELECT pg_catalog.int24le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int24lt calls the stored procedure 'pg_catalog.int24lt(smallint, integer) boolean' on db.
func Int24lt(ctx context.Context, db DB, v0 int16, v1 int) (bool, error) {
	// call pg_catalog.int24lt
	const sqlstr = `SELECT pg_catalog.int24lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int24mi calls the stored procedure 'pg_catalog.int24mi(smallint, integer) integer' on db.
func Int24mi(ctx context.Context, db DB, v0 int16, v1 int) (int, error) {
	// call pg_catalog.int24mi
	const sqlstr = `SELECT pg_catalog.int24mi($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int24mul calls the stored procedure 'pg_catalog.int24mul(smallint, integer) integer' on db.
func Int24mul(ctx context.Context, db DB, v0 int16, v1 int) (int, error) {
	// call pg_catalog.int24mul
	const sqlstr = `SELECT pg_catalog.int24mul($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int24ne calls the stored procedure 'pg_catalog.int24ne(smallint, integer) boolean' on db.
func Int24ne(ctx context.Context, db DB, v0 int16, v1 int) (bool, error) {
	// call pg_catalog.int24ne
	const sqlstr = `SELECT pg_catalog.int24ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int24pl calls the stored procedure 'pg_catalog.int24pl(smallint, integer) integer' on db.
func Int24pl(ctx context.Context, db DB, v0 int16, v1 int) (int, error) {
	// call pg_catalog.int24pl
	const sqlstr = `SELECT pg_catalog.int24pl($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int28div calls the stored procedure 'pg_catalog.int28div(smallint, bigint) bigint' on db.
func Int28div(ctx context.Context, db DB, v0 int16, v1 int64) (int64, error) {
	// call pg_catalog.int28div
	const sqlstr = `SELECT pg_catalog.int28div($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int28eq calls the stored procedure 'pg_catalog.int28eq(smallint, bigint) boolean' on db.
func Int28eq(ctx context.Context, db DB, v0 int16, v1 int64) (bool, error) {
	// call pg_catalog.int28eq
	const sqlstr = `SELECT pg_catalog.int28eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int28ge calls the stored procedure 'pg_catalog.int28ge(smallint, bigint) boolean' on db.
func Int28ge(ctx context.Context, db DB, v0 int16, v1 int64) (bool, error) {
	// call pg_catalog.int28ge
	const sqlstr = `SELECT pg_catalog.int28ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int28gt calls the stored procedure 'pg_catalog.int28gt(smallint, bigint) boolean' on db.
func Int28gt(ctx context.Context, db DB, v0 int16, v1 int64) (bool, error) {
	// call pg_catalog.int28gt
	const sqlstr = `SELECT pg_catalog.int28gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int28le calls the stored procedure 'pg_catalog.int28le(smallint, bigint) boolean' on db.
func Int28le(ctx context.Context, db DB, v0 int16, v1 int64) (bool, error) {
	// call pg_catalog.int28le
	const sqlstr = `SELECT pg_catalog.int28le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int28lt calls the stored procedure 'pg_catalog.int28lt(smallint, bigint) boolean' on db.
func Int28lt(ctx context.Context, db DB, v0 int16, v1 int64) (bool, error) {
	// call pg_catalog.int28lt
	const sqlstr = `SELECT pg_catalog.int28lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int28mi calls the stored procedure 'pg_catalog.int28mi(smallint, bigint) bigint' on db.
func Int28mi(ctx context.Context, db DB, v0 int16, v1 int64) (int64, error) {
	// call pg_catalog.int28mi
	const sqlstr = `SELECT pg_catalog.int28mi($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int28mul calls the stored procedure 'pg_catalog.int28mul(smallint, bigint) bigint' on db.
func Int28mul(ctx context.Context, db DB, v0 int16, v1 int64) (int64, error) {
	// call pg_catalog.int28mul
	const sqlstr = `SELECT pg_catalog.int28mul($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int28ne calls the stored procedure 'pg_catalog.int28ne(smallint, bigint) boolean' on db.
func Int28ne(ctx context.Context, db DB, v0 int16, v1 int64) (bool, error) {
	// call pg_catalog.int28ne
	const sqlstr = `SELECT pg_catalog.int28ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int28pl calls the stored procedure 'pg_catalog.int28pl(smallint, bigint) bigint' on db.
func Int28pl(ctx context.Context, db DB, v0 int16, v1 int64) (int64, error) {
	// call pg_catalog.int28pl
	const sqlstr = `SELECT pg_catalog.int28pl($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2Accum calls the stored procedure 'pg_catalog.int2_accum(internal, smallint) internal' on db.
func Int2Accum(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int16) (pgtypes.Internal, error) {
	// call pg_catalog.int2_accum
	const sqlstr = `SELECT pg_catalog.int2_accum($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Int2AccumInv calls the stored procedure 'pg_catalog.int2_accum_inv(internal, smallint) internal' on db.
func Int2AccumInv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int16) (pgtypes.Internal, error) {
	// call pg_catalog.int2_accum_inv
	const sqlstr = `SELECT pg_catalog.int2_accum_inv($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Int2AvgAccum calls the stored procedure 'pg_catalog.int2_avg_accum(bigint[], smallint) bigint[]' on db.
func Int2AvgAccum(ctx context.Context, db DB, v0 []int64, v1 int16) ([]int64, error) {
	// call pg_catalog.int2_avg_accum
	const sqlstr = `SELECT pg_catalog.int2_avg_accum($1, $2)`
	// run
	var ret []int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Int2AvgAccumInv calls the stored procedure 'pg_catalog.int2_avg_accum_inv(bigint[], smallint) bigint[]' on db.
func Int2AvgAccumInv(ctx context.Context, db DB, v0 []int64, v1 int16) ([]int64, error) {
	// call pg_catalog.int2_avg_accum_inv
	const sqlstr = `SELECT pg_catalog.int2_avg_accum_inv($1, $2)`
	// run
	var ret []int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Int2MulCash calls the stored procedure 'pg_catalog.int2_mul_cash(smallint, money) money' on db.
func Int2MulCash(ctx context.Context, db DB, v0 int16, v1 string) (string, error) {
	// call pg_catalog.int2_mul_cash
	const sqlstr = `SELECT pg_catalog.int2_mul_cash($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Int2Sum calls the stored procedure 'pg_catalog.int2_sum(bigint, smallint) bigint' on db.
func Int2Sum(ctx context.Context, db DB, v0 int64, v1 int16) (int64, error) {
	// call pg_catalog.int2_sum
	const sqlstr = `SELECT pg_catalog.int2_sum($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2abs calls the stored procedure 'pg_catalog.int2abs(smallint) smallint' on db.
func Int2abs(ctx context.Context, db DB, v0 int16) (int16, error) {
	// call pg_catalog.int2abs
	const sqlstr = `SELECT pg_catalog.int2abs($1)`
	// run
	var ret int16
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2and calls the stored procedure 'pg_catalog.int2and(smallint, smallint) smallint' on db.
func Int2and(ctx context.Context, db DB, v0, v1 int16) (int16, error) {
	// call pg_catalog.int2and
	const sqlstr = `SELECT pg_catalog.int2and($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2div calls the stored procedure 'pg_catalog.int2div(smallint, smallint) smallint' on db.
func Int2div(ctx context.Context, db DB, v0, v1 int16) (int16, error) {
	// call pg_catalog.int2div
	const sqlstr = `SELECT pg_catalog.int2div($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2eq calls the stored procedure 'pg_catalog.int2eq(smallint, smallint) boolean' on db.
func Int2eq(ctx context.Context, db DB, v0, v1 int16) (bool, error) {
	// call pg_catalog.int2eq
	const sqlstr = `SELECT pg_catalog.int2eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int2ge calls the stored procedure 'pg_catalog.int2ge(smallint, smallint) boolean' on db.
func Int2ge(ctx context.Context, db DB, v0, v1 int16) (bool, error) {
	// call pg_catalog.int2ge
	const sqlstr = `SELECT pg_catalog.int2ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int2gt calls the stored procedure 'pg_catalog.int2gt(smallint, smallint) boolean' on db.
func Int2gt(ctx context.Context, db DB, v0, v1 int16) (bool, error) {
	// call pg_catalog.int2gt
	const sqlstr = `SELECT pg_catalog.int2gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int2in calls the stored procedure 'pg_catalog.int2in(cstring) smallint' on db.
func Int2in(ctx context.Context, db DB, v0 pgtypes.Cstring) (int16, error) {
	// call pg_catalog.int2in
	const sqlstr = `SELECT pg_catalog.int2in($1)`
	// run
	var ret int16
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2int4Sum calls the stored procedure 'pg_catalog.int2int4_sum(bigint[]) bigint' on db.
func Int2int4Sum(ctx context.Context, db DB, v0 []int64) (int64, error) {
	// call pg_catalog.int2int4_sum
	const sqlstr = `SELECT pg_catalog.int2int4_sum($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2larger calls the stored procedure 'pg_catalog.int2larger(smallint, smallint) smallint' on db.
func Int2larger(ctx context.Context, db DB, v0, v1 int16) (int16, error) {
	// call pg_catalog.int2larger
	const sqlstr = `SELECT pg_catalog.int2larger($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2le calls the stored procedure 'pg_catalog.int2le(smallint, smallint) boolean' on db.
func Int2le(ctx context.Context, db DB, v0, v1 int16) (bool, error) {
	// call pg_catalog.int2le
	const sqlstr = `SELECT pg_catalog.int2le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int2lt calls the stored procedure 'pg_catalog.int2lt(smallint, smallint) boolean' on db.
func Int2lt(ctx context.Context, db DB, v0, v1 int16) (bool, error) {
	// call pg_catalog.int2lt
	const sqlstr = `SELECT pg_catalog.int2lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int2mi calls the stored procedure 'pg_catalog.int2mi(smallint, smallint) smallint' on db.
func Int2mi(ctx context.Context, db DB, v0, v1 int16) (int16, error) {
	// call pg_catalog.int2mi
	const sqlstr = `SELECT pg_catalog.int2mi($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2mod calls the stored procedure 'pg_catalog.int2mod(smallint, smallint) smallint' on db.
func Int2mod(ctx context.Context, db DB, v0, v1 int16) (int16, error) {
	// call pg_catalog.int2mod
	const sqlstr = `SELECT pg_catalog.int2mod($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2mul calls the stored procedure 'pg_catalog.int2mul(smallint, smallint) smallint' on db.
func Int2mul(ctx context.Context, db DB, v0, v1 int16) (int16, error) {
	// call pg_catalog.int2mul
	const sqlstr = `SELECT pg_catalog.int2mul($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2ne calls the stored procedure 'pg_catalog.int2ne(smallint, smallint) boolean' on db.
func Int2ne(ctx context.Context, db DB, v0, v1 int16) (bool, error) {
	// call pg_catalog.int2ne
	const sqlstr = `SELECT pg_catalog.int2ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int2not calls the stored procedure 'pg_catalog.int2not(smallint) smallint' on db.
func Int2not(ctx context.Context, db DB, v0 int16) (int16, error) {
	// call pg_catalog.int2not
	const sqlstr = `SELECT pg_catalog.int2not($1)`
	// run
	var ret int16
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2or calls the stored procedure 'pg_catalog.int2or(smallint, smallint) smallint' on db.
func Int2or(ctx context.Context, db DB, v0, v1 int16) (int16, error) {
	// call pg_catalog.int2or
	const sqlstr = `SELECT pg_catalog.int2or($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2out calls the stored procedure 'pg_catalog.int2out(smallint) cstring' on db.
func Int2out(ctx context.Context, db DB, v0 int16) (pgtypes.Cstring, error) {
	// call pg_catalog.int2out
	const sqlstr = `SELECT pg_catalog.int2out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Int2pl calls the stored procedure 'pg_catalog.int2pl(smallint, smallint) smallint' on db.
func Int2pl(ctx context.Context, db DB, v0, v1 int16) (int16, error) {
	// call pg_catalog.int2pl
	const sqlstr = `SELECT pg_catalog.int2pl($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2recv calls the stored procedure 'pg_catalog.int2recv(internal) smallint' on db.
func Int2recv(ctx context.Context, db DB, v0 pgtypes.Internal) (int16, error) {
	// call pg_catalog.int2recv
	const sqlstr = `SELECT pg_catalog.int2recv($1)`
	// run
	var ret int16
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2send calls the stored procedure 'pg_catalog.int2send(smallint) bytea' on db.
func Int2send(ctx context.Context, db DB, v0 int16) ([]byte, error) {
	// call pg_catalog.int2send
	const sqlstr = `SELECT pg_catalog.int2send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Int2shl calls the stored procedure 'pg_catalog.int2shl(smallint, integer) smallint' on db.
func Int2shl(ctx context.Context, db DB, v0 int16, v1 int) (int16, error) {
	// call pg_catalog.int2shl
	const sqlstr = `SELECT pg_catalog.int2shl($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2shr calls the stored procedure 'pg_catalog.int2shr(smallint, integer) smallint' on db.
func Int2shr(ctx context.Context, db DB, v0 int16, v1 int) (int16, error) {
	// call pg_catalog.int2shr
	const sqlstr = `SELECT pg_catalog.int2shr($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2smaller calls the stored procedure 'pg_catalog.int2smaller(smallint, smallint) smallint' on db.
func Int2smaller(ctx context.Context, db DB, v0, v1 int16) (int16, error) {
	// call pg_catalog.int2smaller
	const sqlstr = `SELECT pg_catalog.int2smaller($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2um calls the stored procedure 'pg_catalog.int2um(smallint) smallint' on db.
func Int2um(ctx context.Context, db DB, v0 int16) (int16, error) {
	// call pg_catalog.int2um
	const sqlstr = `SELECT pg_catalog.int2um($1)`
	// run
	var ret int16
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2up calls the stored procedure 'pg_catalog.int2up(smallint) smallint' on db.
func Int2up(ctx context.Context, db DB, v0 int16) (int16, error) {
	// call pg_catalog.int2up
	const sqlstr = `SELECT pg_catalog.int2up($1)`
	// run
	var ret int16
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int2vectorin calls the stored procedure 'pg_catalog.int2vectorin(cstring) int2vector' on db.
func Int2vectorin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Int2vector, error) {
	// call pg_catalog.int2vectorin
	const sqlstr = `SELECT pg_catalog.int2vectorin($1)`
	// run
	var ret pgtypes.Int2vector
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Int2vector{}, logerror(err)
	}
	return ret, nil
}

// Int2vectorout calls the stored procedure 'pg_catalog.int2vectorout(int2vector) cstring' on db.
func Int2vectorout(ctx context.Context, db DB, v0 pgtypes.Int2vector) (pgtypes.Cstring, error) {
	// call pg_catalog.int2vectorout
	const sqlstr = `SELECT pg_catalog.int2vectorout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Int2vectorrecv calls the stored procedure 'pg_catalog.int2vectorrecv(internal) int2vector' on db.
func Int2vectorrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Int2vector, error) {
	// call pg_catalog.int2vectorrecv
	const sqlstr = `SELECT pg_catalog.int2vectorrecv($1)`
	// run
	var ret pgtypes.Int2vector
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Int2vector{}, logerror(err)
	}
	return ret, nil
}

// Int2vectorsend calls the stored procedure 'pg_catalog.int2vectorsend(int2vector) bytea' on db.
func Int2vectorsend(ctx context.Context, db DB, v0 pgtypes.Int2vector) ([]byte, error) {
	// call pg_catalog.int2vectorsend
	const sqlstr = `SELECT pg_catalog.int2vectorsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Int2xor calls the stored procedure 'pg_catalog.int2xor(smallint, smallint) smallint' on db.
func Int2xor(ctx context.Context, db DB, v0, v1 int16) (int16, error) {
	// call pg_catalog.int2xor
	const sqlstr = `SELECT pg_catalog.int2xor($1, $2)`
	// run
	var ret int16
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4 calls the stored procedure 'pg_catalog.int4(boolean, "char", bigint, smallint, real, double precision, bit, numeric, jsonb) integer' on db.
func Int4(ctx context.Context, db DB, v0 bool, v1 pgtypes.Char, v2 int64, v3 int16, v4 float32, v5 float64, v6 uint8, v7 float64, v8 []byte) (int, error) {
	// call pg_catalog.int4
	const sqlstr = `SELECT pg_catalog.int4($1, $2, $3, $4, $5, $6, $7, $8, $9)`
	// run
	var ret int
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int42div calls the stored procedure 'pg_catalog.int42div(integer, smallint) integer' on db.
func Int42div(ctx context.Context, db DB, v0 int, v1 int16) (int, error) {
	// call pg_catalog.int42div
	const sqlstr = `SELECT pg_catalog.int42div($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int42eq calls the stored procedure 'pg_catalog.int42eq(integer, smallint) boolean' on db.
func Int42eq(ctx context.Context, db DB, v0 int, v1 int16) (bool, error) {
	// call pg_catalog.int42eq
	const sqlstr = `SELECT pg_catalog.int42eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int42ge calls the stored procedure 'pg_catalog.int42ge(integer, smallint) boolean' on db.
func Int42ge(ctx context.Context, db DB, v0 int, v1 int16) (bool, error) {
	// call pg_catalog.int42ge
	const sqlstr = `SELECT pg_catalog.int42ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int42gt calls the stored procedure 'pg_catalog.int42gt(integer, smallint) boolean' on db.
func Int42gt(ctx context.Context, db DB, v0 int, v1 int16) (bool, error) {
	// call pg_catalog.int42gt
	const sqlstr = `SELECT pg_catalog.int42gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int42le calls the stored procedure 'pg_catalog.int42le(integer, smallint) boolean' on db.
func Int42le(ctx context.Context, db DB, v0 int, v1 int16) (bool, error) {
	// call pg_catalog.int42le
	const sqlstr = `SELECT pg_catalog.int42le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int42lt calls the stored procedure 'pg_catalog.int42lt(integer, smallint) boolean' on db.
func Int42lt(ctx context.Context, db DB, v0 int, v1 int16) (bool, error) {
	// call pg_catalog.int42lt
	const sqlstr = `SELECT pg_catalog.int42lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int42mi calls the stored procedure 'pg_catalog.int42mi(integer, smallint) integer' on db.
func Int42mi(ctx context.Context, db DB, v0 int, v1 int16) (int, error) {
	// call pg_catalog.int42mi
	const sqlstr = `SELECT pg_catalog.int42mi($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int42mul calls the stored procedure 'pg_catalog.int42mul(integer, smallint) integer' on db.
func Int42mul(ctx context.Context, db DB, v0 int, v1 int16) (int, error) {
	// call pg_catalog.int42mul
	const sqlstr = `SELECT pg_catalog.int42mul($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int42ne calls the stored procedure 'pg_catalog.int42ne(integer, smallint) boolean' on db.
func Int42ne(ctx context.Context, db DB, v0 int, v1 int16) (bool, error) {
	// call pg_catalog.int42ne
	const sqlstr = `SELECT pg_catalog.int42ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int42pl calls the stored procedure 'pg_catalog.int42pl(integer, smallint) integer' on db.
func Int42pl(ctx context.Context, db DB, v0 int, v1 int16) (int, error) {
	// call pg_catalog.int42pl
	const sqlstr = `SELECT pg_catalog.int42pl($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int48div calls the stored procedure 'pg_catalog.int48div(integer, bigint) bigint' on db.
func Int48div(ctx context.Context, db DB, v0 int, v1 int64) (int64, error) {
	// call pg_catalog.int48div
	const sqlstr = `SELECT pg_catalog.int48div($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int48eq calls the stored procedure 'pg_catalog.int48eq(integer, bigint) boolean' on db.
func Int48eq(ctx context.Context, db DB, v0 int, v1 int64) (bool, error) {
	// call pg_catalog.int48eq
	const sqlstr = `SELECT pg_catalog.int48eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int48ge calls the stored procedure 'pg_catalog.int48ge(integer, bigint) boolean' on db.
func Int48ge(ctx context.Context, db DB, v0 int, v1 int64) (bool, error) {
	// call pg_catalog.int48ge
	const sqlstr = `SELECT pg_catalog.int48ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int48gt calls the stored procedure 'pg_catalog.int48gt(integer, bigint) boolean' on db.
func Int48gt(ctx context.Context, db DB, v0 int, v1 int64) (bool, error) {
	// call pg_catalog.int48gt
	const sqlstr = `SELECT pg_catalog.int48gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int48le calls the stored procedure 'pg_catalog.int48le(integer, bigint) boolean' on db.
func Int48le(ctx context.Context, db DB, v0 int, v1 int64) (bool, error) {
	// call pg_catalog.int48le
	const sqlstr = `SELECT pg_catalog.int48le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int48lt calls the stored procedure 'pg_catalog.int48lt(integer, bigint) boolean' on db.
func Int48lt(ctx context.Context, db DB, v0 int, v1 int64) (bool, error) {
	// call pg_catalog.int48lt
	const sqlstr = `SELECT pg_catalog.int48lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int48mi calls the stored procedure 'pg_catalog.int48mi(integer, bigint) bigint' on db.
func Int48mi(ctx context.Context, db DB, v0 int, v1 int64) (int64, error) {
	// call pg_catalog.int48mi
	const sqlstr = `SELECT pg_catalog.int48mi($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int48mul calls the stored procedure 'pg_catalog.int48mul(integer, bigint) bigint' on db.
func Int48mul(ctx context.Context, db DB, v0 int, v1 int64) (int64, error) {
	// call pg_catalog.int48mul
	const sqlstr = `SELECT pg_catalog.int48mul($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int48ne calls the stored procedure 'pg_catalog.int48ne(integer, bigint) boolean' on db.
func Int48ne(ctx context.Context, db DB, v0 int, v1 int64) (bool, error) {
	// call pg_catalog.int48ne
	const sqlstr = `SELECT pg_catalog.int48ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int48pl calls the stored procedure 'pg_catalog.int48pl(integer, bigint) bigint' on db.
func Int48pl(ctx context.Context, db DB, v0 int, v1 int64) (int64, error) {
	// call pg_catalog.int48pl
	const sqlstr = `SELECT pg_catalog.int48pl($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4Accum calls the stored procedure 'pg_catalog.int4_accum(internal, integer) internal' on db.
func Int4Accum(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int) (pgtypes.Internal, error) {
	// call pg_catalog.int4_accum
	const sqlstr = `SELECT pg_catalog.int4_accum($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Int4AccumInv calls the stored procedure 'pg_catalog.int4_accum_inv(internal, integer) internal' on db.
func Int4AccumInv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int) (pgtypes.Internal, error) {
	// call pg_catalog.int4_accum_inv
	const sqlstr = `SELECT pg_catalog.int4_accum_inv($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Int4AvgAccum calls the stored procedure 'pg_catalog.int4_avg_accum(bigint[], integer) bigint[]' on db.
func Int4AvgAccum(ctx context.Context, db DB, v0 []int64, v1 int) ([]int64, error) {
	// call pg_catalog.int4_avg_accum
	const sqlstr = `SELECT pg_catalog.int4_avg_accum($1, $2)`
	// run
	var ret []int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Int4AvgAccumInv calls the stored procedure 'pg_catalog.int4_avg_accum_inv(bigint[], integer) bigint[]' on db.
func Int4AvgAccumInv(ctx context.Context, db DB, v0 []int64, v1 int) ([]int64, error) {
	// call pg_catalog.int4_avg_accum_inv
	const sqlstr = `SELECT pg_catalog.int4_avg_accum_inv($1, $2)`
	// run
	var ret []int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Int4AvgCombine calls the stored procedure 'pg_catalog.int4_avg_combine(bigint[], bigint[]) bigint[]' on db.
func Int4AvgCombine(ctx context.Context, db DB, v0, v1 []int64) ([]int64, error) {
	// call pg_catalog.int4_avg_combine
	const sqlstr = `SELECT pg_catalog.int4_avg_combine($1, $2)`
	// run
	var ret []int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Int4MulCash calls the stored procedure 'pg_catalog.int4_mul_cash(integer, money) money' on db.
func Int4MulCash(ctx context.Context, db DB, v0 int, v1 string) (string, error) {
	// call pg_catalog.int4_mul_cash
	const sqlstr = `SELECT pg_catalog.int4_mul_cash($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Int4Sum calls the stored procedure 'pg_catalog.int4_sum(bigint, integer) bigint' on db.
func Int4Sum(ctx context.Context, db DB, v0 int64, v1 int) (int64, error) {
	// call pg_catalog.int4_sum
	const sqlstr = `SELECT pg_catalog.int4_sum($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4abs calls the stored procedure 'pg_catalog.int4abs(integer) integer' on db.
func Int4abs(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.int4abs
	const sqlstr = `SELECT pg_catalog.int4abs($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4and calls the stored procedure 'pg_catalog.int4and(integer, integer) integer' on db.
func Int4and(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4and
	const sqlstr = `SELECT pg_catalog.int4and($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4div calls the stored procedure 'pg_catalog.int4div(integer, integer) integer' on db.
func Int4div(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4div
	const sqlstr = `SELECT pg_catalog.int4div($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4eq calls the stored procedure 'pg_catalog.int4eq(integer, integer) boolean' on db.
func Int4eq(ctx context.Context, db DB, v0, v1 int) (bool, error) {
	// call pg_catalog.int4eq
	const sqlstr = `SELECT pg_catalog.int4eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int4ge calls the stored procedure 'pg_catalog.int4ge(integer, integer) boolean' on db.
func Int4ge(ctx context.Context, db DB, v0, v1 int) (bool, error) {
	// call pg_catalog.int4ge
	const sqlstr = `SELECT pg_catalog.int4ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int4gt calls the stored procedure 'pg_catalog.int4gt(integer, integer) boolean' on db.
func Int4gt(ctx context.Context, db DB, v0, v1 int) (bool, error) {
	// call pg_catalog.int4gt
	const sqlstr = `SELECT pg_catalog.int4gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int4in calls the stored procedure 'pg_catalog.int4in(cstring) integer' on db.
func Int4in(ctx context.Context, db DB, v0 pgtypes.Cstring) (int, error) {
	// call pg_catalog.int4in
	const sqlstr = `SELECT pg_catalog.int4in($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4inc calls the stored procedure 'pg_catalog.int4inc(integer) integer' on db.
func Int4inc(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.int4inc
	const sqlstr = `SELECT pg_catalog.int4inc($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4larger calls the stored procedure 'pg_catalog.int4larger(integer, integer) integer' on db.
func Int4larger(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4larger
	const sqlstr = `SELECT pg_catalog.int4larger($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4le calls the stored procedure 'pg_catalog.int4le(integer, integer) boolean' on db.
func Int4le(ctx context.Context, db DB, v0, v1 int) (bool, error) {
	// call pg_catalog.int4le
	const sqlstr = `SELECT pg_catalog.int4le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int4lt calls the stored procedure 'pg_catalog.int4lt(integer, integer) boolean' on db.
func Int4lt(ctx context.Context, db DB, v0, v1 int) (bool, error) {
	// call pg_catalog.int4lt
	const sqlstr = `SELECT pg_catalog.int4lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int4mi calls the stored procedure 'pg_catalog.int4mi(integer, integer) integer' on db.
func Int4mi(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4mi
	const sqlstr = `SELECT pg_catalog.int4mi($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4mod calls the stored procedure 'pg_catalog.int4mod(integer, integer) integer' on db.
func Int4mod(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4mod
	const sqlstr = `SELECT pg_catalog.int4mod($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4mul calls the stored procedure 'pg_catalog.int4mul(integer, integer) integer' on db.
func Int4mul(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4mul
	const sqlstr = `SELECT pg_catalog.int4mul($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4ne calls the stored procedure 'pg_catalog.int4ne(integer, integer) boolean' on db.
func Int4ne(ctx context.Context, db DB, v0, v1 int) (bool, error) {
	// call pg_catalog.int4ne
	const sqlstr = `SELECT pg_catalog.int4ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int4not calls the stored procedure 'pg_catalog.int4not(integer) integer' on db.
func Int4not(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.int4not
	const sqlstr = `SELECT pg_catalog.int4not($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4or calls the stored procedure 'pg_catalog.int4or(integer, integer) integer' on db.
func Int4or(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4or
	const sqlstr = `SELECT pg_catalog.int4or($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4out calls the stored procedure 'pg_catalog.int4out(integer) cstring' on db.
func Int4out(ctx context.Context, db DB, v0 int) (pgtypes.Cstring, error) {
	// call pg_catalog.int4out
	const sqlstr = `SELECT pg_catalog.int4out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Int4pl calls the stored procedure 'pg_catalog.int4pl(integer, integer) integer' on db.
func Int4pl(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4pl
	const sqlstr = `SELECT pg_catalog.int4pl($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4range calls the stored procedure 'pg_catalog.int4range(integer, integer, integer, integer, text) int4range' on db.
func Int4range(ctx context.Context, db DB, v0, v1, v2, v3 int, v4 string) (pgtypes.Int4range, error) {
	// call pg_catalog.int4range
	const sqlstr = `SELECT pg_catalog.int4range($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Int4range
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Int4range{}, logerror(err)
	}
	return ret, nil
}

// Int4rangeCanonical calls the stored procedure 'pg_catalog.int4range_canonical(int4range) int4range' on db.
func Int4rangeCanonical(ctx context.Context, db DB, v0 pgtypes.Int4range) (pgtypes.Int4range, error) {
	// call pg_catalog.int4range_canonical
	const sqlstr = `SELECT pg_catalog.int4range_canonical($1)`
	// run
	var ret pgtypes.Int4range
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Int4range{}, logerror(err)
	}
	return ret, nil
}

// Int4rangeSubdiff calls the stored procedure 'pg_catalog.int4range_subdiff(integer, integer) double precision' on db.
func Int4rangeSubdiff(ctx context.Context, db DB, v0, v1 int) (float64, error) {
	// call pg_catalog.int4range_subdiff
	const sqlstr = `SELECT pg_catalog.int4range_subdiff($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Int4recv calls the stored procedure 'pg_catalog.int4recv(internal) integer' on db.
func Int4recv(ctx context.Context, db DB, v0 pgtypes.Internal) (int, error) {
	// call pg_catalog.int4recv
	const sqlstr = `SELECT pg_catalog.int4recv($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4send calls the stored procedure 'pg_catalog.int4send(integer) bytea' on db.
func Int4send(ctx context.Context, db DB, v0 int) ([]byte, error) {
	// call pg_catalog.int4send
	const sqlstr = `SELECT pg_catalog.int4send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Int4shl calls the stored procedure 'pg_catalog.int4shl(integer, integer) integer' on db.
func Int4shl(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4shl
	const sqlstr = `SELECT pg_catalog.int4shl($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4shr calls the stored procedure 'pg_catalog.int4shr(integer, integer) integer' on db.
func Int4shr(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4shr
	const sqlstr = `SELECT pg_catalog.int4shr($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4smaller calls the stored procedure 'pg_catalog.int4smaller(integer, integer) integer' on db.
func Int4smaller(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4smaller
	const sqlstr = `SELECT pg_catalog.int4smaller($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4um calls the stored procedure 'pg_catalog.int4um(integer) integer' on db.
func Int4um(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.int4um
	const sqlstr = `SELECT pg_catalog.int4um($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4up calls the stored procedure 'pg_catalog.int4up(integer) integer' on db.
func Int4up(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.int4up
	const sqlstr = `SELECT pg_catalog.int4up($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int4xor calls the stored procedure 'pg_catalog.int4xor(integer, integer) integer' on db.
func Int4xor(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.int4xor
	const sqlstr = `SELECT pg_catalog.int4xor($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8 calls the stored procedure 'pg_catalog.int8(smallint, integer, oid, real, double precision, bit, numeric, jsonb) bigint' on db.
func Int8(ctx context.Context, db DB, v0 int16, v1 int, v2 pgtypes.Oid, v3 float32, v4 float64, v5 uint8, v6 float64, v7 []byte) (int64, error) {
	// call pg_catalog.int8
	const sqlstr = `SELECT pg_catalog.int8($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var ret int64
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int82div calls the stored procedure 'pg_catalog.int82div(bigint, smallint) bigint' on db.
func Int82div(ctx context.Context, db DB, v0 int64, v1 int16) (int64, error) {
	// call pg_catalog.int82div
	const sqlstr = `SELECT pg_catalog.int82div($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int82eq calls the stored procedure 'pg_catalog.int82eq(bigint, smallint) boolean' on db.
func Int82eq(ctx context.Context, db DB, v0 int64, v1 int16) (bool, error) {
	// call pg_catalog.int82eq
	const sqlstr = `SELECT pg_catalog.int82eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int82ge calls the stored procedure 'pg_catalog.int82ge(bigint, smallint) boolean' on db.
func Int82ge(ctx context.Context, db DB, v0 int64, v1 int16) (bool, error) {
	// call pg_catalog.int82ge
	const sqlstr = `SELECT pg_catalog.int82ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int82gt calls the stored procedure 'pg_catalog.int82gt(bigint, smallint) boolean' on db.
func Int82gt(ctx context.Context, db DB, v0 int64, v1 int16) (bool, error) {
	// call pg_catalog.int82gt
	const sqlstr = `SELECT pg_catalog.int82gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int82le calls the stored procedure 'pg_catalog.int82le(bigint, smallint) boolean' on db.
func Int82le(ctx context.Context, db DB, v0 int64, v1 int16) (bool, error) {
	// call pg_catalog.int82le
	const sqlstr = `SELECT pg_catalog.int82le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int82lt calls the stored procedure 'pg_catalog.int82lt(bigint, smallint) boolean' on db.
func Int82lt(ctx context.Context, db DB, v0 int64, v1 int16) (bool, error) {
	// call pg_catalog.int82lt
	const sqlstr = `SELECT pg_catalog.int82lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int82mi calls the stored procedure 'pg_catalog.int82mi(bigint, smallint) bigint' on db.
func Int82mi(ctx context.Context, db DB, v0 int64, v1 int16) (int64, error) {
	// call pg_catalog.int82mi
	const sqlstr = `SELECT pg_catalog.int82mi($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int82mul calls the stored procedure 'pg_catalog.int82mul(bigint, smallint) bigint' on db.
func Int82mul(ctx context.Context, db DB, v0 int64, v1 int16) (int64, error) {
	// call pg_catalog.int82mul
	const sqlstr = `SELECT pg_catalog.int82mul($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int82ne calls the stored procedure 'pg_catalog.int82ne(bigint, smallint) boolean' on db.
func Int82ne(ctx context.Context, db DB, v0 int64, v1 int16) (bool, error) {
	// call pg_catalog.int82ne
	const sqlstr = `SELECT pg_catalog.int82ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int82pl calls the stored procedure 'pg_catalog.int82pl(bigint, smallint) bigint' on db.
func Int82pl(ctx context.Context, db DB, v0 int64, v1 int16) (int64, error) {
	// call pg_catalog.int82pl
	const sqlstr = `SELECT pg_catalog.int82pl($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int84div calls the stored procedure 'pg_catalog.int84div(bigint, integer) bigint' on db.
func Int84div(ctx context.Context, db DB, v0 int64, v1 int) (int64, error) {
	// call pg_catalog.int84div
	const sqlstr = `SELECT pg_catalog.int84div($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int84eq calls the stored procedure 'pg_catalog.int84eq(bigint, integer) boolean' on db.
func Int84eq(ctx context.Context, db DB, v0 int64, v1 int) (bool, error) {
	// call pg_catalog.int84eq
	const sqlstr = `SELECT pg_catalog.int84eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int84ge calls the stored procedure 'pg_catalog.int84ge(bigint, integer) boolean' on db.
func Int84ge(ctx context.Context, db DB, v0 int64, v1 int) (bool, error) {
	// call pg_catalog.int84ge
	const sqlstr = `SELECT pg_catalog.int84ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int84gt calls the stored procedure 'pg_catalog.int84gt(bigint, integer) boolean' on db.
func Int84gt(ctx context.Context, db DB, v0 int64, v1 int) (bool, error) {
	// call pg_catalog.int84gt
	const sqlstr = `SELECT pg_catalog.int84gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int84le calls the stored procedure 'pg_catalog.int84le(bigint, integer) boolean' on db.
func Int84le(ctx context.Context, db DB, v0 int64, v1 int) (bool, error) {
	// call pg_catalog.int84le
	const sqlstr = `SELECT pg_catalog.int84le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int84lt calls the stored procedure 'pg_catalog.int84lt(bigint, integer) boolean' on db.
func Int84lt(ctx context.Context, db DB, v0 int64, v1 int) (bool, error) {
	// call pg_catalog.int84lt
	const sqlstr = `SELECT pg_catalog.int84lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int84mi calls the stored procedure 'pg_catalog.int84mi(bigint, integer) bigint' on db.
func Int84mi(ctx context.Context, db DB, v0 int64, v1 int) (int64, error) {
	// call pg_catalog.int84mi
	const sqlstr = `SELECT pg_catalog.int84mi($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int84mul calls the stored procedure 'pg_catalog.int84mul(bigint, integer) bigint' on db.
func Int84mul(ctx context.Context, db DB, v0 int64, v1 int) (int64, error) {
	// call pg_catalog.int84mul
	const sqlstr = `SELECT pg_catalog.int84mul($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int84ne calls the stored procedure 'pg_catalog.int84ne(bigint, integer) boolean' on db.
func Int84ne(ctx context.Context, db DB, v0 int64, v1 int) (bool, error) {
	// call pg_catalog.int84ne
	const sqlstr = `SELECT pg_catalog.int84ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int84pl calls the stored procedure 'pg_catalog.int84pl(bigint, integer) bigint' on db.
func Int84pl(ctx context.Context, db DB, v0 int64, v1 int) (int64, error) {
	// call pg_catalog.int84pl
	const sqlstr = `SELECT pg_catalog.int84pl($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8Accum calls the stored procedure 'pg_catalog.int8_accum(internal, bigint) internal' on db.
func Int8Accum(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int64) (pgtypes.Internal, error) {
	// call pg_catalog.int8_accum
	const sqlstr = `SELECT pg_catalog.int8_accum($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Int8AccumInv calls the stored procedure 'pg_catalog.int8_accum_inv(internal, bigint) internal' on db.
func Int8AccumInv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int64) (pgtypes.Internal, error) {
	// call pg_catalog.int8_accum_inv
	const sqlstr = `SELECT pg_catalog.int8_accum_inv($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Int8Avg calls the stored procedure 'pg_catalog.int8_avg(bigint[]) numeric' on db.
func Int8Avg(ctx context.Context, db DB, v0 []int64) (float64, error) {
	// call pg_catalog.int8_avg
	const sqlstr = `SELECT pg_catalog.int8_avg($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Int8AvgAccum calls the stored procedure 'pg_catalog.int8_avg_accum(internal, bigint) internal' on db.
func Int8AvgAccum(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int64) (pgtypes.Internal, error) {
	// call pg_catalog.int8_avg_accum
	const sqlstr = `SELECT pg_catalog.int8_avg_accum($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Int8AvgAccumInv calls the stored procedure 'pg_catalog.int8_avg_accum_inv(internal, bigint) internal' on db.
func Int8AvgAccumInv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int64) (pgtypes.Internal, error) {
	// call pg_catalog.int8_avg_accum_inv
	const sqlstr = `SELECT pg_catalog.int8_avg_accum_inv($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Int8AvgCombine calls the stored procedure 'pg_catalog.int8_avg_combine(internal, internal) internal' on db.
func Int8AvgCombine(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.int8_avg_combine
	const sqlstr = `SELECT pg_catalog.int8_avg_combine($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Int8AvgDeserialize calls the stored procedure 'pg_catalog.int8_avg_deserialize(bytea, internal) internal' on db.
func Int8AvgDeserialize(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.int8_avg_deserialize
	const sqlstr = `SELECT pg_catalog.int8_avg_deserialize($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Int8AvgSerialize calls the stored procedure 'pg_catalog.int8_avg_serialize(internal) bytea' on db.
func Int8AvgSerialize(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.int8_avg_serialize
	const sqlstr = `SELECT pg_catalog.int8_avg_serialize($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Int8MulCash calls the stored procedure 'pg_catalog.int8_mul_cash(bigint, money) money' on db.
func Int8MulCash(ctx context.Context, db DB, v0 int64, v1 string) (string, error) {
	// call pg_catalog.int8_mul_cash
	const sqlstr = `SELECT pg_catalog.int8_mul_cash($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Int8Sum calls the stored procedure 'pg_catalog.int8_sum(numeric, bigint) numeric' on db.
func Int8Sum(ctx context.Context, db DB, v0 float64, v1 int64) (float64, error) {
	// call pg_catalog.int8_sum
	const sqlstr = `SELECT pg_catalog.int8_sum($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Int8abs calls the stored procedure 'pg_catalog.int8abs(bigint) bigint' on db.
func Int8abs(ctx context.Context, db DB, v0 int64) (int64, error) {
	// call pg_catalog.int8abs
	const sqlstr = `SELECT pg_catalog.int8abs($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8and calls the stored procedure 'pg_catalog.int8and(bigint, bigint) bigint' on db.
func Int8and(ctx context.Context, db DB, v0, v1 int64) (int64, error) {
	// call pg_catalog.int8and
	const sqlstr = `SELECT pg_catalog.int8and($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8dec calls the stored procedure 'pg_catalog.int8dec(bigint) bigint' on db.
func Int8dec(ctx context.Context, db DB, v0 int64) (int64, error) {
	// call pg_catalog.int8dec
	const sqlstr = `SELECT pg_catalog.int8dec($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8decAny calls the stored procedure 'pg_catalog.int8dec_any(bigint, "any") bigint' on db.
func Int8decAny(ctx context.Context, db DB, v0 int64, v1 pgtypes.Any) (int64, error) {
	// call pg_catalog.int8dec_any
	const sqlstr = `SELECT pg_catalog.int8dec_any($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8div calls the stored procedure 'pg_catalog.int8div(bigint, bigint) bigint' on db.
func Int8div(ctx context.Context, db DB, v0, v1 int64) (int64, error) {
	// call pg_catalog.int8div
	const sqlstr = `SELECT pg_catalog.int8div($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8eq calls the stored procedure 'pg_catalog.int8eq(bigint, bigint) boolean' on db.
func Int8eq(ctx context.Context, db DB, v0, v1 int64) (bool, error) {
	// call pg_catalog.int8eq
	const sqlstr = `SELECT pg_catalog.int8eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int8ge calls the stored procedure 'pg_catalog.int8ge(bigint, bigint) boolean' on db.
func Int8ge(ctx context.Context, db DB, v0, v1 int64) (bool, error) {
	// call pg_catalog.int8ge
	const sqlstr = `SELECT pg_catalog.int8ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int8gt calls the stored procedure 'pg_catalog.int8gt(bigint, bigint) boolean' on db.
func Int8gt(ctx context.Context, db DB, v0, v1 int64) (bool, error) {
	// call pg_catalog.int8gt
	const sqlstr = `SELECT pg_catalog.int8gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int8in calls the stored procedure 'pg_catalog.int8in(cstring) bigint' on db.
func Int8in(ctx context.Context, db DB, v0 pgtypes.Cstring) (int64, error) {
	// call pg_catalog.int8in
	const sqlstr = `SELECT pg_catalog.int8in($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8inc calls the stored procedure 'pg_catalog.int8inc(bigint) bigint' on db.
func Int8inc(ctx context.Context, db DB, v0 int64) (int64, error) {
	// call pg_catalog.int8inc
	const sqlstr = `SELECT pg_catalog.int8inc($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8incAny calls the stored procedure 'pg_catalog.int8inc_any(bigint, "any") bigint' on db.
func Int8incAny(ctx context.Context, db DB, v0 int64, v1 pgtypes.Any) (int64, error) {
	// call pg_catalog.int8inc_any
	const sqlstr = `SELECT pg_catalog.int8inc_any($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8incFloat8Float8 calls the stored procedure 'pg_catalog.int8inc_float8_float8(bigint, double precision, double precision) bigint' on db.
func Int8incFloat8Float8(ctx context.Context, db DB, v0 int64, v1, v2 float64) (int64, error) {
	// call pg_catalog.int8inc_float8_float8
	const sqlstr = `SELECT pg_catalog.int8inc_float8_float8($1, $2, $3)`
	// run
	var ret int64
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8larger calls the stored procedure 'pg_catalog.int8larger(bigint, bigint) bigint' on db.
func Int8larger(ctx context.Context, db DB, v0, v1 int64) (int64, error) {
	// call pg_catalog.int8larger
	const sqlstr = `SELECT pg_catalog.int8larger($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8le calls the stored procedure 'pg_catalog.int8le(bigint, bigint) boolean' on db.
func Int8le(ctx context.Context, db DB, v0, v1 int64) (bool, error) {
	// call pg_catalog.int8le
	const sqlstr = `SELECT pg_catalog.int8le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int8lt calls the stored procedure 'pg_catalog.int8lt(bigint, bigint) boolean' on db.
func Int8lt(ctx context.Context, db DB, v0, v1 int64) (bool, error) {
	// call pg_catalog.int8lt
	const sqlstr = `SELECT pg_catalog.int8lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int8mi calls the stored procedure 'pg_catalog.int8mi(bigint, bigint) bigint' on db.
func Int8mi(ctx context.Context, db DB, v0, v1 int64) (int64, error) {
	// call pg_catalog.int8mi
	const sqlstr = `SELECT pg_catalog.int8mi($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8mod calls the stored procedure 'pg_catalog.int8mod(bigint, bigint) bigint' on db.
func Int8mod(ctx context.Context, db DB, v0, v1 int64) (int64, error) {
	// call pg_catalog.int8mod
	const sqlstr = `SELECT pg_catalog.int8mod($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8mul calls the stored procedure 'pg_catalog.int8mul(bigint, bigint) bigint' on db.
func Int8mul(ctx context.Context, db DB, v0, v1 int64) (int64, error) {
	// call pg_catalog.int8mul
	const sqlstr = `SELECT pg_catalog.int8mul($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8ne calls the stored procedure 'pg_catalog.int8ne(bigint, bigint) boolean' on db.
func Int8ne(ctx context.Context, db DB, v0, v1 int64) (bool, error) {
	// call pg_catalog.int8ne
	const sqlstr = `SELECT pg_catalog.int8ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Int8not calls the stored procedure 'pg_catalog.int8not(bigint) bigint' on db.
func Int8not(ctx context.Context, db DB, v0 int64) (int64, error) {
	// call pg_catalog.int8not
	const sqlstr = `SELECT pg_catalog.int8not($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8or calls the stored procedure 'pg_catalog.int8or(bigint, bigint) bigint' on db.
func Int8or(ctx context.Context, db DB, v0, v1 int64) (int64, error) {
	// call pg_catalog.int8or
	const sqlstr = `SELECT pg_catalog.int8or($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8out calls the stored procedure 'pg_catalog.int8out(bigint) cstring' on db.
func Int8out(ctx context.Context, db DB, v0 int64) (pgtypes.Cstring, error) {
	// call pg_catalog.int8out
	const sqlstr = `SELECT pg_catalog.int8out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Int8pl calls the stored procedure 'pg_catalog.int8pl(bigint, bigint) bigint' on db.
func Int8pl(ctx context.Context, db DB, v0, v1 int64) (int64, error) {
	// call pg_catalog.int8pl
	const sqlstr = `SELECT pg_catalog.int8pl($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8plInet calls the stored procedure 'pg_catalog.int8pl_inet(bigint, inet) inet' on db.
func Int8plInet(ctx context.Context, db DB, v0 int64, v1 string) (string, error) {
	// call pg_catalog.int8pl_inet
	const sqlstr = `SELECT pg_catalog.int8pl_inet($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Int8range calls the stored procedure 'pg_catalog.int8range(bigint, bigint, bigint, bigint, text) int8range' on db.
func Int8range(ctx context.Context, db DB, v0, v1, v2, v3 int64, v4 string) (pgtypes.Int8range, error) {
	// call pg_catalog.int8range
	const sqlstr = `SELECT pg_catalog.int8range($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Int8range
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Int8range{}, logerror(err)
	}
	return ret, nil
}

// Int8rangeCanonical calls the stored procedure 'pg_catalog.int8range_canonical(int8range) int8range' on db.
func Int8rangeCanonical(ctx context.Context, db DB, v0 pgtypes.Int8range) (pgtypes.Int8range, error) {
	// call pg_catalog.int8range_canonical
	const sqlstr = `SELECT pg_catalog.int8range_canonical($1)`
	// run
	var ret pgtypes.Int8range
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Int8range{}, logerror(err)
	}
	return ret, nil
}

// Int8rangeSubdiff calls the stored procedure 'pg_catalog.int8range_subdiff(bigint, bigint) double precision' on db.
func Int8rangeSubdiff(ctx context.Context, db DB, v0, v1 int64) (float64, error) {
	// call pg_catalog.int8range_subdiff
	const sqlstr = `SELECT pg_catalog.int8range_subdiff($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Int8recv calls the stored procedure 'pg_catalog.int8recv(internal) bigint' on db.
func Int8recv(ctx context.Context, db DB, v0 pgtypes.Internal) (int64, error) {
	// call pg_catalog.int8recv
	const sqlstr = `SELECT pg_catalog.int8recv($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8send calls the stored procedure 'pg_catalog.int8send(bigint) bytea' on db.
func Int8send(ctx context.Context, db DB, v0 int64) ([]byte, error) {
	// call pg_catalog.int8send
	const sqlstr = `SELECT pg_catalog.int8send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Int8shl calls the stored procedure 'pg_catalog.int8shl(bigint, integer) bigint' on db.
func Int8shl(ctx context.Context, db DB, v0 int64, v1 int) (int64, error) {
	// call pg_catalog.int8shl
	const sqlstr = `SELECT pg_catalog.int8shl($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8shr calls the stored procedure 'pg_catalog.int8shr(bigint, integer) bigint' on db.
func Int8shr(ctx context.Context, db DB, v0 int64, v1 int) (int64, error) {
	// call pg_catalog.int8shr
	const sqlstr = `SELECT pg_catalog.int8shr($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8smaller calls the stored procedure 'pg_catalog.int8smaller(bigint, bigint) bigint' on db.
func Int8smaller(ctx context.Context, db DB, v0, v1 int64) (int64, error) {
	// call pg_catalog.int8smaller
	const sqlstr = `SELECT pg_catalog.int8smaller($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8um calls the stored procedure 'pg_catalog.int8um(bigint) bigint' on db.
func Int8um(ctx context.Context, db DB, v0 int64) (int64, error) {
	// call pg_catalog.int8um
	const sqlstr = `SELECT pg_catalog.int8um($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8up calls the stored procedure 'pg_catalog.int8up(bigint) bigint' on db.
func Int8up(ctx context.Context, db DB, v0 int64) (int64, error) {
	// call pg_catalog.int8up
	const sqlstr = `SELECT pg_catalog.int8up($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Int8xor calls the stored procedure 'pg_catalog.int8xor(bigint, bigint) bigint' on db.
func Int8xor(ctx context.Context, db DB, v0, v1 int64) (int64, error) {
	// call pg_catalog.int8xor
	const sqlstr = `SELECT pg_catalog.int8xor($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// IntegerPlDate calls the stored procedure 'pg_catalog.integer_pl_date(integer, date) date' on db.
func IntegerPlDate(ctx context.Context, db DB, v0 int, v1 time.Time) (time.Time, error) {
	// call pg_catalog.integer_pl_date
	const sqlstr = `SELECT pg_catalog.integer_pl_date($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// InterLb calls the stored procedure 'pg_catalog.inter_lb(line, box) boolean' on db.
func InterLb(ctx context.Context, db DB, v0 pgtypes.Line, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.inter_lb
	const sqlstr = `SELECT pg_catalog.inter_lb($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// InterSb calls the stored procedure 'pg_catalog.inter_sb(lseg, box) boolean' on db.
func InterSb(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.inter_sb
	const sqlstr = `SELECT pg_catalog.inter_sb($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// InterSl calls the stored procedure 'pg_catalog.inter_sl(lseg, line) boolean' on db.
func InterSl(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Line) (bool, error) {
	// call pg_catalog.inter_sl
	const sqlstr = `SELECT pg_catalog.inter_sl($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// InternalIn calls the stored procedure 'pg_catalog.internal_in(cstring) internal' on db.
func InternalIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Internal, error) {
	// call pg_catalog.internal_in
	const sqlstr = `SELECT pg_catalog.internal_in($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// InternalOut calls the stored procedure 'pg_catalog.internal_out(internal) cstring' on db.
func InternalOut(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Cstring, error) {
	// call pg_catalog.internal_out
	const sqlstr = `SELECT pg_catalog.internal_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Interval calls the stored procedure 'pg_catalog.interval(time without time zone, interval, integer) interval' on db.
func Interval(ctx context.Context, db DB, v0 time.Time, v1 []byte, v2 int) ([]byte, error) {
	// call pg_catalog.interval
	const sqlstr = `SELECT pg_catalog.interval($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalAccum calls the stored procedure 'pg_catalog.interval_accum(interval[], interval) interval[]' on db.
func IntervalAccum(ctx context.Context, db DB, v0, v1 []byte) ([]byte, error) {
	// call pg_catalog.interval_accum
	const sqlstr = `SELECT pg_catalog.interval_accum($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalAccumInv calls the stored procedure 'pg_catalog.interval_accum_inv(interval[], interval) interval[]' on db.
func IntervalAccumInv(ctx context.Context, db DB, v0, v1 []byte) ([]byte, error) {
	// call pg_catalog.interval_accum_inv
	const sqlstr = `SELECT pg_catalog.interval_accum_inv($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalAvg calls the stored procedure 'pg_catalog.interval_avg(interval[]) interval' on db.
func IntervalAvg(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.interval_avg
	const sqlstr = `SELECT pg_catalog.interval_avg($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalCmp calls the stored procedure 'pg_catalog.interval_cmp(interval, interval) integer' on db.
func IntervalCmp(ctx context.Context, db DB, v0, v1 []byte) (int, error) {
	// call pg_catalog.interval_cmp
	const sqlstr = `SELECT pg_catalog.interval_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// IntervalCombine calls the stored procedure 'pg_catalog.interval_combine(interval[], interval[]) interval[]' on db.
func IntervalCombine(ctx context.Context, db DB, v0, v1 []byte) ([]byte, error) {
	// call pg_catalog.interval_combine
	const sqlstr = `SELECT pg_catalog.interval_combine($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalDiv calls the stored procedure 'pg_catalog.interval_div(interval, double precision) interval' on db.
func IntervalDiv(ctx context.Context, db DB, v0 []byte, v1 float64) ([]byte, error) {
	// call pg_catalog.interval_div
	const sqlstr = `SELECT pg_catalog.interval_div($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalEq calls the stored procedure 'pg_catalog.interval_eq(interval, interval) boolean' on db.
func IntervalEq(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.interval_eq
	const sqlstr = `SELECT pg_catalog.interval_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// IntervalGe calls the stored procedure 'pg_catalog.interval_ge(interval, interval) boolean' on db.
func IntervalGe(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.interval_ge
	const sqlstr = `SELECT pg_catalog.interval_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// IntervalGt calls the stored procedure 'pg_catalog.interval_gt(interval, interval) boolean' on db.
func IntervalGt(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.interval_gt
	const sqlstr = `SELECT pg_catalog.interval_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// IntervalHash calls the stored procedure 'pg_catalog.interval_hash(interval) integer' on db.
func IntervalHash(ctx context.Context, db DB, v0 []byte) (int, error) {
	// call pg_catalog.interval_hash
	const sqlstr = `SELECT pg_catalog.interval_hash($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// IntervalHashExtended calls the stored procedure 'pg_catalog.interval_hash_extended(interval, bigint) bigint' on db.
func IntervalHashExtended(ctx context.Context, db DB, v0 []byte, v1 int64) (int64, error) {
	// call pg_catalog.interval_hash_extended
	const sqlstr = `SELECT pg_catalog.interval_hash_extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// IntervalIn calls the stored procedure 'pg_catalog.interval_in(cstring, oid, integer) interval' on db.
func IntervalIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) ([]byte, error) {
	// call pg_catalog.interval_in
	const sqlstr = `SELECT pg_catalog.interval_in($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalLarger calls the stored procedure 'pg_catalog.interval_larger(interval, interval) interval' on db.
func IntervalLarger(ctx context.Context, db DB, v0, v1 []byte) ([]byte, error) {
	// call pg_catalog.interval_larger
	const sqlstr = `SELECT pg_catalog.interval_larger($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalLe calls the stored procedure 'pg_catalog.interval_le(interval, interval) boolean' on db.
func IntervalLe(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.interval_le
	const sqlstr = `SELECT pg_catalog.interval_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// IntervalLt calls the stored procedure 'pg_catalog.interval_lt(interval, interval) boolean' on db.
func IntervalLt(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.interval_lt
	const sqlstr = `SELECT pg_catalog.interval_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// IntervalMi calls the stored procedure 'pg_catalog.interval_mi(interval, interval) interval' on db.
func IntervalMi(ctx context.Context, db DB, v0, v1 []byte) ([]byte, error) {
	// call pg_catalog.interval_mi
	const sqlstr = `SELECT pg_catalog.interval_mi($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalMul calls the stored procedure 'pg_catalog.interval_mul(interval, double precision) interval' on db.
func IntervalMul(ctx context.Context, db DB, v0 []byte, v1 float64) ([]byte, error) {
	// call pg_catalog.interval_mul
	const sqlstr = `SELECT pg_catalog.interval_mul($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalNe calls the stored procedure 'pg_catalog.interval_ne(interval, interval) boolean' on db.
func IntervalNe(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.interval_ne
	const sqlstr = `SELECT pg_catalog.interval_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// IntervalOut calls the stored procedure 'pg_catalog.interval_out(interval) cstring' on db.
func IntervalOut(ctx context.Context, db DB, v0 []byte) (pgtypes.Cstring, error) {
	// call pg_catalog.interval_out
	const sqlstr = `SELECT pg_catalog.interval_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// IntervalPl calls the stored procedure 'pg_catalog.interval_pl(interval, interval) interval' on db.
func IntervalPl(ctx context.Context, db DB, v0, v1 []byte) ([]byte, error) {
	// call pg_catalog.interval_pl
	const sqlstr = `SELECT pg_catalog.interval_pl($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalPlDate calls the stored procedure 'pg_catalog.interval_pl_date(interval, date) timestamp without time zone' on db.
func IntervalPlDate(ctx context.Context, db DB, v0 []byte, v1 time.Time) (time.Time, error) {
	// call pg_catalog.interval_pl_date
	const sqlstr = `SELECT pg_catalog.interval_pl_date($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// IntervalPlTime calls the stored procedure 'pg_catalog.interval_pl_time(interval, time without time zone) time without time zone' on db.
func IntervalPlTime(ctx context.Context, db DB, v0 []byte, v1 time.Time) (time.Time, error) {
	// call pg_catalog.interval_pl_time
	const sqlstr = `SELECT pg_catalog.interval_pl_time($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// IntervalPlTimestamp calls the stored procedure 'pg_catalog.interval_pl_timestamp(interval, timestamp without time zone) timestamp without time zone' on db.
func IntervalPlTimestamp(ctx context.Context, db DB, v0 []byte, v1 time.Time) (time.Time, error) {
	// call pg_catalog.interval_pl_timestamp
	const sqlstr = `SELECT pg_catalog.interval_pl_timestamp($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// IntervalPlTimestamptz calls the stored procedure 'pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) timestamp with time zone' on db.
func IntervalPlTimestamptz(ctx context.Context, db DB, v0 []byte, v1 time.Time) (time.Time, error) {
	// call pg_catalog.interval_pl_timestamptz
	const sqlstr = `SELECT pg_catalog.interval_pl_timestamptz($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// IntervalPlTimetz calls the stored procedure 'pg_catalog.interval_pl_timetz(interval, time with time zone) time with time zone' on db.
func IntervalPlTimetz(ctx context.Context, db DB, v0 []byte, v1 time.Time) (time.Time, error) {
	// call pg_catalog.interval_pl_timetz
	const sqlstr = `SELECT pg_catalog.interval_pl_timetz($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// IntervalRecv calls the stored procedure 'pg_catalog.interval_recv(internal, oid, integer) interval' on db.
func IntervalRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) ([]byte, error) {
	// call pg_catalog.interval_recv
	const sqlstr = `SELECT pg_catalog.interval_recv($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalSend calls the stored procedure 'pg_catalog.interval_send(interval) bytea' on db.
func IntervalSend(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.interval_send
	const sqlstr = `SELECT pg_catalog.interval_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalSmaller calls the stored procedure 'pg_catalog.interval_smaller(interval, interval) interval' on db.
func IntervalSmaller(ctx context.Context, db DB, v0, v1 []byte) ([]byte, error) {
	// call pg_catalog.interval_smaller
	const sqlstr = `SELECT pg_catalog.interval_smaller($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// IntervalSupport calls the stored procedure 'pg_catalog.interval_support(internal) internal' on db.
func IntervalSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.interval_support
	const sqlstr = `SELECT pg_catalog.interval_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// IntervalUm calls the stored procedure 'pg_catalog.interval_um(interval) interval' on db.
func IntervalUm(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.interval_um
	const sqlstr = `SELECT pg_catalog.interval_um($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Intervaltypmodin calls the stored procedure 'pg_catalog.intervaltypmodin(cstring[]) integer' on db.
func Intervaltypmodin(ctx context.Context, db DB, v0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.intervaltypmodin
	const sqlstr = `SELECT pg_catalog.intervaltypmodin($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Intervaltypmodout calls the stored procedure 'pg_catalog.intervaltypmodout(integer) cstring' on db.
func Intervaltypmodout(ctx context.Context, db DB, v0 int) (pgtypes.Cstring, error) {
	// call pg_catalog.intervaltypmodout
	const sqlstr = `SELECT pg_catalog.intervaltypmodout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// IsNormalized calls the stored procedure 'pg_catalog.is_normalized(text, text) boolean' on db.
func IsNormalized(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.is_normalized
	const sqlstr = `SELECT pg_catalog.is_normalized($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Isclosed calls the stored procedure 'pg_catalog.isclosed(path) boolean' on db.
func Isclosed(ctx context.Context, db DB, v0 pgtypes.Path) (bool, error) {
	// call pg_catalog.isclosed
	const sqlstr = `SELECT pg_catalog.isclosed($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Isempty calls the stored procedure 'pg_catalog.isempty(anyrange) boolean' on db.
func Isempty(ctx context.Context, db DB, v0 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.isempty
	const sqlstr = `SELECT pg_catalog.isempty($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Isfinite calls the stored procedure 'pg_catalog.isfinite(date, timestamp without time zone, timestamp with time zone, interval) boolean' on db.
func Isfinite(ctx context.Context, db DB, v0, v1, v2 time.Time, v3 []byte) (bool, error) {
	// call pg_catalog.isfinite
	const sqlstr = `SELECT pg_catalog.isfinite($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Ishorizontal calls the stored procedure 'pg_catalog.ishorizontal(lseg, line, point, point) boolean' on db.
func Ishorizontal(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Line, v2, v3 pgtypes.Point) (bool, error) {
	// call pg_catalog.ishorizontal
	const sqlstr = `SELECT pg_catalog.ishorizontal($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Iso88591ToUTF8 calls the stored procedure 'pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func Iso88591ToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.iso8859_1_to_utf8
	const sqlstr = `SELECT pg_catalog.iso8859_1_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Iso8859ToUTF8 calls the stored procedure 'pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func Iso8859ToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.iso8859_to_utf8
	const sqlstr = `SELECT pg_catalog.iso8859_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// IsoToKoi8r calls the stored procedure 'pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer) void' on db.
func IsoToKoi8r(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.iso_to_koi8r
	const sqlstr = `SELECT pg_catalog.iso_to_koi8r($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// IsoToMic calls the stored procedure 'pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer) void' on db.
func IsoToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.iso_to_mic
	const sqlstr = `SELECT pg_catalog.iso_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// IsoToWin1251 calls the stored procedure 'pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer) void' on db.
func IsoToWin1251(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.iso_to_win1251
	const sqlstr = `SELECT pg_catalog.iso_to_win1251($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// IsoToWin866 calls the stored procedure 'pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer) void' on db.
func IsoToWin866(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.iso_to_win866
	const sqlstr = `SELECT pg_catalog.iso_to_win866($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Isopen calls the stored procedure 'pg_catalog.isopen(path) boolean' on db.
func Isopen(ctx context.Context, db DB, v0 pgtypes.Path) (bool, error) {
	// call pg_catalog.isopen
	const sqlstr = `SELECT pg_catalog.isopen($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Isparallel calls the stored procedure 'pg_catalog.isparallel(lseg, lseg, line, line) boolean' on db.
func Isparallel(ctx context.Context, db DB, v0, v1 pgtypes.Lseg, v2, v3 pgtypes.Line) (bool, error) {
	// call pg_catalog.isparallel
	const sqlstr = `SELECT pg_catalog.isparallel($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Isperp calls the stored procedure 'pg_catalog.isperp(lseg, lseg, line, line) boolean' on db.
func Isperp(ctx context.Context, db DB, v0, v1 pgtypes.Lseg, v2, v3 pgtypes.Line) (bool, error) {
	// call pg_catalog.isperp
	const sqlstr = `SELECT pg_catalog.isperp($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Isvertical calls the stored procedure 'pg_catalog.isvertical(lseg, line, point, point) boolean' on db.
func Isvertical(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Line, v2, v3 pgtypes.Point) (bool, error) {
	// call pg_catalog.isvertical
	const sqlstr = `SELECT pg_catalog.isvertical($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JSONAgg calls the stored procedure 'pg_catalog.json_agg(anyelement) json' on db.
func JSONAgg(ctx context.Context, db DB, v0 pgtypes.Anyelement) ([]byte, error) {
	// call pg_catalog.json_agg
	const sqlstr = `SELECT pg_catalog.json_agg($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONAggFinalfn calls the stored procedure 'pg_catalog.json_agg_finalfn(internal) json' on db.
func JSONAggFinalfn(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.json_agg_finalfn
	const sqlstr = `SELECT pg_catalog.json_agg_finalfn($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONAggTransfn calls the stored procedure 'pg_catalog.json_agg_transfn(internal, anyelement) internal' on db.
func JSONAggTransfn(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Anyelement) (pgtypes.Internal, error) {
	// call pg_catalog.json_agg_transfn
	const sqlstr = `SELECT pg_catalog.json_agg_transfn($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// JSONArrayElement calls the stored procedure 'pg_catalog.json_array_element(json, integer) json' on db.
func JSONArrayElement(ctx context.Context, db DB, v0 []byte, v1 int) ([]byte, error) {
	// call pg_catalog.json_array_element
	const sqlstr = `SELECT pg_catalog.json_array_element($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONArrayElementText calls the stored procedure 'pg_catalog.json_array_element_text(json, integer) text' on db.
func JSONArrayElementText(ctx context.Context, db DB, v0 []byte, v1 int) (string, error) {
	// call pg_catalog.json_array_element_text
	const sqlstr = `SELECT pg_catalog.json_array_element_text($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// JSONArrayElements calls the stored procedure 'pg_catalog.json_array_elements(json) SETOF json' on db.
func JSONArrayElements(ctx context.Context, db DB, v0 []byte) ([][]byte, error) {
	// call pg_catalog.json_array_elements
	const sqlstr = `SELECT pg_catalog.json_array_elements($1)`
	// run
	var ret [][]byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONArrayElementsText calls the stored procedure 'pg_catalog.json_array_elements_text(json) SETOF text' on db.
func JSONArrayElementsText(ctx context.Context, db DB, v0 []byte) ([]string, error) {
	// call pg_catalog.json_array_elements_text
	const sqlstr = `SELECT pg_catalog.json_array_elements_text($1)`
	// run
	var ret []string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONArrayLength calls the stored procedure 'pg_catalog.json_array_length(json) integer' on db.
func JSONArrayLength(ctx context.Context, db DB, v0 []byte) (int, error) {
	// call pg_catalog.json_array_length
	const sqlstr = `SELECT pg_catalog.json_array_length($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// JSONBuildArray calls the stored procedure 'pg_catalog.json_build_array("any") json' on db.
func JSONBuildArray(ctx context.Context, db DB, v0 pgtypes.Any) ([]byte, error) {
	// call pg_catalog.json_build_array
	const sqlstr = `SELECT pg_catalog.json_build_array($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONBuildObject calls the stored procedure 'pg_catalog.json_build_object("any") json' on db.
func JSONBuildObject(ctx context.Context, db DB, v0 pgtypes.Any) ([]byte, error) {
	// call pg_catalog.json_build_object
	const sqlstr = `SELECT pg_catalog.json_build_object($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONEach calls the stored procedure 'pg_catalog.json_each(json) SETOF record' on db.
func JSONEach(ctx context.Context, db DB, v0 []byte) ([]pgtypes.Record, error) {
	// call pg_catalog.json_each
	const sqlstr = `SELECT pg_catalog.json_each($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONEachText calls the stored procedure 'pg_catalog.json_each_text(json) SETOF record' on db.
func JSONEachText(ctx context.Context, db DB, v0 []byte) ([]pgtypes.Record, error) {
	// call pg_catalog.json_each_text
	const sqlstr = `SELECT pg_catalog.json_each_text($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONExtractPath calls the stored procedure 'pg_catalog.json_extract_path(json, text[]) json' on db.
func JSONExtractPath(ctx context.Context, db DB, v0 []byte, v1 StringSlice) ([]byte, error) {
	// call pg_catalog.json_extract_path
	const sqlstr = `SELECT pg_catalog.json_extract_path($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONExtractPathText calls the stored procedure 'pg_catalog.json_extract_path_text(json, text[]) text' on db.
func JSONExtractPathText(ctx context.Context, db DB, v0 []byte, v1 StringSlice) (string, error) {
	// call pg_catalog.json_extract_path_text
	const sqlstr = `SELECT pg_catalog.json_extract_path_text($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// JSONIn calls the stored procedure 'pg_catalog.json_in(cstring) json' on db.
func JSONIn(ctx context.Context, db DB, v0 pgtypes.Cstring) ([]byte, error) {
	// call pg_catalog.json_in
	const sqlstr = `SELECT pg_catalog.json_in($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONObject calls the stored procedure 'pg_catalog.json_object(text[], text[], text[]) json' on db.
func JSONObject(ctx context.Context, db DB, v0, v1, v2 StringSlice) ([]byte, error) {
	// call pg_catalog.json_object
	const sqlstr = `SELECT pg_catalog.json_object($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONObjectAgg calls the stored procedure 'pg_catalog.json_object_agg("any", "any") json' on db.
func JSONObjectAgg(ctx context.Context, db DB, v0, v1 pgtypes.Any) ([]byte, error) {
	// call pg_catalog.json_object_agg
	const sqlstr = `SELECT pg_catalog.json_object_agg($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONObjectAggFinalfn calls the stored procedure 'pg_catalog.json_object_agg_finalfn(internal) json' on db.
func JSONObjectAggFinalfn(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.json_object_agg_finalfn
	const sqlstr = `SELECT pg_catalog.json_object_agg_finalfn($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONObjectAggTransfn calls the stored procedure 'pg_catalog.json_object_agg_transfn(internal, "any", "any") internal' on db.
func JSONObjectAggTransfn(ctx context.Context, db DB, v0 pgtypes.Internal, v1, v2 pgtypes.Any) (pgtypes.Internal, error) {
	// call pg_catalog.json_object_agg_transfn
	const sqlstr = `SELECT pg_catalog.json_object_agg_transfn($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// JSONObjectField calls the stored procedure 'pg_catalog.json_object_field(json, text) json' on db.
func JSONObjectField(ctx context.Context, db DB, v0 []byte, v1 string) ([]byte, error) {
	// call pg_catalog.json_object_field
	const sqlstr = `SELECT pg_catalog.json_object_field($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONObjectFieldText calls the stored procedure 'pg_catalog.json_object_field_text(json, text) text' on db.
func JSONObjectFieldText(ctx context.Context, db DB, v0 []byte, v1 string) (string, error) {
	// call pg_catalog.json_object_field_text
	const sqlstr = `SELECT pg_catalog.json_object_field_text($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// JSONObjectKeys calls the stored procedure 'pg_catalog.json_object_keys(json) SETOF text' on db.
func JSONObjectKeys(ctx context.Context, db DB, v0 []byte) ([]string, error) {
	// call pg_catalog.json_object_keys
	const sqlstr = `SELECT pg_catalog.json_object_keys($1)`
	// run
	var ret []string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONOut calls the stored procedure 'pg_catalog.json_out(json) cstring' on db.
func JSONOut(ctx context.Context, db DB, v0 []byte) (pgtypes.Cstring, error) {
	// call pg_catalog.json_out
	const sqlstr = `SELECT pg_catalog.json_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// JSONPopulateRecord calls the stored procedure 'pg_catalog.json_populate_record(anyelement, json, boolean) anyelement' on db.
func JSONPopulateRecord(ctx context.Context, db DB, v0 pgtypes.Anyelement, v1 []byte, v2 bool) (pgtypes.Anyelement, error) {
	// call pg_catalog.json_populate_record
	const sqlstr = `SELECT pg_catalog.json_populate_record($1, $2, $3)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// JSONPopulateRecordset calls the stored procedure 'pg_catalog.json_populate_recordset(anyelement, json, boolean) SETOF anyelement' on db.
func JSONPopulateRecordset(ctx context.Context, db DB, v0 pgtypes.Anyelement, v1 []byte, v2 bool) ([]pgtypes.Anyelement, error) {
	// call pg_catalog.json_populate_recordset
	const sqlstr = `SELECT pg_catalog.json_populate_recordset($1, $2, $3)`
	// run
	var ret []pgtypes.Anyelement
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONRecv calls the stored procedure 'pg_catalog.json_recv(internal) json' on db.
func JSONRecv(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.json_recv
	const sqlstr = `SELECT pg_catalog.json_recv($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONSend calls the stored procedure 'pg_catalog.json_send(json) bytea' on db.
func JSONSend(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.json_send
	const sqlstr = `SELECT pg_catalog.json_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONStripNulls calls the stored procedure 'pg_catalog.json_strip_nulls(json) json' on db.
func JSONStripNulls(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.json_strip_nulls
	const sqlstr = `SELECT pg_catalog.json_strip_nulls($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONToRecord calls the stored procedure 'pg_catalog.json_to_record(json) record' on db.
func JSONToRecord(ctx context.Context, db DB, v0 []byte) (pgtypes.Record, error) {
	// call pg_catalog.json_to_record
	const sqlstr = `SELECT pg_catalog.json_to_record($1)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// JSONToRecordset calls the stored procedure 'pg_catalog.json_to_recordset(json) SETOF record' on db.
func JSONToRecordset(ctx context.Context, db DB, v0 []byte) ([]pgtypes.Record, error) {
	// call pg_catalog.json_to_recordset
	const sqlstr = `SELECT pg_catalog.json_to_recordset($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JSONToTsvector calls the stored procedure 'pg_catalog.json_to_tsvector(json, jsonb, regconfig, json, jsonb) tsvector' on db.
func JSONToTsvector(ctx context.Context, db DB, v0, v1 []byte, v2 pgtypes.Regconfig, v3, v4 []byte) (pgtypes.Tsvector, error) {
	// call pg_catalog.json_to_tsvector
	const sqlstr = `SELECT pg_catalog.json_to_tsvector($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Tsvector
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return ret, nil
}

// JSONTypeof calls the stored procedure 'pg_catalog.json_typeof(json) text' on db.
func JSONTypeof(ctx context.Context, db DB, v0 []byte) (string, error) {
	// call pg_catalog.json_typeof
	const sqlstr = `SELECT pg_catalog.json_typeof($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// JohabToUTF8 calls the stored procedure 'pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func JohabToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.johab_to_utf8
	const sqlstr = `SELECT pg_catalog.johab_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// JsonbAgg calls the stored procedure 'pg_catalog.jsonb_agg(anyelement) jsonb' on db.
func JsonbAgg(ctx context.Context, db DB, v0 pgtypes.Anyelement) ([]byte, error) {
	// call pg_catalog.jsonb_agg
	const sqlstr = `SELECT pg_catalog.jsonb_agg($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbAggFinalfn calls the stored procedure 'pg_catalog.jsonb_agg_finalfn(internal) jsonb' on db.
func JsonbAggFinalfn(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.jsonb_agg_finalfn
	const sqlstr = `SELECT pg_catalog.jsonb_agg_finalfn($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbAggTransfn calls the stored procedure 'pg_catalog.jsonb_agg_transfn(internal, anyelement) internal' on db.
func JsonbAggTransfn(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Anyelement) (pgtypes.Internal, error) {
	// call pg_catalog.jsonb_agg_transfn
	const sqlstr = `SELECT pg_catalog.jsonb_agg_transfn($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// JsonbArrayElement calls the stored procedure 'pg_catalog.jsonb_array_element(jsonb, integer) jsonb' on db.
func JsonbArrayElement(ctx context.Context, db DB, v0 []byte, v1 int) ([]byte, error) {
	// call pg_catalog.jsonb_array_element
	const sqlstr = `SELECT pg_catalog.jsonb_array_element($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbArrayElementText calls the stored procedure 'pg_catalog.jsonb_array_element_text(jsonb, integer) text' on db.
func JsonbArrayElementText(ctx context.Context, db DB, v0 []byte, v1 int) (string, error) {
	// call pg_catalog.jsonb_array_element_text
	const sqlstr = `SELECT pg_catalog.jsonb_array_element_text($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// JsonbArrayElements calls the stored procedure 'pg_catalog.jsonb_array_elements(jsonb) SETOF jsonb' on db.
func JsonbArrayElements(ctx context.Context, db DB, v0 []byte) ([][]byte, error) {
	// call pg_catalog.jsonb_array_elements
	const sqlstr = `SELECT pg_catalog.jsonb_array_elements($1)`
	// run
	var ret [][]byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbArrayElementsText calls the stored procedure 'pg_catalog.jsonb_array_elements_text(jsonb) SETOF text' on db.
func JsonbArrayElementsText(ctx context.Context, db DB, v0 []byte) ([]string, error) {
	// call pg_catalog.jsonb_array_elements_text
	const sqlstr = `SELECT pg_catalog.jsonb_array_elements_text($1)`
	// run
	var ret []string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbArrayLength calls the stored procedure 'pg_catalog.jsonb_array_length(jsonb) integer' on db.
func JsonbArrayLength(ctx context.Context, db DB, v0 []byte) (int, error) {
	// call pg_catalog.jsonb_array_length
	const sqlstr = `SELECT pg_catalog.jsonb_array_length($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// JsonbBuildArray calls the stored procedure 'pg_catalog.jsonb_build_array("any") jsonb' on db.
func JsonbBuildArray(ctx context.Context, db DB, v0 pgtypes.Any) ([]byte, error) {
	// call pg_catalog.jsonb_build_array
	const sqlstr = `SELECT pg_catalog.jsonb_build_array($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbBuildObject calls the stored procedure 'pg_catalog.jsonb_build_object("any") jsonb' on db.
func JsonbBuildObject(ctx context.Context, db DB, v0 pgtypes.Any) ([]byte, error) {
	// call pg_catalog.jsonb_build_object
	const sqlstr = `SELECT pg_catalog.jsonb_build_object($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbCmp calls the stored procedure 'pg_catalog.jsonb_cmp(jsonb, jsonb) integer' on db.
func JsonbCmp(ctx context.Context, db DB, v0, v1 []byte) (int, error) {
	// call pg_catalog.jsonb_cmp
	const sqlstr = `SELECT pg_catalog.jsonb_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// JsonbConcat calls the stored procedure 'pg_catalog.jsonb_concat(jsonb, jsonb) jsonb' on db.
func JsonbConcat(ctx context.Context, db DB, v0, v1 []byte) ([]byte, error) {
	// call pg_catalog.jsonb_concat
	const sqlstr = `SELECT pg_catalog.jsonb_concat($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbContained calls the stored procedure 'pg_catalog.jsonb_contained(jsonb, jsonb) boolean' on db.
func JsonbContained(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.jsonb_contained
	const sqlstr = `SELECT pg_catalog.jsonb_contained($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbContains calls the stored procedure 'pg_catalog.jsonb_contains(jsonb, jsonb) boolean' on db.
func JsonbContains(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.jsonb_contains
	const sqlstr = `SELECT pg_catalog.jsonb_contains($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbDelete calls the stored procedure 'pg_catalog.jsonb_delete(jsonb, integer, jsonb, text, jsonb, text[]) jsonb' on db.
func JsonbDelete(ctx context.Context, db DB, v0 []byte, v1 int, v2 []byte, v3 string, v4 []byte, v5 StringSlice) ([]byte, error) {
	// call pg_catalog.jsonb_delete
	const sqlstr = `SELECT pg_catalog.jsonb_delete($1, $2, $3, $4, $5, $6)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbDeletePath calls the stored procedure 'pg_catalog.jsonb_delete_path(jsonb, text[]) jsonb' on db.
func JsonbDeletePath(ctx context.Context, db DB, v0 []byte, v1 StringSlice) ([]byte, error) {
	// call pg_catalog.jsonb_delete_path
	const sqlstr = `SELECT pg_catalog.jsonb_delete_path($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbEach calls the stored procedure 'pg_catalog.jsonb_each(jsonb) SETOF record' on db.
func JsonbEach(ctx context.Context, db DB, v0 []byte) ([]pgtypes.Record, error) {
	// call pg_catalog.jsonb_each
	const sqlstr = `SELECT pg_catalog.jsonb_each($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbEachText calls the stored procedure 'pg_catalog.jsonb_each_text(jsonb) SETOF record' on db.
func JsonbEachText(ctx context.Context, db DB, v0 []byte) ([]pgtypes.Record, error) {
	// call pg_catalog.jsonb_each_text
	const sqlstr = `SELECT pg_catalog.jsonb_each_text($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbEq calls the stored procedure 'pg_catalog.jsonb_eq(jsonb, jsonb) boolean' on db.
func JsonbEq(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.jsonb_eq
	const sqlstr = `SELECT pg_catalog.jsonb_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbExists calls the stored procedure 'pg_catalog.jsonb_exists(jsonb, text) boolean' on db.
func JsonbExists(ctx context.Context, db DB, v0 []byte, v1 string) (bool, error) {
	// call pg_catalog.jsonb_exists
	const sqlstr = `SELECT pg_catalog.jsonb_exists($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbExistsAll calls the stored procedure 'pg_catalog.jsonb_exists_all(jsonb, text[]) boolean' on db.
func JsonbExistsAll(ctx context.Context, db DB, v0 []byte, v1 StringSlice) (bool, error) {
	// call pg_catalog.jsonb_exists_all
	const sqlstr = `SELECT pg_catalog.jsonb_exists_all($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbExistsAny calls the stored procedure 'pg_catalog.jsonb_exists_any(jsonb, text[]) boolean' on db.
func JsonbExistsAny(ctx context.Context, db DB, v0 []byte, v1 StringSlice) (bool, error) {
	// call pg_catalog.jsonb_exists_any
	const sqlstr = `SELECT pg_catalog.jsonb_exists_any($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbExtractPath calls the stored procedure 'pg_catalog.jsonb_extract_path(jsonb, text[]) jsonb' on db.
func JsonbExtractPath(ctx context.Context, db DB, v0 []byte, v1 StringSlice) ([]byte, error) {
	// call pg_catalog.jsonb_extract_path
	const sqlstr = `SELECT pg_catalog.jsonb_extract_path($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbExtractPathText calls the stored procedure 'pg_catalog.jsonb_extract_path_text(jsonb, text[]) text' on db.
func JsonbExtractPathText(ctx context.Context, db DB, v0 []byte, v1 StringSlice) (string, error) {
	// call pg_catalog.jsonb_extract_path_text
	const sqlstr = `SELECT pg_catalog.jsonb_extract_path_text($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// JsonbGe calls the stored procedure 'pg_catalog.jsonb_ge(jsonb, jsonb) boolean' on db.
func JsonbGe(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.jsonb_ge
	const sqlstr = `SELECT pg_catalog.jsonb_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbGt calls the stored procedure 'pg_catalog.jsonb_gt(jsonb, jsonb) boolean' on db.
func JsonbGt(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.jsonb_gt
	const sqlstr = `SELECT pg_catalog.jsonb_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbHash calls the stored procedure 'pg_catalog.jsonb_hash(jsonb) integer' on db.
func JsonbHash(ctx context.Context, db DB, v0 []byte) (int, error) {
	// call pg_catalog.jsonb_hash
	const sqlstr = `SELECT pg_catalog.jsonb_hash($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// JsonbHashExtended calls the stored procedure 'pg_catalog.jsonb_hash_extended(jsonb, bigint) bigint' on db.
func JsonbHashExtended(ctx context.Context, db DB, v0 []byte, v1 int64) (int64, error) {
	// call pg_catalog.jsonb_hash_extended
	const sqlstr = `SELECT pg_catalog.jsonb_hash_extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// JsonbIn calls the stored procedure 'pg_catalog.jsonb_in(cstring) jsonb' on db.
func JsonbIn(ctx context.Context, db DB, v0 pgtypes.Cstring) ([]byte, error) {
	// call pg_catalog.jsonb_in
	const sqlstr = `SELECT pg_catalog.jsonb_in($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbInsert calls the stored procedure 'pg_catalog.jsonb_insert(jsonb, text[], jsonb, boolean) jsonb' on db.
func JsonbInsert(ctx context.Context, db DB, v0 []byte, v1 StringSlice, v2 []byte, v3 bool) ([]byte, error) {
	// call pg_catalog.jsonb_insert
	const sqlstr = `SELECT pg_catalog.jsonb_insert($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbLe calls the stored procedure 'pg_catalog.jsonb_le(jsonb, jsonb) boolean' on db.
func JsonbLe(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.jsonb_le
	const sqlstr = `SELECT pg_catalog.jsonb_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbLt calls the stored procedure 'pg_catalog.jsonb_lt(jsonb, jsonb) boolean' on db.
func JsonbLt(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.jsonb_lt
	const sqlstr = `SELECT pg_catalog.jsonb_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbNe calls the stored procedure 'pg_catalog.jsonb_ne(jsonb, jsonb) boolean' on db.
func JsonbNe(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.jsonb_ne
	const sqlstr = `SELECT pg_catalog.jsonb_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbObject calls the stored procedure 'pg_catalog.jsonb_object(text[], text[], text[]) jsonb' on db.
func JsonbObject(ctx context.Context, db DB, v0, v1, v2 StringSlice) ([]byte, error) {
	// call pg_catalog.jsonb_object
	const sqlstr = `SELECT pg_catalog.jsonb_object($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbObjectAgg calls the stored procedure 'pg_catalog.jsonb_object_agg("any", "any") jsonb' on db.
func JsonbObjectAgg(ctx context.Context, db DB, v0, v1 pgtypes.Any) ([]byte, error) {
	// call pg_catalog.jsonb_object_agg
	const sqlstr = `SELECT pg_catalog.jsonb_object_agg($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbObjectAggFinalfn calls the stored procedure 'pg_catalog.jsonb_object_agg_finalfn(internal) jsonb' on db.
func JsonbObjectAggFinalfn(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.jsonb_object_agg_finalfn
	const sqlstr = `SELECT pg_catalog.jsonb_object_agg_finalfn($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbObjectAggTransfn calls the stored procedure 'pg_catalog.jsonb_object_agg_transfn(internal, "any", "any") internal' on db.
func JsonbObjectAggTransfn(ctx context.Context, db DB, v0 pgtypes.Internal, v1, v2 pgtypes.Any) (pgtypes.Internal, error) {
	// call pg_catalog.jsonb_object_agg_transfn
	const sqlstr = `SELECT pg_catalog.jsonb_object_agg_transfn($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// JsonbObjectField calls the stored procedure 'pg_catalog.jsonb_object_field(jsonb, text) jsonb' on db.
func JsonbObjectField(ctx context.Context, db DB, v0 []byte, v1 string) ([]byte, error) {
	// call pg_catalog.jsonb_object_field
	const sqlstr = `SELECT pg_catalog.jsonb_object_field($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbObjectFieldText calls the stored procedure 'pg_catalog.jsonb_object_field_text(jsonb, text) text' on db.
func JsonbObjectFieldText(ctx context.Context, db DB, v0 []byte, v1 string) (string, error) {
	// call pg_catalog.jsonb_object_field_text
	const sqlstr = `SELECT pg_catalog.jsonb_object_field_text($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// JsonbObjectKeys calls the stored procedure 'pg_catalog.jsonb_object_keys(jsonb) SETOF text' on db.
func JsonbObjectKeys(ctx context.Context, db DB, v0 []byte) ([]string, error) {
	// call pg_catalog.jsonb_object_keys
	const sqlstr = `SELECT pg_catalog.jsonb_object_keys($1)`
	// run
	var ret []string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbOut calls the stored procedure 'pg_catalog.jsonb_out(jsonb) cstring' on db.
func JsonbOut(ctx context.Context, db DB, v0 []byte) (pgtypes.Cstring, error) {
	// call pg_catalog.jsonb_out
	const sqlstr = `SELECT pg_catalog.jsonb_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// JsonbPathExists calls the stored procedure 'pg_catalog.jsonb_path_exists(jsonb, jsonpath, jsonb, boolean) boolean' on db.
func JsonbPathExists(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath, v2 []byte, v3 bool) (bool, error) {
	// call pg_catalog.jsonb_path_exists
	const sqlstr = `SELECT pg_catalog.jsonb_path_exists($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbPathExistsOpr calls the stored procedure 'pg_catalog.jsonb_path_exists_opr(jsonb, jsonpath) boolean' on db.
func JsonbPathExistsOpr(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath) (bool, error) {
	// call pg_catalog.jsonb_path_exists_opr
	const sqlstr = `SELECT pg_catalog.jsonb_path_exists_opr($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbPathExistsTz calls the stored procedure 'pg_catalog.jsonb_path_exists_tz(jsonb, jsonpath, jsonb, boolean) boolean' on db.
func JsonbPathExistsTz(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath, v2 []byte, v3 bool) (bool, error) {
	// call pg_catalog.jsonb_path_exists_tz
	const sqlstr = `SELECT pg_catalog.jsonb_path_exists_tz($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbPathMatch calls the stored procedure 'pg_catalog.jsonb_path_match(jsonb, jsonpath, jsonb, boolean) boolean' on db.
func JsonbPathMatch(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath, v2 []byte, v3 bool) (bool, error) {
	// call pg_catalog.jsonb_path_match
	const sqlstr = `SELECT pg_catalog.jsonb_path_match($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbPathMatchOpr calls the stored procedure 'pg_catalog.jsonb_path_match_opr(jsonb, jsonpath) boolean' on db.
func JsonbPathMatchOpr(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath) (bool, error) {
	// call pg_catalog.jsonb_path_match_opr
	const sqlstr = `SELECT pg_catalog.jsonb_path_match_opr($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbPathMatchTz calls the stored procedure 'pg_catalog.jsonb_path_match_tz(jsonb, jsonpath, jsonb, boolean) boolean' on db.
func JsonbPathMatchTz(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath, v2 []byte, v3 bool) (bool, error) {
	// call pg_catalog.jsonb_path_match_tz
	const sqlstr = `SELECT pg_catalog.jsonb_path_match_tz($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// JsonbPathQuery calls the stored procedure 'pg_catalog.jsonb_path_query(jsonb, jsonpath, jsonb, boolean) SETOF jsonb' on db.
func JsonbPathQuery(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath, v2 []byte, v3 bool) ([][]byte, error) {
	// call pg_catalog.jsonb_path_query
	const sqlstr = `SELECT pg_catalog.jsonb_path_query($1, $2, $3, $4)`
	// run
	var ret [][]byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbPathQueryArray calls the stored procedure 'pg_catalog.jsonb_path_query_array(jsonb, jsonpath, jsonb, boolean) jsonb' on db.
func JsonbPathQueryArray(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath, v2 []byte, v3 bool) ([]byte, error) {
	// call pg_catalog.jsonb_path_query_array
	const sqlstr = `SELECT pg_catalog.jsonb_path_query_array($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbPathQueryArrayTz calls the stored procedure 'pg_catalog.jsonb_path_query_array_tz(jsonb, jsonpath, jsonb, boolean) jsonb' on db.
func JsonbPathQueryArrayTz(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath, v2 []byte, v3 bool) ([]byte, error) {
	// call pg_catalog.jsonb_path_query_array_tz
	const sqlstr = `SELECT pg_catalog.jsonb_path_query_array_tz($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbPathQueryFirst calls the stored procedure 'pg_catalog.jsonb_path_query_first(jsonb, jsonpath, jsonb, boolean) jsonb' on db.
func JsonbPathQueryFirst(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath, v2 []byte, v3 bool) ([]byte, error) {
	// call pg_catalog.jsonb_path_query_first
	const sqlstr = `SELECT pg_catalog.jsonb_path_query_first($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbPathQueryFirstTz calls the stored procedure 'pg_catalog.jsonb_path_query_first_tz(jsonb, jsonpath, jsonb, boolean) jsonb' on db.
func JsonbPathQueryFirstTz(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath, v2 []byte, v3 bool) ([]byte, error) {
	// call pg_catalog.jsonb_path_query_first_tz
	const sqlstr = `SELECT pg_catalog.jsonb_path_query_first_tz($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbPathQueryTz calls the stored procedure 'pg_catalog.jsonb_path_query_tz(jsonb, jsonpath, jsonb, boolean) SETOF jsonb' on db.
func JsonbPathQueryTz(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Jsonpath, v2 []byte, v3 bool) ([][]byte, error) {
	// call pg_catalog.jsonb_path_query_tz
	const sqlstr = `SELECT pg_catalog.jsonb_path_query_tz($1, $2, $3, $4)`
	// run
	var ret [][]byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbPopulateRecord calls the stored procedure 'pg_catalog.jsonb_populate_record(anyelement, jsonb) anyelement' on db.
func JsonbPopulateRecord(ctx context.Context, db DB, v0 pgtypes.Anyelement, v1 []byte) (pgtypes.Anyelement, error) {
	// call pg_catalog.jsonb_populate_record
	const sqlstr = `SELECT pg_catalog.jsonb_populate_record($1, $2)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// JsonbPopulateRecordset calls the stored procedure 'pg_catalog.jsonb_populate_recordset(anyelement, jsonb) SETOF anyelement' on db.
func JsonbPopulateRecordset(ctx context.Context, db DB, v0 pgtypes.Anyelement, v1 []byte) ([]pgtypes.Anyelement, error) {
	// call pg_catalog.jsonb_populate_recordset
	const sqlstr = `SELECT pg_catalog.jsonb_populate_recordset($1, $2)`
	// run
	var ret []pgtypes.Anyelement
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbPretty calls the stored procedure 'pg_catalog.jsonb_pretty(jsonb) text' on db.
func JsonbPretty(ctx context.Context, db DB, v0 []byte) (string, error) {
	// call pg_catalog.jsonb_pretty
	const sqlstr = `SELECT pg_catalog.jsonb_pretty($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// JsonbRecv calls the stored procedure 'pg_catalog.jsonb_recv(internal) jsonb' on db.
func JsonbRecv(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.jsonb_recv
	const sqlstr = `SELECT pg_catalog.jsonb_recv($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbSend calls the stored procedure 'pg_catalog.jsonb_send(jsonb) bytea' on db.
func JsonbSend(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.jsonb_send
	const sqlstr = `SELECT pg_catalog.jsonb_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbSet calls the stored procedure 'pg_catalog.jsonb_set(jsonb, text[], jsonb, boolean) jsonb' on db.
func JsonbSet(ctx context.Context, db DB, v0 []byte, v1 StringSlice, v2 []byte, v3 bool) ([]byte, error) {
	// call pg_catalog.jsonb_set
	const sqlstr = `SELECT pg_catalog.jsonb_set($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbSetLax calls the stored procedure 'pg_catalog.jsonb_set_lax(jsonb, text[], jsonb, boolean, text) jsonb' on db.
func JsonbSetLax(ctx context.Context, db DB, v0 []byte, v1 StringSlice, v2 []byte, v3 bool, v4 string) ([]byte, error) {
	// call pg_catalog.jsonb_set_lax
	const sqlstr = `SELECT pg_catalog.jsonb_set_lax($1, $2, $3, $4, $5)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbStripNulls calls the stored procedure 'pg_catalog.jsonb_strip_nulls(jsonb) jsonb' on db.
func JsonbStripNulls(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.jsonb_strip_nulls
	const sqlstr = `SELECT pg_catalog.jsonb_strip_nulls($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbToRecord calls the stored procedure 'pg_catalog.jsonb_to_record(jsonb) record' on db.
func JsonbToRecord(ctx context.Context, db DB, v0 []byte) (pgtypes.Record, error) {
	// call pg_catalog.jsonb_to_record
	const sqlstr = `SELECT pg_catalog.jsonb_to_record($1)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// JsonbToRecordset calls the stored procedure 'pg_catalog.jsonb_to_recordset(jsonb) SETOF record' on db.
func JsonbToRecordset(ctx context.Context, db DB, v0 []byte) ([]pgtypes.Record, error) {
	// call pg_catalog.jsonb_to_recordset
	const sqlstr = `SELECT pg_catalog.jsonb_to_recordset($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JsonbToTsvector calls the stored procedure 'pg_catalog.jsonb_to_tsvector(jsonb, jsonb, regconfig, jsonb, jsonb) tsvector' on db.
func JsonbToTsvector(ctx context.Context, db DB, v0, v1 []byte, v2 pgtypes.Regconfig, v3, v4 []byte) (pgtypes.Tsvector, error) {
	// call pg_catalog.jsonb_to_tsvector
	const sqlstr = `SELECT pg_catalog.jsonb_to_tsvector($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Tsvector
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return ret, nil
}

// JsonbTypeof calls the stored procedure 'pg_catalog.jsonb_typeof(jsonb) text' on db.
func JsonbTypeof(ctx context.Context, db DB, v0 []byte) (string, error) {
	// call pg_catalog.jsonb_typeof
	const sqlstr = `SELECT pg_catalog.jsonb_typeof($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// JsonpathIn calls the stored procedure 'pg_catalog.jsonpath_in(cstring) jsonpath' on db.
func JsonpathIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Jsonpath, error) {
	// call pg_catalog.jsonpath_in
	const sqlstr = `SELECT pg_catalog.jsonpath_in($1)`
	// run
	var ret pgtypes.Jsonpath
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Jsonpath{}, logerror(err)
	}
	return ret, nil
}

// JsonpathOut calls the stored procedure 'pg_catalog.jsonpath_out(jsonpath) cstring' on db.
func JsonpathOut(ctx context.Context, db DB, v0 pgtypes.Jsonpath) (pgtypes.Cstring, error) {
	// call pg_catalog.jsonpath_out
	const sqlstr = `SELECT pg_catalog.jsonpath_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// JsonpathRecv calls the stored procedure 'pg_catalog.jsonpath_recv(internal) jsonpath' on db.
func JsonpathRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Jsonpath, error) {
	// call pg_catalog.jsonpath_recv
	const sqlstr = `SELECT pg_catalog.jsonpath_recv($1)`
	// run
	var ret pgtypes.Jsonpath
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Jsonpath{}, logerror(err)
	}
	return ret, nil
}

// JsonpathSend calls the stored procedure 'pg_catalog.jsonpath_send(jsonpath) bytea' on db.
func JsonpathSend(ctx context.Context, db DB, v0 pgtypes.Jsonpath) ([]byte, error) {
	// call pg_catalog.jsonpath_send
	const sqlstr = `SELECT pg_catalog.jsonpath_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JustifyDays calls the stored procedure 'pg_catalog.justify_days(interval) interval' on db.
func JustifyDays(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.justify_days
	const sqlstr = `SELECT pg_catalog.justify_days($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JustifyHours calls the stored procedure 'pg_catalog.justify_hours(interval) interval' on db.
func JustifyHours(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.justify_hours
	const sqlstr = `SELECT pg_catalog.justify_hours($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// JustifyInterval calls the stored procedure 'pg_catalog.justify_interval(interval) interval' on db.
func JustifyInterval(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.justify_interval
	const sqlstr = `SELECT pg_catalog.justify_interval($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Koi8rToIso calls the stored procedure 'pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer) void' on db.
func Koi8rToIso(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.koi8r_to_iso
	const sqlstr = `SELECT pg_catalog.koi8r_to_iso($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Koi8rToMic calls the stored procedure 'pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer) void' on db.
func Koi8rToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.koi8r_to_mic
	const sqlstr = `SELECT pg_catalog.koi8r_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Koi8rToUTF8 calls the stored procedure 'pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func Koi8rToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.koi8r_to_utf8
	const sqlstr = `SELECT pg_catalog.koi8r_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Koi8rToWin1251 calls the stored procedure 'pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer) void' on db.
func Koi8rToWin1251(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.koi8r_to_win1251
	const sqlstr = `SELECT pg_catalog.koi8r_to_win1251($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Koi8rToWin866 calls the stored procedure 'pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer) void' on db.
func Koi8rToWin866(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.koi8r_to_win866
	const sqlstr = `SELECT pg_catalog.koi8r_to_win866($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Koi8uToUTF8 calls the stored procedure 'pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func Koi8uToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.koi8u_to_utf8
	const sqlstr = `SELECT pg_catalog.koi8u_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Lag calls the stored procedure 'pg_catalog.lag(anyelement, anyelement, integer, anyelement, integer, anyelement) anyelement' on db.
func Lag(ctx context.Context, db DB, v0, v1 pgtypes.Anyelement, v2 int, v3 pgtypes.Anyelement, v4 int, v5 pgtypes.Anyelement) (pgtypes.Anyelement, error) {
	// call pg_catalog.lag
	const sqlstr = `SELECT pg_catalog.lag($1, $2, $3, $4, $5, $6)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// LanguageHandlerIn calls the stored procedure 'pg_catalog.language_handler_in(cstring) language_handler' on db.
func LanguageHandlerIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.LanguageHandler, error) {
	// call pg_catalog.language_handler_in
	const sqlstr = `SELECT pg_catalog.language_handler_in($1)`
	// run
	var ret pgtypes.LanguageHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.LanguageHandler{}, logerror(err)
	}
	return ret, nil
}

// LanguageHandlerOut calls the stored procedure 'pg_catalog.language_handler_out(language_handler) cstring' on db.
func LanguageHandlerOut(ctx context.Context, db DB, v0 pgtypes.LanguageHandler) (pgtypes.Cstring, error) {
	// call pg_catalog.language_handler_out
	const sqlstr = `SELECT pg_catalog.language_handler_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// LastValue calls the stored procedure 'pg_catalog.last_value(anyelement) anyelement' on db.
func LastValue(ctx context.Context, db DB, v0 pgtypes.Anyelement) (pgtypes.Anyelement, error) {
	// call pg_catalog.last_value
	const sqlstr = `SELECT pg_catalog.last_value($1)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// Lastval calls the stored procedure 'pg_catalog.lastval() bigint' on db.
func Lastval(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.lastval
	const sqlstr = `SELECT pg_catalog.lastval()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Latin1ToMic calls the stored procedure 'pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer) void' on db.
func Latin1ToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.latin1_to_mic
	const sqlstr = `SELECT pg_catalog.latin1_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Latin2ToMic calls the stored procedure 'pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer) void' on db.
func Latin2ToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.latin2_to_mic
	const sqlstr = `SELECT pg_catalog.latin2_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Latin2ToWin1250 calls the stored procedure 'pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer) void' on db.
func Latin2ToWin1250(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.latin2_to_win1250
	const sqlstr = `SELECT pg_catalog.latin2_to_win1250($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Latin3ToMic calls the stored procedure 'pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer) void' on db.
func Latin3ToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.latin3_to_mic
	const sqlstr = `SELECT pg_catalog.latin3_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Latin4ToMic calls the stored procedure 'pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer) void' on db.
func Latin4ToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.latin4_to_mic
	const sqlstr = `SELECT pg_catalog.latin4_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Lcm calls the stored procedure 'pg_catalog.lcm(bigint, bigint, integer, integer, numeric, numeric) numeric' on db.
func Lcm(ctx context.Context, db DB, v0, v1 int64, v2, v3 int, v4, v5 float64) (float64, error) {
	// call pg_catalog.lcm
	const sqlstr = `SELECT pg_catalog.lcm($1, $2, $3, $4, $5, $6)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Lead calls the stored procedure 'pg_catalog.lead(anyelement, anyelement, integer, anyelement, integer, anyelement) anyelement' on db.
func Lead(ctx context.Context, db DB, v0, v1 pgtypes.Anyelement, v2 int, v3 pgtypes.Anyelement, v4 int, v5 pgtypes.Anyelement) (pgtypes.Anyelement, error) {
	// call pg_catalog.lead
	const sqlstr = `SELECT pg_catalog.lead($1, $2, $3, $4, $5, $6)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// Left calls the stored procedure 'pg_catalog.left(text, integer) text' on db.
func Left(ctx context.Context, db DB, v0 string, v1 int) (string, error) {
	// call pg_catalog.left
	const sqlstr = `SELECT pg_catalog.left($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Length calls the stored procedure 'pg_catalog.length(bytea, text, lseg, path, character, bit, tsvector, bytea, name) integer' on db.
func Length(ctx context.Context, db DB, v0 []byte, v1 string, v2 pgtypes.Lseg, v3 pgtypes.Path, v4 string, v5 uint8, v6 pgtypes.Tsvector, v7 []byte, v8 pgtypes.Name) (int, error) {
	// call pg_catalog.length
	const sqlstr = `SELECT pg_catalog.length($1, $2, $3, $4, $5, $6, $7, $8, $9)`
	// run
	var ret int
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Like calls the stored procedure 'pg_catalog.like(bytea, bytea, name, text, text, text) boolean' on db.
func Like(ctx context.Context, db DB, v0, v1 []byte, v2 pgtypes.Name, v3, v4, v5 string) (bool, error) {
	// call pg_catalog.like
	const sqlstr = `SELECT pg_catalog.like($1, $2, $3, $4, $5, $6)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LikeEscape calls the stored procedure 'pg_catalog.like_escape(bytea, bytea, text, text) bytea' on db.
func LikeEscape(ctx context.Context, db DB, v0, v1 []byte, v2, v3 string) ([]byte, error) {
	// call pg_catalog.like_escape
	const sqlstr = `SELECT pg_catalog.like_escape($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Likejoinsel calls the stored procedure 'pg_catalog.likejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Likejoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.likejoinsel
	const sqlstr = `SELECT pg_catalog.likejoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Likesel calls the stored procedure 'pg_catalog.likesel(internal, oid, internal, integer) double precision' on db.
func Likesel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.likesel
	const sqlstr = `SELECT pg_catalog.likesel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Line calls the stored procedure 'pg_catalog.line(point, point) line' on db.
func Line(ctx context.Context, db DB, v0, v1 pgtypes.Point) (pgtypes.Line, error) {
	// call pg_catalog.line
	const sqlstr = `SELECT pg_catalog.line($1, $2)`
	// run
	var ret pgtypes.Line
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Line{}, logerror(err)
	}
	return ret, nil
}

// LineDistance calls the stored procedure 'pg_catalog.line_distance(line, line) double precision' on db.
func LineDistance(ctx context.Context, db DB, v0, v1 pgtypes.Line) (float64, error) {
	// call pg_catalog.line_distance
	const sqlstr = `SELECT pg_catalog.line_distance($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// LineEq calls the stored procedure 'pg_catalog.line_eq(line, line) boolean' on db.
func LineEq(ctx context.Context, db DB, v0, v1 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_eq
	const sqlstr = `SELECT pg_catalog.line_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LineHorizontal calls the stored procedure 'pg_catalog.line_horizontal(line) boolean' on db.
func LineHorizontal(ctx context.Context, db DB, v0 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_horizontal
	const sqlstr = `SELECT pg_catalog.line_horizontal($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LineIn calls the stored procedure 'pg_catalog.line_in(cstring) line' on db.
func LineIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Line, error) {
	// call pg_catalog.line_in
	const sqlstr = `SELECT pg_catalog.line_in($1)`
	// run
	var ret pgtypes.Line
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Line{}, logerror(err)
	}
	return ret, nil
}

// LineInterpt calls the stored procedure 'pg_catalog.line_interpt(line, line) point' on db.
func LineInterpt(ctx context.Context, db DB, v0, v1 pgtypes.Line) (pgtypes.Point, error) {
	// call pg_catalog.line_interpt
	const sqlstr = `SELECT pg_catalog.line_interpt($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// LineIntersect calls the stored procedure 'pg_catalog.line_intersect(line, line) boolean' on db.
func LineIntersect(ctx context.Context, db DB, v0, v1 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_intersect
	const sqlstr = `SELECT pg_catalog.line_intersect($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LineOut calls the stored procedure 'pg_catalog.line_out(line) cstring' on db.
func LineOut(ctx context.Context, db DB, v0 pgtypes.Line) (pgtypes.Cstring, error) {
	// call pg_catalog.line_out
	const sqlstr = `SELECT pg_catalog.line_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// LineParallel calls the stored procedure 'pg_catalog.line_parallel(line, line) boolean' on db.
func LineParallel(ctx context.Context, db DB, v0, v1 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_parallel
	const sqlstr = `SELECT pg_catalog.line_parallel($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LinePerp calls the stored procedure 'pg_catalog.line_perp(line, line) boolean' on db.
func LinePerp(ctx context.Context, db DB, v0, v1 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_perp
	const sqlstr = `SELECT pg_catalog.line_perp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LineRecv calls the stored procedure 'pg_catalog.line_recv(internal) line' on db.
func LineRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Line, error) {
	// call pg_catalog.line_recv
	const sqlstr = `SELECT pg_catalog.line_recv($1)`
	// run
	var ret pgtypes.Line
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Line{}, logerror(err)
	}
	return ret, nil
}

// LineSend calls the stored procedure 'pg_catalog.line_send(line) bytea' on db.
func LineSend(ctx context.Context, db DB, v0 pgtypes.Line) ([]byte, error) {
	// call pg_catalog.line_send
	const sqlstr = `SELECT pg_catalog.line_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// LineVertical calls the stored procedure 'pg_catalog.line_vertical(line) boolean' on db.
func LineVertical(ctx context.Context, db DB, v0 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_vertical
	const sqlstr = `SELECT pg_catalog.line_vertical($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Ln calls the stored procedure 'pg_catalog.ln(double precision, numeric) numeric' on db.
func Ln(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.ln
	const sqlstr = `SELECT pg_catalog.ln($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// LoClose calls the stored procedure 'pg_catalog.lo_close(integer) integer' on db.
func LoClose(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.lo_close
	const sqlstr = `SELECT pg_catalog.lo_close($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// LoCreat calls the stored procedure 'pg_catalog.lo_creat(integer) oid' on db.
func LoCreat(ctx context.Context, db DB, v0 int) (pgtypes.Oid, error) {
	// call pg_catalog.lo_creat
	const sqlstr = `SELECT pg_catalog.lo_creat($1)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// LoCreate calls the stored procedure 'pg_catalog.lo_create(oid) oid' on db.
func LoCreate(ctx context.Context, db DB, v0 pgtypes.Oid) (pgtypes.Oid, error) {
	// call pg_catalog.lo_create
	const sqlstr = `SELECT pg_catalog.lo_create($1)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// LoExport calls the stored procedure 'pg_catalog.lo_export(oid, text) integer' on db.
func LoExport(ctx context.Context, db DB, v0 pgtypes.Oid, v1 string) (int, error) {
	// call pg_catalog.lo_export
	const sqlstr = `SELECT pg_catalog.lo_export($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// LoFromBytea calls the stored procedure 'pg_catalog.lo_from_bytea(oid, bytea) oid' on db.
func LoFromBytea(ctx context.Context, db DB, v0 pgtypes.Oid, v1 []byte) (pgtypes.Oid, error) {
	// call pg_catalog.lo_from_bytea
	const sqlstr = `SELECT pg_catalog.lo_from_bytea($1, $2)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// LoGet calls the stored procedure 'pg_catalog.lo_get(oid, oid, bigint, integer) bytea' on db.
func LoGet(ctx context.Context, db DB, v0, v1 pgtypes.Oid, v2 int64, v3 int) ([]byte, error) {
	// call pg_catalog.lo_get
	const sqlstr = `SELECT pg_catalog.lo_get($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// LoImport calls the stored procedure 'pg_catalog.lo_import(text, text, oid) oid' on db.
func LoImport(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid) (pgtypes.Oid, error) {
	// call pg_catalog.lo_import
	const sqlstr = `SELECT pg_catalog.lo_import($1, $2, $3)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// LoLseek calls the stored procedure 'pg_catalog.lo_lseek(integer, integer, integer) integer' on db.
func LoLseek(ctx context.Context, db DB, v0, v1, v2 int) (int, error) {
	// call pg_catalog.lo_lseek
	const sqlstr = `SELECT pg_catalog.lo_lseek($1, $2, $3)`
	// run
	var ret int
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// LoLseek64 calls the stored procedure 'pg_catalog.lo_lseek64(integer, bigint, integer) bigint' on db.
func LoLseek64(ctx context.Context, db DB, v0 int, v1 int64, v2 int) (int64, error) {
	// call pg_catalog.lo_lseek64
	const sqlstr = `SELECT pg_catalog.lo_lseek64($1, $2, $3)`
	// run
	var ret int64
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// LoOpen calls the stored procedure 'pg_catalog.lo_open(oid, integer) integer' on db.
func LoOpen(ctx context.Context, db DB, v0 pgtypes.Oid, v1 int) (int, error) {
	// call pg_catalog.lo_open
	const sqlstr = `SELECT pg_catalog.lo_open($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// LoPut calls the stored procedure 'pg_catalog.lo_put(oid, bigint, bytea) void' on db.
func LoPut(ctx context.Context, db DB, v0 pgtypes.Oid, v1 int64, v2 []byte) error {
	// call pg_catalog.lo_put
	const sqlstr = `SELECT pg_catalog.lo_put($1, $2, $3)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// LoTell calls the stored procedure 'pg_catalog.lo_tell(integer) integer' on db.
func LoTell(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.lo_tell
	const sqlstr = `SELECT pg_catalog.lo_tell($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// LoTell64 calls the stored procedure 'pg_catalog.lo_tell64(integer) bigint' on db.
func LoTell64(ctx context.Context, db DB, v0 int) (int64, error) {
	// call pg_catalog.lo_tell64
	const sqlstr = `SELECT pg_catalog.lo_tell64($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// LoTruncate calls the stored procedure 'pg_catalog.lo_truncate(integer, integer) integer' on db.
func LoTruncate(ctx context.Context, db DB, v0, v1 int) (int, error) {
	// call pg_catalog.lo_truncate
	const sqlstr = `SELECT pg_catalog.lo_truncate($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// LoTruncate64 calls the stored procedure 'pg_catalog.lo_truncate64(integer, bigint) integer' on db.
func LoTruncate64(ctx context.Context, db DB, v0 int, v1 int64) (int, error) {
	// call pg_catalog.lo_truncate64
	const sqlstr = `SELECT pg_catalog.lo_truncate64($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// LoUnlink calls the stored procedure 'pg_catalog.lo_unlink(oid) integer' on db.
func LoUnlink(ctx context.Context, db DB, v0 pgtypes.Oid) (int, error) {
	// call pg_catalog.lo_unlink
	const sqlstr = `SELECT pg_catalog.lo_unlink($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Log calls the stored procedure 'pg_catalog.log(double precision, numeric, numeric, numeric) numeric' on db.
func Log(ctx context.Context, db DB, v0, v1, v2, v3 float64) (float64, error) {
	// call pg_catalog.log
	const sqlstr = `SELECT pg_catalog.log($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Log10 calls the stored procedure 'pg_catalog.log10(double precision, numeric) numeric' on db.
func Log10(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.log10
	const sqlstr = `SELECT pg_catalog.log10($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Loread calls the stored procedure 'pg_catalog.loread(integer, integer) bytea' on db.
func Loread(ctx context.Context, db DB, v0, v1 int) ([]byte, error) {
	// call pg_catalog.loread
	const sqlstr = `SELECT pg_catalog.loread($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Lower calls the stored procedure 'pg_catalog.lower(text, anyrange) anyelement' on db.
func Lower(ctx context.Context, db DB, v0 string, v1 pgtypes.Anyrange) (pgtypes.Anyelement, error) {
	// call pg_catalog.lower
	const sqlstr = `SELECT pg_catalog.lower($1, $2)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// LowerInc calls the stored procedure 'pg_catalog.lower_inc(anyrange) boolean' on db.
func LowerInc(ctx context.Context, db DB, v0 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.lower_inc
	const sqlstr = `SELECT pg_catalog.lower_inc($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LowerInf calls the stored procedure 'pg_catalog.lower_inf(anyrange) boolean' on db.
func LowerInf(ctx context.Context, db DB, v0 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.lower_inf
	const sqlstr = `SELECT pg_catalog.lower_inf($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Lowrite calls the stored procedure 'pg_catalog.lowrite(integer, bytea) integer' on db.
func Lowrite(ctx context.Context, db DB, v0 int, v1 []byte) (int, error) {
	// call pg_catalog.lowrite
	const sqlstr = `SELECT pg_catalog.lowrite($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Lpad calls the stored procedure 'pg_catalog.lpad(text, integer, text, integer, text) text' on db.
func Lpad(ctx context.Context, db DB, v0 string, v1 int, v2 string, v3 int, v4 string) (string, error) {
	// call pg_catalog.lpad
	const sqlstr = `SELECT pg_catalog.lpad($1, $2, $3, $4, $5)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Lseg calls the stored procedure 'pg_catalog.lseg(box, point, point) lseg' on db.
func Lseg(ctx context.Context, db DB, v0 pgtypes.Box, v1, v2 pgtypes.Point) (pgtypes.Lseg, error) {
	// call pg_catalog.lseg
	const sqlstr = `SELECT pg_catalog.lseg($1, $2, $3)`
	// run
	var ret pgtypes.Lseg
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Lseg{}, logerror(err)
	}
	return ret, nil
}

// LsegCenter calls the stored procedure 'pg_catalog.lseg_center(lseg) point' on db.
func LsegCenter(ctx context.Context, db DB, v0 pgtypes.Lseg) (pgtypes.Point, error) {
	// call pg_catalog.lseg_center
	const sqlstr = `SELECT pg_catalog.lseg_center($1)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// LsegDistance calls the stored procedure 'pg_catalog.lseg_distance(lseg, lseg) double precision' on db.
func LsegDistance(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (float64, error) {
	// call pg_catalog.lseg_distance
	const sqlstr = `SELECT pg_catalog.lseg_distance($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// LsegEq calls the stored procedure 'pg_catalog.lseg_eq(lseg, lseg) boolean' on db.
func LsegEq(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_eq
	const sqlstr = `SELECT pg_catalog.lseg_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LsegGe calls the stored procedure 'pg_catalog.lseg_ge(lseg, lseg) boolean' on db.
func LsegGe(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_ge
	const sqlstr = `SELECT pg_catalog.lseg_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LsegGt calls the stored procedure 'pg_catalog.lseg_gt(lseg, lseg) boolean' on db.
func LsegGt(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_gt
	const sqlstr = `SELECT pg_catalog.lseg_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LsegHorizontal calls the stored procedure 'pg_catalog.lseg_horizontal(lseg) boolean' on db.
func LsegHorizontal(ctx context.Context, db DB, v0 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_horizontal
	const sqlstr = `SELECT pg_catalog.lseg_horizontal($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LsegIn calls the stored procedure 'pg_catalog.lseg_in(cstring) lseg' on db.
func LsegIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Lseg, error) {
	// call pg_catalog.lseg_in
	const sqlstr = `SELECT pg_catalog.lseg_in($1)`
	// run
	var ret pgtypes.Lseg
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Lseg{}, logerror(err)
	}
	return ret, nil
}

// LsegInterpt calls the stored procedure 'pg_catalog.lseg_interpt(lseg, lseg) point' on db.
func LsegInterpt(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (pgtypes.Point, error) {
	// call pg_catalog.lseg_interpt
	const sqlstr = `SELECT pg_catalog.lseg_interpt($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// LsegIntersect calls the stored procedure 'pg_catalog.lseg_intersect(lseg, lseg) boolean' on db.
func LsegIntersect(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_intersect
	const sqlstr = `SELECT pg_catalog.lseg_intersect($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LsegLe calls the stored procedure 'pg_catalog.lseg_le(lseg, lseg) boolean' on db.
func LsegLe(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_le
	const sqlstr = `SELECT pg_catalog.lseg_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LsegLength calls the stored procedure 'pg_catalog.lseg_length(lseg) double precision' on db.
func LsegLength(ctx context.Context, db DB, v0 pgtypes.Lseg) (float64, error) {
	// call pg_catalog.lseg_length
	const sqlstr = `SELECT pg_catalog.lseg_length($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// LsegLt calls the stored procedure 'pg_catalog.lseg_lt(lseg, lseg) boolean' on db.
func LsegLt(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_lt
	const sqlstr = `SELECT pg_catalog.lseg_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LsegNe calls the stored procedure 'pg_catalog.lseg_ne(lseg, lseg) boolean' on db.
func LsegNe(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_ne
	const sqlstr = `SELECT pg_catalog.lseg_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LsegOut calls the stored procedure 'pg_catalog.lseg_out(lseg) cstring' on db.
func LsegOut(ctx context.Context, db DB, v0 pgtypes.Lseg) (pgtypes.Cstring, error) {
	// call pg_catalog.lseg_out
	const sqlstr = `SELECT pg_catalog.lseg_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// LsegParallel calls the stored procedure 'pg_catalog.lseg_parallel(lseg, lseg) boolean' on db.
func LsegParallel(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_parallel
	const sqlstr = `SELECT pg_catalog.lseg_parallel($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LsegPerp calls the stored procedure 'pg_catalog.lseg_perp(lseg, lseg) boolean' on db.
func LsegPerp(ctx context.Context, db DB, v0, v1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_perp
	const sqlstr = `SELECT pg_catalog.lseg_perp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// LsegRecv calls the stored procedure 'pg_catalog.lseg_recv(internal) lseg' on db.
func LsegRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Lseg, error) {
	// call pg_catalog.lseg_recv
	const sqlstr = `SELECT pg_catalog.lseg_recv($1)`
	// run
	var ret pgtypes.Lseg
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Lseg{}, logerror(err)
	}
	return ret, nil
}

// LsegSend calls the stored procedure 'pg_catalog.lseg_send(lseg) bytea' on db.
func LsegSend(ctx context.Context, db DB, v0 pgtypes.Lseg) ([]byte, error) {
	// call pg_catalog.lseg_send
	const sqlstr = `SELECT pg_catalog.lseg_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// LsegVertical calls the stored procedure 'pg_catalog.lseg_vertical(lseg) boolean' on db.
func LsegVertical(ctx context.Context, db DB, v0 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_vertical
	const sqlstr = `SELECT pg_catalog.lseg_vertical($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Ltrim calls the stored procedure 'pg_catalog.ltrim(text, text, text) text' on db.
func Ltrim(ctx context.Context, db DB, v0, v1, v2 string) (string, error) {
	// call pg_catalog.ltrim
	const sqlstr = `SELECT pg_catalog.ltrim($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Macaddr calls the stored procedure 'pg_catalog.macaddr(macaddr8) macaddr' on db.
func Macaddr(ctx context.Context, db DB, v0 pgtypes.Macaddr8) (pgtypes.Macaddr, error) {
	// call pg_catalog.macaddr
	const sqlstr = `SELECT pg_catalog.macaddr($1)`
	// run
	var ret pgtypes.Macaddr
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return ret, nil
}

// Macaddr8 calls the stored procedure 'pg_catalog.macaddr8(macaddr) macaddr8' on db.
func Macaddr8(ctx context.Context, db DB, v0 pgtypes.Macaddr) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8
	const sqlstr = `SELECT pg_catalog.macaddr8($1)`
	// run
	var ret pgtypes.Macaddr8
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return ret, nil
}

// Macaddr8And calls the stored procedure 'pg_catalog.macaddr8_and(macaddr8, macaddr8) macaddr8' on db.
func Macaddr8And(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr8) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8_and
	const sqlstr = `SELECT pg_catalog.macaddr8_and($1, $2)`
	// run
	var ret pgtypes.Macaddr8
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return ret, nil
}

// Macaddr8Cmp calls the stored procedure 'pg_catalog.macaddr8_cmp(macaddr8, macaddr8) integer' on db.
func Macaddr8Cmp(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr8) (int, error) {
	// call pg_catalog.macaddr8_cmp
	const sqlstr = `SELECT pg_catalog.macaddr8_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Macaddr8Eq calls the stored procedure 'pg_catalog.macaddr8_eq(macaddr8, macaddr8) boolean' on db.
func Macaddr8Eq(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_eq
	const sqlstr = `SELECT pg_catalog.macaddr8_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Macaddr8Ge calls the stored procedure 'pg_catalog.macaddr8_ge(macaddr8, macaddr8) boolean' on db.
func Macaddr8Ge(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_ge
	const sqlstr = `SELECT pg_catalog.macaddr8_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Macaddr8Gt calls the stored procedure 'pg_catalog.macaddr8_gt(macaddr8, macaddr8) boolean' on db.
func Macaddr8Gt(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_gt
	const sqlstr = `SELECT pg_catalog.macaddr8_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Macaddr8In calls the stored procedure 'pg_catalog.macaddr8_in(cstring) macaddr8' on db.
func Macaddr8In(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8_in
	const sqlstr = `SELECT pg_catalog.macaddr8_in($1)`
	// run
	var ret pgtypes.Macaddr8
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return ret, nil
}

// Macaddr8Le calls the stored procedure 'pg_catalog.macaddr8_le(macaddr8, macaddr8) boolean' on db.
func Macaddr8Le(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_le
	const sqlstr = `SELECT pg_catalog.macaddr8_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Macaddr8Lt calls the stored procedure 'pg_catalog.macaddr8_lt(macaddr8, macaddr8) boolean' on db.
func Macaddr8Lt(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_lt
	const sqlstr = `SELECT pg_catalog.macaddr8_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Macaddr8Ne calls the stored procedure 'pg_catalog.macaddr8_ne(macaddr8, macaddr8) boolean' on db.
func Macaddr8Ne(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_ne
	const sqlstr = `SELECT pg_catalog.macaddr8_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Macaddr8Not calls the stored procedure 'pg_catalog.macaddr8_not(macaddr8) macaddr8' on db.
func Macaddr8Not(ctx context.Context, db DB, v0 pgtypes.Macaddr8) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8_not
	const sqlstr = `SELECT pg_catalog.macaddr8_not($1)`
	// run
	var ret pgtypes.Macaddr8
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return ret, nil
}

// Macaddr8Or calls the stored procedure 'pg_catalog.macaddr8_or(macaddr8, macaddr8) macaddr8' on db.
func Macaddr8Or(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr8) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8_or
	const sqlstr = `SELECT pg_catalog.macaddr8_or($1, $2)`
	// run
	var ret pgtypes.Macaddr8
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return ret, nil
}

// Macaddr8Out calls the stored procedure 'pg_catalog.macaddr8_out(macaddr8) cstring' on db.
func Macaddr8Out(ctx context.Context, db DB, v0 pgtypes.Macaddr8) (pgtypes.Cstring, error) {
	// call pg_catalog.macaddr8_out
	const sqlstr = `SELECT pg_catalog.macaddr8_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Macaddr8Recv calls the stored procedure 'pg_catalog.macaddr8_recv(internal) macaddr8' on db.
func Macaddr8Recv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8_recv
	const sqlstr = `SELECT pg_catalog.macaddr8_recv($1)`
	// run
	var ret pgtypes.Macaddr8
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return ret, nil
}

// Macaddr8Send calls the stored procedure 'pg_catalog.macaddr8_send(macaddr8) bytea' on db.
func Macaddr8Send(ctx context.Context, db DB, v0 pgtypes.Macaddr8) ([]byte, error) {
	// call pg_catalog.macaddr8_send
	const sqlstr = `SELECT pg_catalog.macaddr8_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Macaddr8Set7bit calls the stored procedure 'pg_catalog.macaddr8_set7bit(macaddr8) macaddr8' on db.
func Macaddr8Set7bit(ctx context.Context, db DB, v0 pgtypes.Macaddr8) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8_set7bit
	const sqlstr = `SELECT pg_catalog.macaddr8_set7bit($1)`
	// run
	var ret pgtypes.Macaddr8
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return ret, nil
}

// MacaddrAnd calls the stored procedure 'pg_catalog.macaddr_and(macaddr, macaddr) macaddr' on db.
func MacaddrAnd(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr) (pgtypes.Macaddr, error) {
	// call pg_catalog.macaddr_and
	const sqlstr = `SELECT pg_catalog.macaddr_and($1, $2)`
	// run
	var ret pgtypes.Macaddr
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return ret, nil
}

// MacaddrCmp calls the stored procedure 'pg_catalog.macaddr_cmp(macaddr, macaddr) integer' on db.
func MacaddrCmp(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr) (int, error) {
	// call pg_catalog.macaddr_cmp
	const sqlstr = `SELECT pg_catalog.macaddr_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// MacaddrEq calls the stored procedure 'pg_catalog.macaddr_eq(macaddr, macaddr) boolean' on db.
func MacaddrEq(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_eq
	const sqlstr = `SELECT pg_catalog.macaddr_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// MacaddrGe calls the stored procedure 'pg_catalog.macaddr_ge(macaddr, macaddr) boolean' on db.
func MacaddrGe(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_ge
	const sqlstr = `SELECT pg_catalog.macaddr_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// MacaddrGt calls the stored procedure 'pg_catalog.macaddr_gt(macaddr, macaddr) boolean' on db.
func MacaddrGt(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_gt
	const sqlstr = `SELECT pg_catalog.macaddr_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// MacaddrIn calls the stored procedure 'pg_catalog.macaddr_in(cstring) macaddr' on db.
func MacaddrIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Macaddr, error) {
	// call pg_catalog.macaddr_in
	const sqlstr = `SELECT pg_catalog.macaddr_in($1)`
	// run
	var ret pgtypes.Macaddr
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return ret, nil
}

// MacaddrLe calls the stored procedure 'pg_catalog.macaddr_le(macaddr, macaddr) boolean' on db.
func MacaddrLe(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_le
	const sqlstr = `SELECT pg_catalog.macaddr_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// MacaddrLt calls the stored procedure 'pg_catalog.macaddr_lt(macaddr, macaddr) boolean' on db.
func MacaddrLt(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_lt
	const sqlstr = `SELECT pg_catalog.macaddr_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// MacaddrNe calls the stored procedure 'pg_catalog.macaddr_ne(macaddr, macaddr) boolean' on db.
func MacaddrNe(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_ne
	const sqlstr = `SELECT pg_catalog.macaddr_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// MacaddrNot calls the stored procedure 'pg_catalog.macaddr_not(macaddr) macaddr' on db.
func MacaddrNot(ctx context.Context, db DB, v0 pgtypes.Macaddr) (pgtypes.Macaddr, error) {
	// call pg_catalog.macaddr_not
	const sqlstr = `SELECT pg_catalog.macaddr_not($1)`
	// run
	var ret pgtypes.Macaddr
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return ret, nil
}

// MacaddrOr calls the stored procedure 'pg_catalog.macaddr_or(macaddr, macaddr) macaddr' on db.
func MacaddrOr(ctx context.Context, db DB, v0, v1 pgtypes.Macaddr) (pgtypes.Macaddr, error) {
	// call pg_catalog.macaddr_or
	const sqlstr = `SELECT pg_catalog.macaddr_or($1, $2)`
	// run
	var ret pgtypes.Macaddr
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return ret, nil
}

// MacaddrOut calls the stored procedure 'pg_catalog.macaddr_out(macaddr) cstring' on db.
func MacaddrOut(ctx context.Context, db DB, v0 pgtypes.Macaddr) (pgtypes.Cstring, error) {
	// call pg_catalog.macaddr_out
	const sqlstr = `SELECT pg_catalog.macaddr_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// MacaddrRecv calls the stored procedure 'pg_catalog.macaddr_recv(internal) macaddr' on db.
func MacaddrRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Macaddr, error) {
	// call pg_catalog.macaddr_recv
	const sqlstr = `SELECT pg_catalog.macaddr_recv($1)`
	// run
	var ret pgtypes.Macaddr
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return ret, nil
}

// MacaddrSend calls the stored procedure 'pg_catalog.macaddr_send(macaddr) bytea' on db.
func MacaddrSend(ctx context.Context, db DB, v0 pgtypes.Macaddr) ([]byte, error) {
	// call pg_catalog.macaddr_send
	const sqlstr = `SELECT pg_catalog.macaddr_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// MacaddrSortsupport calls the stored procedure 'pg_catalog.macaddr_sortsupport(internal) void' on db.
func MacaddrSortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.macaddr_sortsupport
	const sqlstr = `SELECT pg_catalog.macaddr_sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MakeDate calls the stored procedure 'pg_catalog.make_date(integer, integer, integer) date' on db.
func MakeDate(ctx context.Context, db DB, v0, v1, v2 int) (time.Time, error) {
	// call pg_catalog.make_date
	const sqlstr = `SELECT pg_catalog.make_date($1, $2, $3)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// MakeInterval calls the stored procedure 'pg_catalog.make_interval(integer, integer, integer, integer, integer, integer, double precision) interval' on db.
func MakeInterval(ctx context.Context, db DB, v0, v1, v2, v3, v4, v5 int, v6 float64) ([]byte, error) {
	// call pg_catalog.make_interval
	const sqlstr = `SELECT pg_catalog.make_interval($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// MakeTime calls the stored procedure 'pg_catalog.make_time(integer, integer, double precision) time without time zone' on db.
func MakeTime(ctx context.Context, db DB, v0, v1 int, v2 float64) (time.Time, error) {
	// call pg_catalog.make_time
	const sqlstr = `SELECT pg_catalog.make_time($1, $2, $3)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// MakeTimestamp calls the stored procedure 'pg_catalog.make_timestamp(integer, integer, integer, integer, integer, double precision) timestamp without time zone' on db.
func MakeTimestamp(ctx context.Context, db DB, v0, v1, v2, v3, v4 int, v5 float64) (time.Time, error) {
	// call pg_catalog.make_timestamp
	const sqlstr = `SELECT pg_catalog.make_timestamp($1, $2, $3, $4, $5, $6)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// MakeTimestamptz calls the stored procedure 'pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision, integer, integer, integer, integer, integer, double precision, text) timestamp with time zone' on db.
func MakeTimestamptz(ctx context.Context, db DB, v0, v1, v2, v3, v4 int, v5 float64, v6, v7, v8, v9, v10 int, v11 float64, v12 string) (time.Time, error) {
	// call pg_catalog.make_timestamptz
	const sqlstr = `SELECT pg_catalog.make_timestamptz($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// Makeaclitem calls the stored procedure 'pg_catalog.makeaclitem(oid, oid, text, boolean) aclitem' on db.
func Makeaclitem(ctx context.Context, db DB, v0, v1 pgtypes.Oid, v2 string, v3 bool) (pgtypes.Aclitem, error) {
	// call pg_catalog.makeaclitem
	const sqlstr = `SELECT pg_catalog.makeaclitem($1, $2, $3, $4)`
	// run
	var ret pgtypes.Aclitem
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return pgtypes.Aclitem{}, logerror(err)
	}
	return ret, nil
}

// Masklen calls the stored procedure 'pg_catalog.masklen(inet) integer' on db.
func Masklen(ctx context.Context, db DB, v0 string) (int, error) {
	// call pg_catalog.masklen
	const sqlstr = `SELECT pg_catalog.masklen($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Matchingjoinsel calls the stored procedure 'pg_catalog.matchingjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Matchingjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.matchingjoinsel
	const sqlstr = `SELECT pg_catalog.matchingjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Matchingsel calls the stored procedure 'pg_catalog.matchingsel(internal, oid, internal, integer) double precision' on db.
func Matchingsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.matchingsel
	const sqlstr = `SELECT pg_catalog.matchingsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Max calls the stored procedure 'pg_catalog.max(bigint, smallint, integer, text, oid, tid, real, double precision, money, inet, character, date, time without time zone, timestamp without time zone, timestamp with time zone, interval, time with time zone, numeric, anyarray, pg_lsn, anyenum) anyenum' on db.
func Max(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 string, v4 pgtypes.Oid, v5 pgtypes.Tid, v6 float32, v7 float64, v8, v9, v10 string, v11, v12, v13, v14 time.Time, v15 []byte, v16 time.Time, v17 float64, v18 pgtypes.Anyarray, v19 pgtypes.PgLsn, v20 pgtypes.Anyenum) (pgtypes.Anyenum, error) {
	// call pg_catalog.max
	const sqlstr = `SELECT pg_catalog.max($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)`
	// run
	var ret pgtypes.Anyenum
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20).Scan(&ret); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return ret, nil
}

// Md5 calls the stored procedure 'pg_catalog.md5(bytea, text) text' on db.
func Md5(ctx context.Context, db DB, v0 []byte, v1 string) (string, error) {
	// call pg_catalog.md5
	const sqlstr = `SELECT pg_catalog.md5($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// MicToBig5 calls the stored procedure 'pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer) void' on db.
func MicToBig5(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_big5
	const sqlstr = `SELECT pg_catalog.mic_to_big5($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToEucCn calls the stored procedure 'pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer) void' on db.
func MicToEucCn(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_euc_cn
	const sqlstr = `SELECT pg_catalog.mic_to_euc_cn($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToEucJp calls the stored procedure 'pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer) void' on db.
func MicToEucJp(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_euc_jp
	const sqlstr = `SELECT pg_catalog.mic_to_euc_jp($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToEucKr calls the stored procedure 'pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer) void' on db.
func MicToEucKr(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_euc_kr
	const sqlstr = `SELECT pg_catalog.mic_to_euc_kr($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToEucTw calls the stored procedure 'pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer) void' on db.
func MicToEucTw(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_euc_tw
	const sqlstr = `SELECT pg_catalog.mic_to_euc_tw($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToIso calls the stored procedure 'pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer) void' on db.
func MicToIso(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_iso
	const sqlstr = `SELECT pg_catalog.mic_to_iso($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToKoi8r calls the stored procedure 'pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer) void' on db.
func MicToKoi8r(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_koi8r
	const sqlstr = `SELECT pg_catalog.mic_to_koi8r($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToLatin1 calls the stored procedure 'pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer) void' on db.
func MicToLatin1(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_latin1
	const sqlstr = `SELECT pg_catalog.mic_to_latin1($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToLatin2 calls the stored procedure 'pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer) void' on db.
func MicToLatin2(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_latin2
	const sqlstr = `SELECT pg_catalog.mic_to_latin2($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToLatin3 calls the stored procedure 'pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer) void' on db.
func MicToLatin3(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_latin3
	const sqlstr = `SELECT pg_catalog.mic_to_latin3($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToLatin4 calls the stored procedure 'pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer) void' on db.
func MicToLatin4(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_latin4
	const sqlstr = `SELECT pg_catalog.mic_to_latin4($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToSjis calls the stored procedure 'pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer) void' on db.
func MicToSjis(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_sjis
	const sqlstr = `SELECT pg_catalog.mic_to_sjis($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToWin1250 calls the stored procedure 'pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer) void' on db.
func MicToWin1250(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_win1250
	const sqlstr = `SELECT pg_catalog.mic_to_win1250($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToWin1251 calls the stored procedure 'pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer) void' on db.
func MicToWin1251(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_win1251
	const sqlstr = `SELECT pg_catalog.mic_to_win1251($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToWin866 calls the stored procedure 'pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer) void' on db.
func MicToWin866(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.mic_to_win866
	const sqlstr = `SELECT pg_catalog.mic_to_win866($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Min calls the stored procedure 'pg_catalog.min(bigint, smallint, integer, text, oid, tid, real, double precision, money, inet, character, date, time without time zone, timestamp without time zone, timestamp with time zone, interval, time with time zone, numeric, anyarray, pg_lsn, anyenum) anyenum' on db.
func Min(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 string, v4 pgtypes.Oid, v5 pgtypes.Tid, v6 float32, v7 float64, v8, v9, v10 string, v11, v12, v13, v14 time.Time, v15 []byte, v16 time.Time, v17 float64, v18 pgtypes.Anyarray, v19 pgtypes.PgLsn, v20 pgtypes.Anyenum) (pgtypes.Anyenum, error) {
	// call pg_catalog.min
	const sqlstr = `SELECT pg_catalog.min($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)`
	// run
	var ret pgtypes.Anyenum
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20).Scan(&ret); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return ret, nil
}

// MinScale calls the stored procedure 'pg_catalog.min_scale(numeric) integer' on db.
func MinScale(ctx context.Context, db DB, v0 float64) (int, error) {
	// call pg_catalog.min_scale
	const sqlstr = `SELECT pg_catalog.min_scale($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Mod calls the stored procedure 'pg_catalog.mod(bigint, bigint, smallint, smallint, integer, integer, numeric, numeric) numeric' on db.
func Mod(ctx context.Context, db DB, v0, v1 int64, v2, v3 int16, v4, v5 int, v6, v7 float64) (float64, error) {
	// call pg_catalog.mod
	const sqlstr = `SELECT pg_catalog.mod($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Mode calls the stored procedure 'pg_catalog.mode(anyelement) anyelement' on db.
func Mode(ctx context.Context, db DB, v0 pgtypes.Anyelement) (pgtypes.Anyelement, error) {
	// call pg_catalog.mode
	const sqlstr = `SELECT pg_catalog.mode($1)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// ModeFinal calls the stored procedure 'pg_catalog.mode_final(internal, anyelement) anyelement' on db.
func ModeFinal(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Anyelement) (pgtypes.Anyelement, error) {
	// call pg_catalog.mode_final
	const sqlstr = `SELECT pg_catalog.mode_final($1, $2)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// Money calls the stored procedure 'pg_catalog.money(bigint, integer, numeric) money' on db.
func Money(ctx context.Context, db DB, v0 int64, v1 int, v2 float64) (string, error) {
	// call pg_catalog.money
	const sqlstr = `SELECT pg_catalog.money($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// MulDInterval calls the stored procedure 'pg_catalog.mul_d_interval(double precision, interval) interval' on db.
func MulDInterval(ctx context.Context, db DB, v0 float64, v1 []byte) ([]byte, error) {
	// call pg_catalog.mul_d_interval
	const sqlstr = `SELECT pg_catalog.mul_d_interval($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// MxidAge calls the stored procedure 'pg_catalog.mxid_age(xid) integer' on db.
func MxidAge(ctx context.Context, db DB, v0 pgtypes.Xid) (int, error) {
	// call pg_catalog.mxid_age
	const sqlstr = `SELECT pg_catalog.mxid_age($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Name calls the stored procedure 'pg_catalog.name(text, character, character varying) name' on db.
func Name(ctx context.Context, db DB, v0, v1, v2 string) (pgtypes.Name, error) {
	// call pg_catalog.name
	const sqlstr = `SELECT pg_catalog.name($1, $2, $3)`
	// run
	var ret pgtypes.Name
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// Nameconcatoid calls the stored procedure 'pg_catalog.nameconcatoid(name, oid) name' on db.
func Nameconcatoid(ctx context.Context, db DB, v0 pgtypes.Name, v1 pgtypes.Oid) (pgtypes.Name, error) {
	// call pg_catalog.nameconcatoid
	const sqlstr = `SELECT pg_catalog.nameconcatoid($1, $2)`
	// run
	var ret pgtypes.Name
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// Nameeq calls the stored procedure 'pg_catalog.nameeq(name, name) boolean' on db.
func Nameeq(ctx context.Context, db DB, v0, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.nameeq
	const sqlstr = `SELECT pg_catalog.nameeq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Nameeqtext calls the stored procedure 'pg_catalog.nameeqtext(name, text) boolean' on db.
func Nameeqtext(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.nameeqtext
	const sqlstr = `SELECT pg_catalog.nameeqtext($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namege calls the stored procedure 'pg_catalog.namege(name, name) boolean' on db.
func Namege(ctx context.Context, db DB, v0, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.namege
	const sqlstr = `SELECT pg_catalog.namege($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namegetext calls the stored procedure 'pg_catalog.namegetext(name, text) boolean' on db.
func Namegetext(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.namegetext
	const sqlstr = `SELECT pg_catalog.namegetext($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namegt calls the stored procedure 'pg_catalog.namegt(name, name) boolean' on db.
func Namegt(ctx context.Context, db DB, v0, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.namegt
	const sqlstr = `SELECT pg_catalog.namegt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namegttext calls the stored procedure 'pg_catalog.namegttext(name, text) boolean' on db.
func Namegttext(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.namegttext
	const sqlstr = `SELECT pg_catalog.namegttext($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Nameiclike calls the stored procedure 'pg_catalog.nameiclike(name, text) boolean' on db.
func Nameiclike(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.nameiclike
	const sqlstr = `SELECT pg_catalog.nameiclike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Nameicnlike calls the stored procedure 'pg_catalog.nameicnlike(name, text) boolean' on db.
func Nameicnlike(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.nameicnlike
	const sqlstr = `SELECT pg_catalog.nameicnlike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Nameicregexeq calls the stored procedure 'pg_catalog.nameicregexeq(name, text) boolean' on db.
func Nameicregexeq(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.nameicregexeq
	const sqlstr = `SELECT pg_catalog.nameicregexeq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Nameicregexne calls the stored procedure 'pg_catalog.nameicregexne(name, text) boolean' on db.
func Nameicregexne(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.nameicregexne
	const sqlstr = `SELECT pg_catalog.nameicregexne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namein calls the stored procedure 'pg_catalog.namein(cstring) name' on db.
func Namein(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Name, error) {
	// call pg_catalog.namein
	const sqlstr = `SELECT pg_catalog.namein($1)`
	// run
	var ret pgtypes.Name
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// Namele calls the stored procedure 'pg_catalog.namele(name, name) boolean' on db.
func Namele(ctx context.Context, db DB, v0, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.namele
	const sqlstr = `SELECT pg_catalog.namele($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Nameletext calls the stored procedure 'pg_catalog.nameletext(name, text) boolean' on db.
func Nameletext(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.nameletext
	const sqlstr = `SELECT pg_catalog.nameletext($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namelike calls the stored procedure 'pg_catalog.namelike(name, text) boolean' on db.
func Namelike(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.namelike
	const sqlstr = `SELECT pg_catalog.namelike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namelt calls the stored procedure 'pg_catalog.namelt(name, name) boolean' on db.
func Namelt(ctx context.Context, db DB, v0, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.namelt
	const sqlstr = `SELECT pg_catalog.namelt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namelttext calls the stored procedure 'pg_catalog.namelttext(name, text) boolean' on db.
func Namelttext(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.namelttext
	const sqlstr = `SELECT pg_catalog.namelttext($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namene calls the stored procedure 'pg_catalog.namene(name, name) boolean' on db.
func Namene(ctx context.Context, db DB, v0, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.namene
	const sqlstr = `SELECT pg_catalog.namene($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namenetext calls the stored procedure 'pg_catalog.namenetext(name, text) boolean' on db.
func Namenetext(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.namenetext
	const sqlstr = `SELECT pg_catalog.namenetext($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namenlike calls the stored procedure 'pg_catalog.namenlike(name, text) boolean' on db.
func Namenlike(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.namenlike
	const sqlstr = `SELECT pg_catalog.namenlike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Nameout calls the stored procedure 'pg_catalog.nameout(name) cstring' on db.
func Nameout(ctx context.Context, db DB, v0 pgtypes.Name) (pgtypes.Cstring, error) {
	// call pg_catalog.nameout
	const sqlstr = `SELECT pg_catalog.nameout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Namerecv calls the stored procedure 'pg_catalog.namerecv(internal) name' on db.
func Namerecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Name, error) {
	// call pg_catalog.namerecv
	const sqlstr = `SELECT pg_catalog.namerecv($1)`
	// run
	var ret pgtypes.Name
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// Nameregexeq calls the stored procedure 'pg_catalog.nameregexeq(name, text) boolean' on db.
func Nameregexeq(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.nameregexeq
	const sqlstr = `SELECT pg_catalog.nameregexeq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Nameregexne calls the stored procedure 'pg_catalog.nameregexne(name, text) boolean' on db.
func Nameregexne(ctx context.Context, db DB, v0 pgtypes.Name, v1 string) (bool, error) {
	// call pg_catalog.nameregexne
	const sqlstr = `SELECT pg_catalog.nameregexne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Namesend calls the stored procedure 'pg_catalog.namesend(name) bytea' on db.
func Namesend(ctx context.Context, db DB, v0 pgtypes.Name) ([]byte, error) {
	// call pg_catalog.namesend
	const sqlstr = `SELECT pg_catalog.namesend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Neqjoinsel calls the stored procedure 'pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Neqjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.neqjoinsel
	const sqlstr = `SELECT pg_catalog.neqjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Neqsel calls the stored procedure 'pg_catalog.neqsel(internal, oid, internal, integer) double precision' on db.
func Neqsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.neqsel
	const sqlstr = `SELECT pg_catalog.neqsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Netmask calls the stored procedure 'pg_catalog.netmask(inet) inet' on db.
func Netmask(ctx context.Context, db DB, v0 string) (string, error) {
	// call pg_catalog.netmask
	const sqlstr = `SELECT pg_catalog.netmask($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Network calls the stored procedure 'pg_catalog.network(inet) cidr' on db.
func Network(ctx context.Context, db DB, v0 string) (pgtypes.Cidr, error) {
	// call pg_catalog.network
	const sqlstr = `SELECT pg_catalog.network($1)`
	// run
	var ret pgtypes.Cidr
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cidr{}, logerror(err)
	}
	return ret, nil
}

// NetworkCmp calls the stored procedure 'pg_catalog.network_cmp(inet, inet) integer' on db.
func NetworkCmp(ctx context.Context, db DB, v0, v1 string) (int, error) {
	// call pg_catalog.network_cmp
	const sqlstr = `SELECT pg_catalog.network_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// NetworkEq calls the stored procedure 'pg_catalog.network_eq(inet, inet) boolean' on db.
func NetworkEq(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.network_eq
	const sqlstr = `SELECT pg_catalog.network_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NetworkGe calls the stored procedure 'pg_catalog.network_ge(inet, inet) boolean' on db.
func NetworkGe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.network_ge
	const sqlstr = `SELECT pg_catalog.network_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NetworkGt calls the stored procedure 'pg_catalog.network_gt(inet, inet) boolean' on db.
func NetworkGt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.network_gt
	const sqlstr = `SELECT pg_catalog.network_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NetworkLarger calls the stored procedure 'pg_catalog.network_larger(inet, inet) inet' on db.
func NetworkLarger(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.network_larger
	const sqlstr = `SELECT pg_catalog.network_larger($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// NetworkLe calls the stored procedure 'pg_catalog.network_le(inet, inet) boolean' on db.
func NetworkLe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.network_le
	const sqlstr = `SELECT pg_catalog.network_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NetworkLt calls the stored procedure 'pg_catalog.network_lt(inet, inet) boolean' on db.
func NetworkLt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.network_lt
	const sqlstr = `SELECT pg_catalog.network_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NetworkNe calls the stored procedure 'pg_catalog.network_ne(inet, inet) boolean' on db.
func NetworkNe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.network_ne
	const sqlstr = `SELECT pg_catalog.network_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NetworkOverlap calls the stored procedure 'pg_catalog.network_overlap(inet, inet) boolean' on db.
func NetworkOverlap(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.network_overlap
	const sqlstr = `SELECT pg_catalog.network_overlap($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NetworkSmaller calls the stored procedure 'pg_catalog.network_smaller(inet, inet) inet' on db.
func NetworkSmaller(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.network_smaller
	const sqlstr = `SELECT pg_catalog.network_smaller($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// NetworkSortsupport calls the stored procedure 'pg_catalog.network_sortsupport(internal) void' on db.
func NetworkSortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.network_sortsupport
	const sqlstr = `SELECT pg_catalog.network_sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// NetworkSub calls the stored procedure 'pg_catalog.network_sub(inet, inet) boolean' on db.
func NetworkSub(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.network_sub
	const sqlstr = `SELECT pg_catalog.network_sub($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NetworkSubeq calls the stored procedure 'pg_catalog.network_subeq(inet, inet) boolean' on db.
func NetworkSubeq(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.network_subeq
	const sqlstr = `SELECT pg_catalog.network_subeq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NetworkSubsetSupport calls the stored procedure 'pg_catalog.network_subset_support(internal) internal' on db.
func NetworkSubsetSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.network_subset_support
	const sqlstr = `SELECT pg_catalog.network_subset_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// NetworkSup calls the stored procedure 'pg_catalog.network_sup(inet, inet) boolean' on db.
func NetworkSup(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.network_sup
	const sqlstr = `SELECT pg_catalog.network_sup($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NetworkSupeq calls the stored procedure 'pg_catalog.network_supeq(inet, inet) boolean' on db.
func NetworkSupeq(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.network_supeq
	const sqlstr = `SELECT pg_catalog.network_supeq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Networkjoinsel calls the stored procedure 'pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Networkjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.networkjoinsel
	const sqlstr = `SELECT pg_catalog.networkjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Networksel calls the stored procedure 'pg_catalog.networksel(internal, oid, internal, integer) double precision' on db.
func Networksel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.networksel
	const sqlstr = `SELECT pg_catalog.networksel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Nextval calls the stored procedure 'pg_catalog.nextval(regclass) bigint' on db.
func Nextval(ctx context.Context, db DB, v0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.nextval
	const sqlstr = `SELECT pg_catalog.nextval($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Nlikejoinsel calls the stored procedure 'pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Nlikejoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.nlikejoinsel
	const sqlstr = `SELECT pg_catalog.nlikejoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Nlikesel calls the stored procedure 'pg_catalog.nlikesel(internal, oid, internal, integer) double precision' on db.
func Nlikesel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.nlikesel
	const sqlstr = `SELECT pg_catalog.nlikesel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Normalize calls the stored procedure 'pg_catalog.normalize(text, text) text' on db.
func Normalize(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.normalize
	const sqlstr = `SELECT pg_catalog.normalize($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Notlike calls the stored procedure 'pg_catalog.notlike(bytea, bytea, name, text, text, text) boolean' on db.
func Notlike(ctx context.Context, db DB, v0, v1 []byte, v2 pgtypes.Name, v3, v4, v5 string) (bool, error) {
	// call pg_catalog.notlike
	const sqlstr = `SELECT pg_catalog.notlike($1, $2, $3, $4, $5, $6)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Now calls the stored procedure 'pg_catalog.now() timestamp with time zone' on db.
func Now(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.now
	const sqlstr = `SELECT pg_catalog.now()`
	// run
	var ret time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// Npoints calls the stored procedure 'pg_catalog.npoints(path, polygon) integer' on db.
func Npoints(ctx context.Context, db DB, v0 pgtypes.Path, v1 pgtypes.Polygon) (int, error) {
	// call pg_catalog.npoints
	const sqlstr = `SELECT pg_catalog.npoints($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// NthValue calls the stored procedure 'pg_catalog.nth_value(anyelement, integer) anyelement' on db.
func NthValue(ctx context.Context, db DB, v0 pgtypes.Anyelement, v1 int) (pgtypes.Anyelement, error) {
	// call pg_catalog.nth_value
	const sqlstr = `SELECT pg_catalog.nth_value($1, $2)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// Ntile calls the stored procedure 'pg_catalog.ntile(integer) integer' on db.
func Ntile(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.ntile
	const sqlstr = `SELECT pg_catalog.ntile($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// NumNonnulls calls the stored procedure 'pg_catalog.num_nonnulls("any") integer' on db.
func NumNonnulls(ctx context.Context, db DB, v0 pgtypes.Any) (int, error) {
	// call pg_catalog.num_nonnulls
	const sqlstr = `SELECT pg_catalog.num_nonnulls($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// NumNulls calls the stored procedure 'pg_catalog.num_nulls("any") integer' on db.
func NumNulls(ctx context.Context, db DB, v0 pgtypes.Any) (int, error) {
	// call pg_catalog.num_nulls
	const sqlstr = `SELECT pg_catalog.num_nulls($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Numeric calls the stored procedure 'pg_catalog.numeric(bigint, smallint, integer, real, double precision, money, jsonb, numeric, integer) numeric' on db.
func Numeric(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 float32, v4 float64, v5 string, v6 []byte, v7 float64, v8 int) (float64, error) {
	// call pg_catalog.numeric
	const sqlstr = `SELECT pg_catalog.numeric($1, $2, $3, $4, $5, $6, $7, $8, $9)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericAbs calls the stored procedure 'pg_catalog.numeric_abs(numeric) numeric' on db.
func NumericAbs(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.numeric_abs
	const sqlstr = `SELECT pg_catalog.numeric_abs($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericAccum calls the stored procedure 'pg_catalog.numeric_accum(internal, numeric) internal' on db.
func NumericAccum(ctx context.Context, db DB, v0 pgtypes.Internal, v1 float64) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_accum
	const sqlstr = `SELECT pg_catalog.numeric_accum($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// NumericAccumInv calls the stored procedure 'pg_catalog.numeric_accum_inv(internal, numeric) internal' on db.
func NumericAccumInv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 float64) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_accum_inv
	const sqlstr = `SELECT pg_catalog.numeric_accum_inv($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// NumericAdd calls the stored procedure 'pg_catalog.numeric_add(numeric, numeric) numeric' on db.
func NumericAdd(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.numeric_add
	const sqlstr = `SELECT pg_catalog.numeric_add($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericAvg calls the stored procedure 'pg_catalog.numeric_avg(internal) numeric' on db.
func NumericAvg(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_avg
	const sqlstr = `SELECT pg_catalog.numeric_avg($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericAvgAccum calls the stored procedure 'pg_catalog.numeric_avg_accum(internal, numeric) internal' on db.
func NumericAvgAccum(ctx context.Context, db DB, v0 pgtypes.Internal, v1 float64) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_avg_accum
	const sqlstr = `SELECT pg_catalog.numeric_avg_accum($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// NumericAvgCombine calls the stored procedure 'pg_catalog.numeric_avg_combine(internal, internal) internal' on db.
func NumericAvgCombine(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_avg_combine
	const sqlstr = `SELECT pg_catalog.numeric_avg_combine($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// NumericAvgDeserialize calls the stored procedure 'pg_catalog.numeric_avg_deserialize(bytea, internal) internal' on db.
func NumericAvgDeserialize(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_avg_deserialize
	const sqlstr = `SELECT pg_catalog.numeric_avg_deserialize($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// NumericAvgSerialize calls the stored procedure 'pg_catalog.numeric_avg_serialize(internal) bytea' on db.
func NumericAvgSerialize(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.numeric_avg_serialize
	const sqlstr = `SELECT pg_catalog.numeric_avg_serialize($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// NumericCmp calls the stored procedure 'pg_catalog.numeric_cmp(numeric, numeric) integer' on db.
func NumericCmp(ctx context.Context, db DB, v0, v1 float64) (int, error) {
	// call pg_catalog.numeric_cmp
	const sqlstr = `SELECT pg_catalog.numeric_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// NumericCombine calls the stored procedure 'pg_catalog.numeric_combine(internal, internal) internal' on db.
func NumericCombine(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_combine
	const sqlstr = `SELECT pg_catalog.numeric_combine($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// NumericDeserialize calls the stored procedure 'pg_catalog.numeric_deserialize(bytea, internal) internal' on db.
func NumericDeserialize(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_deserialize
	const sqlstr = `SELECT pg_catalog.numeric_deserialize($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// NumericDiv calls the stored procedure 'pg_catalog.numeric_div(numeric, numeric) numeric' on db.
func NumericDiv(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.numeric_div
	const sqlstr = `SELECT pg_catalog.numeric_div($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericDivTrunc calls the stored procedure 'pg_catalog.numeric_div_trunc(numeric, numeric) numeric' on db.
func NumericDivTrunc(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.numeric_div_trunc
	const sqlstr = `SELECT pg_catalog.numeric_div_trunc($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericEq calls the stored procedure 'pg_catalog.numeric_eq(numeric, numeric) boolean' on db.
func NumericEq(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.numeric_eq
	const sqlstr = `SELECT pg_catalog.numeric_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NumericExp calls the stored procedure 'pg_catalog.numeric_exp(numeric) numeric' on db.
func NumericExp(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.numeric_exp
	const sqlstr = `SELECT pg_catalog.numeric_exp($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericFac calls the stored procedure 'pg_catalog.numeric_fac(bigint) numeric' on db.
func NumericFac(ctx context.Context, db DB, v0 int64) (float64, error) {
	// call pg_catalog.numeric_fac
	const sqlstr = `SELECT pg_catalog.numeric_fac($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericGe calls the stored procedure 'pg_catalog.numeric_ge(numeric, numeric) boolean' on db.
func NumericGe(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.numeric_ge
	const sqlstr = `SELECT pg_catalog.numeric_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NumericGt calls the stored procedure 'pg_catalog.numeric_gt(numeric, numeric) boolean' on db.
func NumericGt(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.numeric_gt
	const sqlstr = `SELECT pg_catalog.numeric_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NumericIn calls the stored procedure 'pg_catalog.numeric_in(cstring, oid, integer) numeric' on db.
func NumericIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (float64, error) {
	// call pg_catalog.numeric_in
	const sqlstr = `SELECT pg_catalog.numeric_in($1, $2, $3)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericInc calls the stored procedure 'pg_catalog.numeric_inc(numeric) numeric' on db.
func NumericInc(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.numeric_inc
	const sqlstr = `SELECT pg_catalog.numeric_inc($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericLarger calls the stored procedure 'pg_catalog.numeric_larger(numeric, numeric) numeric' on db.
func NumericLarger(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.numeric_larger
	const sqlstr = `SELECT pg_catalog.numeric_larger($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericLe calls the stored procedure 'pg_catalog.numeric_le(numeric, numeric) boolean' on db.
func NumericLe(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.numeric_le
	const sqlstr = `SELECT pg_catalog.numeric_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NumericLn calls the stored procedure 'pg_catalog.numeric_ln(numeric) numeric' on db.
func NumericLn(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.numeric_ln
	const sqlstr = `SELECT pg_catalog.numeric_ln($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericLog calls the stored procedure 'pg_catalog.numeric_log(numeric, numeric) numeric' on db.
func NumericLog(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.numeric_log
	const sqlstr = `SELECT pg_catalog.numeric_log($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericLt calls the stored procedure 'pg_catalog.numeric_lt(numeric, numeric) boolean' on db.
func NumericLt(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.numeric_lt
	const sqlstr = `SELECT pg_catalog.numeric_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NumericMod calls the stored procedure 'pg_catalog.numeric_mod(numeric, numeric) numeric' on db.
func NumericMod(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.numeric_mod
	const sqlstr = `SELECT pg_catalog.numeric_mod($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericMul calls the stored procedure 'pg_catalog.numeric_mul(numeric, numeric) numeric' on db.
func NumericMul(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.numeric_mul
	const sqlstr = `SELECT pg_catalog.numeric_mul($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericNe calls the stored procedure 'pg_catalog.numeric_ne(numeric, numeric) boolean' on db.
func NumericNe(ctx context.Context, db DB, v0, v1 float64) (bool, error) {
	// call pg_catalog.numeric_ne
	const sqlstr = `SELECT pg_catalog.numeric_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// NumericOut calls the stored procedure 'pg_catalog.numeric_out(numeric) cstring' on db.
func NumericOut(ctx context.Context, db DB, v0 float64) (pgtypes.Cstring, error) {
	// call pg_catalog.numeric_out
	const sqlstr = `SELECT pg_catalog.numeric_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// NumericPolyAvg calls the stored procedure 'pg_catalog.numeric_poly_avg(internal) numeric' on db.
func NumericPolyAvg(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_avg
	const sqlstr = `SELECT pg_catalog.numeric_poly_avg($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericPolyCombine calls the stored procedure 'pg_catalog.numeric_poly_combine(internal, internal) internal' on db.
func NumericPolyCombine(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_poly_combine
	const sqlstr = `SELECT pg_catalog.numeric_poly_combine($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// NumericPolyDeserialize calls the stored procedure 'pg_catalog.numeric_poly_deserialize(bytea, internal) internal' on db.
func NumericPolyDeserialize(ctx context.Context, db DB, v0 []byte, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_poly_deserialize
	const sqlstr = `SELECT pg_catalog.numeric_poly_deserialize($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// NumericPolySerialize calls the stored procedure 'pg_catalog.numeric_poly_serialize(internal) bytea' on db.
func NumericPolySerialize(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.numeric_poly_serialize
	const sqlstr = `SELECT pg_catalog.numeric_poly_serialize($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// NumericPolyStddevPop calls the stored procedure 'pg_catalog.numeric_poly_stddev_pop(internal) numeric' on db.
func NumericPolyStddevPop(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_stddev_pop
	const sqlstr = `SELECT pg_catalog.numeric_poly_stddev_pop($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericPolyStddevSamp calls the stored procedure 'pg_catalog.numeric_poly_stddev_samp(internal) numeric' on db.
func NumericPolyStddevSamp(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_stddev_samp
	const sqlstr = `SELECT pg_catalog.numeric_poly_stddev_samp($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericPolySum calls the stored procedure 'pg_catalog.numeric_poly_sum(internal) numeric' on db.
func NumericPolySum(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_sum
	const sqlstr = `SELECT pg_catalog.numeric_poly_sum($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericPolyVarPop calls the stored procedure 'pg_catalog.numeric_poly_var_pop(internal) numeric' on db.
func NumericPolyVarPop(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_var_pop
	const sqlstr = `SELECT pg_catalog.numeric_poly_var_pop($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericPolyVarSamp calls the stored procedure 'pg_catalog.numeric_poly_var_samp(internal) numeric' on db.
func NumericPolyVarSamp(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_var_samp
	const sqlstr = `SELECT pg_catalog.numeric_poly_var_samp($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericPower calls the stored procedure 'pg_catalog.numeric_power(numeric, numeric) numeric' on db.
func NumericPower(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.numeric_power
	const sqlstr = `SELECT pg_catalog.numeric_power($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericRecv calls the stored procedure 'pg_catalog.numeric_recv(internal, oid, integer) numeric' on db.
func NumericRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (float64, error) {
	// call pg_catalog.numeric_recv
	const sqlstr = `SELECT pg_catalog.numeric_recv($1, $2, $3)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericSend calls the stored procedure 'pg_catalog.numeric_send(numeric) bytea' on db.
func NumericSend(ctx context.Context, db DB, v0 float64) ([]byte, error) {
	// call pg_catalog.numeric_send
	const sqlstr = `SELECT pg_catalog.numeric_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// NumericSerialize calls the stored procedure 'pg_catalog.numeric_serialize(internal) bytea' on db.
func NumericSerialize(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.numeric_serialize
	const sqlstr = `SELECT pg_catalog.numeric_serialize($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// NumericSmaller calls the stored procedure 'pg_catalog.numeric_smaller(numeric, numeric) numeric' on db.
func NumericSmaller(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.numeric_smaller
	const sqlstr = `SELECT pg_catalog.numeric_smaller($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericSortsupport calls the stored procedure 'pg_catalog.numeric_sortsupport(internal) void' on db.
func NumericSortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.numeric_sortsupport
	const sqlstr = `SELECT pg_catalog.numeric_sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// NumericSqrt calls the stored procedure 'pg_catalog.numeric_sqrt(numeric) numeric' on db.
func NumericSqrt(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.numeric_sqrt
	const sqlstr = `SELECT pg_catalog.numeric_sqrt($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericStddevPop calls the stored procedure 'pg_catalog.numeric_stddev_pop(internal) numeric' on db.
func NumericStddevPop(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_stddev_pop
	const sqlstr = `SELECT pg_catalog.numeric_stddev_pop($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericStddevSamp calls the stored procedure 'pg_catalog.numeric_stddev_samp(internal) numeric' on db.
func NumericStddevSamp(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_stddev_samp
	const sqlstr = `SELECT pg_catalog.numeric_stddev_samp($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericSub calls the stored procedure 'pg_catalog.numeric_sub(numeric, numeric) numeric' on db.
func NumericSub(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.numeric_sub
	const sqlstr = `SELECT pg_catalog.numeric_sub($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericSum calls the stored procedure 'pg_catalog.numeric_sum(internal) numeric' on db.
func NumericSum(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_sum
	const sqlstr = `SELECT pg_catalog.numeric_sum($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericSupport calls the stored procedure 'pg_catalog.numeric_support(internal) internal' on db.
func NumericSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_support
	const sqlstr = `SELECT pg_catalog.numeric_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// NumericUminus calls the stored procedure 'pg_catalog.numeric_uminus(numeric) numeric' on db.
func NumericUminus(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.numeric_uminus
	const sqlstr = `SELECT pg_catalog.numeric_uminus($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericUplus calls the stored procedure 'pg_catalog.numeric_uplus(numeric) numeric' on db.
func NumericUplus(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.numeric_uplus
	const sqlstr = `SELECT pg_catalog.numeric_uplus($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericVarPop calls the stored procedure 'pg_catalog.numeric_var_pop(internal) numeric' on db.
func NumericVarPop(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_var_pop
	const sqlstr = `SELECT pg_catalog.numeric_var_pop($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// NumericVarSamp calls the stored procedure 'pg_catalog.numeric_var_samp(internal) numeric' on db.
func NumericVarSamp(ctx context.Context, db DB, v0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_var_samp
	const sqlstr = `SELECT pg_catalog.numeric_var_samp($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Numerictypmodin calls the stored procedure 'pg_catalog.numerictypmodin(cstring[]) integer' on db.
func Numerictypmodin(ctx context.Context, db DB, v0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.numerictypmodin
	const sqlstr = `SELECT pg_catalog.numerictypmodin($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Numerictypmodout calls the stored procedure 'pg_catalog.numerictypmodout(integer) cstring' on db.
func Numerictypmodout(ctx context.Context, db DB, v0 int) (pgtypes.Cstring, error) {
	// call pg_catalog.numerictypmodout
	const sqlstr = `SELECT pg_catalog.numerictypmodout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Numnode calls the stored procedure 'pg_catalog.numnode(tsquery) integer' on db.
func Numnode(ctx context.Context, db DB, v0 pgtypes.Tsquery) (int, error) {
	// call pg_catalog.numnode
	const sqlstr = `SELECT pg_catalog.numnode($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Numrange calls the stored procedure 'pg_catalog.numrange(numeric, numeric, numeric, numeric, text) numrange' on db.
func Numrange(ctx context.Context, db DB, v0, v1, v2, v3 float64, v4 string) (pgtypes.Numrange, error) {
	// call pg_catalog.numrange
	const sqlstr = `SELECT pg_catalog.numrange($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Numrange
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Numrange{}, logerror(err)
	}
	return ret, nil
}

// NumrangeSubdiff calls the stored procedure 'pg_catalog.numrange_subdiff(numeric, numeric) double precision' on db.
func NumrangeSubdiff(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.numrange_subdiff
	const sqlstr = `SELECT pg_catalog.numrange_subdiff($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// ObjDescription calls the stored procedure 'pg_catalog.obj_description(oid, oid, name) text' on db.
func ObjDescription(ctx context.Context, db DB, v0, v1 pgtypes.Oid, v2 pgtypes.Name) (string, error) {
	// call pg_catalog.obj_description
	const sqlstr = `SELECT pg_catalog.obj_description($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// OctetLength calls the stored procedure 'pg_catalog.octet_length(bytea, text, character, bit) integer' on db.
func OctetLength(ctx context.Context, db DB, v0 []byte, v1, v2 string, v3 uint8) (int, error) {
	// call pg_catalog.octet_length
	const sqlstr = `SELECT pg_catalog.octet_length($1, $2, $3, $4)`
	// run
	var ret int
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Oid calls the stored procedure 'pg_catalog.oid(bigint) oid' on db.
func Oid(ctx context.Context, db DB, v0 int64) (pgtypes.Oid, error) {
	// call pg_catalog.oid
	const sqlstr = `SELECT pg_catalog.oid($1)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// Oideq calls the stored procedure 'pg_catalog.oideq(oid, oid) boolean' on db.
func Oideq(ctx context.Context, db DB, v0, v1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oideq
	const sqlstr = `SELECT pg_catalog.oideq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidge calls the stored procedure 'pg_catalog.oidge(oid, oid) boolean' on db.
func Oidge(ctx context.Context, db DB, v0, v1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oidge
	const sqlstr = `SELECT pg_catalog.oidge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidgt calls the stored procedure 'pg_catalog.oidgt(oid, oid) boolean' on db.
func Oidgt(ctx context.Context, db DB, v0, v1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oidgt
	const sqlstr = `SELECT pg_catalog.oidgt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidin calls the stored procedure 'pg_catalog.oidin(cstring) oid' on db.
func Oidin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Oid, error) {
	// call pg_catalog.oidin
	const sqlstr = `SELECT pg_catalog.oidin($1)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// Oidlarger calls the stored procedure 'pg_catalog.oidlarger(oid, oid) oid' on db.
func Oidlarger(ctx context.Context, db DB, v0, v1 pgtypes.Oid) (pgtypes.Oid, error) {
	// call pg_catalog.oidlarger
	const sqlstr = `SELECT pg_catalog.oidlarger($1, $2)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// Oidle calls the stored procedure 'pg_catalog.oidle(oid, oid) boolean' on db.
func Oidle(ctx context.Context, db DB, v0, v1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oidle
	const sqlstr = `SELECT pg_catalog.oidle($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidlt calls the stored procedure 'pg_catalog.oidlt(oid, oid) boolean' on db.
func Oidlt(ctx context.Context, db DB, v0, v1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oidlt
	const sqlstr = `SELECT pg_catalog.oidlt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidne calls the stored procedure 'pg_catalog.oidne(oid, oid) boolean' on db.
func Oidne(ctx context.Context, db DB, v0, v1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oidne
	const sqlstr = `SELECT pg_catalog.oidne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidout calls the stored procedure 'pg_catalog.oidout(oid) cstring' on db.
func Oidout(ctx context.Context, db DB, v0 pgtypes.Oid) (pgtypes.Cstring, error) {
	// call pg_catalog.oidout
	const sqlstr = `SELECT pg_catalog.oidout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Oidrecv calls the stored procedure 'pg_catalog.oidrecv(internal) oid' on db.
func Oidrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Oid, error) {
	// call pg_catalog.oidrecv
	const sqlstr = `SELECT pg_catalog.oidrecv($1)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// Oidsend calls the stored procedure 'pg_catalog.oidsend(oid) bytea' on db.
func Oidsend(ctx context.Context, db DB, v0 pgtypes.Oid) ([]byte, error) {
	// call pg_catalog.oidsend
	const sqlstr = `SELECT pg_catalog.oidsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Oidsmaller calls the stored procedure 'pg_catalog.oidsmaller(oid, oid) oid' on db.
func Oidsmaller(ctx context.Context, db DB, v0, v1 pgtypes.Oid) (pgtypes.Oid, error) {
	// call pg_catalog.oidsmaller
	const sqlstr = `SELECT pg_catalog.oidsmaller($1, $2)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// Oidvectoreq calls the stored procedure 'pg_catalog.oidvectoreq(oidvector, oidvector) boolean' on db.
func Oidvectoreq(ctx context.Context, db DB, v0, v1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectoreq
	const sqlstr = `SELECT pg_catalog.oidvectoreq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidvectorge calls the stored procedure 'pg_catalog.oidvectorge(oidvector, oidvector) boolean' on db.
func Oidvectorge(ctx context.Context, db DB, v0, v1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectorge
	const sqlstr = `SELECT pg_catalog.oidvectorge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidvectorgt calls the stored procedure 'pg_catalog.oidvectorgt(oidvector, oidvector) boolean' on db.
func Oidvectorgt(ctx context.Context, db DB, v0, v1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectorgt
	const sqlstr = `SELECT pg_catalog.oidvectorgt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidvectorin calls the stored procedure 'pg_catalog.oidvectorin(cstring) oidvector' on db.
func Oidvectorin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Oidvector, error) {
	// call pg_catalog.oidvectorin
	const sqlstr = `SELECT pg_catalog.oidvectorin($1)`
	// run
	var ret pgtypes.Oidvector
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oidvector{}, logerror(err)
	}
	return ret, nil
}

// Oidvectorle calls the stored procedure 'pg_catalog.oidvectorle(oidvector, oidvector) boolean' on db.
func Oidvectorle(ctx context.Context, db DB, v0, v1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectorle
	const sqlstr = `SELECT pg_catalog.oidvectorle($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidvectorlt calls the stored procedure 'pg_catalog.oidvectorlt(oidvector, oidvector) boolean' on db.
func Oidvectorlt(ctx context.Context, db DB, v0, v1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectorlt
	const sqlstr = `SELECT pg_catalog.oidvectorlt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidvectorne calls the stored procedure 'pg_catalog.oidvectorne(oidvector, oidvector) boolean' on db.
func Oidvectorne(ctx context.Context, db DB, v0, v1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectorne
	const sqlstr = `SELECT pg_catalog.oidvectorne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Oidvectorout calls the stored procedure 'pg_catalog.oidvectorout(oidvector) cstring' on db.
func Oidvectorout(ctx context.Context, db DB, v0 pgtypes.Oidvector) (pgtypes.Cstring, error) {
	// call pg_catalog.oidvectorout
	const sqlstr = `SELECT pg_catalog.oidvectorout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Oidvectorrecv calls the stored procedure 'pg_catalog.oidvectorrecv(internal) oidvector' on db.
func Oidvectorrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Oidvector, error) {
	// call pg_catalog.oidvectorrecv
	const sqlstr = `SELECT pg_catalog.oidvectorrecv($1)`
	// run
	var ret pgtypes.Oidvector
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oidvector{}, logerror(err)
	}
	return ret, nil
}

// Oidvectorsend calls the stored procedure 'pg_catalog.oidvectorsend(oidvector) bytea' on db.
func Oidvectorsend(ctx context.Context, db DB, v0 pgtypes.Oidvector) ([]byte, error) {
	// call pg_catalog.oidvectorsend
	const sqlstr = `SELECT pg_catalog.oidvectorsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Oidvectortypes calls the stored procedure 'pg_catalog.oidvectortypes(oidvector) text' on db.
func Oidvectortypes(ctx context.Context, db DB, v0 pgtypes.Oidvector) (string, error) {
	// call pg_catalog.oidvectortypes
	const sqlstr = `SELECT pg_catalog.oidvectortypes($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// OnPb calls the stored procedure 'pg_catalog.on_pb(point, box) boolean' on db.
func OnPb(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.on_pb
	const sqlstr = `SELECT pg_catalog.on_pb($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// OnPl calls the stored procedure 'pg_catalog.on_pl(point, line) boolean' on db.
func OnPl(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Line) (bool, error) {
	// call pg_catalog.on_pl
	const sqlstr = `SELECT pg_catalog.on_pl($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// OnPpath calls the stored procedure 'pg_catalog.on_ppath(point, path) boolean' on db.
func OnPpath(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Path) (bool, error) {
	// call pg_catalog.on_ppath
	const sqlstr = `SELECT pg_catalog.on_ppath($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// OnPs calls the stored procedure 'pg_catalog.on_ps(point, lseg) boolean' on db.
func OnPs(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.on_ps
	const sqlstr = `SELECT pg_catalog.on_ps($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// OnSb calls the stored procedure 'pg_catalog.on_sb(lseg, box) boolean' on db.
func OnSb(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Box) (bool, error) {
	// call pg_catalog.on_sb
	const sqlstr = `SELECT pg_catalog.on_sb($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// OnSl calls the stored procedure 'pg_catalog.on_sl(lseg, line) boolean' on db.
func OnSl(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Line) (bool, error) {
	// call pg_catalog.on_sl
	const sqlstr = `SELECT pg_catalog.on_sl($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// OrderedSetTransition calls the stored procedure 'pg_catalog.ordered_set_transition(internal, "any") internal' on db.
func OrderedSetTransition(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Any) (pgtypes.Internal, error) {
	// call pg_catalog.ordered_set_transition
	const sqlstr = `SELECT pg_catalog.ordered_set_transition($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// OrderedSetTransitionMulti calls the stored procedure 'pg_catalog.ordered_set_transition_multi(internal, "any") internal' on db.
func OrderedSetTransitionMulti(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Any) (pgtypes.Internal, error) {
	// call pg_catalog.ordered_set_transition_multi
	const sqlstr = `SELECT pg_catalog.ordered_set_transition_multi($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Overlaps calls the stored procedure 'pg_catalog.overlaps(time without time zone, time without time zone, time without time zone, time without time zone, time without time zone, time without time zone, time without time zone, interval, time without time zone, interval, time without time zone, time without time zone, time without time zone, interval, time without time zone, interval, timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, interval, timestamp without time zone, interval, timestamp without time zone, timestamp without time zone, timestamp without time zone, interval, timestamp without time zone, interval, timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone, interval, timestamp with time zone, interval, timestamp with time zone, timestamp with time zone, timestamp with time zone, interval, timestamp with time zone, interval, time with time zone, time with time zone, time with time zone, time with time zone) boolean' on db.
func Overlaps(ctx context.Context, db DB, v0, v1, v2, v3, v4, v5, v6 time.Time, v7 []byte, v8 time.Time, v9 []byte, v10, v11, v12 time.Time, v13 []byte, v14 time.Time, v15 []byte, v16, v17, v18, v19, v20, v21, v22 time.Time, v23 []byte, v24 time.Time, v25 []byte, v26, v27, v28 time.Time, v29 []byte, v30 time.Time, v31 []byte, v32, v33, v34, v35, v36, v37, v38 time.Time, v39 []byte, v40 time.Time, v41 []byte, v42, v43, v44 time.Time, v45 []byte, v46 time.Time, v47 []byte, v48, v49, v50, v51 time.Time) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT pg_catalog.overlaps($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Overlay calls the stored procedure 'pg_catalog.overlay(bytea, bytea, integer, text, text, integer, bit, bit, integer, bytea, bytea, integer, integer, text, text, integer, integer, bit, bit, integer, integer) bit' on db.
func Overlay(ctx context.Context, db DB, v0, v1 []byte, v2 int, v3, v4 string, v5 int, v6, v7 uint8, v8 int, v9, v10 []byte, v11, v12 int, v13, v14 string, v15, v16 int, v17, v18 uint8, v19, v20 int) (uint8, error) {
	// call pg_catalog.overlay
	const sqlstr = `SELECT pg_catalog.overlay($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// ParseIdent calls the stored procedure 'pg_catalog.parse_ident(text, boolean) text[]' on db.
func ParseIdent(ctx context.Context, db DB, v0 string, v1 bool) (StringSlice, error) {
	// call pg_catalog.parse_ident
	const sqlstr = `SELECT pg_catalog.parse_ident($1, $2)`
	// run
	var ret StringSlice
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return StringSlice{}, logerror(err)
	}
	return ret, nil
}

// Path calls the stored procedure 'pg_catalog.path(polygon) path' on db.
func Path(ctx context.Context, db DB, v0 pgtypes.Polygon) (pgtypes.Path, error) {
	// call pg_catalog.path
	const sqlstr = `SELECT pg_catalog.path($1)`
	// run
	var ret pgtypes.Path
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return ret, nil
}

// PathAdd calls the stored procedure 'pg_catalog.path_add(path, path) path' on db.
func PathAdd(ctx context.Context, db DB, v0, v1 pgtypes.Path) (pgtypes.Path, error) {
	// call pg_catalog.path_add
	const sqlstr = `SELECT pg_catalog.path_add($1, $2)`
	// run
	var ret pgtypes.Path
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return ret, nil
}

// PathAddPt calls the stored procedure 'pg_catalog.path_add_pt(path, point) path' on db.
func PathAddPt(ctx context.Context, db DB, v0 pgtypes.Path, v1 pgtypes.Point) (pgtypes.Path, error) {
	// call pg_catalog.path_add_pt
	const sqlstr = `SELECT pg_catalog.path_add_pt($1, $2)`
	// run
	var ret pgtypes.Path
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return ret, nil
}

// PathCenter calls the stored procedure 'pg_catalog.path_center(path) point' on db.
func PathCenter(ctx context.Context, db DB, v0 pgtypes.Path) (pgtypes.Point, error) {
	// call pg_catalog.path_center
	const sqlstr = `SELECT pg_catalog.path_center($1)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// PathContainPt calls the stored procedure 'pg_catalog.path_contain_pt(path, point) boolean' on db.
func PathContainPt(ctx context.Context, db DB, v0 pgtypes.Path, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.path_contain_pt
	const sqlstr = `SELECT pg_catalog.path_contain_pt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PathDistance calls the stored procedure 'pg_catalog.path_distance(path, path) double precision' on db.
func PathDistance(ctx context.Context, db DB, v0, v1 pgtypes.Path) (float64, error) {
	// call pg_catalog.path_distance
	const sqlstr = `SELECT pg_catalog.path_distance($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PathDivPt calls the stored procedure 'pg_catalog.path_div_pt(path, point) path' on db.
func PathDivPt(ctx context.Context, db DB, v0 pgtypes.Path, v1 pgtypes.Point) (pgtypes.Path, error) {
	// call pg_catalog.path_div_pt
	const sqlstr = `SELECT pg_catalog.path_div_pt($1, $2)`
	// run
	var ret pgtypes.Path
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return ret, nil
}

// PathIn calls the stored procedure 'pg_catalog.path_in(cstring) path' on db.
func PathIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Path, error) {
	// call pg_catalog.path_in
	const sqlstr = `SELECT pg_catalog.path_in($1)`
	// run
	var ret pgtypes.Path
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return ret, nil
}

// PathInter calls the stored procedure 'pg_catalog.path_inter(path, path) boolean' on db.
func PathInter(ctx context.Context, db DB, v0, v1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_inter
	const sqlstr = `SELECT pg_catalog.path_inter($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PathLength calls the stored procedure 'pg_catalog.path_length(path) double precision' on db.
func PathLength(ctx context.Context, db DB, v0 pgtypes.Path) (float64, error) {
	// call pg_catalog.path_length
	const sqlstr = `SELECT pg_catalog.path_length($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PathMulPt calls the stored procedure 'pg_catalog.path_mul_pt(path, point) path' on db.
func PathMulPt(ctx context.Context, db DB, v0 pgtypes.Path, v1 pgtypes.Point) (pgtypes.Path, error) {
	// call pg_catalog.path_mul_pt
	const sqlstr = `SELECT pg_catalog.path_mul_pt($1, $2)`
	// run
	var ret pgtypes.Path
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return ret, nil
}

// PathNEq calls the stored procedure 'pg_catalog.path_n_eq(path, path) boolean' on db.
func PathNEq(ctx context.Context, db DB, v0, v1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_n_eq
	const sqlstr = `SELECT pg_catalog.path_n_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PathNGe calls the stored procedure 'pg_catalog.path_n_ge(path, path) boolean' on db.
func PathNGe(ctx context.Context, db DB, v0, v1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_n_ge
	const sqlstr = `SELECT pg_catalog.path_n_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PathNGt calls the stored procedure 'pg_catalog.path_n_gt(path, path) boolean' on db.
func PathNGt(ctx context.Context, db DB, v0, v1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_n_gt
	const sqlstr = `SELECT pg_catalog.path_n_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PathNLe calls the stored procedure 'pg_catalog.path_n_le(path, path) boolean' on db.
func PathNLe(ctx context.Context, db DB, v0, v1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_n_le
	const sqlstr = `SELECT pg_catalog.path_n_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PathNLt calls the stored procedure 'pg_catalog.path_n_lt(path, path) boolean' on db.
func PathNLt(ctx context.Context, db DB, v0, v1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_n_lt
	const sqlstr = `SELECT pg_catalog.path_n_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PathNpoints calls the stored procedure 'pg_catalog.path_npoints(path) integer' on db.
func PathNpoints(ctx context.Context, db DB, v0 pgtypes.Path) (int, error) {
	// call pg_catalog.path_npoints
	const sqlstr = `SELECT pg_catalog.path_npoints($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PathOut calls the stored procedure 'pg_catalog.path_out(path) cstring' on db.
func PathOut(ctx context.Context, db DB, v0 pgtypes.Path) (pgtypes.Cstring, error) {
	// call pg_catalog.path_out
	const sqlstr = `SELECT pg_catalog.path_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// PathRecv calls the stored procedure 'pg_catalog.path_recv(internal) path' on db.
func PathRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Path, error) {
	// call pg_catalog.path_recv
	const sqlstr = `SELECT pg_catalog.path_recv($1)`
	// run
	var ret pgtypes.Path
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return ret, nil
}

// PathSend calls the stored procedure 'pg_catalog.path_send(path) bytea' on db.
func PathSend(ctx context.Context, db DB, v0 pgtypes.Path) ([]byte, error) {
	// call pg_catalog.path_send
	const sqlstr = `SELECT pg_catalog.path_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PathSubPt calls the stored procedure 'pg_catalog.path_sub_pt(path, point) path' on db.
func PathSubPt(ctx context.Context, db DB, v0 pgtypes.Path, v1 pgtypes.Point) (pgtypes.Path, error) {
	// call pg_catalog.path_sub_pt
	const sqlstr = `SELECT pg_catalog.path_sub_pt($1, $2)`
	// run
	var ret pgtypes.Path
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return ret, nil
}

// Pclose calls the stored procedure 'pg_catalog.pclose(path) path' on db.
func Pclose(ctx context.Context, db DB, v0 pgtypes.Path) (pgtypes.Path, error) {
	// call pg_catalog.pclose
	const sqlstr = `SELECT pg_catalog.pclose($1)`
	// run
	var ret pgtypes.Path
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return ret, nil
}

// PercentRank calls the stored procedure 'pg_catalog.percent_rank("any") double precision' on db.
func PercentRank(ctx context.Context, db DB, v0 pgtypes.Any) (float64, error) {
	// call pg_catalog.percent_rank
	const sqlstr = `SELECT pg_catalog.percent_rank($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PercentRankFinal calls the stored procedure 'pg_catalog.percent_rank_final(internal, "any") double precision' on db.
func PercentRankFinal(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Any) (float64, error) {
	// call pg_catalog.percent_rank_final
	const sqlstr = `SELECT pg_catalog.percent_rank_final($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PercentileCont calls the stored procedure 'pg_catalog.percentile_cont(double precision, double precision, double precision, interval, double precision[], double precision, double precision[], interval) interval[]' on db.
func PercentileCont(ctx context.Context, db DB, v0, v1, v2 float64, v3 []byte, v4 []float64, v5 float64, v6 []float64, v7 []byte) ([]byte, error) {
	// call pg_catalog.percentile_cont
	const sqlstr = `SELECT pg_catalog.percentile_cont($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PercentileContFloat8Final calls the stored procedure 'pg_catalog.percentile_cont_float8_final(internal, double precision) double precision' on db.
func PercentileContFloat8Final(ctx context.Context, db DB, v0 pgtypes.Internal, v1 float64) (float64, error) {
	// call pg_catalog.percentile_cont_float8_final
	const sqlstr = `SELECT pg_catalog.percentile_cont_float8_final($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PercentileContFloat8MultiFinal calls the stored procedure 'pg_catalog.percentile_cont_float8_multi_final(internal, double precision[]) double precision[]' on db.
func PercentileContFloat8MultiFinal(ctx context.Context, db DB, v0 pgtypes.Internal, v1 []float64) ([]float64, error) {
	// call pg_catalog.percentile_cont_float8_multi_final
	const sqlstr = `SELECT pg_catalog.percentile_cont_float8_multi_final($1, $2)`
	// run
	var ret []float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PercentileContIntervalFinal calls the stored procedure 'pg_catalog.percentile_cont_interval_final(internal, double precision) interval' on db.
func PercentileContIntervalFinal(ctx context.Context, db DB, v0 pgtypes.Internal, v1 float64) ([]byte, error) {
	// call pg_catalog.percentile_cont_interval_final
	const sqlstr = `SELECT pg_catalog.percentile_cont_interval_final($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PercentileContIntervalMultiFinal calls the stored procedure 'pg_catalog.percentile_cont_interval_multi_final(internal, double precision[]) interval[]' on db.
func PercentileContIntervalMultiFinal(ctx context.Context, db DB, v0 pgtypes.Internal, v1 []float64) ([]byte, error) {
	// call pg_catalog.percentile_cont_interval_multi_final
	const sqlstr = `SELECT pg_catalog.percentile_cont_interval_multi_final($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PercentileDisc calls the stored procedure 'pg_catalog.percentile_disc(double precision, anyelement, double precision[], anyelement) anyarray' on db.
func PercentileDisc(ctx context.Context, db DB, v0 float64, v1 pgtypes.Anyelement, v2 []float64, v3 pgtypes.Anyelement) (pgtypes.Anyarray, error) {
	// call pg_catalog.percentile_disc
	const sqlstr = `SELECT pg_catalog.percentile_disc($1, $2, $3, $4)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// PercentileDiscFinal calls the stored procedure 'pg_catalog.percentile_disc_final(internal, double precision, anyelement) anyelement' on db.
func PercentileDiscFinal(ctx context.Context, db DB, v0 pgtypes.Internal, v1 float64, v2 pgtypes.Anyelement) (pgtypes.Anyelement, error) {
	// call pg_catalog.percentile_disc_final
	const sqlstr = `SELECT pg_catalog.percentile_disc_final($1, $2, $3)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// PercentileDiscMultiFinal calls the stored procedure 'pg_catalog.percentile_disc_multi_final(internal, double precision[], anyelement) anyarray' on db.
func PercentileDiscMultiFinal(ctx context.Context, db DB, v0 pgtypes.Internal, v1 []float64, v2 pgtypes.Anyelement) (pgtypes.Anyarray, error) {
	// call pg_catalog.percentile_disc_multi_final
	const sqlstr = `SELECT pg_catalog.percentile_disc_multi_final($1, $2, $3)`
	// run
	var ret pgtypes.Anyarray
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return ret, nil
}

// PgAdvisoryLock calls the stored procedure 'pg_catalog.pg_advisory_lock(bigint, integer, integer) void' on db.
func PgAdvisoryLock(ctx context.Context, db DB, v0 int64, v1, v2 int) error {
	// call pg_catalog.pg_advisory_lock
	const sqlstr = `SELECT pg_catalog.pg_advisory_lock($1, $2, $3)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryLockShared calls the stored procedure 'pg_catalog.pg_advisory_lock_shared(bigint, integer, integer) void' on db.
func PgAdvisoryLockShared(ctx context.Context, db DB, v0 int64, v1, v2 int) error {
	// call pg_catalog.pg_advisory_lock_shared
	const sqlstr = `SELECT pg_catalog.pg_advisory_lock_shared($1, $2, $3)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryUnlock calls the stored procedure 'pg_catalog.pg_advisory_unlock(bigint, integer, integer) boolean' on db.
func PgAdvisoryUnlock(ctx context.Context, db DB, v0 int64, v1, v2 int) (bool, error) {
	// call pg_catalog.pg_advisory_unlock
	const sqlstr = `SELECT pg_catalog.pg_advisory_unlock($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgAdvisoryUnlockAll calls the stored procedure 'pg_catalog.pg_advisory_unlock_all() void' on db.
func PgAdvisoryUnlockAll(ctx context.Context, db DB) error {
	// call pg_catalog.pg_advisory_unlock_all
	const sqlstr = `SELECT pg_catalog.pg_advisory_unlock_all()`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryUnlockShared calls the stored procedure 'pg_catalog.pg_advisory_unlock_shared(bigint, integer, integer) boolean' on db.
func PgAdvisoryUnlockShared(ctx context.Context, db DB, v0 int64, v1, v2 int) (bool, error) {
	// call pg_catalog.pg_advisory_unlock_shared
	const sqlstr = `SELECT pg_catalog.pg_advisory_unlock_shared($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgAdvisoryXactLock calls the stored procedure 'pg_catalog.pg_advisory_xact_lock(bigint, integer, integer) void' on db.
func PgAdvisoryXactLock(ctx context.Context, db DB, v0 int64, v1, v2 int) error {
	// call pg_catalog.pg_advisory_xact_lock
	const sqlstr = `SELECT pg_catalog.pg_advisory_xact_lock($1, $2, $3)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryXactLockShared calls the stored procedure 'pg_catalog.pg_advisory_xact_lock_shared(bigint, integer, integer) void' on db.
func PgAdvisoryXactLockShared(ctx context.Context, db DB, v0 int64, v1, v2 int) error {
	// call pg_catalog.pg_advisory_xact_lock_shared
	const sqlstr = `SELECT pg_catalog.pg_advisory_xact_lock_shared($1, $2, $3)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAvailableExtensionVersions calls the stored procedure 'pg_catalog.pg_available_extension_versions() SETOF record' on db.
func PgAvailableExtensionVersions(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_available_extension_versions
	const sqlstr = `SELECT pg_catalog.pg_available_extension_versions()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgAvailableExtensions calls the stored procedure 'pg_catalog.pg_available_extensions() SETOF record' on db.
func PgAvailableExtensions(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_available_extensions
	const sqlstr = `SELECT pg_catalog.pg_available_extensions()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgBackendPid calls the stored procedure 'pg_catalog.pg_backend_pid() integer' on db.
func PgBackendPid(ctx context.Context, db DB) (int, error) {
	// call pg_catalog.pg_backend_pid
	const sqlstr = `SELECT pg_catalog.pg_backend_pid()`
	// run
	var ret int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgBackupStartTime calls the stored procedure 'pg_catalog.pg_backup_start_time() timestamp with time zone' on db.
func PgBackupStartTime(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_backup_start_time
	const sqlstr = `SELECT pg_catalog.pg_backup_start_time()`
	// run
	var ret time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgBlockingPids calls the stored procedure 'pg_catalog.pg_blocking_pids(integer) integer[]' on db.
func PgBlockingPids(ctx context.Context, db DB, v0 int) ([]int, error) {
	// call pg_catalog.pg_blocking_pids
	const sqlstr = `SELECT pg_catalog.pg_blocking_pids($1)`
	// run
	var ret []int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgCancelBackend calls the stored procedure 'pg_catalog.pg_cancel_backend(integer) boolean' on db.
func PgCancelBackend(ctx context.Context, db DB, v0 int) (bool, error) {
	// call pg_catalog.pg_cancel_backend
	const sqlstr = `SELECT pg_catalog.pg_cancel_backend($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgCharToEncoding calls the stored procedure 'pg_catalog.pg_char_to_encoding(name) integer' on db.
func PgCharToEncoding(ctx context.Context, db DB, v0 pgtypes.Name) (int, error) {
	// call pg_catalog.pg_char_to_encoding
	const sqlstr = `SELECT pg_catalog.pg_char_to_encoding($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgClientEncoding calls the stored procedure 'pg_catalog.pg_client_encoding() name' on db.
func PgClientEncoding(ctx context.Context, db DB) (pgtypes.Name, error) {
	// call pg_catalog.pg_client_encoding
	const sqlstr = `SELECT pg_catalog.pg_client_encoding()`
	// run
	var ret pgtypes.Name
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// PgCollationActualVersion calls the stored procedure 'pg_catalog.pg_collation_actual_version(oid) text' on db.
func PgCollationActualVersion(ctx context.Context, db DB, v0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_collation_actual_version
	const sqlstr = `SELECT pg_catalog.pg_collation_actual_version($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgCollationFor calls the stored procedure 'pg_catalog.pg_collation_for("any") text' on db.
func PgCollationFor(ctx context.Context, db DB, v0 pgtypes.Any) (string, error) {
	// call pg_catalog.pg_collation_for
	const sqlstr = `SELECT pg_catalog.pg_collation_for($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgCollationIsVisible calls the stored procedure 'pg_catalog.pg_collation_is_visible(oid) boolean' on db.
func PgCollationIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_collation_is_visible
	const sqlstr = `SELECT pg_catalog.pg_collation_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgColumnIsUpdatable calls the stored procedure 'pg_catalog.pg_column_is_updatable(regclass, smallint, boolean) boolean' on db.
func PgColumnIsUpdatable(ctx context.Context, db DB, v0 pgtypes.Regclass, v1 int16, v2 bool) (bool, error) {
	// call pg_catalog.pg_column_is_updatable
	const sqlstr = `SELECT pg_catalog.pg_column_is_updatable($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgColumnSize calls the stored procedure 'pg_catalog.pg_column_size("any") integer' on db.
func PgColumnSize(ctx context.Context, db DB, v0 pgtypes.Any) (int, error) {
	// call pg_catalog.pg_column_size
	const sqlstr = `SELECT pg_catalog.pg_column_size($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgConfLoadTime calls the stored procedure 'pg_catalog.pg_conf_load_time() timestamp with time zone' on db.
func PgConfLoadTime(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_conf_load_time
	const sqlstr = `SELECT pg_catalog.pg_conf_load_time()`
	// run
	var ret time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgConfig calls the stored procedure 'pg_catalog.pg_config() SETOF record' on db.
func PgConfig(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_config
	const sqlstr = `SELECT pg_catalog.pg_config()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgControlCheckpoint calls the stored procedure 'pg_catalog.pg_control_checkpoint() record' on db.
func PgControlCheckpoint(ctx context.Context, db DB) (pgtypes.Record, error) {
	// call pg_catalog.pg_control_checkpoint
	const sqlstr = `SELECT pg_catalog.pg_control_checkpoint()`
	// run
	var ret pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgControlInit calls the stored procedure 'pg_catalog.pg_control_init() record' on db.
func PgControlInit(ctx context.Context, db DB) (pgtypes.Record, error) {
	// call pg_catalog.pg_control_init
	const sqlstr = `SELECT pg_catalog.pg_control_init()`
	// run
	var ret pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgControlRecovery calls the stored procedure 'pg_catalog.pg_control_recovery() record' on db.
func PgControlRecovery(ctx context.Context, db DB) (pgtypes.Record, error) {
	// call pg_catalog.pg_control_recovery
	const sqlstr = `SELECT pg_catalog.pg_control_recovery()`
	// run
	var ret pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgControlSystem calls the stored procedure 'pg_catalog.pg_control_system() record' on db.
func PgControlSystem(ctx context.Context, db DB) (pgtypes.Record, error) {
	// call pg_catalog.pg_control_system
	const sqlstr = `SELECT pg_catalog.pg_control_system()`
	// run
	var ret pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgConversionIsVisible calls the stored procedure 'pg_catalog.pg_conversion_is_visible(oid) boolean' on db.
func PgConversionIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_conversion_is_visible
	const sqlstr = `SELECT pg_catalog.pg_conversion_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgCopyLogicalReplicationSlot calls the stored procedure 'pg_catalog.pg_copy_logical_replication_slot(name, name, name, name, boolean, name, name, boolean, name) record' on db.
func PgCopyLogicalReplicationSlot(ctx context.Context, db DB, v0, v1, v2, v3 pgtypes.Name, v4 bool, v5, v6 pgtypes.Name, v7 bool, v8 pgtypes.Name) (pgtypes.Record, error) {
	// call pg_catalog.pg_copy_logical_replication_slot
	const sqlstr = `SELECT pg_catalog.pg_copy_logical_replication_slot($1, $2, $3, $4, $5, $6, $7, $8, $9)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgCopyPhysicalReplicationSlot calls the stored procedure 'pg_catalog.pg_copy_physical_replication_slot(name, name, name, name, boolean) record' on db.
func PgCopyPhysicalReplicationSlot(ctx context.Context, db DB, v0, v1, v2, v3 pgtypes.Name, v4 bool) (pgtypes.Record, error) {
	// call pg_catalog.pg_copy_physical_replication_slot
	const sqlstr = `SELECT pg_catalog.pg_copy_physical_replication_slot($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgCreateLogicalReplicationSlot calls the stored procedure 'pg_catalog.pg_create_logical_replication_slot(name, name, boolean) record' on db.
func PgCreateLogicalReplicationSlot(ctx context.Context, db DB, v0, v1 pgtypes.Name, v2 bool) (pgtypes.Record, error) {
	// call pg_catalog.pg_create_logical_replication_slot
	const sqlstr = `SELECT pg_catalog.pg_create_logical_replication_slot($1, $2, $3)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgCreatePhysicalReplicationSlot calls the stored procedure 'pg_catalog.pg_create_physical_replication_slot(name, boolean, boolean) record' on db.
func PgCreatePhysicalReplicationSlot(ctx context.Context, db DB, v0 pgtypes.Name, v1, v2 bool) (pgtypes.Record, error) {
	// call pg_catalog.pg_create_physical_replication_slot
	const sqlstr = `SELECT pg_catalog.pg_create_physical_replication_slot($1, $2, $3)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgCreateRestorePoint calls the stored procedure 'pg_catalog.pg_create_restore_point(text) pg_lsn' on db.
func PgCreateRestorePoint(ctx context.Context, db DB, v0 string) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_create_restore_point
	const sqlstr = `SELECT pg_catalog.pg_create_restore_point($1)`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgCurrentLogfile calls the stored procedure 'pg_catalog.pg_current_logfile(text) text' on db.
func PgCurrentLogfile(ctx context.Context, db DB, v0 string) (string, error) {
	// call pg_catalog.pg_current_logfile
	const sqlstr = `SELECT pg_catalog.pg_current_logfile($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgCurrentSnapshot calls the stored procedure 'pg_catalog.pg_current_snapshot() pg_snapshot' on db.
func PgCurrentSnapshot(ctx context.Context, db DB) (pgtypes.PgSnapshot, error) {
	// call pg_catalog.pg_current_snapshot
	const sqlstr = `SELECT pg_catalog.pg_current_snapshot()`
	// run
	var ret pgtypes.PgSnapshot
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.PgSnapshot{}, logerror(err)
	}
	return ret, nil
}

// PgCurrentWalFlushLsn calls the stored procedure 'pg_catalog.pg_current_wal_flush_lsn() pg_lsn' on db.
func PgCurrentWalFlushLsn(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_current_wal_flush_lsn
	const sqlstr = `SELECT pg_catalog.pg_current_wal_flush_lsn()`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgCurrentWalInsertLsn calls the stored procedure 'pg_catalog.pg_current_wal_insert_lsn() pg_lsn' on db.
func PgCurrentWalInsertLsn(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_current_wal_insert_lsn
	const sqlstr = `SELECT pg_catalog.pg_current_wal_insert_lsn()`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgCurrentWalLsn calls the stored procedure 'pg_catalog.pg_current_wal_lsn() pg_lsn' on db.
func PgCurrentWalLsn(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_current_wal_lsn
	const sqlstr = `SELECT pg_catalog.pg_current_wal_lsn()`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgCurrentXactID calls the stored procedure 'pg_catalog.pg_current_xact_id() xid8' on db.
func PgCurrentXactID(ctx context.Context, db DB) (pgtypes.Xid8, error) {
	// call pg_catalog.pg_current_xact_id
	const sqlstr = `SELECT pg_catalog.pg_current_xact_id()`
	// run
	var ret pgtypes.Xid8
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return ret, nil
}

// PgCurrentXactIDIfAssigned calls the stored procedure 'pg_catalog.pg_current_xact_id_if_assigned() xid8' on db.
func PgCurrentXactIDIfAssigned(ctx context.Context, db DB) (pgtypes.Xid8, error) {
	// call pg_catalog.pg_current_xact_id_if_assigned
	const sqlstr = `SELECT pg_catalog.pg_current_xact_id_if_assigned()`
	// run
	var ret pgtypes.Xid8
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return ret, nil
}

// PgCursor calls the stored procedure 'pg_catalog.pg_cursor() SETOF record' on db.
func PgCursor(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_cursor
	const sqlstr = `SELECT pg_catalog.pg_cursor()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgDatabaseSize calls the stored procedure 'pg_catalog.pg_database_size(name, oid) bigint' on db.
func PgDatabaseSize(ctx context.Context, db DB, v0 pgtypes.Name, v1 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_database_size
	const sqlstr = `SELECT pg_catalog.pg_database_size($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgDdlCommandIn calls the stored procedure 'pg_catalog.pg_ddl_command_in(cstring) pg_ddl_command' on db.
func PgDdlCommandIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.PgDdlCommand, error) {
	// call pg_catalog.pg_ddl_command_in
	const sqlstr = `SELECT pg_catalog.pg_ddl_command_in($1)`
	// run
	var ret pgtypes.PgDdlCommand
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgDdlCommand{}, logerror(err)
	}
	return ret, nil
}

// PgDdlCommandOut calls the stored procedure 'pg_catalog.pg_ddl_command_out(pg_ddl_command) cstring' on db.
func PgDdlCommandOut(ctx context.Context, db DB, v0 pgtypes.PgDdlCommand) (pgtypes.Cstring, error) {
	// call pg_catalog.pg_ddl_command_out
	const sqlstr = `SELECT pg_catalog.pg_ddl_command_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// PgDdlCommandRecv calls the stored procedure 'pg_catalog.pg_ddl_command_recv(internal) pg_ddl_command' on db.
func PgDdlCommandRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.PgDdlCommand, error) {
	// call pg_catalog.pg_ddl_command_recv
	const sqlstr = `SELECT pg_catalog.pg_ddl_command_recv($1)`
	// run
	var ret pgtypes.PgDdlCommand
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgDdlCommand{}, logerror(err)
	}
	return ret, nil
}

// PgDdlCommandSend calls the stored procedure 'pg_catalog.pg_ddl_command_send(pg_ddl_command) bytea' on db.
func PgDdlCommandSend(ctx context.Context, db DB, v0 pgtypes.PgDdlCommand) ([]byte, error) {
	// call pg_catalog.pg_ddl_command_send
	const sqlstr = `SELECT pg_catalog.pg_ddl_command_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgDependenciesIn calls the stored procedure 'pg_catalog.pg_dependencies_in(cstring) pg_dependencies' on db.
func PgDependenciesIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.PgDependencies, error) {
	// call pg_catalog.pg_dependencies_in
	const sqlstr = `SELECT pg_catalog.pg_dependencies_in($1)`
	// run
	var ret pgtypes.PgDependencies
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgDependencies{}, logerror(err)
	}
	return ret, nil
}

// PgDependenciesOut calls the stored procedure 'pg_catalog.pg_dependencies_out(pg_dependencies) cstring' on db.
func PgDependenciesOut(ctx context.Context, db DB, v0 pgtypes.PgDependencies) (pgtypes.Cstring, error) {
	// call pg_catalog.pg_dependencies_out
	const sqlstr = `SELECT pg_catalog.pg_dependencies_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// PgDependenciesRecv calls the stored procedure 'pg_catalog.pg_dependencies_recv(internal) pg_dependencies' on db.
func PgDependenciesRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.PgDependencies, error) {
	// call pg_catalog.pg_dependencies_recv
	const sqlstr = `SELECT pg_catalog.pg_dependencies_recv($1)`
	// run
	var ret pgtypes.PgDependencies
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgDependencies{}, logerror(err)
	}
	return ret, nil
}

// PgDependenciesSend calls the stored procedure 'pg_catalog.pg_dependencies_send(pg_dependencies) bytea' on db.
func PgDependenciesSend(ctx context.Context, db DB, v0 pgtypes.PgDependencies) ([]byte, error) {
	// call pg_catalog.pg_dependencies_send
	const sqlstr = `SELECT pg_catalog.pg_dependencies_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgDescribeObject calls the stored procedure 'pg_catalog.pg_describe_object(oid, oid, integer) text' on db.
func PgDescribeObject(ctx context.Context, db DB, v0, v1 pgtypes.Oid, v2 int) (string, error) {
	// call pg_catalog.pg_describe_object
	const sqlstr = `SELECT pg_catalog.pg_describe_object($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgDropReplicationSlot calls the stored procedure 'pg_catalog.pg_drop_replication_slot(name) void' on db.
func PgDropReplicationSlot(ctx context.Context, db DB, v0 pgtypes.Name) error {
	// call pg_catalog.pg_drop_replication_slot
	const sqlstr = `SELECT pg_catalog.pg_drop_replication_slot($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgEncodingMaxLength calls the stored procedure 'pg_catalog.pg_encoding_max_length(integer) integer' on db.
func PgEncodingMaxLength(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.pg_encoding_max_length
	const sqlstr = `SELECT pg_catalog.pg_encoding_max_length($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgEncodingToChar calls the stored procedure 'pg_catalog.pg_encoding_to_char(integer) name' on db.
func PgEncodingToChar(ctx context.Context, db DB, v0 int) (pgtypes.Name, error) {
	// call pg_catalog.pg_encoding_to_char
	const sqlstr = `SELECT pg_catalog.pg_encoding_to_char($1)`
	// run
	var ret pgtypes.Name
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// PgEventTriggerDdlCommands calls the stored procedure 'pg_catalog.pg_event_trigger_ddl_commands() SETOF record' on db.
func PgEventTriggerDdlCommands(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_event_trigger_ddl_commands
	const sqlstr = `SELECT pg_catalog.pg_event_trigger_ddl_commands()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgEventTriggerDroppedObjects calls the stored procedure 'pg_catalog.pg_event_trigger_dropped_objects() SETOF record' on db.
func PgEventTriggerDroppedObjects(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_event_trigger_dropped_objects
	const sqlstr = `SELECT pg_catalog.pg_event_trigger_dropped_objects()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgEventTriggerTableRewriteOid calls the stored procedure 'pg_catalog.pg_event_trigger_table_rewrite_oid() oid' on db.
func PgEventTriggerTableRewriteOid(ctx context.Context, db DB) (pgtypes.Oid, error) {
	// call pg_catalog.pg_event_trigger_table_rewrite_oid
	const sqlstr = `SELECT pg_catalog.pg_event_trigger_table_rewrite_oid()`
	// run
	var ret pgtypes.Oid
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// PgEventTriggerTableRewriteReason calls the stored procedure 'pg_catalog.pg_event_trigger_table_rewrite_reason() integer' on db.
func PgEventTriggerTableRewriteReason(ctx context.Context, db DB) (int, error) {
	// call pg_catalog.pg_event_trigger_table_rewrite_reason
	const sqlstr = `SELECT pg_catalog.pg_event_trigger_table_rewrite_reason()`
	// run
	var ret int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgExportSnapshot calls the stored procedure 'pg_catalog.pg_export_snapshot() text' on db.
func PgExportSnapshot(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.pg_export_snapshot
	const sqlstr = `SELECT pg_catalog.pg_export_snapshot()`
	// run
	var ret string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgExtensionConfigDump calls the stored procedure 'pg_catalog.pg_extension_config_dump(regclass, text) void' on db.
func PgExtensionConfigDump(ctx context.Context, db DB, v0 pgtypes.Regclass, v1 string) error {
	// call pg_catalog.pg_extension_config_dump
	const sqlstr = `SELECT pg_catalog.pg_extension_config_dump($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgExtensionUpdatePaths calls the stored procedure 'pg_catalog.pg_extension_update_paths(name) SETOF record' on db.
func PgExtensionUpdatePaths(ctx context.Context, db DB, v0 pgtypes.Name) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_extension_update_paths
	const sqlstr = `SELECT pg_catalog.pg_extension_update_paths($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgFilenodeRelation calls the stored procedure 'pg_catalog.pg_filenode_relation(oid, oid) regclass' on db.
func PgFilenodeRelation(ctx context.Context, db DB, v0, v1 pgtypes.Oid) (pgtypes.Regclass, error) {
	// call pg_catalog.pg_filenode_relation
	const sqlstr = `SELECT pg_catalog.pg_filenode_relation($1, $2)`
	// run
	var ret pgtypes.Regclass
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return ret, nil
}

// PgFunctionIsVisible calls the stored procedure 'pg_catalog.pg_function_is_visible(oid) boolean' on db.
func PgFunctionIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_function_is_visible
	const sqlstr = `SELECT pg_catalog.pg_function_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgGetConstraintdef calls the stored procedure 'pg_catalog.pg_get_constraintdef(oid, oid, boolean) text' on db.
func PgGetConstraintdef(ctx context.Context, db DB, v0, v1 pgtypes.Oid, v2 bool) (string, error) {
	// call pg_catalog.pg_get_constraintdef
	const sqlstr = `SELECT pg_catalog.pg_get_constraintdef($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetExpr calls the stored procedure 'pg_catalog.pg_get_expr(pg_node_tree, oid, pg_node_tree, oid, boolean) text' on db.
func PgGetExpr(ctx context.Context, db DB, v0 pgtypes.PgNodeTree, v1 pgtypes.Oid, v2 pgtypes.PgNodeTree, v3 pgtypes.Oid, v4 bool) (string, error) {
	// call pg_catalog.pg_get_expr
	const sqlstr = `SELECT pg_catalog.pg_get_expr($1, $2, $3, $4, $5)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetFunctionArgDefault calls the stored procedure 'pg_catalog.pg_get_function_arg_default(oid, integer) text' on db.
func PgGetFunctionArgDefault(ctx context.Context, db DB, v0 pgtypes.Oid, v1 int) (string, error) {
	// call pg_catalog.pg_get_function_arg_default
	const sqlstr = `SELECT pg_catalog.pg_get_function_arg_default($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetFunctionArguments calls the stored procedure 'pg_catalog.pg_get_function_arguments(oid) text' on db.
func PgGetFunctionArguments(ctx context.Context, db DB, v0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_function_arguments
	const sqlstr = `SELECT pg_catalog.pg_get_function_arguments($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetFunctionIdentityArguments calls the stored procedure 'pg_catalog.pg_get_function_identity_arguments(oid) text' on db.
func PgGetFunctionIdentityArguments(ctx context.Context, db DB, v0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_function_identity_arguments
	const sqlstr = `SELECT pg_catalog.pg_get_function_identity_arguments($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetFunctionResult calls the stored procedure 'pg_catalog.pg_get_function_result(oid) text' on db.
func PgGetFunctionResult(ctx context.Context, db DB, v0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_function_result
	const sqlstr = `SELECT pg_catalog.pg_get_function_result($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetFunctiondef calls the stored procedure 'pg_catalog.pg_get_functiondef(oid) text' on db.
func PgGetFunctiondef(ctx context.Context, db DB, v0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_functiondef
	const sqlstr = `SELECT pg_catalog.pg_get_functiondef($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetIndexdef calls the stored procedure 'pg_catalog.pg_get_indexdef(oid, oid, integer, boolean) text' on db.
func PgGetIndexdef(ctx context.Context, db DB, v0, v1 pgtypes.Oid, v2 int, v3 bool) (string, error) {
	// call pg_catalog.pg_get_indexdef
	const sqlstr = `SELECT pg_catalog.pg_get_indexdef($1, $2, $3, $4)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetKeywords calls the stored procedure 'pg_catalog.pg_get_keywords() SETOF record' on db.
func PgGetKeywords(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_get_keywords
	const sqlstr = `SELECT pg_catalog.pg_get_keywords()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgGetMultixactMembers calls the stored procedure 'pg_catalog.pg_get_multixact_members(xid) SETOF record' on db.
func PgGetMultixactMembers(ctx context.Context, db DB, v0 pgtypes.Xid) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_get_multixact_members
	const sqlstr = `SELECT pg_catalog.pg_get_multixact_members($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgGetObjectAddress calls the stored procedure 'pg_catalog.pg_get_object_address(text, text[], text[]) record' on db.
func PgGetObjectAddress(ctx context.Context, db DB, v0 string, v1, v2 StringSlice) (pgtypes.Record, error) {
	// call pg_catalog.pg_get_object_address
	const sqlstr = `SELECT pg_catalog.pg_get_object_address($1, $2, $3)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgGetPartitionConstraintdef calls the stored procedure 'pg_catalog.pg_get_partition_constraintdef(oid) text' on db.
func PgGetPartitionConstraintdef(ctx context.Context, db DB, v0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_partition_constraintdef
	const sqlstr = `SELECT pg_catalog.pg_get_partition_constraintdef($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetPartkeydef calls the stored procedure 'pg_catalog.pg_get_partkeydef(oid) text' on db.
func PgGetPartkeydef(ctx context.Context, db DB, v0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_partkeydef
	const sqlstr = `SELECT pg_catalog.pg_get_partkeydef($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetPublicationTables calls the stored procedure 'pg_catalog.pg_get_publication_tables(text) SETOF oid' on db.
func PgGetPublicationTables(ctx context.Context, db DB, v0 string) ([]pgtypes.Oid, error) {
	// call pg_catalog.pg_get_publication_tables
	const sqlstr = `SELECT pg_catalog.pg_get_publication_tables($1)`
	// run
	var ret []pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgGetReplicaIdentityIndex calls the stored procedure 'pg_catalog.pg_get_replica_identity_index(regclass) regclass' on db.
func PgGetReplicaIdentityIndex(ctx context.Context, db DB, v0 pgtypes.Regclass) (pgtypes.Regclass, error) {
	// call pg_catalog.pg_get_replica_identity_index
	const sqlstr = `SELECT pg_catalog.pg_get_replica_identity_index($1)`
	// run
	var ret pgtypes.Regclass
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return ret, nil
}

// PgGetReplicationSlots calls the stored procedure 'pg_catalog.pg_get_replication_slots() SETOF record' on db.
func PgGetReplicationSlots(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_get_replication_slots
	const sqlstr = `SELECT pg_catalog.pg_get_replication_slots()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgGetRuledef calls the stored procedure 'pg_catalog.pg_get_ruledef(oid, oid, boolean) text' on db.
func PgGetRuledef(ctx context.Context, db DB, v0, v1 pgtypes.Oid, v2 bool) (string, error) {
	// call pg_catalog.pg_get_ruledef
	const sqlstr = `SELECT pg_catalog.pg_get_ruledef($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetSerialSequence calls the stored procedure 'pg_catalog.pg_get_serial_sequence(text, text) text' on db.
func PgGetSerialSequence(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.pg_get_serial_sequence
	const sqlstr = `SELECT pg_catalog.pg_get_serial_sequence($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetShmemAllocations calls the stored procedure 'pg_catalog.pg_get_shmem_allocations() SETOF record' on db.
func PgGetShmemAllocations(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_get_shmem_allocations
	const sqlstr = `SELECT pg_catalog.pg_get_shmem_allocations()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgGetStatisticsobjdef calls the stored procedure 'pg_catalog.pg_get_statisticsobjdef(oid) text' on db.
func PgGetStatisticsobjdef(ctx context.Context, db DB, v0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_statisticsobjdef
	const sqlstr = `SELECT pg_catalog.pg_get_statisticsobjdef($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetTriggerdef calls the stored procedure 'pg_catalog.pg_get_triggerdef(oid, oid, boolean) text' on db.
func PgGetTriggerdef(ctx context.Context, db DB, v0, v1 pgtypes.Oid, v2 bool) (string, error) {
	// call pg_catalog.pg_get_triggerdef
	const sqlstr = `SELECT pg_catalog.pg_get_triggerdef($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgGetUserbyid calls the stored procedure 'pg_catalog.pg_get_userbyid(oid) name' on db.
func PgGetUserbyid(ctx context.Context, db DB, v0 pgtypes.Oid) (pgtypes.Name, error) {
	// call pg_catalog.pg_get_userbyid
	const sqlstr = `SELECT pg_catalog.pg_get_userbyid($1)`
	// run
	var ret pgtypes.Name
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// PgGetViewdef calls the stored procedure 'pg_catalog.pg_get_viewdef(text, oid, text, boolean, oid, boolean, oid, integer) text' on db.
func PgGetViewdef(ctx context.Context, db DB, v0 string, v1 pgtypes.Oid, v2 string, v3 bool, v4 pgtypes.Oid, v5 bool, v6 pgtypes.Oid, v7 int) (string, error) {
	// call pg_catalog.pg_get_viewdef
	const sqlstr = `SELECT pg_catalog.pg_get_viewdef($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgHasRole calls the stored procedure 'pg_catalog.pg_has_role(name, text, oid, text, name, name, text, name, oid, text, oid, name, text, oid, oid, text) boolean' on db.
func PgHasRole(ctx context.Context, db DB, v0 pgtypes.Name, v1 string, v2 pgtypes.Oid, v3 string, v4, v5 pgtypes.Name, v6 string, v7 pgtypes.Name, v8 pgtypes.Oid, v9 string, v10 pgtypes.Oid, v11 pgtypes.Name, v12 string, v13, v14 pgtypes.Oid, v15 string) (bool, error) {
	// call pg_catalog.pg_has_role
	const sqlstr = `SELECT pg_catalog.pg_has_role($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgHbaFileRules calls the stored procedure 'pg_catalog.pg_hba_file_rules() SETOF record' on db.
func PgHbaFileRules(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_hba_file_rules
	const sqlstr = `SELECT pg_catalog.pg_hba_file_rules()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgIdentifyObject calls the stored procedure 'pg_catalog.pg_identify_object(oid, oid, integer) record' on db.
func PgIdentifyObject(ctx context.Context, db DB, v0, v1 pgtypes.Oid, v2 int) (pgtypes.Record, error) {
	// call pg_catalog.pg_identify_object
	const sqlstr = `SELECT pg_catalog.pg_identify_object($1, $2, $3)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgIdentifyObjectAsAddress calls the stored procedure 'pg_catalog.pg_identify_object_as_address(oid, oid, integer) record' on db.
func PgIdentifyObjectAsAddress(ctx context.Context, db DB, v0, v1 pgtypes.Oid, v2 int) (pgtypes.Record, error) {
	// call pg_catalog.pg_identify_object_as_address
	const sqlstr = `SELECT pg_catalog.pg_identify_object_as_address($1, $2, $3)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgImportSystemCollations calls the stored procedure 'pg_catalog.pg_import_system_collations(regnamespace) integer' on db.
func PgImportSystemCollations(ctx context.Context, db DB, v0 pgtypes.Regnamespace) (int, error) {
	// call pg_catalog.pg_import_system_collations
	const sqlstr = `SELECT pg_catalog.pg_import_system_collations($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgIndexColumnHasProperty calls the stored procedure 'pg_catalog.pg_index_column_has_property(regclass, integer, text) boolean' on db.
func PgIndexColumnHasProperty(ctx context.Context, db DB, v0 pgtypes.Regclass, v1 int, v2 string) (bool, error) {
	// call pg_catalog.pg_index_column_has_property
	const sqlstr = `SELECT pg_catalog.pg_index_column_has_property($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgIndexHasProperty calls the stored procedure 'pg_catalog.pg_index_has_property(regclass, text) boolean' on db.
func PgIndexHasProperty(ctx context.Context, db DB, v0 pgtypes.Regclass, v1 string) (bool, error) {
	// call pg_catalog.pg_index_has_property
	const sqlstr = `SELECT pg_catalog.pg_index_has_property($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgIndexamHasProperty calls the stored procedure 'pg_catalog.pg_indexam_has_property(oid, text) boolean' on db.
func PgIndexamHasProperty(ctx context.Context, db DB, v0 pgtypes.Oid, v1 string) (bool, error) {
	// call pg_catalog.pg_indexam_has_property
	const sqlstr = `SELECT pg_catalog.pg_indexam_has_property($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgIndexamProgressPhasename calls the stored procedure 'pg_catalog.pg_indexam_progress_phasename(oid, bigint) text' on db.
func PgIndexamProgressPhasename(ctx context.Context, db DB, v0 pgtypes.Oid, v1 int64) (string, error) {
	// call pg_catalog.pg_indexam_progress_phasename
	const sqlstr = `SELECT pg_catalog.pg_indexam_progress_phasename($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgIndexesSize calls the stored procedure 'pg_catalog.pg_indexes_size(regclass) bigint' on db.
func PgIndexesSize(ctx context.Context, db DB, v0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.pg_indexes_size
	const sqlstr = `SELECT pg_catalog.pg_indexes_size($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgIsInBackup calls the stored procedure 'pg_catalog.pg_is_in_backup() boolean' on db.
func PgIsInBackup(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_is_in_backup
	const sqlstr = `SELECT pg_catalog.pg_is_in_backup()`
	// run
	var ret bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgIsInRecovery calls the stored procedure 'pg_catalog.pg_is_in_recovery() boolean' on db.
func PgIsInRecovery(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_is_in_recovery
	const sqlstr = `SELECT pg_catalog.pg_is_in_recovery()`
	// run
	var ret bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgIsOtherTempSchema calls the stored procedure 'pg_catalog.pg_is_other_temp_schema(oid) boolean' on db.
func PgIsOtherTempSchema(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_is_other_temp_schema
	const sqlstr = `SELECT pg_catalog.pg_is_other_temp_schema($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgIsWalReplayPaused calls the stored procedure 'pg_catalog.pg_is_wal_replay_paused() boolean' on db.
func PgIsWalReplayPaused(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_is_wal_replay_paused
	const sqlstr = `SELECT pg_catalog.pg_is_wal_replay_paused()`
	// run
	var ret bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgIsolationTestSessionIsBlocked calls the stored procedure 'pg_catalog.pg_isolation_test_session_is_blocked(integer, integer[]) boolean' on db.
func PgIsolationTestSessionIsBlocked(ctx context.Context, db DB, v0 int, v1 []int) (bool, error) {
	// call pg_catalog.pg_isolation_test_session_is_blocked
	const sqlstr = `SELECT pg_catalog.pg_isolation_test_session_is_blocked($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgJitAvailable calls the stored procedure 'pg_catalog.pg_jit_available() boolean' on db.
func PgJitAvailable(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_jit_available
	const sqlstr = `SELECT pg_catalog.pg_jit_available()`
	// run
	var ret bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgLastCommittedXact calls the stored procedure 'pg_catalog.pg_last_committed_xact() record' on db.
func PgLastCommittedXact(ctx context.Context, db DB) (pgtypes.Record, error) {
	// call pg_catalog.pg_last_committed_xact
	const sqlstr = `SELECT pg_catalog.pg_last_committed_xact()`
	// run
	var ret pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgLastWalReceiveLsn calls the stored procedure 'pg_catalog.pg_last_wal_receive_lsn() pg_lsn' on db.
func PgLastWalReceiveLsn(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_last_wal_receive_lsn
	const sqlstr = `SELECT pg_catalog.pg_last_wal_receive_lsn()`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgLastWalReplayLsn calls the stored procedure 'pg_catalog.pg_last_wal_replay_lsn() pg_lsn' on db.
func PgLastWalReplayLsn(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_last_wal_replay_lsn
	const sqlstr = `SELECT pg_catalog.pg_last_wal_replay_lsn()`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgLastXactReplayTimestamp calls the stored procedure 'pg_catalog.pg_last_xact_replay_timestamp() timestamp with time zone' on db.
func PgLastXactReplayTimestamp(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_last_xact_replay_timestamp
	const sqlstr = `SELECT pg_catalog.pg_last_xact_replay_timestamp()`
	// run
	var ret time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgListeningChannels calls the stored procedure 'pg_catalog.pg_listening_channels() SETOF text' on db.
func PgListeningChannels(ctx context.Context, db DB) ([]string, error) {
	// call pg_catalog.pg_listening_channels
	const sqlstr = `SELECT pg_catalog.pg_listening_channels()`
	// run
	var ret []string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLockStatus calls the stored procedure 'pg_catalog.pg_lock_status() SETOF record' on db.
func PgLockStatus(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_lock_status
	const sqlstr = `SELECT pg_catalog.pg_lock_status()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLogicalEmitMessage calls the stored procedure 'pg_catalog.pg_logical_emit_message(boolean, text, bytea, boolean, text, text) pg_lsn' on db.
func PgLogicalEmitMessage(ctx context.Context, db DB, v0 bool, v1 string, v2 []byte, v3 bool, v4, v5 string) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_logical_emit_message
	const sqlstr = `SELECT pg_catalog.pg_logical_emit_message($1, $2, $3, $4, $5, $6)`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgLogicalSlotGetBinaryChanges calls the stored procedure 'pg_catalog.pg_logical_slot_get_binary_changes(name, pg_lsn, integer, text[]) SETOF record' on db.
func PgLogicalSlotGetBinaryChanges(ctx context.Context, db DB, v0 pgtypes.Name, v1 pgtypes.PgLsn, v2 int, v3 StringSlice) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_logical_slot_get_binary_changes
	const sqlstr = `SELECT pg_catalog.pg_logical_slot_get_binary_changes($1, $2, $3, $4)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLogicalSlotGetChanges calls the stored procedure 'pg_catalog.pg_logical_slot_get_changes(name, pg_lsn, integer, text[]) SETOF record' on db.
func PgLogicalSlotGetChanges(ctx context.Context, db DB, v0 pgtypes.Name, v1 pgtypes.PgLsn, v2 int, v3 StringSlice) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_logical_slot_get_changes
	const sqlstr = `SELECT pg_catalog.pg_logical_slot_get_changes($1, $2, $3, $4)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLogicalSlotPeekBinaryChanges calls the stored procedure 'pg_catalog.pg_logical_slot_peek_binary_changes(name, pg_lsn, integer, text[]) SETOF record' on db.
func PgLogicalSlotPeekBinaryChanges(ctx context.Context, db DB, v0 pgtypes.Name, v1 pgtypes.PgLsn, v2 int, v3 StringSlice) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_logical_slot_peek_binary_changes
	const sqlstr = `SELECT pg_catalog.pg_logical_slot_peek_binary_changes($1, $2, $3, $4)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLogicalSlotPeekChanges calls the stored procedure 'pg_catalog.pg_logical_slot_peek_changes(name, pg_lsn, integer, text[]) SETOF record' on db.
func PgLogicalSlotPeekChanges(ctx context.Context, db DB, v0 pgtypes.Name, v1 pgtypes.PgLsn, v2 int, v3 StringSlice) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_logical_slot_peek_changes
	const sqlstr = `SELECT pg_catalog.pg_logical_slot_peek_changes($1, $2, $3, $4)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLsArchiveStatusdir calls the stored procedure 'pg_catalog.pg_ls_archive_statusdir() SETOF record' on db.
func PgLsArchiveStatusdir(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_ls_archive_statusdir
	const sqlstr = `SELECT pg_catalog.pg_ls_archive_statusdir()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLsDir calls the stored procedure 'pg_catalog.pg_ls_dir(text, text, boolean, boolean) SETOF text' on db.
func PgLsDir(ctx context.Context, db DB, v0, v1 string, v2, v3 bool) ([]string, error) {
	// call pg_catalog.pg_ls_dir
	const sqlstr = `SELECT pg_catalog.pg_ls_dir($1, $2, $3, $4)`
	// run
	var ret []string
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLsLogdir calls the stored procedure 'pg_catalog.pg_ls_logdir() SETOF record' on db.
func PgLsLogdir(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_ls_logdir
	const sqlstr = `SELECT pg_catalog.pg_ls_logdir()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLsTmpdir calls the stored procedure 'pg_catalog.pg_ls_tmpdir(oid) SETOF record' on db.
func PgLsTmpdir(ctx context.Context, db DB, v0 pgtypes.Oid) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_ls_tmpdir
	const sqlstr = `SELECT pg_catalog.pg_ls_tmpdir($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLsWaldir calls the stored procedure 'pg_catalog.pg_ls_waldir() SETOF record' on db.
func PgLsWaldir(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_ls_waldir
	const sqlstr = `SELECT pg_catalog.pg_ls_waldir()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLsnCmp calls the stored procedure 'pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn) integer' on db.
func PgLsnCmp(ctx context.Context, db DB, v0, v1 pgtypes.PgLsn) (int, error) {
	// call pg_catalog.pg_lsn_cmp
	const sqlstr = `SELECT pg_catalog.pg_lsn_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgLsnEq calls the stored procedure 'pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn) boolean' on db.
func PgLsnEq(ctx context.Context, db DB, v0, v1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_eq
	const sqlstr = `SELECT pg_catalog.pg_lsn_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgLsnGe calls the stored procedure 'pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn) boolean' on db.
func PgLsnGe(ctx context.Context, db DB, v0, v1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_ge
	const sqlstr = `SELECT pg_catalog.pg_lsn_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgLsnGt calls the stored procedure 'pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn) boolean' on db.
func PgLsnGt(ctx context.Context, db DB, v0, v1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_gt
	const sqlstr = `SELECT pg_catalog.pg_lsn_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgLsnHash calls the stored procedure 'pg_catalog.pg_lsn_hash(pg_lsn) integer' on db.
func PgLsnHash(ctx context.Context, db DB, v0 pgtypes.PgLsn) (int, error) {
	// call pg_catalog.pg_lsn_hash
	const sqlstr = `SELECT pg_catalog.pg_lsn_hash($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgLsnHashExtended calls the stored procedure 'pg_catalog.pg_lsn_hash_extended(pg_lsn, bigint) bigint' on db.
func PgLsnHashExtended(ctx context.Context, db DB, v0 pgtypes.PgLsn, v1 int64) (int64, error) {
	// call pg_catalog.pg_lsn_hash_extended
	const sqlstr = `SELECT pg_catalog.pg_lsn_hash_extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgLsnIn calls the stored procedure 'pg_catalog.pg_lsn_in(cstring) pg_lsn' on db.
func PgLsnIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_lsn_in
	const sqlstr = `SELECT pg_catalog.pg_lsn_in($1)`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgLsnLarger calls the stored procedure 'pg_catalog.pg_lsn_larger(pg_lsn, pg_lsn) pg_lsn' on db.
func PgLsnLarger(ctx context.Context, db DB, v0, v1 pgtypes.PgLsn) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_lsn_larger
	const sqlstr = `SELECT pg_catalog.pg_lsn_larger($1, $2)`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgLsnLe calls the stored procedure 'pg_catalog.pg_lsn_le(pg_lsn, pg_lsn) boolean' on db.
func PgLsnLe(ctx context.Context, db DB, v0, v1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_le
	const sqlstr = `SELECT pg_catalog.pg_lsn_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgLsnLt calls the stored procedure 'pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn) boolean' on db.
func PgLsnLt(ctx context.Context, db DB, v0, v1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_lt
	const sqlstr = `SELECT pg_catalog.pg_lsn_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgLsnMi calls the stored procedure 'pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn) numeric' on db.
func PgLsnMi(ctx context.Context, db DB, v0, v1 pgtypes.PgLsn) (float64, error) {
	// call pg_catalog.pg_lsn_mi
	const sqlstr = `SELECT pg_catalog.pg_lsn_mi($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PgLsnNe calls the stored procedure 'pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn) boolean' on db.
func PgLsnNe(ctx context.Context, db DB, v0, v1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_ne
	const sqlstr = `SELECT pg_catalog.pg_lsn_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgLsnOut calls the stored procedure 'pg_catalog.pg_lsn_out(pg_lsn) cstring' on db.
func PgLsnOut(ctx context.Context, db DB, v0 pgtypes.PgLsn) (pgtypes.Cstring, error) {
	// call pg_catalog.pg_lsn_out
	const sqlstr = `SELECT pg_catalog.pg_lsn_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// PgLsnRecv calls the stored procedure 'pg_catalog.pg_lsn_recv(internal) pg_lsn' on db.
func PgLsnRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_lsn_recv
	const sqlstr = `SELECT pg_catalog.pg_lsn_recv($1)`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgLsnSend calls the stored procedure 'pg_catalog.pg_lsn_send(pg_lsn) bytea' on db.
func PgLsnSend(ctx context.Context, db DB, v0 pgtypes.PgLsn) ([]byte, error) {
	// call pg_catalog.pg_lsn_send
	const sqlstr = `SELECT pg_catalog.pg_lsn_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgLsnSmaller calls the stored procedure 'pg_catalog.pg_lsn_smaller(pg_lsn, pg_lsn) pg_lsn' on db.
func PgLsnSmaller(ctx context.Context, db DB, v0, v1 pgtypes.PgLsn) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_lsn_smaller
	const sqlstr = `SELECT pg_catalog.pg_lsn_smaller($1, $2)`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgMcvListIn calls the stored procedure 'pg_catalog.pg_mcv_list_in(cstring) pg_mcv_list' on db.
func PgMcvListIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.PgMcvList, error) {
	// call pg_catalog.pg_mcv_list_in
	const sqlstr = `SELECT pg_catalog.pg_mcv_list_in($1)`
	// run
	var ret pgtypes.PgMcvList
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgMcvList{}, logerror(err)
	}
	return ret, nil
}

// PgMcvListItems calls the stored procedure 'pg_catalog.pg_mcv_list_items(pg_mcv_list) SETOF record' on db.
func PgMcvListItems(ctx context.Context, db DB, v0 pgtypes.PgMcvList) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_mcv_list_items
	const sqlstr = `SELECT pg_catalog.pg_mcv_list_items($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgMcvListOut calls the stored procedure 'pg_catalog.pg_mcv_list_out(pg_mcv_list) cstring' on db.
func PgMcvListOut(ctx context.Context, db DB, v0 pgtypes.PgMcvList) (pgtypes.Cstring, error) {
	// call pg_catalog.pg_mcv_list_out
	const sqlstr = `SELECT pg_catalog.pg_mcv_list_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// PgMcvListRecv calls the stored procedure 'pg_catalog.pg_mcv_list_recv(internal) pg_mcv_list' on db.
func PgMcvListRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.PgMcvList, error) {
	// call pg_catalog.pg_mcv_list_recv
	const sqlstr = `SELECT pg_catalog.pg_mcv_list_recv($1)`
	// run
	var ret pgtypes.PgMcvList
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgMcvList{}, logerror(err)
	}
	return ret, nil
}

// PgMcvListSend calls the stored procedure 'pg_catalog.pg_mcv_list_send(pg_mcv_list) bytea' on db.
func PgMcvListSend(ctx context.Context, db DB, v0 pgtypes.PgMcvList) ([]byte, error) {
	// call pg_catalog.pg_mcv_list_send
	const sqlstr = `SELECT pg_catalog.pg_mcv_list_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgMyTempSchema calls the stored procedure 'pg_catalog.pg_my_temp_schema() oid' on db.
func PgMyTempSchema(ctx context.Context, db DB) (pgtypes.Oid, error) {
	// call pg_catalog.pg_my_temp_schema
	const sqlstr = `SELECT pg_catalog.pg_my_temp_schema()`
	// run
	var ret pgtypes.Oid
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// PgNdistinctIn calls the stored procedure 'pg_catalog.pg_ndistinct_in(cstring) pg_ndistinct' on db.
func PgNdistinctIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.PgNdistinct, error) {
	// call pg_catalog.pg_ndistinct_in
	const sqlstr = `SELECT pg_catalog.pg_ndistinct_in($1)`
	// run
	var ret pgtypes.PgNdistinct
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgNdistinct{}, logerror(err)
	}
	return ret, nil
}

// PgNdistinctOut calls the stored procedure 'pg_catalog.pg_ndistinct_out(pg_ndistinct) cstring' on db.
func PgNdistinctOut(ctx context.Context, db DB, v0 pgtypes.PgNdistinct) (pgtypes.Cstring, error) {
	// call pg_catalog.pg_ndistinct_out
	const sqlstr = `SELECT pg_catalog.pg_ndistinct_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// PgNdistinctRecv calls the stored procedure 'pg_catalog.pg_ndistinct_recv(internal) pg_ndistinct' on db.
func PgNdistinctRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.PgNdistinct, error) {
	// call pg_catalog.pg_ndistinct_recv
	const sqlstr = `SELECT pg_catalog.pg_ndistinct_recv($1)`
	// run
	var ret pgtypes.PgNdistinct
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgNdistinct{}, logerror(err)
	}
	return ret, nil
}

// PgNdistinctSend calls the stored procedure 'pg_catalog.pg_ndistinct_send(pg_ndistinct) bytea' on db.
func PgNdistinctSend(ctx context.Context, db DB, v0 pgtypes.PgNdistinct) ([]byte, error) {
	// call pg_catalog.pg_ndistinct_send
	const sqlstr = `SELECT pg_catalog.pg_ndistinct_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgNextoid calls the stored procedure 'pg_catalog.pg_nextoid(regclass, name, regclass) oid' on db.
func PgNextoid(ctx context.Context, db DB, v0 pgtypes.Regclass, v1 pgtypes.Name, v2 pgtypes.Regclass) (pgtypes.Oid, error) {
	// call pg_catalog.pg_nextoid
	const sqlstr = `SELECT pg_catalog.pg_nextoid($1, $2, $3)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// PgNodeTreeIn calls the stored procedure 'pg_catalog.pg_node_tree_in(cstring) pg_node_tree' on db.
func PgNodeTreeIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.PgNodeTree, error) {
	// call pg_catalog.pg_node_tree_in
	const sqlstr = `SELECT pg_catalog.pg_node_tree_in($1)`
	// run
	var ret pgtypes.PgNodeTree
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgNodeTree{}, logerror(err)
	}
	return ret, nil
}

// PgNodeTreeOut calls the stored procedure 'pg_catalog.pg_node_tree_out(pg_node_tree) cstring' on db.
func PgNodeTreeOut(ctx context.Context, db DB, v0 pgtypes.PgNodeTree) (pgtypes.Cstring, error) {
	// call pg_catalog.pg_node_tree_out
	const sqlstr = `SELECT pg_catalog.pg_node_tree_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// PgNodeTreeRecv calls the stored procedure 'pg_catalog.pg_node_tree_recv(internal) pg_node_tree' on db.
func PgNodeTreeRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.PgNodeTree, error) {
	// call pg_catalog.pg_node_tree_recv
	const sqlstr = `SELECT pg_catalog.pg_node_tree_recv($1)`
	// run
	var ret pgtypes.PgNodeTree
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgNodeTree{}, logerror(err)
	}
	return ret, nil
}

// PgNodeTreeSend calls the stored procedure 'pg_catalog.pg_node_tree_send(pg_node_tree) bytea' on db.
func PgNodeTreeSend(ctx context.Context, db DB, v0 pgtypes.PgNodeTree) ([]byte, error) {
	// call pg_catalog.pg_node_tree_send
	const sqlstr = `SELECT pg_catalog.pg_node_tree_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgNotificationQueueUsage calls the stored procedure 'pg_catalog.pg_notification_queue_usage() double precision' on db.
func PgNotificationQueueUsage(ctx context.Context, db DB) (float64, error) {
	// call pg_catalog.pg_notification_queue_usage
	const sqlstr = `SELECT pg_catalog.pg_notification_queue_usage()`
	// run
	var ret float64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PgNotify calls the stored procedure 'pg_catalog.pg_notify(text, text) void' on db.
func PgNotify(ctx context.Context, db DB, v0, v1 string) error {
	// call pg_catalog.pg_notify
	const sqlstr = `SELECT pg_catalog.pg_notify($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgOpclassIsVisible calls the stored procedure 'pg_catalog.pg_opclass_is_visible(oid) boolean' on db.
func PgOpclassIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_opclass_is_visible
	const sqlstr = `SELECT pg_catalog.pg_opclass_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgOperatorIsVisible calls the stored procedure 'pg_catalog.pg_operator_is_visible(oid) boolean' on db.
func PgOperatorIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_operator_is_visible
	const sqlstr = `SELECT pg_catalog.pg_operator_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgOpfamilyIsVisible calls the stored procedure 'pg_catalog.pg_opfamily_is_visible(oid) boolean' on db.
func PgOpfamilyIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_opfamily_is_visible
	const sqlstr = `SELECT pg_catalog.pg_opfamily_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgOptionsToTable calls the stored procedure 'pg_catalog.pg_options_to_table(text[]) SETOF record' on db.
func PgOptionsToTable(ctx context.Context, db DB, v0 StringSlice) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_options_to_table
	const sqlstr = `SELECT pg_catalog.pg_options_to_table($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgPartitionAncestors calls the stored procedure 'pg_catalog.pg_partition_ancestors(regclass) SETOF regclass' on db.
func PgPartitionAncestors(ctx context.Context, db DB, v0 pgtypes.Regclass) ([]pgtypes.Regclass, error) {
	// call pg_catalog.pg_partition_ancestors
	const sqlstr = `SELECT pg_catalog.pg_partition_ancestors($1)`
	// run
	var ret []pgtypes.Regclass
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgPartitionRoot calls the stored procedure 'pg_catalog.pg_partition_root(regclass) regclass' on db.
func PgPartitionRoot(ctx context.Context, db DB, v0 pgtypes.Regclass) (pgtypes.Regclass, error) {
	// call pg_catalog.pg_partition_root
	const sqlstr = `SELECT pg_catalog.pg_partition_root($1)`
	// run
	var ret pgtypes.Regclass
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return ret, nil
}

// PgPartitionTree calls the stored procedure 'pg_catalog.pg_partition_tree(regclass) SETOF record' on db.
func PgPartitionTree(ctx context.Context, db DB, v0 pgtypes.Regclass) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_partition_tree
	const sqlstr = `SELECT pg_catalog.pg_partition_tree($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgPostmasterStartTime calls the stored procedure 'pg_catalog.pg_postmaster_start_time() timestamp with time zone' on db.
func PgPostmasterStartTime(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_postmaster_start_time
	const sqlstr = `SELECT pg_catalog.pg_postmaster_start_time()`
	// run
	var ret time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgPreparedStatement calls the stored procedure 'pg_catalog.pg_prepared_statement() SETOF record' on db.
func PgPreparedStatement(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_prepared_statement
	const sqlstr = `SELECT pg_catalog.pg_prepared_statement()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgPreparedXact calls the stored procedure 'pg_catalog.pg_prepared_xact() SETOF record' on db.
func PgPreparedXact(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_prepared_xact
	const sqlstr = `SELECT pg_catalog.pg_prepared_xact()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgPromote calls the stored procedure 'pg_catalog.pg_promote(boolean, integer) boolean' on db.
func PgPromote(ctx context.Context, db DB, v0 bool, v1 int) (bool, error) {
	// call pg_catalog.pg_promote
	const sqlstr = `SELECT pg_catalog.pg_promote($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgReadBinaryFile calls the stored procedure 'pg_catalog.pg_read_binary_file(text, text, bigint, bigint, text, bigint, bigint, boolean) bytea' on db.
func PgReadBinaryFile(ctx context.Context, db DB, v0, v1 string, v2, v3 int64, v4 string, v5, v6 int64, v7 bool) ([]byte, error) {
	// call pg_catalog.pg_read_binary_file
	const sqlstr = `SELECT pg_catalog.pg_read_binary_file($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgReadFile calls the stored procedure 'pg_catalog.pg_read_file(text, text, bigint, bigint, text, bigint, bigint, boolean) text' on db.
func PgReadFile(ctx context.Context, db DB, v0, v1 string, v2, v3 int64, v4 string, v5, v6 int64, v7 bool) (string, error) {
	// call pg_catalog.pg_read_file
	const sqlstr = `SELECT pg_catalog.pg_read_file($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgReadFileOld calls the stored procedure 'pg_catalog.pg_read_file_old(text, bigint, bigint) text' on db.
func PgReadFileOld(ctx context.Context, db DB, v0 string, v1, v2 int64) (string, error) {
	// call pg_catalog.pg_read_file_old
	const sqlstr = `SELECT pg_catalog.pg_read_file_old($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgRelationFilenode calls the stored procedure 'pg_catalog.pg_relation_filenode(regclass) oid' on db.
func PgRelationFilenode(ctx context.Context, db DB, v0 pgtypes.Regclass) (pgtypes.Oid, error) {
	// call pg_catalog.pg_relation_filenode
	const sqlstr = `SELECT pg_catalog.pg_relation_filenode($1)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// PgRelationFilepath calls the stored procedure 'pg_catalog.pg_relation_filepath(regclass) text' on db.
func PgRelationFilepath(ctx context.Context, db DB, v0 pgtypes.Regclass) (string, error) {
	// call pg_catalog.pg_relation_filepath
	const sqlstr = `SELECT pg_catalog.pg_relation_filepath($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgRelationIsPublishable calls the stored procedure 'pg_catalog.pg_relation_is_publishable(regclass) boolean' on db.
func PgRelationIsPublishable(ctx context.Context, db DB, v0 pgtypes.Regclass) (bool, error) {
	// call pg_catalog.pg_relation_is_publishable
	const sqlstr = `SELECT pg_catalog.pg_relation_is_publishable($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgRelationIsUpdatable calls the stored procedure 'pg_catalog.pg_relation_is_updatable(regclass, boolean) integer' on db.
func PgRelationIsUpdatable(ctx context.Context, db DB, v0 pgtypes.Regclass, v1 bool) (int, error) {
	// call pg_catalog.pg_relation_is_updatable
	const sqlstr = `SELECT pg_catalog.pg_relation_is_updatable($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgRelationSize calls the stored procedure 'pg_catalog.pg_relation_size(regclass, regclass, text) bigint' on db.
func PgRelationSize(ctx context.Context, db DB, v0, v1 pgtypes.Regclass, v2 string) (int64, error) {
	// call pg_catalog.pg_relation_size
	const sqlstr = `SELECT pg_catalog.pg_relation_size($1, $2, $3)`
	// run
	var ret int64
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgReloadConf calls the stored procedure 'pg_catalog.pg_reload_conf() boolean' on db.
func PgReloadConf(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_reload_conf
	const sqlstr = `SELECT pg_catalog.pg_reload_conf()`
	// run
	var ret bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgReplicationOriginAdvance calls the stored procedure 'pg_catalog.pg_replication_origin_advance(text, pg_lsn) void' on db.
func PgReplicationOriginAdvance(ctx context.Context, db DB, v0 string, v1 pgtypes.PgLsn) error {
	// call pg_catalog.pg_replication_origin_advance
	const sqlstr = `SELECT pg_catalog.pg_replication_origin_advance($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationOriginCreate calls the stored procedure 'pg_catalog.pg_replication_origin_create(text) oid' on db.
func PgReplicationOriginCreate(ctx context.Context, db DB, v0 string) (pgtypes.Oid, error) {
	// call pg_catalog.pg_replication_origin_create
	const sqlstr = `SELECT pg_catalog.pg_replication_origin_create($1)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// PgReplicationOriginDrop calls the stored procedure 'pg_catalog.pg_replication_origin_drop(text) void' on db.
func PgReplicationOriginDrop(ctx context.Context, db DB, v0 string) error {
	// call pg_catalog.pg_replication_origin_drop
	const sqlstr = `SELECT pg_catalog.pg_replication_origin_drop($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationOriginOid calls the stored procedure 'pg_catalog.pg_replication_origin_oid(text) oid' on db.
func PgReplicationOriginOid(ctx context.Context, db DB, v0 string) (pgtypes.Oid, error) {
	// call pg_catalog.pg_replication_origin_oid
	const sqlstr = `SELECT pg_catalog.pg_replication_origin_oid($1)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// PgReplicationOriginProgress calls the stored procedure 'pg_catalog.pg_replication_origin_progress(text, boolean) pg_lsn' on db.
func PgReplicationOriginProgress(ctx context.Context, db DB, v0 string, v1 bool) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_replication_origin_progress
	const sqlstr = `SELECT pg_catalog.pg_replication_origin_progress($1, $2)`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgReplicationOriginSessionIsSetup calls the stored procedure 'pg_catalog.pg_replication_origin_session_is_setup() boolean' on db.
func PgReplicationOriginSessionIsSetup(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_replication_origin_session_is_setup
	const sqlstr = `SELECT pg_catalog.pg_replication_origin_session_is_setup()`
	// run
	var ret bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgReplicationOriginSessionProgress calls the stored procedure 'pg_catalog.pg_replication_origin_session_progress(boolean) pg_lsn' on db.
func PgReplicationOriginSessionProgress(ctx context.Context, db DB, v0 bool) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_replication_origin_session_progress
	const sqlstr = `SELECT pg_catalog.pg_replication_origin_session_progress($1)`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgReplicationOriginSessionReset calls the stored procedure 'pg_catalog.pg_replication_origin_session_reset() void' on db.
func PgReplicationOriginSessionReset(ctx context.Context, db DB) error {
	// call pg_catalog.pg_replication_origin_session_reset
	const sqlstr = `SELECT pg_catalog.pg_replication_origin_session_reset()`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationOriginSessionSetup calls the stored procedure 'pg_catalog.pg_replication_origin_session_setup(text) void' on db.
func PgReplicationOriginSessionSetup(ctx context.Context, db DB, v0 string) error {
	// call pg_catalog.pg_replication_origin_session_setup
	const sqlstr = `SELECT pg_catalog.pg_replication_origin_session_setup($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationOriginXactReset calls the stored procedure 'pg_catalog.pg_replication_origin_xact_reset() void' on db.
func PgReplicationOriginXactReset(ctx context.Context, db DB) error {
	// call pg_catalog.pg_replication_origin_xact_reset
	const sqlstr = `SELECT pg_catalog.pg_replication_origin_xact_reset()`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationOriginXactSetup calls the stored procedure 'pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone) void' on db.
func PgReplicationOriginXactSetup(ctx context.Context, db DB, v0 pgtypes.PgLsn, v1 time.Time) error {
	// call pg_catalog.pg_replication_origin_xact_setup
	const sqlstr = `SELECT pg_catalog.pg_replication_origin_xact_setup($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationSlotAdvance calls the stored procedure 'pg_catalog.pg_replication_slot_advance(name, pg_lsn) record' on db.
func PgReplicationSlotAdvance(ctx context.Context, db DB, v0 pgtypes.Name, v1 pgtypes.PgLsn) (pgtypes.Record, error) {
	// call pg_catalog.pg_replication_slot_advance
	const sqlstr = `SELECT pg_catalog.pg_replication_slot_advance($1, $2)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgRotateLogfile calls the stored procedure 'pg_catalog.pg_rotate_logfile() boolean' on db.
func PgRotateLogfile(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_rotate_logfile
	const sqlstr = `SELECT pg_catalog.pg_rotate_logfile()`
	// run
	var ret bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgRotateLogfileOld calls the stored procedure 'pg_catalog.pg_rotate_logfile_old() boolean' on db.
func PgRotateLogfileOld(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_rotate_logfile_old
	const sqlstr = `SELECT pg_catalog.pg_rotate_logfile_old()`
	// run
	var ret bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgSafeSnapshotBlockingPids calls the stored procedure 'pg_catalog.pg_safe_snapshot_blocking_pids(integer) integer[]' on db.
func PgSafeSnapshotBlockingPids(ctx context.Context, db DB, v0 int) ([]int, error) {
	// call pg_catalog.pg_safe_snapshot_blocking_pids
	const sqlstr = `SELECT pg_catalog.pg_safe_snapshot_blocking_pids($1)`
	// run
	var ret []int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgSequenceLastValue calls the stored procedure 'pg_catalog.pg_sequence_last_value(regclass) bigint' on db.
func PgSequenceLastValue(ctx context.Context, db DB, v0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.pg_sequence_last_value
	const sqlstr = `SELECT pg_catalog.pg_sequence_last_value($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgSequenceParameters calls the stored procedure 'pg_catalog.pg_sequence_parameters(oid) record' on db.
func PgSequenceParameters(ctx context.Context, db DB, v0 pgtypes.Oid) (pgtypes.Record, error) {
	// call pg_catalog.pg_sequence_parameters
	const sqlstr = `SELECT pg_catalog.pg_sequence_parameters($1)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgShowAllFileSettings calls the stored procedure 'pg_catalog.pg_show_all_file_settings() SETOF record' on db.
func PgShowAllFileSettings(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_show_all_file_settings
	const sqlstr = `SELECT pg_catalog.pg_show_all_file_settings()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgShowAllSettings calls the stored procedure 'pg_catalog.pg_show_all_settings() SETOF record' on db.
func PgShowAllSettings(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_show_all_settings
	const sqlstr = `SELECT pg_catalog.pg_show_all_settings()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgShowReplicationOriginStatus calls the stored procedure 'pg_catalog.pg_show_replication_origin_status() SETOF record' on db.
func PgShowReplicationOriginStatus(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_show_replication_origin_status
	const sqlstr = `SELECT pg_catalog.pg_show_replication_origin_status()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgSizeBytes calls the stored procedure 'pg_catalog.pg_size_bytes(text) bigint' on db.
func PgSizeBytes(ctx context.Context, db DB, v0 string) (int64, error) {
	// call pg_catalog.pg_size_bytes
	const sqlstr = `SELECT pg_catalog.pg_size_bytes($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgSizePretty calls the stored procedure 'pg_catalog.pg_size_pretty(bigint, numeric) text' on db.
func PgSizePretty(ctx context.Context, db DB, v0 int64, v1 float64) (string, error) {
	// call pg_catalog.pg_size_pretty
	const sqlstr = `SELECT pg_catalog.pg_size_pretty($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgSleep calls the stored procedure 'pg_catalog.pg_sleep(double precision) void' on db.
func PgSleep(ctx context.Context, db DB, v0 float64) error {
	// call pg_catalog.pg_sleep
	const sqlstr = `SELECT pg_catalog.pg_sleep($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgSleepFor calls the stored procedure 'pg_catalog.pg_sleep_for(interval) void' on db.
func PgSleepFor(ctx context.Context, db DB, v0 []byte) error {
	// call pg_catalog.pg_sleep_for
	const sqlstr = `SELECT pg_catalog.pg_sleep_for($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgSleepUntil calls the stored procedure 'pg_catalog.pg_sleep_until(timestamp with time zone) void' on db.
func PgSleepUntil(ctx context.Context, db DB, v0 time.Time) error {
	// call pg_catalog.pg_sleep_until
	const sqlstr = `SELECT pg_catalog.pg_sleep_until($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgSnapshotIn calls the stored procedure 'pg_catalog.pg_snapshot_in(cstring) pg_snapshot' on db.
func PgSnapshotIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.PgSnapshot, error) {
	// call pg_catalog.pg_snapshot_in
	const sqlstr = `SELECT pg_catalog.pg_snapshot_in($1)`
	// run
	var ret pgtypes.PgSnapshot
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgSnapshot{}, logerror(err)
	}
	return ret, nil
}

// PgSnapshotOut calls the stored procedure 'pg_catalog.pg_snapshot_out(pg_snapshot) cstring' on db.
func PgSnapshotOut(ctx context.Context, db DB, v0 pgtypes.PgSnapshot) (pgtypes.Cstring, error) {
	// call pg_catalog.pg_snapshot_out
	const sqlstr = `SELECT pg_catalog.pg_snapshot_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// PgSnapshotRecv calls the stored procedure 'pg_catalog.pg_snapshot_recv(internal) pg_snapshot' on db.
func PgSnapshotRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.PgSnapshot, error) {
	// call pg_catalog.pg_snapshot_recv
	const sqlstr = `SELECT pg_catalog.pg_snapshot_recv($1)`
	// run
	var ret pgtypes.PgSnapshot
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.PgSnapshot{}, logerror(err)
	}
	return ret, nil
}

// PgSnapshotSend calls the stored procedure 'pg_catalog.pg_snapshot_send(pg_snapshot) bytea' on db.
func PgSnapshotSend(ctx context.Context, db DB, v0 pgtypes.PgSnapshot) ([]byte, error) {
	// call pg_catalog.pg_snapshot_send
	const sqlstr = `SELECT pg_catalog.pg_snapshot_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgSnapshotXip calls the stored procedure 'pg_catalog.pg_snapshot_xip(pg_snapshot) SETOF xid8' on db.
func PgSnapshotXip(ctx context.Context, db DB, v0 pgtypes.PgSnapshot) ([]pgtypes.Xid8, error) {
	// call pg_catalog.pg_snapshot_xip
	const sqlstr = `SELECT pg_catalog.pg_snapshot_xip($1)`
	// run
	var ret []pgtypes.Xid8
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgSnapshotXmax calls the stored procedure 'pg_catalog.pg_snapshot_xmax(pg_snapshot) xid8' on db.
func PgSnapshotXmax(ctx context.Context, db DB, v0 pgtypes.PgSnapshot) (pgtypes.Xid8, error) {
	// call pg_catalog.pg_snapshot_xmax
	const sqlstr = `SELECT pg_catalog.pg_snapshot_xmax($1)`
	// run
	var ret pgtypes.Xid8
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return ret, nil
}

// PgSnapshotXmin calls the stored procedure 'pg_catalog.pg_snapshot_xmin(pg_snapshot) xid8' on db.
func PgSnapshotXmin(ctx context.Context, db DB, v0 pgtypes.PgSnapshot) (pgtypes.Xid8, error) {
	// call pg_catalog.pg_snapshot_xmin
	const sqlstr = `SELECT pg_catalog.pg_snapshot_xmin($1)`
	// run
	var ret pgtypes.Xid8
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return ret, nil
}

// PgStartBackup calls the stored procedure 'pg_catalog.pg_start_backup(text, boolean, boolean) pg_lsn' on db.
func PgStartBackup(ctx context.Context, db DB, v0 string, v1, v2 bool) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_start_backup
	const sqlstr = `SELECT pg_catalog.pg_start_backup($1, $2, $3)`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgStatClearSnapshot calls the stored procedure 'pg_catalog.pg_stat_clear_snapshot() void' on db.
func PgStatClearSnapshot(ctx context.Context, db DB) error {
	// call pg_catalog.pg_stat_clear_snapshot
	const sqlstr = `SELECT pg_catalog.pg_stat_clear_snapshot()`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatFile calls the stored procedure 'pg_catalog.pg_stat_file(text, text, boolean) record' on db.
func PgStatFile(ctx context.Context, db DB, v0, v1 string, v2 bool) (pgtypes.Record, error) {
	// call pg_catalog.pg_stat_file
	const sqlstr = `SELECT pg_catalog.pg_stat_file($1, $2, $3)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetActivity calls the stored procedure 'pg_catalog.pg_stat_get_activity(integer) SETOF record' on db.
func PgStatGetActivity(ctx context.Context, db DB, v0 int) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_stat_get_activity
	const sqlstr = `SELECT pg_catalog.pg_stat_get_activity($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgStatGetAnalyzeCount calls the stored procedure 'pg_catalog.pg_stat_get_analyze_count(oid) bigint' on db.
func PgStatGetAnalyzeCount(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_analyze_count
	const sqlstr = `SELECT pg_catalog.pg_stat_get_analyze_count($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetArchiver calls the stored procedure 'pg_catalog.pg_stat_get_archiver() record' on db.
func PgStatGetArchiver(ctx context.Context, db DB) (pgtypes.Record, error) {
	// call pg_catalog.pg_stat_get_archiver
	const sqlstr = `SELECT pg_catalog.pg_stat_get_archiver()`
	// run
	var ret pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetAutoanalyzeCount calls the stored procedure 'pg_catalog.pg_stat_get_autoanalyze_count(oid) bigint' on db.
func PgStatGetAutoanalyzeCount(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_autoanalyze_count
	const sqlstr = `SELECT pg_catalog.pg_stat_get_autoanalyze_count($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetAutovacuumCount calls the stored procedure 'pg_catalog.pg_stat_get_autovacuum_count(oid) bigint' on db.
func PgStatGetAutovacuumCount(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_autovacuum_count
	const sqlstr = `SELECT pg_catalog.pg_stat_get_autovacuum_count($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendActivity calls the stored procedure 'pg_catalog.pg_stat_get_backend_activity(integer) text' on db.
func PgStatGetBackendActivity(ctx context.Context, db DB, v0 int) (string, error) {
	// call pg_catalog.pg_stat_get_backend_activity
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_activity($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendActivityStart calls the stored procedure 'pg_catalog.pg_stat_get_backend_activity_start(integer) timestamp with time zone' on db.
func PgStatGetBackendActivityStart(ctx context.Context, db DB, v0 int) (time.Time, error) {
	// call pg_catalog.pg_stat_get_backend_activity_start
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_activity_start($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendClientAddr calls the stored procedure 'pg_catalog.pg_stat_get_backend_client_addr(integer) inet' on db.
func PgStatGetBackendClientAddr(ctx context.Context, db DB, v0 int) (string, error) {
	// call pg_catalog.pg_stat_get_backend_client_addr
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_client_addr($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendClientPort calls the stored procedure 'pg_catalog.pg_stat_get_backend_client_port(integer) integer' on db.
func PgStatGetBackendClientPort(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.pg_stat_get_backend_client_port
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_client_port($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendDbid calls the stored procedure 'pg_catalog.pg_stat_get_backend_dbid(integer) oid' on db.
func PgStatGetBackendDbid(ctx context.Context, db DB, v0 int) (pgtypes.Oid, error) {
	// call pg_catalog.pg_stat_get_backend_dbid
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_dbid($1)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendIdset calls the stored procedure 'pg_catalog.pg_stat_get_backend_idset() SETOF integer' on db.
func PgStatGetBackendIdset(ctx context.Context, db DB) ([]int, error) {
	// call pg_catalog.pg_stat_get_backend_idset
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_idset()`
	// run
	var ret []int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendPid calls the stored procedure 'pg_catalog.pg_stat_get_backend_pid(integer) integer' on db.
func PgStatGetBackendPid(ctx context.Context, db DB, v0 int) (int, error) {
	// call pg_catalog.pg_stat_get_backend_pid
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_pid($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendStart calls the stored procedure 'pg_catalog.pg_stat_get_backend_start(integer) timestamp with time zone' on db.
func PgStatGetBackendStart(ctx context.Context, db DB, v0 int) (time.Time, error) {
	// call pg_catalog.pg_stat_get_backend_start
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_start($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendUserid calls the stored procedure 'pg_catalog.pg_stat_get_backend_userid(integer) oid' on db.
func PgStatGetBackendUserid(ctx context.Context, db DB, v0 int) (pgtypes.Oid, error) {
	// call pg_catalog.pg_stat_get_backend_userid
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_userid($1)`
	// run
	var ret pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendWaitEvent calls the stored procedure 'pg_catalog.pg_stat_get_backend_wait_event(integer) text' on db.
func PgStatGetBackendWaitEvent(ctx context.Context, db DB, v0 int) (string, error) {
	// call pg_catalog.pg_stat_get_backend_wait_event
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_wait_event($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendWaitEventType calls the stored procedure 'pg_catalog.pg_stat_get_backend_wait_event_type(integer) text' on db.
func PgStatGetBackendWaitEventType(ctx context.Context, db DB, v0 int) (string, error) {
	// call pg_catalog.pg_stat_get_backend_wait_event_type
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_wait_event_type($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgStatGetBackendXactStart calls the stored procedure 'pg_catalog.pg_stat_get_backend_xact_start(integer) timestamp with time zone' on db.
func PgStatGetBackendXactStart(ctx context.Context, db DB, v0 int) (time.Time, error) {
	// call pg_catalog.pg_stat_get_backend_xact_start
	const sqlstr = `SELECT pg_catalog.pg_stat_get_backend_xact_start($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetBgwriterBufWrittenCheckpoints calls the stored procedure 'pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() bigint' on db.
func PgStatGetBgwriterBufWrittenCheckpoints(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints
	const sqlstr = `SELECT pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBgwriterBufWrittenClean calls the stored procedure 'pg_catalog.pg_stat_get_bgwriter_buf_written_clean() bigint' on db.
func PgStatGetBgwriterBufWrittenClean(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_bgwriter_buf_written_clean
	const sqlstr = `SELECT pg_catalog.pg_stat_get_bgwriter_buf_written_clean()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBgwriterMaxwrittenClean calls the stored procedure 'pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() bigint' on db.
func PgStatGetBgwriterMaxwrittenClean(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_bgwriter_maxwritten_clean
	const sqlstr = `SELECT pg_catalog.pg_stat_get_bgwriter_maxwritten_clean()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBgwriterRequestedCheckpoints calls the stored procedure 'pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() bigint' on db.
func PgStatGetBgwriterRequestedCheckpoints(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_bgwriter_requested_checkpoints
	const sqlstr = `SELECT pg_catalog.pg_stat_get_bgwriter_requested_checkpoints()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBgwriterStatResetTime calls the stored procedure 'pg_catalog.pg_stat_get_bgwriter_stat_reset_time() timestamp with time zone' on db.
func PgStatGetBgwriterStatResetTime(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_stat_get_bgwriter_stat_reset_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_bgwriter_stat_reset_time()`
	// run
	var ret time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetBgwriterTimedCheckpoints calls the stored procedure 'pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() bigint' on db.
func PgStatGetBgwriterTimedCheckpoints(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_bgwriter_timed_checkpoints
	const sqlstr = `SELECT pg_catalog.pg_stat_get_bgwriter_timed_checkpoints()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBlocksFetched calls the stored procedure 'pg_catalog.pg_stat_get_blocks_fetched(oid) bigint' on db.
func PgStatGetBlocksFetched(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_blocks_fetched
	const sqlstr = `SELECT pg_catalog.pg_stat_get_blocks_fetched($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBlocksHit calls the stored procedure 'pg_catalog.pg_stat_get_blocks_hit(oid) bigint' on db.
func PgStatGetBlocksHit(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_blocks_hit
	const sqlstr = `SELECT pg_catalog.pg_stat_get_blocks_hit($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBufAlloc calls the stored procedure 'pg_catalog.pg_stat_get_buf_alloc() bigint' on db.
func PgStatGetBufAlloc(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_buf_alloc
	const sqlstr = `SELECT pg_catalog.pg_stat_get_buf_alloc()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBufFsyncBackend calls the stored procedure 'pg_catalog.pg_stat_get_buf_fsync_backend() bigint' on db.
func PgStatGetBufFsyncBackend(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_buf_fsync_backend
	const sqlstr = `SELECT pg_catalog.pg_stat_get_buf_fsync_backend()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetBufWrittenBackend calls the stored procedure 'pg_catalog.pg_stat_get_buf_written_backend() bigint' on db.
func PgStatGetBufWrittenBackend(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_buf_written_backend
	const sqlstr = `SELECT pg_catalog.pg_stat_get_buf_written_backend()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetCheckpointSyncTime calls the stored procedure 'pg_catalog.pg_stat_get_checkpoint_sync_time() double precision' on db.
func PgStatGetCheckpointSyncTime(ctx context.Context, db DB) (float64, error) {
	// call pg_catalog.pg_stat_get_checkpoint_sync_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_checkpoint_sync_time()`
	// run
	var ret float64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PgStatGetCheckpointWriteTime calls the stored procedure 'pg_catalog.pg_stat_get_checkpoint_write_time() double precision' on db.
func PgStatGetCheckpointWriteTime(ctx context.Context, db DB) (float64, error) {
	// call pg_catalog.pg_stat_get_checkpoint_write_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_checkpoint_write_time()`
	// run
	var ret float64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbBlkReadTime calls the stored procedure 'pg_catalog.pg_stat_get_db_blk_read_time(oid) double precision' on db.
func PgStatGetDbBlkReadTime(ctx context.Context, db DB, v0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_db_blk_read_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_blk_read_time($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbBlkWriteTime calls the stored procedure 'pg_catalog.pg_stat_get_db_blk_write_time(oid) double precision' on db.
func PgStatGetDbBlkWriteTime(ctx context.Context, db DB, v0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_db_blk_write_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_blk_write_time($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbBlocksFetched calls the stored procedure 'pg_catalog.pg_stat_get_db_blocks_fetched(oid) bigint' on db.
func PgStatGetDbBlocksFetched(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_blocks_fetched
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_blocks_fetched($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbBlocksHit calls the stored procedure 'pg_catalog.pg_stat_get_db_blocks_hit(oid) bigint' on db.
func PgStatGetDbBlocksHit(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_blocks_hit
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_blocks_hit($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbChecksumFailures calls the stored procedure 'pg_catalog.pg_stat_get_db_checksum_failures(oid) bigint' on db.
func PgStatGetDbChecksumFailures(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_checksum_failures
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_checksum_failures($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbChecksumLastFailure calls the stored procedure 'pg_catalog.pg_stat_get_db_checksum_last_failure(oid) timestamp with time zone' on db.
func PgStatGetDbChecksumLastFailure(ctx context.Context, db DB, v0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_db_checksum_last_failure
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_checksum_last_failure($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbConflictAll calls the stored procedure 'pg_catalog.pg_stat_get_db_conflict_all(oid) bigint' on db.
func PgStatGetDbConflictAll(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_all
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_conflict_all($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbConflictBufferpin calls the stored procedure 'pg_catalog.pg_stat_get_db_conflict_bufferpin(oid) bigint' on db.
func PgStatGetDbConflictBufferpin(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_bufferpin
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_conflict_bufferpin($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbConflictLock calls the stored procedure 'pg_catalog.pg_stat_get_db_conflict_lock(oid) bigint' on db.
func PgStatGetDbConflictLock(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_lock
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_conflict_lock($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbConflictSnapshot calls the stored procedure 'pg_catalog.pg_stat_get_db_conflict_snapshot(oid) bigint' on db.
func PgStatGetDbConflictSnapshot(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_snapshot
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_conflict_snapshot($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbConflictStartupDeadlock calls the stored procedure 'pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid) bigint' on db.
func PgStatGetDbConflictStartupDeadlock(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_startup_deadlock
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_conflict_startup_deadlock($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbConflictTablespace calls the stored procedure 'pg_catalog.pg_stat_get_db_conflict_tablespace(oid) bigint' on db.
func PgStatGetDbConflictTablespace(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_tablespace
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_conflict_tablespace($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbDeadlocks calls the stored procedure 'pg_catalog.pg_stat_get_db_deadlocks(oid) bigint' on db.
func PgStatGetDbDeadlocks(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_deadlocks
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_deadlocks($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbNumbackends calls the stored procedure 'pg_catalog.pg_stat_get_db_numbackends(oid) integer' on db.
func PgStatGetDbNumbackends(ctx context.Context, db DB, v0 pgtypes.Oid) (int, error) {
	// call pg_catalog.pg_stat_get_db_numbackends
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_numbackends($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbStatResetTime calls the stored procedure 'pg_catalog.pg_stat_get_db_stat_reset_time(oid) timestamp with time zone' on db.
func PgStatGetDbStatResetTime(ctx context.Context, db DB, v0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_db_stat_reset_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_stat_reset_time($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbTempBytes calls the stored procedure 'pg_catalog.pg_stat_get_db_temp_bytes(oid) bigint' on db.
func PgStatGetDbTempBytes(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_temp_bytes
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_temp_bytes($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbTempFiles calls the stored procedure 'pg_catalog.pg_stat_get_db_temp_files(oid) bigint' on db.
func PgStatGetDbTempFiles(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_temp_files
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_temp_files($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbTuplesDeleted calls the stored procedure 'pg_catalog.pg_stat_get_db_tuples_deleted(oid) bigint' on db.
func PgStatGetDbTuplesDeleted(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_tuples_deleted
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_tuples_deleted($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbTuplesFetched calls the stored procedure 'pg_catalog.pg_stat_get_db_tuples_fetched(oid) bigint' on db.
func PgStatGetDbTuplesFetched(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_tuples_fetched
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_tuples_fetched($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbTuplesInserted calls the stored procedure 'pg_catalog.pg_stat_get_db_tuples_inserted(oid) bigint' on db.
func PgStatGetDbTuplesInserted(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_tuples_inserted
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_tuples_inserted($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbTuplesReturned calls the stored procedure 'pg_catalog.pg_stat_get_db_tuples_returned(oid) bigint' on db.
func PgStatGetDbTuplesReturned(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_tuples_returned
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_tuples_returned($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbTuplesUpdated calls the stored procedure 'pg_catalog.pg_stat_get_db_tuples_updated(oid) bigint' on db.
func PgStatGetDbTuplesUpdated(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_tuples_updated
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_tuples_updated($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbXactCommit calls the stored procedure 'pg_catalog.pg_stat_get_db_xact_commit(oid) bigint' on db.
func PgStatGetDbXactCommit(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_xact_commit
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_xact_commit($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDbXactRollback calls the stored procedure 'pg_catalog.pg_stat_get_db_xact_rollback(oid) bigint' on db.
func PgStatGetDbXactRollback(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_xact_rollback
	const sqlstr = `SELECT pg_catalog.pg_stat_get_db_xact_rollback($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetDeadTuples calls the stored procedure 'pg_catalog.pg_stat_get_dead_tuples(oid) bigint' on db.
func PgStatGetDeadTuples(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_dead_tuples
	const sqlstr = `SELECT pg_catalog.pg_stat_get_dead_tuples($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetFunctionCalls calls the stored procedure 'pg_catalog.pg_stat_get_function_calls(oid) bigint' on db.
func PgStatGetFunctionCalls(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_function_calls
	const sqlstr = `SELECT pg_catalog.pg_stat_get_function_calls($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetFunctionSelfTime calls the stored procedure 'pg_catalog.pg_stat_get_function_self_time(oid) double precision' on db.
func PgStatGetFunctionSelfTime(ctx context.Context, db DB, v0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_function_self_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_function_self_time($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PgStatGetFunctionTotalTime calls the stored procedure 'pg_catalog.pg_stat_get_function_total_time(oid) double precision' on db.
func PgStatGetFunctionTotalTime(ctx context.Context, db DB, v0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_function_total_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_function_total_time($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PgStatGetInsSinceVacuum calls the stored procedure 'pg_catalog.pg_stat_get_ins_since_vacuum(oid) bigint' on db.
func PgStatGetInsSinceVacuum(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_ins_since_vacuum
	const sqlstr = `SELECT pg_catalog.pg_stat_get_ins_since_vacuum($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetLastAnalyzeTime calls the stored procedure 'pg_catalog.pg_stat_get_last_analyze_time(oid) timestamp with time zone' on db.
func PgStatGetLastAnalyzeTime(ctx context.Context, db DB, v0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_last_analyze_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_last_analyze_time($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetLastAutoanalyzeTime calls the stored procedure 'pg_catalog.pg_stat_get_last_autoanalyze_time(oid) timestamp with time zone' on db.
func PgStatGetLastAutoanalyzeTime(ctx context.Context, db DB, v0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_last_autoanalyze_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_last_autoanalyze_time($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetLastAutovacuumTime calls the stored procedure 'pg_catalog.pg_stat_get_last_autovacuum_time(oid) timestamp with time zone' on db.
func PgStatGetLastAutovacuumTime(ctx context.Context, db DB, v0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_last_autovacuum_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_last_autovacuum_time($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetLastVacuumTime calls the stored procedure 'pg_catalog.pg_stat_get_last_vacuum_time(oid) timestamp with time zone' on db.
func PgStatGetLastVacuumTime(ctx context.Context, db DB, v0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_last_vacuum_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_last_vacuum_time($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetLiveTuples calls the stored procedure 'pg_catalog.pg_stat_get_live_tuples(oid) bigint' on db.
func PgStatGetLiveTuples(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_live_tuples
	const sqlstr = `SELECT pg_catalog.pg_stat_get_live_tuples($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetModSinceAnalyze calls the stored procedure 'pg_catalog.pg_stat_get_mod_since_analyze(oid) bigint' on db.
func PgStatGetModSinceAnalyze(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_mod_since_analyze
	const sqlstr = `SELECT pg_catalog.pg_stat_get_mod_since_analyze($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetNumscans calls the stored procedure 'pg_catalog.pg_stat_get_numscans(oid) bigint' on db.
func PgStatGetNumscans(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_numscans
	const sqlstr = `SELECT pg_catalog.pg_stat_get_numscans($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetProgressInfo calls the stored procedure 'pg_catalog.pg_stat_get_progress_info(text) SETOF record' on db.
func PgStatGetProgressInfo(ctx context.Context, db DB, v0 string) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_stat_get_progress_info
	const sqlstr = `SELECT pg_catalog.pg_stat_get_progress_info($1)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgStatGetSlru calls the stored procedure 'pg_catalog.pg_stat_get_slru() SETOF record' on db.
func PgStatGetSlru(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_stat_get_slru
	const sqlstr = `SELECT pg_catalog.pg_stat_get_slru()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgStatGetSnapshotTimestamp calls the stored procedure 'pg_catalog.pg_stat_get_snapshot_timestamp() timestamp with time zone' on db.
func PgStatGetSnapshotTimestamp(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_stat_get_snapshot_timestamp
	const sqlstr = `SELECT pg_catalog.pg_stat_get_snapshot_timestamp()`
	// run
	var ret time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetSubscription calls the stored procedure 'pg_catalog.pg_stat_get_subscription(oid) record' on db.
func PgStatGetSubscription(ctx context.Context, db DB, v0 pgtypes.Oid) (pgtypes.Record, error) {
	// call pg_catalog.pg_stat_get_subscription
	const sqlstr = `SELECT pg_catalog.pg_stat_get_subscription($1)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetTuplesDeleted calls the stored procedure 'pg_catalog.pg_stat_get_tuples_deleted(oid) bigint' on db.
func PgStatGetTuplesDeleted(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_deleted
	const sqlstr = `SELECT pg_catalog.pg_stat_get_tuples_deleted($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetTuplesFetched calls the stored procedure 'pg_catalog.pg_stat_get_tuples_fetched(oid) bigint' on db.
func PgStatGetTuplesFetched(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_fetched
	const sqlstr = `SELECT pg_catalog.pg_stat_get_tuples_fetched($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetTuplesHotUpdated calls the stored procedure 'pg_catalog.pg_stat_get_tuples_hot_updated(oid) bigint' on db.
func PgStatGetTuplesHotUpdated(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_hot_updated
	const sqlstr = `SELECT pg_catalog.pg_stat_get_tuples_hot_updated($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetTuplesInserted calls the stored procedure 'pg_catalog.pg_stat_get_tuples_inserted(oid) bigint' on db.
func PgStatGetTuplesInserted(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_inserted
	const sqlstr = `SELECT pg_catalog.pg_stat_get_tuples_inserted($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetTuplesReturned calls the stored procedure 'pg_catalog.pg_stat_get_tuples_returned(oid) bigint' on db.
func PgStatGetTuplesReturned(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_returned
	const sqlstr = `SELECT pg_catalog.pg_stat_get_tuples_returned($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetTuplesUpdated calls the stored procedure 'pg_catalog.pg_stat_get_tuples_updated(oid) bigint' on db.
func PgStatGetTuplesUpdated(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_updated
	const sqlstr = `SELECT pg_catalog.pg_stat_get_tuples_updated($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetVacuumCount calls the stored procedure 'pg_catalog.pg_stat_get_vacuum_count(oid) bigint' on db.
func PgStatGetVacuumCount(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_vacuum_count
	const sqlstr = `SELECT pg_catalog.pg_stat_get_vacuum_count($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetWalReceiver calls the stored procedure 'pg_catalog.pg_stat_get_wal_receiver() record' on db.
func PgStatGetWalReceiver(ctx context.Context, db DB) (pgtypes.Record, error) {
	// call pg_catalog.pg_stat_get_wal_receiver
	const sqlstr = `SELECT pg_catalog.pg_stat_get_wal_receiver()`
	// run
	var ret pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgStatGetWalSenders calls the stored procedure 'pg_catalog.pg_stat_get_wal_senders() SETOF record' on db.
func PgStatGetWalSenders(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_stat_get_wal_senders
	const sqlstr = `SELECT pg_catalog.pg_stat_get_wal_senders()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactBlocksFetched calls the stored procedure 'pg_catalog.pg_stat_get_xact_blocks_fetched(oid) bigint' on db.
func PgStatGetXactBlocksFetched(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_blocks_fetched
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_blocks_fetched($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactBlocksHit calls the stored procedure 'pg_catalog.pg_stat_get_xact_blocks_hit(oid) bigint' on db.
func PgStatGetXactBlocksHit(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_blocks_hit
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_blocks_hit($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactFunctionCalls calls the stored procedure 'pg_catalog.pg_stat_get_xact_function_calls(oid) bigint' on db.
func PgStatGetXactFunctionCalls(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_function_calls
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_function_calls($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactFunctionSelfTime calls the stored procedure 'pg_catalog.pg_stat_get_xact_function_self_time(oid) double precision' on db.
func PgStatGetXactFunctionSelfTime(ctx context.Context, db DB, v0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_xact_function_self_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_function_self_time($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactFunctionTotalTime calls the stored procedure 'pg_catalog.pg_stat_get_xact_function_total_time(oid) double precision' on db.
func PgStatGetXactFunctionTotalTime(ctx context.Context, db DB, v0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_xact_function_total_time
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_function_total_time($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactNumscans calls the stored procedure 'pg_catalog.pg_stat_get_xact_numscans(oid) bigint' on db.
func PgStatGetXactNumscans(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_numscans
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_numscans($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactTuplesDeleted calls the stored procedure 'pg_catalog.pg_stat_get_xact_tuples_deleted(oid) bigint' on db.
func PgStatGetXactTuplesDeleted(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_deleted
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_tuples_deleted($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactTuplesFetched calls the stored procedure 'pg_catalog.pg_stat_get_xact_tuples_fetched(oid) bigint' on db.
func PgStatGetXactTuplesFetched(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_fetched
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_tuples_fetched($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactTuplesHotUpdated calls the stored procedure 'pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid) bigint' on db.
func PgStatGetXactTuplesHotUpdated(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_hot_updated
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_tuples_hot_updated($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactTuplesInserted calls the stored procedure 'pg_catalog.pg_stat_get_xact_tuples_inserted(oid) bigint' on db.
func PgStatGetXactTuplesInserted(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_inserted
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_tuples_inserted($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactTuplesReturned calls the stored procedure 'pg_catalog.pg_stat_get_xact_tuples_returned(oid) bigint' on db.
func PgStatGetXactTuplesReturned(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_returned
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_tuples_returned($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatGetXactTuplesUpdated calls the stored procedure 'pg_catalog.pg_stat_get_xact_tuples_updated(oid) bigint' on db.
func PgStatGetXactTuplesUpdated(ctx context.Context, db DB, v0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_updated
	const sqlstr = `SELECT pg_catalog.pg_stat_get_xact_tuples_updated($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgStatReset calls the stored procedure 'pg_catalog.pg_stat_reset() void' on db.
func PgStatReset(ctx context.Context, db DB) error {
	// call pg_catalog.pg_stat_reset
	const sqlstr = `SELECT pg_catalog.pg_stat_reset()`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatResetShared calls the stored procedure 'pg_catalog.pg_stat_reset_shared(text) void' on db.
func PgStatResetShared(ctx context.Context, db DB, v0 string) error {
	// call pg_catalog.pg_stat_reset_shared
	const sqlstr = `SELECT pg_catalog.pg_stat_reset_shared($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatResetSingleFunctionCounters calls the stored procedure 'pg_catalog.pg_stat_reset_single_function_counters(oid) void' on db.
func PgStatResetSingleFunctionCounters(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.pg_stat_reset_single_function_counters
	const sqlstr = `SELECT pg_catalog.pg_stat_reset_single_function_counters($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatResetSingleTableCounters calls the stored procedure 'pg_catalog.pg_stat_reset_single_table_counters(oid) void' on db.
func PgStatResetSingleTableCounters(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.pg_stat_reset_single_table_counters
	const sqlstr = `SELECT pg_catalog.pg_stat_reset_single_table_counters($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatResetSlru calls the stored procedure 'pg_catalog.pg_stat_reset_slru(text) void' on db.
func PgStatResetSlru(ctx context.Context, db DB, v0 string) error {
	// call pg_catalog.pg_stat_reset_slru
	const sqlstr = `SELECT pg_catalog.pg_stat_reset_slru($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatisticsObjIsVisible calls the stored procedure 'pg_catalog.pg_statistics_obj_is_visible(oid) boolean' on db.
func PgStatisticsObjIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_statistics_obj_is_visible
	const sqlstr = `SELECT pg_catalog.pg_statistics_obj_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgStopBackup calls the stored procedure 'pg_catalog.pg_stop_backup(boolean, boolean) SETOF record' on db.
func PgStopBackup(ctx context.Context, db DB, v0, v1 bool) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_stop_backup
	const sqlstr = `SELECT pg_catalog.pg_stop_backup($1, $2)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgSwitchWal calls the stored procedure 'pg_catalog.pg_switch_wal() pg_lsn' on db.
func PgSwitchWal(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_switch_wal
	const sqlstr = `SELECT pg_catalog.pg_switch_wal()`
	// run
	var ret pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return ret, nil
}

// PgTableIsVisible calls the stored procedure 'pg_catalog.pg_table_is_visible(oid) boolean' on db.
func PgTableIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_table_is_visible
	const sqlstr = `SELECT pg_catalog.pg_table_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgTableSize calls the stored procedure 'pg_catalog.pg_table_size(regclass) bigint' on db.
func PgTableSize(ctx context.Context, db DB, v0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.pg_table_size
	const sqlstr = `SELECT pg_catalog.pg_table_size($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgTablespaceDatabases calls the stored procedure 'pg_catalog.pg_tablespace_databases(oid) SETOF oid' on db.
func PgTablespaceDatabases(ctx context.Context, db DB, v0 pgtypes.Oid) ([]pgtypes.Oid, error) {
	// call pg_catalog.pg_tablespace_databases
	const sqlstr = `SELECT pg_catalog.pg_tablespace_databases($1)`
	// run
	var ret []pgtypes.Oid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgTablespaceLocation calls the stored procedure 'pg_catalog.pg_tablespace_location(oid) text' on db.
func PgTablespaceLocation(ctx context.Context, db DB, v0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_tablespace_location
	const sqlstr = `SELECT pg_catalog.pg_tablespace_location($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgTablespaceSize calls the stored procedure 'pg_catalog.pg_tablespace_size(name, oid) bigint' on db.
func PgTablespaceSize(ctx context.Context, db DB, v0 pgtypes.Name, v1 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_tablespace_size
	const sqlstr = `SELECT pg_catalog.pg_tablespace_size($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgTerminateBackend calls the stored procedure 'pg_catalog.pg_terminate_backend(integer) boolean' on db.
func PgTerminateBackend(ctx context.Context, db DB, v0 int) (bool, error) {
	// call pg_catalog.pg_terminate_backend
	const sqlstr = `SELECT pg_catalog.pg_terminate_backend($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgTimezoneAbbrevs calls the stored procedure 'pg_catalog.pg_timezone_abbrevs() SETOF record' on db.
func PgTimezoneAbbrevs(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_timezone_abbrevs
	const sqlstr = `SELECT pg_catalog.pg_timezone_abbrevs()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgTimezoneNames calls the stored procedure 'pg_catalog.pg_timezone_names() SETOF record' on db.
func PgTimezoneNames(ctx context.Context, db DB) ([]pgtypes.Record, error) {
	// call pg_catalog.pg_timezone_names
	const sqlstr = `SELECT pg_catalog.pg_timezone_names()`
	// run
	var ret []pgtypes.Record
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PgTotalRelationSize calls the stored procedure 'pg_catalog.pg_total_relation_size(regclass) bigint' on db.
func PgTotalRelationSize(ctx context.Context, db DB, v0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.pg_total_relation_size
	const sqlstr = `SELECT pg_catalog.pg_total_relation_size($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgTriggerDepth calls the stored procedure 'pg_catalog.pg_trigger_depth() integer' on db.
func PgTriggerDepth(ctx context.Context, db DB) (int, error) {
	// call pg_catalog.pg_trigger_depth
	const sqlstr = `SELECT pg_catalog.pg_trigger_depth()`
	// run
	var ret int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PgTryAdvisoryLock calls the stored procedure 'pg_catalog.pg_try_advisory_lock(bigint, integer, integer) boolean' on db.
func PgTryAdvisoryLock(ctx context.Context, db DB, v0 int64, v1, v2 int) (bool, error) {
	// call pg_catalog.pg_try_advisory_lock
	const sqlstr = `SELECT pg_catalog.pg_try_advisory_lock($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgTryAdvisoryLockShared calls the stored procedure 'pg_catalog.pg_try_advisory_lock_shared(bigint, integer, integer) boolean' on db.
func PgTryAdvisoryLockShared(ctx context.Context, db DB, v0 int64, v1, v2 int) (bool, error) {
	// call pg_catalog.pg_try_advisory_lock_shared
	const sqlstr = `SELECT pg_catalog.pg_try_advisory_lock_shared($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgTryAdvisoryXactLock calls the stored procedure 'pg_catalog.pg_try_advisory_xact_lock(bigint, integer, integer) boolean' on db.
func PgTryAdvisoryXactLock(ctx context.Context, db DB, v0 int64, v1, v2 int) (bool, error) {
	// call pg_catalog.pg_try_advisory_xact_lock
	const sqlstr = `SELECT pg_catalog.pg_try_advisory_xact_lock($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgTryAdvisoryXactLockShared calls the stored procedure 'pg_catalog.pg_try_advisory_xact_lock_shared(bigint, integer, integer) boolean' on db.
func PgTryAdvisoryXactLockShared(ctx context.Context, db DB, v0 int64, v1, v2 int) (bool, error) {
	// call pg_catalog.pg_try_advisory_xact_lock_shared
	const sqlstr = `SELECT pg_catalog.pg_try_advisory_xact_lock_shared($1, $2, $3)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgTsConfigIsVisible calls the stored procedure 'pg_catalog.pg_ts_config_is_visible(oid) boolean' on db.
func PgTsConfigIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_ts_config_is_visible
	const sqlstr = `SELECT pg_catalog.pg_ts_config_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgTsDictIsVisible calls the stored procedure 'pg_catalog.pg_ts_dict_is_visible(oid) boolean' on db.
func PgTsDictIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_ts_dict_is_visible
	const sqlstr = `SELECT pg_catalog.pg_ts_dict_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgTsParserIsVisible calls the stored procedure 'pg_catalog.pg_ts_parser_is_visible(oid) boolean' on db.
func PgTsParserIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_ts_parser_is_visible
	const sqlstr = `SELECT pg_catalog.pg_ts_parser_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgTsTemplateIsVisible calls the stored procedure 'pg_catalog.pg_ts_template_is_visible(oid) boolean' on db.
func PgTsTemplateIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_ts_template_is_visible
	const sqlstr = `SELECT pg_catalog.pg_ts_template_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgTypeIsVisible calls the stored procedure 'pg_catalog.pg_type_is_visible(oid) boolean' on db.
func PgTypeIsVisible(ctx context.Context, db DB, v0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_type_is_visible
	const sqlstr = `SELECT pg_catalog.pg_type_is_visible($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgTypeof calls the stored procedure 'pg_catalog.pg_typeof("any") regtype' on db.
func PgTypeof(ctx context.Context, db DB, v0 pgtypes.Any) (pgtypes.Regtype, error) {
	// call pg_catalog.pg_typeof
	const sqlstr = `SELECT pg_catalog.pg_typeof($1)`
	// run
	var ret pgtypes.Regtype
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regtype{}, logerror(err)
	}
	return ret, nil
}

// PgVisibleInSnapshot calls the stored procedure 'pg_catalog.pg_visible_in_snapshot(xid8, pg_snapshot) boolean' on db.
func PgVisibleInSnapshot(ctx context.Context, db DB, v0 pgtypes.Xid8, v1 pgtypes.PgSnapshot) (bool, error) {
	// call pg_catalog.pg_visible_in_snapshot
	const sqlstr = `SELECT pg_catalog.pg_visible_in_snapshot($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PgWalLsnDiff calls the stored procedure 'pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn) numeric' on db.
func PgWalLsnDiff(ctx context.Context, db DB, v0, v1 pgtypes.PgLsn) (float64, error) {
	// call pg_catalog.pg_wal_lsn_diff
	const sqlstr = `SELECT pg_catalog.pg_wal_lsn_diff($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PgWalReplayPause calls the stored procedure 'pg_catalog.pg_wal_replay_pause() void' on db.
func PgWalReplayPause(ctx context.Context, db DB) error {
	// call pg_catalog.pg_wal_replay_pause
	const sqlstr = `SELECT pg_catalog.pg_wal_replay_pause()`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgWalReplayResume calls the stored procedure 'pg_catalog.pg_wal_replay_resume() void' on db.
func PgWalReplayResume(ctx context.Context, db DB) error {
	// call pg_catalog.pg_wal_replay_resume
	const sqlstr = `SELECT pg_catalog.pg_wal_replay_resume()`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgWalfileName calls the stored procedure 'pg_catalog.pg_walfile_name(pg_lsn) text' on db.
func PgWalfileName(ctx context.Context, db DB, v0 pgtypes.PgLsn) (string, error) {
	// call pg_catalog.pg_walfile_name
	const sqlstr = `SELECT pg_catalog.pg_walfile_name($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PgWalfileNameOffset calls the stored procedure 'pg_catalog.pg_walfile_name_offset(pg_lsn) record' on db.
func PgWalfileNameOffset(ctx context.Context, db DB, v0 pgtypes.PgLsn) (pgtypes.Record, error) {
	// call pg_catalog.pg_walfile_name_offset
	const sqlstr = `SELECT pg_catalog.pg_walfile_name_offset($1)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// PgXactCommitTimestamp calls the stored procedure 'pg_catalog.pg_xact_commit_timestamp(xid) timestamp with time zone' on db.
func PgXactCommitTimestamp(ctx context.Context, db DB, v0 pgtypes.Xid) (time.Time, error) {
	// call pg_catalog.pg_xact_commit_timestamp
	const sqlstr = `SELECT pg_catalog.pg_xact_commit_timestamp($1)`
	// run
	var ret time.Time
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// PgXactStatus calls the stored procedure 'pg_catalog.pg_xact_status(xid8) text' on db.
func PgXactStatus(ctx context.Context, db DB, v0 pgtypes.Xid8) (string, error) {
	// call pg_catalog.pg_xact_status
	const sqlstr = `SELECT pg_catalog.pg_xact_status($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// PhrasetoTsquery calls the stored procedure 'pg_catalog.phraseto_tsquery(text, regconfig, text) tsquery' on db.
func PhrasetoTsquery(ctx context.Context, db DB, v0 string, v1 pgtypes.Regconfig, v2 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.phraseto_tsquery
	const sqlstr = `SELECT pg_catalog.phraseto_tsquery($1, $2, $3)`
	// run
	var ret pgtypes.Tsquery
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return ret, nil
}

// Pi calls the stored procedure 'pg_catalog.pi() double precision' on db.
func Pi(ctx context.Context, db DB) (float64, error) {
	// call pg_catalog.pi
	const sqlstr = `SELECT pg_catalog.pi()`
	// run
	var ret float64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PlaintoTsquery calls the stored procedure 'pg_catalog.plainto_tsquery(text, regconfig, text) tsquery' on db.
func PlaintoTsquery(ctx context.Context, db DB, v0 string, v1 pgtypes.Regconfig, v2 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.plainto_tsquery
	const sqlstr = `SELECT pg_catalog.plainto_tsquery($1, $2, $3)`
	// run
	var ret pgtypes.Tsquery
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return ret, nil
}

// PlpgsqlCallHandler calls the stored procedure 'pg_catalog.plpgsql_call_handler() language_handler' on db.
func PlpgsqlCallHandler(ctx context.Context, db DB) (pgtypes.LanguageHandler, error) {
	// call pg_catalog.plpgsql_call_handler
	const sqlstr = `SELECT pg_catalog.plpgsql_call_handler()`
	// run
	var ret pgtypes.LanguageHandler
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.LanguageHandler{}, logerror(err)
	}
	return ret, nil
}

// PlpgsqlInlineHandler calls the stored procedure 'pg_catalog.plpgsql_inline_handler(internal) void' on db.
func PlpgsqlInlineHandler(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.plpgsql_inline_handler
	const sqlstr = `SELECT pg_catalog.plpgsql_inline_handler($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PlpgsqlValidator calls the stored procedure 'pg_catalog.plpgsql_validator(oid) void' on db.
func PlpgsqlValidator(ctx context.Context, db DB, v0 pgtypes.Oid) error {
	// call pg_catalog.plpgsql_validator
	const sqlstr = `SELECT pg_catalog.plpgsql_validator($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Point calls the stored procedure 'pg_catalog.point(lseg, path, box, polygon, circle, double precision, double precision) point' on db.
func Point(ctx context.Context, db DB, v0 pgtypes.Lseg, v1 pgtypes.Path, v2 pgtypes.Box, v3 pgtypes.Polygon, v4 pgtypes.Circle, v5, v6 float64) (pgtypes.Point, error) {
	// call pg_catalog.point
	const sqlstr = `SELECT pg_catalog.point($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// PointAbove calls the stored procedure 'pg_catalog.point_above(point, point) boolean' on db.
func PointAbove(ctx context.Context, db DB, v0, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_above
	const sqlstr = `SELECT pg_catalog.point_above($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PointAdd calls the stored procedure 'pg_catalog.point_add(point, point) point' on db.
func PointAdd(ctx context.Context, db DB, v0, v1 pgtypes.Point) (pgtypes.Point, error) {
	// call pg_catalog.point_add
	const sqlstr = `SELECT pg_catalog.point_add($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// PointBelow calls the stored procedure 'pg_catalog.point_below(point, point) boolean' on db.
func PointBelow(ctx context.Context, db DB, v0, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_below
	const sqlstr = `SELECT pg_catalog.point_below($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PointDistance calls the stored procedure 'pg_catalog.point_distance(point, point) double precision' on db.
func PointDistance(ctx context.Context, db DB, v0, v1 pgtypes.Point) (float64, error) {
	// call pg_catalog.point_distance
	const sqlstr = `SELECT pg_catalog.point_distance($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PointDiv calls the stored procedure 'pg_catalog.point_div(point, point) point' on db.
func PointDiv(ctx context.Context, db DB, v0, v1 pgtypes.Point) (pgtypes.Point, error) {
	// call pg_catalog.point_div
	const sqlstr = `SELECT pg_catalog.point_div($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// PointEq calls the stored procedure 'pg_catalog.point_eq(point, point) boolean' on db.
func PointEq(ctx context.Context, db DB, v0, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_eq
	const sqlstr = `SELECT pg_catalog.point_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PointHoriz calls the stored procedure 'pg_catalog.point_horiz(point, point) boolean' on db.
func PointHoriz(ctx context.Context, db DB, v0, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_horiz
	const sqlstr = `SELECT pg_catalog.point_horiz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PointIn calls the stored procedure 'pg_catalog.point_in(cstring) point' on db.
func PointIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Point, error) {
	// call pg_catalog.point_in
	const sqlstr = `SELECT pg_catalog.point_in($1)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// PointLeft calls the stored procedure 'pg_catalog.point_left(point, point) boolean' on db.
func PointLeft(ctx context.Context, db DB, v0, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_left
	const sqlstr = `SELECT pg_catalog.point_left($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PointMul calls the stored procedure 'pg_catalog.point_mul(point, point) point' on db.
func PointMul(ctx context.Context, db DB, v0, v1 pgtypes.Point) (pgtypes.Point, error) {
	// call pg_catalog.point_mul
	const sqlstr = `SELECT pg_catalog.point_mul($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// PointNe calls the stored procedure 'pg_catalog.point_ne(point, point) boolean' on db.
func PointNe(ctx context.Context, db DB, v0, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_ne
	const sqlstr = `SELECT pg_catalog.point_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PointOut calls the stored procedure 'pg_catalog.point_out(point) cstring' on db.
func PointOut(ctx context.Context, db DB, v0 pgtypes.Point) (pgtypes.Cstring, error) {
	// call pg_catalog.point_out
	const sqlstr = `SELECT pg_catalog.point_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// PointRecv calls the stored procedure 'pg_catalog.point_recv(internal) point' on db.
func PointRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Point, error) {
	// call pg_catalog.point_recv
	const sqlstr = `SELECT pg_catalog.point_recv($1)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// PointRight calls the stored procedure 'pg_catalog.point_right(point, point) boolean' on db.
func PointRight(ctx context.Context, db DB, v0, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_right
	const sqlstr = `SELECT pg_catalog.point_right($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PointSend calls the stored procedure 'pg_catalog.point_send(point) bytea' on db.
func PointSend(ctx context.Context, db DB, v0 pgtypes.Point) ([]byte, error) {
	// call pg_catalog.point_send
	const sqlstr = `SELECT pg_catalog.point_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// PointSub calls the stored procedure 'pg_catalog.point_sub(point, point) point' on db.
func PointSub(ctx context.Context, db DB, v0, v1 pgtypes.Point) (pgtypes.Point, error) {
	// call pg_catalog.point_sub
	const sqlstr = `SELECT pg_catalog.point_sub($1, $2)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// PointVert calls the stored procedure 'pg_catalog.point_vert(point, point) boolean' on db.
func PointVert(ctx context.Context, db DB, v0, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_vert
	const sqlstr = `SELECT pg_catalog.point_vert($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyAbove calls the stored procedure 'pg_catalog.poly_above(polygon, polygon) boolean' on db.
func PolyAbove(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_above
	const sqlstr = `SELECT pg_catalog.poly_above($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyBelow calls the stored procedure 'pg_catalog.poly_below(polygon, polygon) boolean' on db.
func PolyBelow(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_below
	const sqlstr = `SELECT pg_catalog.poly_below($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyCenter calls the stored procedure 'pg_catalog.poly_center(polygon) point' on db.
func PolyCenter(ctx context.Context, db DB, v0 pgtypes.Polygon) (pgtypes.Point, error) {
	// call pg_catalog.poly_center
	const sqlstr = `SELECT pg_catalog.poly_center($1)`
	// run
	var ret pgtypes.Point
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return ret, nil
}

// PolyContain calls the stored procedure 'pg_catalog.poly_contain(polygon, polygon) boolean' on db.
func PolyContain(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_contain
	const sqlstr = `SELECT pg_catalog.poly_contain($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyContainPt calls the stored procedure 'pg_catalog.poly_contain_pt(polygon, point) boolean' on db.
func PolyContainPt(ctx context.Context, db DB, v0 pgtypes.Polygon, v1 pgtypes.Point) (bool, error) {
	// call pg_catalog.poly_contain_pt
	const sqlstr = `SELECT pg_catalog.poly_contain_pt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyContained calls the stored procedure 'pg_catalog.poly_contained(polygon, polygon) boolean' on db.
func PolyContained(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_contained
	const sqlstr = `SELECT pg_catalog.poly_contained($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyDistance calls the stored procedure 'pg_catalog.poly_distance(polygon, polygon) double precision' on db.
func PolyDistance(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (float64, error) {
	// call pg_catalog.poly_distance
	const sqlstr = `SELECT pg_catalog.poly_distance($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PolyIn calls the stored procedure 'pg_catalog.poly_in(cstring) polygon' on db.
func PolyIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Polygon, error) {
	// call pg_catalog.poly_in
	const sqlstr = `SELECT pg_catalog.poly_in($1)`
	// run
	var ret pgtypes.Polygon
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Polygon{}, logerror(err)
	}
	return ret, nil
}

// PolyLeft calls the stored procedure 'pg_catalog.poly_left(polygon, polygon) boolean' on db.
func PolyLeft(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_left
	const sqlstr = `SELECT pg_catalog.poly_left($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyNpoints calls the stored procedure 'pg_catalog.poly_npoints(polygon) integer' on db.
func PolyNpoints(ctx context.Context, db DB, v0 pgtypes.Polygon) (int, error) {
	// call pg_catalog.poly_npoints
	const sqlstr = `SELECT pg_catalog.poly_npoints($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// PolyOut calls the stored procedure 'pg_catalog.poly_out(polygon) cstring' on db.
func PolyOut(ctx context.Context, db DB, v0 pgtypes.Polygon) (pgtypes.Cstring, error) {
	// call pg_catalog.poly_out
	const sqlstr = `SELECT pg_catalog.poly_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// PolyOverabove calls the stored procedure 'pg_catalog.poly_overabove(polygon, polygon) boolean' on db.
func PolyOverabove(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_overabove
	const sqlstr = `SELECT pg_catalog.poly_overabove($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyOverbelow calls the stored procedure 'pg_catalog.poly_overbelow(polygon, polygon) boolean' on db.
func PolyOverbelow(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_overbelow
	const sqlstr = `SELECT pg_catalog.poly_overbelow($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyOverlap calls the stored procedure 'pg_catalog.poly_overlap(polygon, polygon) boolean' on db.
func PolyOverlap(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_overlap
	const sqlstr = `SELECT pg_catalog.poly_overlap($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyOverleft calls the stored procedure 'pg_catalog.poly_overleft(polygon, polygon) boolean' on db.
func PolyOverleft(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_overleft
	const sqlstr = `SELECT pg_catalog.poly_overleft($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyOverright calls the stored procedure 'pg_catalog.poly_overright(polygon, polygon) boolean' on db.
func PolyOverright(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_overright
	const sqlstr = `SELECT pg_catalog.poly_overright($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolyRecv calls the stored procedure 'pg_catalog.poly_recv(internal) polygon' on db.
func PolyRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Polygon, error) {
	// call pg_catalog.poly_recv
	const sqlstr = `SELECT pg_catalog.poly_recv($1)`
	// run
	var ret pgtypes.Polygon
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Polygon{}, logerror(err)
	}
	return ret, nil
}

// PolyRight calls the stored procedure 'pg_catalog.poly_right(polygon, polygon) boolean' on db.
func PolyRight(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_right
	const sqlstr = `SELECT pg_catalog.poly_right($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolySame calls the stored procedure 'pg_catalog.poly_same(polygon, polygon) boolean' on db.
func PolySame(ctx context.Context, db DB, v0, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_same
	const sqlstr = `SELECT pg_catalog.poly_same($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PolySend calls the stored procedure 'pg_catalog.poly_send(polygon) bytea' on db.
func PolySend(ctx context.Context, db DB, v0 pgtypes.Polygon) ([]byte, error) {
	// call pg_catalog.poly_send
	const sqlstr = `SELECT pg_catalog.poly_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Polygon calls the stored procedure 'pg_catalog.polygon(path, box, circle, integer, circle) polygon' on db.
func Polygon(ctx context.Context, db DB, v0 pgtypes.Path, v1 pgtypes.Box, v2 pgtypes.Circle, v3 int, v4 pgtypes.Circle) (pgtypes.Polygon, error) {
	// call pg_catalog.polygon
	const sqlstr = `SELECT pg_catalog.polygon($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Polygon
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Polygon{}, logerror(err)
	}
	return ret, nil
}

// Popen calls the stored procedure 'pg_catalog.popen(path) path' on db.
func Popen(ctx context.Context, db DB, v0 pgtypes.Path) (pgtypes.Path, error) {
	// call pg_catalog.popen
	const sqlstr = `SELECT pg_catalog.popen($1)`
	// run
	var ret pgtypes.Path
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return ret, nil
}

// Position calls the stored procedure 'pg_catalog.position(bytea, bytea, text, text, bit, bit) integer' on db.
func Position(ctx context.Context, db DB, v0, v1 []byte, v2, v3 string, v4, v5 uint8) (int, error) {
	// call pg_catalog.position
	const sqlstr = `SELECT pg_catalog.position($1, $2, $3, $4, $5, $6)`
	// run
	var ret int
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Positionjoinsel calls the stored procedure 'pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Positionjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.positionjoinsel
	const sqlstr = `SELECT pg_catalog.positionjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Positionsel calls the stored procedure 'pg_catalog.positionsel(internal, oid, internal, integer) double precision' on db.
func Positionsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.positionsel
	const sqlstr = `SELECT pg_catalog.positionsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PostgresqlFdwValidator calls the stored procedure 'pg_catalog.postgresql_fdw_validator(text[], oid) boolean' on db.
func PostgresqlFdwValidator(ctx context.Context, db DB, v0 StringSlice, v1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.postgresql_fdw_validator
	const sqlstr = `SELECT pg_catalog.postgresql_fdw_validator($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Pow calls the stored procedure 'pg_catalog.pow(double precision, double precision, numeric, numeric) numeric' on db.
func Pow(ctx context.Context, db DB, v0, v1, v2, v3 float64) (float64, error) {
	// call pg_catalog.pow
	const sqlstr = `SELECT pg_catalog.pow($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Power calls the stored procedure 'pg_catalog.power(double precision, double precision, numeric, numeric) numeric' on db.
func Power(ctx context.Context, db DB, v0, v1, v2, v3 float64) (float64, error) {
	// call pg_catalog.power
	const sqlstr = `SELECT pg_catalog.power($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Prefixjoinsel calls the stored procedure 'pg_catalog.prefixjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Prefixjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.prefixjoinsel
	const sqlstr = `SELECT pg_catalog.prefixjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Prefixsel calls the stored procedure 'pg_catalog.prefixsel(internal, oid, internal, integer) double precision' on db.
func Prefixsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.prefixsel
	const sqlstr = `SELECT pg_catalog.prefixsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// PrsdEnd calls the stored procedure 'pg_catalog.prsd_end(internal) void' on db.
func PrsdEnd(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.prsd_end
	const sqlstr = `SELECT pg_catalog.prsd_end($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PrsdHeadline calls the stored procedure 'pg_catalog.prsd_headline(internal, internal, tsquery) internal' on db.
func PrsdHeadline(ctx context.Context, db DB, v0, v1 pgtypes.Internal, v2 pgtypes.Tsquery) (pgtypes.Internal, error) {
	// call pg_catalog.prsd_headline
	const sqlstr = `SELECT pg_catalog.prsd_headline($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// PrsdLextype calls the stored procedure 'pg_catalog.prsd_lextype(internal) internal' on db.
func PrsdLextype(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.prsd_lextype
	const sqlstr = `SELECT pg_catalog.prsd_lextype($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// PrsdNexttoken calls the stored procedure 'pg_catalog.prsd_nexttoken(internal, internal, internal) internal' on db.
func PrsdNexttoken(ctx context.Context, db DB, v0, v1, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.prsd_nexttoken
	const sqlstr = `SELECT pg_catalog.prsd_nexttoken($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// PrsdStart calls the stored procedure 'pg_catalog.prsd_start(internal, integer) internal' on db.
func PrsdStart(ctx context.Context, db DB, v0 pgtypes.Internal, v1 int) (pgtypes.Internal, error) {
	// call pg_catalog.prsd_start
	const sqlstr = `SELECT pg_catalog.prsd_start($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// PtContainedCircle calls the stored procedure 'pg_catalog.pt_contained_circle(point, circle) boolean' on db.
func PtContainedCircle(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.pt_contained_circle
	const sqlstr = `SELECT pg_catalog.pt_contained_circle($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// PtContainedPoly calls the stored procedure 'pg_catalog.pt_contained_poly(point, polygon) boolean' on db.
func PtContainedPoly(ctx context.Context, db DB, v0 pgtypes.Point, v1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.pt_contained_poly
	const sqlstr = `SELECT pg_catalog.pt_contained_poly($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// QueryToXML calls the stored procedure 'pg_catalog.query_to_xml(text, boolean, boolean, text) xml' on db.
func QueryToXML(ctx context.Context, db DB, v0 string, v1, v2 bool, v3 string) ([]byte, error) {
	// call pg_catalog.query_to_xml
	const sqlstr = `SELECT pg_catalog.query_to_xml($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// QueryToXMLAndXmlschema calls the stored procedure 'pg_catalog.query_to_xml_and_xmlschema(text, boolean, boolean, text) xml' on db.
func QueryToXMLAndXmlschema(ctx context.Context, db DB, v0 string, v1, v2 bool, v3 string) ([]byte, error) {
	// call pg_catalog.query_to_xml_and_xmlschema
	const sqlstr = `SELECT pg_catalog.query_to_xml_and_xmlschema($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// QueryToXmlschema calls the stored procedure 'pg_catalog.query_to_xmlschema(text, boolean, boolean, text) xml' on db.
func QueryToXmlschema(ctx context.Context, db DB, v0 string, v1, v2 bool, v3 string) ([]byte, error) {
	// call pg_catalog.query_to_xmlschema
	const sqlstr = `SELECT pg_catalog.query_to_xmlschema($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Querytree calls the stored procedure 'pg_catalog.querytree(tsquery) text' on db.
func Querytree(ctx context.Context, db DB, v0 pgtypes.Tsquery) (string, error) {
	// call pg_catalog.querytree
	const sqlstr = `SELECT pg_catalog.querytree($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// QuoteIdent calls the stored procedure 'pg_catalog.quote_ident(text) text' on db.
func QuoteIdent(ctx context.Context, db DB, v0 string) (string, error) {
	// call pg_catalog.quote_ident
	const sqlstr = `SELECT pg_catalog.quote_ident($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// QuoteLiteral calls the stored procedure 'pg_catalog.quote_literal(text, anyelement) text' on db.
func QuoteLiteral(ctx context.Context, db DB, v0 string, v1 pgtypes.Anyelement) (string, error) {
	// call pg_catalog.quote_literal
	const sqlstr = `SELECT pg_catalog.quote_literal($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// QuoteNullable calls the stored procedure 'pg_catalog.quote_nullable(text, anyelement) text' on db.
func QuoteNullable(ctx context.Context, db DB, v0 string, v1 pgtypes.Anyelement) (string, error) {
	// call pg_catalog.quote_nullable
	const sqlstr = `SELECT pg_catalog.quote_nullable($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Radians calls the stored procedure 'pg_catalog.radians(double precision) double precision' on db.
func Radians(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.radians
	const sqlstr = `SELECT pg_catalog.radians($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Radius calls the stored procedure 'pg_catalog.radius(circle) double precision' on db.
func Radius(ctx context.Context, db DB, v0 pgtypes.Circle) (float64, error) {
	// call pg_catalog.radius
	const sqlstr = `SELECT pg_catalog.radius($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Random calls the stored procedure 'pg_catalog.random() double precision' on db.
func Random(ctx context.Context, db DB) (float64, error) {
	// call pg_catalog.random
	const sqlstr = `SELECT pg_catalog.random()`
	// run
	var ret float64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// RangeAdjacent calls the stored procedure 'pg_catalog.range_adjacent(anyrange, anyrange) boolean' on db.
func RangeAdjacent(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_adjacent
	const sqlstr = `SELECT pg_catalog.range_adjacent($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeAfter calls the stored procedure 'pg_catalog.range_after(anyrange, anyrange) boolean' on db.
func RangeAfter(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_after
	const sqlstr = `SELECT pg_catalog.range_after($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeBefore calls the stored procedure 'pg_catalog.range_before(anyrange, anyrange) boolean' on db.
func RangeBefore(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_before
	const sqlstr = `SELECT pg_catalog.range_before($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeCmp calls the stored procedure 'pg_catalog.range_cmp(anyrange, anyrange) integer' on db.
func RangeCmp(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (int, error) {
	// call pg_catalog.range_cmp
	const sqlstr = `SELECT pg_catalog.range_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// RangeContainedBy calls the stored procedure 'pg_catalog.range_contained_by(anyrange, anyrange) boolean' on db.
func RangeContainedBy(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_contained_by
	const sqlstr = `SELECT pg_catalog.range_contained_by($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeContains calls the stored procedure 'pg_catalog.range_contains(anyrange, anyrange) boolean' on db.
func RangeContains(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_contains
	const sqlstr = `SELECT pg_catalog.range_contains($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeContainsElem calls the stored procedure 'pg_catalog.range_contains_elem(anyrange, anyelement) boolean' on db.
func RangeContainsElem(ctx context.Context, db DB, v0 pgtypes.Anyrange, v1 pgtypes.Anyelement) (bool, error) {
	// call pg_catalog.range_contains_elem
	const sqlstr = `SELECT pg_catalog.range_contains_elem($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeEq calls the stored procedure 'pg_catalog.range_eq(anyrange, anyrange) boolean' on db.
func RangeEq(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_eq
	const sqlstr = `SELECT pg_catalog.range_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeGe calls the stored procedure 'pg_catalog.range_ge(anyrange, anyrange) boolean' on db.
func RangeGe(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_ge
	const sqlstr = `SELECT pg_catalog.range_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeGistConsistent calls the stored procedure 'pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal) boolean' on db.
func RangeGistConsistent(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Anyrange, v2 int16, v3 pgtypes.Oid, v4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.range_gist_consistent
	const sqlstr = `SELECT pg_catalog.range_gist_consistent($1, $2, $3, $4, $5)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeGistPenalty calls the stored procedure 'pg_catalog.range_gist_penalty(internal, internal, internal) internal' on db.
func RangeGistPenalty(ctx context.Context, db DB, v0, v1, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.range_gist_penalty
	const sqlstr = `SELECT pg_catalog.range_gist_penalty($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// RangeGistPicksplit calls the stored procedure 'pg_catalog.range_gist_picksplit(internal, internal) internal' on db.
func RangeGistPicksplit(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.range_gist_picksplit
	const sqlstr = `SELECT pg_catalog.range_gist_picksplit($1, $2)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// RangeGistSame calls the stored procedure 'pg_catalog.range_gist_same(anyrange, anyrange, internal) internal' on db.
func RangeGistSame(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange, v2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.range_gist_same
	const sqlstr = `SELECT pg_catalog.range_gist_same($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// RangeGistUnion calls the stored procedure 'pg_catalog.range_gist_union(internal, internal) anyrange' on db.
func RangeGistUnion(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_gist_union
	const sqlstr = `SELECT pg_catalog.range_gist_union($1, $2)`
	// run
	var ret pgtypes.Anyrange
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return ret, nil
}

// RangeGt calls the stored procedure 'pg_catalog.range_gt(anyrange, anyrange) boolean' on db.
func RangeGt(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_gt
	const sqlstr = `SELECT pg_catalog.range_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeIn calls the stored procedure 'pg_catalog.range_in(cstring, oid, integer) anyrange' on db.
func RangeIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_in
	const sqlstr = `SELECT pg_catalog.range_in($1, $2, $3)`
	// run
	var ret pgtypes.Anyrange
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return ret, nil
}

// RangeIntersect calls the stored procedure 'pg_catalog.range_intersect(anyrange, anyrange) anyrange' on db.
func RangeIntersect(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_intersect
	const sqlstr = `SELECT pg_catalog.range_intersect($1, $2)`
	// run
	var ret pgtypes.Anyrange
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return ret, nil
}

// RangeLe calls the stored procedure 'pg_catalog.range_le(anyrange, anyrange) boolean' on db.
func RangeLe(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_le
	const sqlstr = `SELECT pg_catalog.range_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeLt calls the stored procedure 'pg_catalog.range_lt(anyrange, anyrange) boolean' on db.
func RangeLt(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_lt
	const sqlstr = `SELECT pg_catalog.range_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeMerge calls the stored procedure 'pg_catalog.range_merge(anyrange, anyrange) anyrange' on db.
func RangeMerge(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_merge
	const sqlstr = `SELECT pg_catalog.range_merge($1, $2)`
	// run
	var ret pgtypes.Anyrange
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return ret, nil
}

// RangeMinus calls the stored procedure 'pg_catalog.range_minus(anyrange, anyrange) anyrange' on db.
func RangeMinus(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_minus
	const sqlstr = `SELECT pg_catalog.range_minus($1, $2)`
	// run
	var ret pgtypes.Anyrange
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return ret, nil
}

// RangeNe calls the stored procedure 'pg_catalog.range_ne(anyrange, anyrange) boolean' on db.
func RangeNe(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_ne
	const sqlstr = `SELECT pg_catalog.range_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeOut calls the stored procedure 'pg_catalog.range_out(anyrange) cstring' on db.
func RangeOut(ctx context.Context, db DB, v0 pgtypes.Anyrange) (pgtypes.Cstring, error) {
	// call pg_catalog.range_out
	const sqlstr = `SELECT pg_catalog.range_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// RangeOverlaps calls the stored procedure 'pg_catalog.range_overlaps(anyrange, anyrange) boolean' on db.
func RangeOverlaps(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_overlaps
	const sqlstr = `SELECT pg_catalog.range_overlaps($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeOverleft calls the stored procedure 'pg_catalog.range_overleft(anyrange, anyrange) boolean' on db.
func RangeOverleft(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_overleft
	const sqlstr = `SELECT pg_catalog.range_overleft($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeOverright calls the stored procedure 'pg_catalog.range_overright(anyrange, anyrange) boolean' on db.
func RangeOverright(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_overright
	const sqlstr = `SELECT pg_catalog.range_overright($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeRecv calls the stored procedure 'pg_catalog.range_recv(internal, oid, integer) anyrange' on db.
func RangeRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_recv
	const sqlstr = `SELECT pg_catalog.range_recv($1, $2, $3)`
	// run
	var ret pgtypes.Anyrange
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return ret, nil
}

// RangeSend calls the stored procedure 'pg_catalog.range_send(anyrange) bytea' on db.
func RangeSend(ctx context.Context, db DB, v0 pgtypes.Anyrange) ([]byte, error) {
	// call pg_catalog.range_send
	const sqlstr = `SELECT pg_catalog.range_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// RangeTypanalyze calls the stored procedure 'pg_catalog.range_typanalyze(internal) boolean' on db.
func RangeTypanalyze(ctx context.Context, db DB, v0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.range_typanalyze
	const sqlstr = `SELECT pg_catalog.range_typanalyze($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RangeUnion calls the stored procedure 'pg_catalog.range_union(anyrange, anyrange) anyrange' on db.
func RangeUnion(ctx context.Context, db DB, v0, v1 pgtypes.Anyrange) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_union
	const sqlstr = `SELECT pg_catalog.range_union($1, $2)`
	// run
	var ret pgtypes.Anyrange
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return ret, nil
}

// Rangesel calls the stored procedure 'pg_catalog.rangesel(internal, oid, internal, integer) double precision' on db.
func Rangesel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.rangesel
	const sqlstr = `SELECT pg_catalog.rangesel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Rank calls the stored procedure 'pg_catalog.rank("any") bigint' on db.
func Rank(ctx context.Context, db DB, v0 pgtypes.Any) (int64, error) {
	// call pg_catalog.rank
	const sqlstr = `SELECT pg_catalog.rank($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// RankFinal calls the stored procedure 'pg_catalog.rank_final(internal, "any") bigint' on db.
func RankFinal(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Any) (int64, error) {
	// call pg_catalog.rank_final
	const sqlstr = `SELECT pg_catalog.rank_final($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// RecordEq calls the stored procedure 'pg_catalog.record_eq(record, record) boolean' on db.
func RecordEq(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_eq
	const sqlstr = `SELECT pg_catalog.record_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordGe calls the stored procedure 'pg_catalog.record_ge(record, record) boolean' on db.
func RecordGe(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_ge
	const sqlstr = `SELECT pg_catalog.record_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordGt calls the stored procedure 'pg_catalog.record_gt(record, record) boolean' on db.
func RecordGt(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_gt
	const sqlstr = `SELECT pg_catalog.record_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordImageEq calls the stored procedure 'pg_catalog.record_image_eq(record, record) boolean' on db.
func RecordImageEq(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_eq
	const sqlstr = `SELECT pg_catalog.record_image_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordImageGe calls the stored procedure 'pg_catalog.record_image_ge(record, record) boolean' on db.
func RecordImageGe(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_ge
	const sqlstr = `SELECT pg_catalog.record_image_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordImageGt calls the stored procedure 'pg_catalog.record_image_gt(record, record) boolean' on db.
func RecordImageGt(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_gt
	const sqlstr = `SELECT pg_catalog.record_image_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordImageLe calls the stored procedure 'pg_catalog.record_image_le(record, record) boolean' on db.
func RecordImageLe(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_le
	const sqlstr = `SELECT pg_catalog.record_image_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordImageLt calls the stored procedure 'pg_catalog.record_image_lt(record, record) boolean' on db.
func RecordImageLt(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_lt
	const sqlstr = `SELECT pg_catalog.record_image_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordImageNe calls the stored procedure 'pg_catalog.record_image_ne(record, record) boolean' on db.
func RecordImageNe(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_ne
	const sqlstr = `SELECT pg_catalog.record_image_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordIn calls the stored procedure 'pg_catalog.record_in(cstring, oid, integer) record' on db.
func RecordIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (pgtypes.Record, error) {
	// call pg_catalog.record_in
	const sqlstr = `SELECT pg_catalog.record_in($1, $2, $3)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// RecordLe calls the stored procedure 'pg_catalog.record_le(record, record) boolean' on db.
func RecordLe(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_le
	const sqlstr = `SELECT pg_catalog.record_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordLt calls the stored procedure 'pg_catalog.record_lt(record, record) boolean' on db.
func RecordLt(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_lt
	const sqlstr = `SELECT pg_catalog.record_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordNe calls the stored procedure 'pg_catalog.record_ne(record, record) boolean' on db.
func RecordNe(ctx context.Context, db DB, v0, v1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_ne
	const sqlstr = `SELECT pg_catalog.record_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RecordOut calls the stored procedure 'pg_catalog.record_out(record) cstring' on db.
func RecordOut(ctx context.Context, db DB, v0 pgtypes.Record) (pgtypes.Cstring, error) {
	// call pg_catalog.record_out
	const sqlstr = `SELECT pg_catalog.record_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// RecordRecv calls the stored procedure 'pg_catalog.record_recv(internal, oid, integer) record' on db.
func RecordRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (pgtypes.Record, error) {
	// call pg_catalog.record_recv
	const sqlstr = `SELECT pg_catalog.record_recv($1, $2, $3)`
	// run
	var ret pgtypes.Record
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return ret, nil
}

// RecordSend calls the stored procedure 'pg_catalog.record_send(record) bytea' on db.
func RecordSend(ctx context.Context, db DB, v0 pgtypes.Record) ([]byte, error) {
	// call pg_catalog.record_send
	const sqlstr = `SELECT pg_catalog.record_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Regclass calls the stored procedure 'pg_catalog.regclass(text) regclass' on db.
func Regclass(ctx context.Context, db DB, v0 string) (pgtypes.Regclass, error) {
	// call pg_catalog.regclass
	const sqlstr = `SELECT pg_catalog.regclass($1)`
	// run
	var ret pgtypes.Regclass
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return ret, nil
}

// Regclassin calls the stored procedure 'pg_catalog.regclassin(cstring) regclass' on db.
func Regclassin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Regclass, error) {
	// call pg_catalog.regclassin
	const sqlstr = `SELECT pg_catalog.regclassin($1)`
	// run
	var ret pgtypes.Regclass
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return ret, nil
}

// Regclassout calls the stored procedure 'pg_catalog.regclassout(regclass) cstring' on db.
func Regclassout(ctx context.Context, db DB, v0 pgtypes.Regclass) (pgtypes.Cstring, error) {
	// call pg_catalog.regclassout
	const sqlstr = `SELECT pg_catalog.regclassout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Regclassrecv calls the stored procedure 'pg_catalog.regclassrecv(internal) regclass' on db.
func Regclassrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Regclass, error) {
	// call pg_catalog.regclassrecv
	const sqlstr = `SELECT pg_catalog.regclassrecv($1)`
	// run
	var ret pgtypes.Regclass
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return ret, nil
}

// Regclasssend calls the stored procedure 'pg_catalog.regclasssend(regclass) bytea' on db.
func Regclasssend(ctx context.Context, db DB, v0 pgtypes.Regclass) ([]byte, error) {
	// call pg_catalog.regclasssend
	const sqlstr = `SELECT pg_catalog.regclasssend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Regcollationin calls the stored procedure 'pg_catalog.regcollationin(cstring) regcollation' on db.
func Regcollationin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Regcollation, error) {
	// call pg_catalog.regcollationin
	const sqlstr = `SELECT pg_catalog.regcollationin($1)`
	// run
	var ret pgtypes.Regcollation
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regcollation{}, logerror(err)
	}
	return ret, nil
}

// Regcollationout calls the stored procedure 'pg_catalog.regcollationout(regcollation) cstring' on db.
func Regcollationout(ctx context.Context, db DB, v0 pgtypes.Regcollation) (pgtypes.Cstring, error) {
	// call pg_catalog.regcollationout
	const sqlstr = `SELECT pg_catalog.regcollationout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Regcollationrecv calls the stored procedure 'pg_catalog.regcollationrecv(internal) regcollation' on db.
func Regcollationrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Regcollation, error) {
	// call pg_catalog.regcollationrecv
	const sqlstr = `SELECT pg_catalog.regcollationrecv($1)`
	// run
	var ret pgtypes.Regcollation
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regcollation{}, logerror(err)
	}
	return ret, nil
}

// Regcollationsend calls the stored procedure 'pg_catalog.regcollationsend(regcollation) bytea' on db.
func Regcollationsend(ctx context.Context, db DB, v0 pgtypes.Regcollation) ([]byte, error) {
	// call pg_catalog.regcollationsend
	const sqlstr = `SELECT pg_catalog.regcollationsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Regconfigin calls the stored procedure 'pg_catalog.regconfigin(cstring) regconfig' on db.
func Regconfigin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Regconfig, error) {
	// call pg_catalog.regconfigin
	const sqlstr = `SELECT pg_catalog.regconfigin($1)`
	// run
	var ret pgtypes.Regconfig
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regconfig{}, logerror(err)
	}
	return ret, nil
}

// Regconfigout calls the stored procedure 'pg_catalog.regconfigout(regconfig) cstring' on db.
func Regconfigout(ctx context.Context, db DB, v0 pgtypes.Regconfig) (pgtypes.Cstring, error) {
	// call pg_catalog.regconfigout
	const sqlstr = `SELECT pg_catalog.regconfigout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Regconfigrecv calls the stored procedure 'pg_catalog.regconfigrecv(internal) regconfig' on db.
func Regconfigrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Regconfig, error) {
	// call pg_catalog.regconfigrecv
	const sqlstr = `SELECT pg_catalog.regconfigrecv($1)`
	// run
	var ret pgtypes.Regconfig
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regconfig{}, logerror(err)
	}
	return ret, nil
}

// Regconfigsend calls the stored procedure 'pg_catalog.regconfigsend(regconfig) bytea' on db.
func Regconfigsend(ctx context.Context, db DB, v0 pgtypes.Regconfig) ([]byte, error) {
	// call pg_catalog.regconfigsend
	const sqlstr = `SELECT pg_catalog.regconfigsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Regdictionaryin calls the stored procedure 'pg_catalog.regdictionaryin(cstring) regdictionary' on db.
func Regdictionaryin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Regdictionary, error) {
	// call pg_catalog.regdictionaryin
	const sqlstr = `SELECT pg_catalog.regdictionaryin($1)`
	// run
	var ret pgtypes.Regdictionary
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regdictionary{}, logerror(err)
	}
	return ret, nil
}

// Regdictionaryout calls the stored procedure 'pg_catalog.regdictionaryout(regdictionary) cstring' on db.
func Regdictionaryout(ctx context.Context, db DB, v0 pgtypes.Regdictionary) (pgtypes.Cstring, error) {
	// call pg_catalog.regdictionaryout
	const sqlstr = `SELECT pg_catalog.regdictionaryout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Regdictionaryrecv calls the stored procedure 'pg_catalog.regdictionaryrecv(internal) regdictionary' on db.
func Regdictionaryrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Regdictionary, error) {
	// call pg_catalog.regdictionaryrecv
	const sqlstr = `SELECT pg_catalog.regdictionaryrecv($1)`
	// run
	var ret pgtypes.Regdictionary
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regdictionary{}, logerror(err)
	}
	return ret, nil
}

// Regdictionarysend calls the stored procedure 'pg_catalog.regdictionarysend(regdictionary) bytea' on db.
func Regdictionarysend(ctx context.Context, db DB, v0 pgtypes.Regdictionary) ([]byte, error) {
	// call pg_catalog.regdictionarysend
	const sqlstr = `SELECT pg_catalog.regdictionarysend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Regexeqjoinsel calls the stored procedure 'pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Regexeqjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.regexeqjoinsel
	const sqlstr = `SELECT pg_catalog.regexeqjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Regexeqsel calls the stored procedure 'pg_catalog.regexeqsel(internal, oid, internal, integer) double precision' on db.
func Regexeqsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.regexeqsel
	const sqlstr = `SELECT pg_catalog.regexeqsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Regexnejoinsel calls the stored procedure 'pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Regexnejoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.regexnejoinsel
	const sqlstr = `SELECT pg_catalog.regexnejoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Regexnesel calls the stored procedure 'pg_catalog.regexnesel(internal, oid, internal, integer) double precision' on db.
func Regexnesel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.regexnesel
	const sqlstr = `SELECT pg_catalog.regexnesel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// RegexpMatch calls the stored procedure 'pg_catalog.regexp_match(text, text, text, text, text) text[]' on db.
func RegexpMatch(ctx context.Context, db DB, v0, v1, v2, v3, v4 string) (StringSlice, error) {
	// call pg_catalog.regexp_match
	const sqlstr = `SELECT pg_catalog.regexp_match($1, $2, $3, $4, $5)`
	// run
	var ret StringSlice
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return StringSlice{}, logerror(err)
	}
	return ret, nil
}

// RegexpMatches calls the stored procedure 'pg_catalog.regexp_matches(text, text, text, text, text) SETOF text[]' on db.
func RegexpMatches(ctx context.Context, db DB, v0, v1, v2, v3, v4 string) ([]StringSlice, error) {
	// call pg_catalog.regexp_matches
	const sqlstr = `SELECT pg_catalog.regexp_matches($1, $2, $3, $4, $5)`
	// run
	var ret []StringSlice
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// RegexpReplace calls the stored procedure 'pg_catalog.regexp_replace(text, text, text, text, text, text, text) text' on db.
func RegexpReplace(ctx context.Context, db DB, v0, v1, v2, v3, v4, v5, v6 string) (string, error) {
	// call pg_catalog.regexp_replace
	const sqlstr = `SELECT pg_catalog.regexp_replace($1, $2, $3, $4, $5, $6, $7)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// RegexpSplitToArray calls the stored procedure 'pg_catalog.regexp_split_to_array(text, text, text, text, text) text[]' on db.
func RegexpSplitToArray(ctx context.Context, db DB, v0, v1, v2, v3, v4 string) (StringSlice, error) {
	// call pg_catalog.regexp_split_to_array
	const sqlstr = `SELECT pg_catalog.regexp_split_to_array($1, $2, $3, $4, $5)`
	// run
	var ret StringSlice
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return StringSlice{}, logerror(err)
	}
	return ret, nil
}

// RegexpSplitToTable calls the stored procedure 'pg_catalog.regexp_split_to_table(text, text, text, text, text) SETOF text' on db.
func RegexpSplitToTable(ctx context.Context, db DB, v0, v1, v2, v3, v4 string) ([]string, error) {
	// call pg_catalog.regexp_split_to_table
	const sqlstr = `SELECT pg_catalog.regexp_split_to_table($1, $2, $3, $4, $5)`
	// run
	var ret []string
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Regnamespacein calls the stored procedure 'pg_catalog.regnamespacein(cstring) regnamespace' on db.
func Regnamespacein(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Regnamespace, error) {
	// call pg_catalog.regnamespacein
	const sqlstr = `SELECT pg_catalog.regnamespacein($1)`
	// run
	var ret pgtypes.Regnamespace
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regnamespace{}, logerror(err)
	}
	return ret, nil
}

// Regnamespaceout calls the stored procedure 'pg_catalog.regnamespaceout(regnamespace) cstring' on db.
func Regnamespaceout(ctx context.Context, db DB, v0 pgtypes.Regnamespace) (pgtypes.Cstring, error) {
	// call pg_catalog.regnamespaceout
	const sqlstr = `SELECT pg_catalog.regnamespaceout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Regnamespacerecv calls the stored procedure 'pg_catalog.regnamespacerecv(internal) regnamespace' on db.
func Regnamespacerecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Regnamespace, error) {
	// call pg_catalog.regnamespacerecv
	const sqlstr = `SELECT pg_catalog.regnamespacerecv($1)`
	// run
	var ret pgtypes.Regnamespace
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regnamespace{}, logerror(err)
	}
	return ret, nil
}

// Regnamespacesend calls the stored procedure 'pg_catalog.regnamespacesend(regnamespace) bytea' on db.
func Regnamespacesend(ctx context.Context, db DB, v0 pgtypes.Regnamespace) ([]byte, error) {
	// call pg_catalog.regnamespacesend
	const sqlstr = `SELECT pg_catalog.regnamespacesend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Regoperatorin calls the stored procedure 'pg_catalog.regoperatorin(cstring) regoperator' on db.
func Regoperatorin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Regoperator, error) {
	// call pg_catalog.regoperatorin
	const sqlstr = `SELECT pg_catalog.regoperatorin($1)`
	// run
	var ret pgtypes.Regoperator
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regoperator{}, logerror(err)
	}
	return ret, nil
}

// Regoperatorout calls the stored procedure 'pg_catalog.regoperatorout(regoperator) cstring' on db.
func Regoperatorout(ctx context.Context, db DB, v0 pgtypes.Regoperator) (pgtypes.Cstring, error) {
	// call pg_catalog.regoperatorout
	const sqlstr = `SELECT pg_catalog.regoperatorout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Regoperatorrecv calls the stored procedure 'pg_catalog.regoperatorrecv(internal) regoperator' on db.
func Regoperatorrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Regoperator, error) {
	// call pg_catalog.regoperatorrecv
	const sqlstr = `SELECT pg_catalog.regoperatorrecv($1)`
	// run
	var ret pgtypes.Regoperator
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regoperator{}, logerror(err)
	}
	return ret, nil
}

// Regoperatorsend calls the stored procedure 'pg_catalog.regoperatorsend(regoperator) bytea' on db.
func Regoperatorsend(ctx context.Context, db DB, v0 pgtypes.Regoperator) ([]byte, error) {
	// call pg_catalog.regoperatorsend
	const sqlstr = `SELECT pg_catalog.regoperatorsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Regoperin calls the stored procedure 'pg_catalog.regoperin(cstring) regoper' on db.
func Regoperin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Regoper, error) {
	// call pg_catalog.regoperin
	const sqlstr = `SELECT pg_catalog.regoperin($1)`
	// run
	var ret pgtypes.Regoper
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regoper{}, logerror(err)
	}
	return ret, nil
}

// Regoperout calls the stored procedure 'pg_catalog.regoperout(regoper) cstring' on db.
func Regoperout(ctx context.Context, db DB, v0 pgtypes.Regoper) (pgtypes.Cstring, error) {
	// call pg_catalog.regoperout
	const sqlstr = `SELECT pg_catalog.regoperout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Regoperrecv calls the stored procedure 'pg_catalog.regoperrecv(internal) regoper' on db.
func Regoperrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Regoper, error) {
	// call pg_catalog.regoperrecv
	const sqlstr = `SELECT pg_catalog.regoperrecv($1)`
	// run
	var ret pgtypes.Regoper
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regoper{}, logerror(err)
	}
	return ret, nil
}

// Regopersend calls the stored procedure 'pg_catalog.regopersend(regoper) bytea' on db.
func Regopersend(ctx context.Context, db DB, v0 pgtypes.Regoper) ([]byte, error) {
	// call pg_catalog.regopersend
	const sqlstr = `SELECT pg_catalog.regopersend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Regprocedurein calls the stored procedure 'pg_catalog.regprocedurein(cstring) regprocedure' on db.
func Regprocedurein(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Regprocedure, error) {
	// call pg_catalog.regprocedurein
	const sqlstr = `SELECT pg_catalog.regprocedurein($1)`
	// run
	var ret pgtypes.Regprocedure
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regprocedure{}, logerror(err)
	}
	return ret, nil
}

// Regprocedureout calls the stored procedure 'pg_catalog.regprocedureout(regprocedure) cstring' on db.
func Regprocedureout(ctx context.Context, db DB, v0 pgtypes.Regprocedure) (pgtypes.Cstring, error) {
	// call pg_catalog.regprocedureout
	const sqlstr = `SELECT pg_catalog.regprocedureout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Regprocedurerecv calls the stored procedure 'pg_catalog.regprocedurerecv(internal) regprocedure' on db.
func Regprocedurerecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Regprocedure, error) {
	// call pg_catalog.regprocedurerecv
	const sqlstr = `SELECT pg_catalog.regprocedurerecv($1)`
	// run
	var ret pgtypes.Regprocedure
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regprocedure{}, logerror(err)
	}
	return ret, nil
}

// Regproceduresend calls the stored procedure 'pg_catalog.regproceduresend(regprocedure) bytea' on db.
func Regproceduresend(ctx context.Context, db DB, v0 pgtypes.Regprocedure) ([]byte, error) {
	// call pg_catalog.regproceduresend
	const sqlstr = `SELECT pg_catalog.regproceduresend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Regprocin calls the stored procedure 'pg_catalog.regprocin(cstring) regproc' on db.
func Regprocin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Regproc, error) {
	// call pg_catalog.regprocin
	const sqlstr = `SELECT pg_catalog.regprocin($1)`
	// run
	var ret pgtypes.Regproc
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regproc{}, logerror(err)
	}
	return ret, nil
}

// Regprocout calls the stored procedure 'pg_catalog.regprocout(regproc) cstring' on db.
func Regprocout(ctx context.Context, db DB, v0 pgtypes.Regproc) (pgtypes.Cstring, error) {
	// call pg_catalog.regprocout
	const sqlstr = `SELECT pg_catalog.regprocout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Regprocrecv calls the stored procedure 'pg_catalog.regprocrecv(internal) regproc' on db.
func Regprocrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Regproc, error) {
	// call pg_catalog.regprocrecv
	const sqlstr = `SELECT pg_catalog.regprocrecv($1)`
	// run
	var ret pgtypes.Regproc
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regproc{}, logerror(err)
	}
	return ret, nil
}

// Regprocsend calls the stored procedure 'pg_catalog.regprocsend(regproc) bytea' on db.
func Regprocsend(ctx context.Context, db DB, v0 pgtypes.Regproc) ([]byte, error) {
	// call pg_catalog.regprocsend
	const sqlstr = `SELECT pg_catalog.regprocsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// RegrAvgx calls the stored procedure 'pg_catalog.regr_avgx(double precision, double precision) double precision' on db.
func RegrAvgx(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.regr_avgx
	const sqlstr = `SELECT pg_catalog.regr_avgx($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// RegrAvgy calls the stored procedure 'pg_catalog.regr_avgy(double precision, double precision) double precision' on db.
func RegrAvgy(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.regr_avgy
	const sqlstr = `SELECT pg_catalog.regr_avgy($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// RegrCount calls the stored procedure 'pg_catalog.regr_count(double precision, double precision) bigint' on db.
func RegrCount(ctx context.Context, db DB, v0, v1 float64) (int64, error) {
	// call pg_catalog.regr_count
	const sqlstr = `SELECT pg_catalog.regr_count($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// RegrIntercept calls the stored procedure 'pg_catalog.regr_intercept(double precision, double precision) double precision' on db.
func RegrIntercept(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.regr_intercept
	const sqlstr = `SELECT pg_catalog.regr_intercept($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// RegrR2 calls the stored procedure 'pg_catalog.regr_r2(double precision, double precision) double precision' on db.
func RegrR2(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.regr_r2
	const sqlstr = `SELECT pg_catalog.regr_r2($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// RegrSlope calls the stored procedure 'pg_catalog.regr_slope(double precision, double precision) double precision' on db.
func RegrSlope(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.regr_slope
	const sqlstr = `SELECT pg_catalog.regr_slope($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// RegrSxx calls the stored procedure 'pg_catalog.regr_sxx(double precision, double precision) double precision' on db.
func RegrSxx(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.regr_sxx
	const sqlstr = `SELECT pg_catalog.regr_sxx($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// RegrSxy calls the stored procedure 'pg_catalog.regr_sxy(double precision, double precision) double precision' on db.
func RegrSxy(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.regr_sxy
	const sqlstr = `SELECT pg_catalog.regr_sxy($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// RegrSyy calls the stored procedure 'pg_catalog.regr_syy(double precision, double precision) double precision' on db.
func RegrSyy(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.regr_syy
	const sqlstr = `SELECT pg_catalog.regr_syy($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Regrolein calls the stored procedure 'pg_catalog.regrolein(cstring) regrole' on db.
func Regrolein(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Regrole, error) {
	// call pg_catalog.regrolein
	const sqlstr = `SELECT pg_catalog.regrolein($1)`
	// run
	var ret pgtypes.Regrole
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regrole{}, logerror(err)
	}
	return ret, nil
}

// Regroleout calls the stored procedure 'pg_catalog.regroleout(regrole) cstring' on db.
func Regroleout(ctx context.Context, db DB, v0 pgtypes.Regrole) (pgtypes.Cstring, error) {
	// call pg_catalog.regroleout
	const sqlstr = `SELECT pg_catalog.regroleout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Regrolerecv calls the stored procedure 'pg_catalog.regrolerecv(internal) regrole' on db.
func Regrolerecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Regrole, error) {
	// call pg_catalog.regrolerecv
	const sqlstr = `SELECT pg_catalog.regrolerecv($1)`
	// run
	var ret pgtypes.Regrole
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regrole{}, logerror(err)
	}
	return ret, nil
}

// Regrolesend calls the stored procedure 'pg_catalog.regrolesend(regrole) bytea' on db.
func Regrolesend(ctx context.Context, db DB, v0 pgtypes.Regrole) ([]byte, error) {
	// call pg_catalog.regrolesend
	const sqlstr = `SELECT pg_catalog.regrolesend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Regtypein calls the stored procedure 'pg_catalog.regtypein(cstring) regtype' on db.
func Regtypein(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Regtype, error) {
	// call pg_catalog.regtypein
	const sqlstr = `SELECT pg_catalog.regtypein($1)`
	// run
	var ret pgtypes.Regtype
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regtype{}, logerror(err)
	}
	return ret, nil
}

// Regtypeout calls the stored procedure 'pg_catalog.regtypeout(regtype) cstring' on db.
func Regtypeout(ctx context.Context, db DB, v0 pgtypes.Regtype) (pgtypes.Cstring, error) {
	// call pg_catalog.regtypeout
	const sqlstr = `SELECT pg_catalog.regtypeout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Regtyperecv calls the stored procedure 'pg_catalog.regtyperecv(internal) regtype' on db.
func Regtyperecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Regtype, error) {
	// call pg_catalog.regtyperecv
	const sqlstr = `SELECT pg_catalog.regtyperecv($1)`
	// run
	var ret pgtypes.Regtype
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regtype{}, logerror(err)
	}
	return ret, nil
}

// Regtypesend calls the stored procedure 'pg_catalog.regtypesend(regtype) bytea' on db.
func Regtypesend(ctx context.Context, db DB, v0 pgtypes.Regtype) ([]byte, error) {
	// call pg_catalog.regtypesend
	const sqlstr = `SELECT pg_catalog.regtypesend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Repeat calls the stored procedure 'pg_catalog.repeat(text, integer) text' on db.
func Repeat(ctx context.Context, db DB, v0 string, v1 int) (string, error) {
	// call pg_catalog.repeat
	const sqlstr = `SELECT pg_catalog.repeat($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Replace calls the stored procedure 'pg_catalog.replace(text, text, text) text' on db.
func Replace(ctx context.Context, db DB, v0, v1, v2 string) (string, error) {
	// call pg_catalog.replace
	const sqlstr = `SELECT pg_catalog.replace($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Reverse calls the stored procedure 'pg_catalog.reverse(text) text' on db.
func Reverse(ctx context.Context, db DB, v0 string) (string, error) {
	// call pg_catalog.reverse
	const sqlstr = `SELECT pg_catalog.reverse($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Right calls the stored procedure 'pg_catalog.right(text, integer) text' on db.
func Right(ctx context.Context, db DB, v0 string, v1 int) (string, error) {
	// call pg_catalog.right
	const sqlstr = `SELECT pg_catalog.right($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Round calls the stored procedure 'pg_catalog.round(double precision, numeric, numeric, integer) numeric' on db.
func Round(ctx context.Context, db DB, v0, v1, v2 float64, v3 int) (float64, error) {
	// call pg_catalog.round
	const sqlstr = `SELECT pg_catalog.round($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// RowNumber calls the stored procedure 'pg_catalog.row_number() bigint' on db.
func RowNumber(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.row_number
	const sqlstr = `SELECT pg_catalog.row_number()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// RowSecurityActive calls the stored procedure 'pg_catalog.row_security_active(text, oid) boolean' on db.
func RowSecurityActive(ctx context.Context, db DB, v0 string, v1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.row_security_active
	const sqlstr = `SELECT pg_catalog.row_security_active($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// RowToJSON calls the stored procedure 'pg_catalog.row_to_json(record, record, boolean) json' on db.
func RowToJSON(ctx context.Context, db DB, v0, v1 pgtypes.Record, v2 bool) ([]byte, error) {
	// call pg_catalog.row_to_json
	const sqlstr = `SELECT pg_catalog.row_to_json($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Rpad calls the stored procedure 'pg_catalog.rpad(text, integer, text, integer, text) text' on db.
func Rpad(ctx context.Context, db DB, v0 string, v1 int, v2 string, v3 int, v4 string) (string, error) {
	// call pg_catalog.rpad
	const sqlstr = `SELECT pg_catalog.rpad($1, $2, $3, $4, $5)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Rtrim calls the stored procedure 'pg_catalog.rtrim(text, text, text) text' on db.
func Rtrim(ctx context.Context, db DB, v0, v1, v2 string) (string, error) {
	// call pg_catalog.rtrim
	const sqlstr = `SELECT pg_catalog.rtrim($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// SatisfiesHashPartition calls the stored procedure 'pg_catalog.satisfies_hash_partition(oid, integer, integer, "any") boolean' on db.
func SatisfiesHashPartition(ctx context.Context, db DB, v0 pgtypes.Oid, v1, v2 int, v3 pgtypes.Any) (bool, error) {
	// call pg_catalog.satisfies_hash_partition
	const sqlstr = `SELECT pg_catalog.satisfies_hash_partition($1, $2, $3, $4)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Scalargejoinsel calls the stored procedure 'pg_catalog.scalargejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Scalargejoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.scalargejoinsel
	const sqlstr = `SELECT pg_catalog.scalargejoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Scalargesel calls the stored procedure 'pg_catalog.scalargesel(internal, oid, internal, integer) double precision' on db.
func Scalargesel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.scalargesel
	const sqlstr = `SELECT pg_catalog.scalargesel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Scalargtjoinsel calls the stored procedure 'pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Scalargtjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.scalargtjoinsel
	const sqlstr = `SELECT pg_catalog.scalargtjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Scalargtsel calls the stored procedure 'pg_catalog.scalargtsel(internal, oid, internal, integer) double precision' on db.
func Scalargtsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.scalargtsel
	const sqlstr = `SELECT pg_catalog.scalargtsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Scalarlejoinsel calls the stored procedure 'pg_catalog.scalarlejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Scalarlejoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.scalarlejoinsel
	const sqlstr = `SELECT pg_catalog.scalarlejoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Scalarlesel calls the stored procedure 'pg_catalog.scalarlesel(internal, oid, internal, integer) double precision' on db.
func Scalarlesel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.scalarlesel
	const sqlstr = `SELECT pg_catalog.scalarlesel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Scalarltjoinsel calls the stored procedure 'pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Scalarltjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.scalarltjoinsel
	const sqlstr = `SELECT pg_catalog.scalarltjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Scalarltsel calls the stored procedure 'pg_catalog.scalarltsel(internal, oid, internal, integer) double precision' on db.
func Scalarltsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.scalarltsel
	const sqlstr = `SELECT pg_catalog.scalarltsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Scale calls the stored procedure 'pg_catalog.scale(numeric) integer' on db.
func Scale(ctx context.Context, db DB, v0 float64) (int, error) {
	// call pg_catalog.scale
	const sqlstr = `SELECT pg_catalog.scale($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// SchemaToXML calls the stored procedure 'pg_catalog.schema_to_xml(name, boolean, boolean, text) xml' on db.
func SchemaToXML(ctx context.Context, db DB, v0 pgtypes.Name, v1, v2 bool, v3 string) ([]byte, error) {
	// call pg_catalog.schema_to_xml
	const sqlstr = `SELECT pg_catalog.schema_to_xml($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// SchemaToXMLAndXmlschema calls the stored procedure 'pg_catalog.schema_to_xml_and_xmlschema(name, boolean, boolean, text) xml' on db.
func SchemaToXMLAndXmlschema(ctx context.Context, db DB, v0 pgtypes.Name, v1, v2 bool, v3 string) ([]byte, error) {
	// call pg_catalog.schema_to_xml_and_xmlschema
	const sqlstr = `SELECT pg_catalog.schema_to_xml_and_xmlschema($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// SchemaToXmlschema calls the stored procedure 'pg_catalog.schema_to_xmlschema(name, boolean, boolean, text) xml' on db.
func SchemaToXmlschema(ctx context.Context, db DB, v0 pgtypes.Name, v1, v2 bool, v3 string) ([]byte, error) {
	// call pg_catalog.schema_to_xmlschema
	const sqlstr = `SELECT pg_catalog.schema_to_xmlschema($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// SessionUser calls the stored procedure 'pg_catalog.session_user() name' on db.
func SessionUser(ctx context.Context, db DB) (pgtypes.Name, error) {
	// call pg_catalog.session_user
	const sqlstr = `SELECT pg_catalog.session_user()`
	// run
	var ret pgtypes.Name
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.Name{}, logerror(err)
	}
	return ret, nil
}

// SetBit calls the stored procedure 'pg_catalog.set_bit(bytea, bigint, integer, bit, integer, integer) bit' on db.
func SetBit(ctx context.Context, db DB, v0 []byte, v1 int64, v2 int, v3 uint8, v4, v5 int) (uint8, error) {
	// call pg_catalog.set_bit
	const sqlstr = `SELECT pg_catalog.set_bit($1, $2, $3, $4, $5, $6)`
	// run
	var ret uint8
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// SetByte calls the stored procedure 'pg_catalog.set_byte(bytea, integer, integer) bytea' on db.
func SetByte(ctx context.Context, db DB, v0 []byte, v1, v2 int) ([]byte, error) {
	// call pg_catalog.set_byte
	const sqlstr = `SELECT pg_catalog.set_byte($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// SetConfig calls the stored procedure 'pg_catalog.set_config(text, text, boolean) text' on db.
func SetConfig(ctx context.Context, db DB, v0, v1 string, v2 bool) (string, error) {
	// call pg_catalog.set_config
	const sqlstr = `SELECT pg_catalog.set_config($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// SetMasklen calls the stored procedure 'pg_catalog.set_masklen(cidr, integer, inet, integer) cidr' on db.
func SetMasklen(ctx context.Context, db DB, v0 pgtypes.Cidr, v1 int, v2 string, v3 int) (pgtypes.Cidr, error) {
	// call pg_catalog.set_masklen
	const sqlstr = `SELECT pg_catalog.set_masklen($1, $2, $3, $4)`
	// run
	var ret pgtypes.Cidr
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return pgtypes.Cidr{}, logerror(err)
	}
	return ret, nil
}

// Setseed calls the stored procedure 'pg_catalog.setseed(double precision) void' on db.
func Setseed(ctx context.Context, db DB, v0 float64) error {
	// call pg_catalog.setseed
	const sqlstr = `SELECT pg_catalog.setseed($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Setval calls the stored procedure 'pg_catalog.setval(regclass, bigint, regclass, bigint, boolean) bigint' on db.
func Setval(ctx context.Context, db DB, v0 pgtypes.Regclass, v1 int64, v2 pgtypes.Regclass, v3 int64, v4 bool) (int64, error) {
	// call pg_catalog.setval
	const sqlstr = `SELECT pg_catalog.setval($1, $2, $3, $4, $5)`
	// run
	var ret int64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Setweight calls the stored procedure 'pg_catalog.setweight(tsvector, "char", tsvector, "char", text[]) tsvector' on db.
func Setweight(ctx context.Context, db DB, v0 pgtypes.Tsvector, v1 pgtypes.Char, v2 pgtypes.Tsvector, v3 pgtypes.Char, v4 StringSlice) (pgtypes.Tsvector, error) {
	// call pg_catalog.setweight
	const sqlstr = `SELECT pg_catalog.setweight($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Tsvector
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return ret, nil
}

// Sha224 calls the stored procedure 'pg_catalog.sha224(bytea) bytea' on db.
func Sha224(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.sha224
	const sqlstr = `SELECT pg_catalog.sha224($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Sha256 calls the stored procedure 'pg_catalog.sha256(bytea) bytea' on db.
func Sha256(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.sha256
	const sqlstr = `SELECT pg_catalog.sha256($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Sha384 calls the stored procedure 'pg_catalog.sha384(bytea) bytea' on db.
func Sha384(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.sha384
	const sqlstr = `SELECT pg_catalog.sha384($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Sha512 calls the stored procedure 'pg_catalog.sha512(bytea) bytea' on db.
func Sha512(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.sha512
	const sqlstr = `SELECT pg_catalog.sha512($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// ShellIn calls the stored procedure 'pg_catalog.shell_in(cstring) void' on db.
func ShellIn(ctx context.Context, db DB, v0 pgtypes.Cstring) error {
	// call pg_catalog.shell_in
	const sqlstr = `SELECT pg_catalog.shell_in($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// ShellOut calls the stored procedure 'pg_catalog.shell_out(void) cstring' on db.
func ShellOut(ctx context.Context, db DB, v0 pgtypes.Void) (pgtypes.Cstring, error) {
	// call pg_catalog.shell_out
	const sqlstr = `SELECT pg_catalog.shell_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// ShiftJis2004ToEucJis2004 calls the stored procedure 'pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer) void' on db.
func ShiftJis2004ToEucJis2004(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.shift_jis_2004_to_euc_jis_2004
	const sqlstr = `SELECT pg_catalog.shift_jis_2004_to_euc_jis_2004($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// ShiftJis2004ToUTF8 calls the stored procedure 'pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func ShiftJis2004ToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.shift_jis_2004_to_utf8
	const sqlstr = `SELECT pg_catalog.shift_jis_2004_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// ShobjDescription calls the stored procedure 'pg_catalog.shobj_description(oid, name) text' on db.
func ShobjDescription(ctx context.Context, db DB, v0 pgtypes.Oid, v1 pgtypes.Name) (string, error) {
	// call pg_catalog.shobj_description
	const sqlstr = `SELECT pg_catalog.shobj_description($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Sign calls the stored procedure 'pg_catalog.sign(double precision, numeric) numeric' on db.
func Sign(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.sign
	const sqlstr = `SELECT pg_catalog.sign($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// SimilarEscape calls the stored procedure 'pg_catalog.similar_escape(text, text) text' on db.
func SimilarEscape(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.similar_escape
	const sqlstr = `SELECT pg_catalog.similar_escape($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// SimilarToEscape calls the stored procedure 'pg_catalog.similar_to_escape(text, text, text) text' on db.
func SimilarToEscape(ctx context.Context, db DB, v0, v1, v2 string) (string, error) {
	// call pg_catalog.similar_to_escape
	const sqlstr = `SELECT pg_catalog.similar_to_escape($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Sin calls the stored procedure 'pg_catalog.sin(double precision) double precision' on db.
func Sin(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.sin
	const sqlstr = `SELECT pg_catalog.sin($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Sind calls the stored procedure 'pg_catalog.sind(double precision) double precision' on db.
func Sind(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.sind
	const sqlstr = `SELECT pg_catalog.sind($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Sinh calls the stored procedure 'pg_catalog.sinh(double precision) double precision' on db.
func Sinh(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.sinh
	const sqlstr = `SELECT pg_catalog.sinh($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// SjisToEucJp calls the stored procedure 'pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer) void' on db.
func SjisToEucJp(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.sjis_to_euc_jp
	const sqlstr = `SELECT pg_catalog.sjis_to_euc_jp($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SjisToMic calls the stored procedure 'pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer) void' on db.
func SjisToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.sjis_to_mic
	const sqlstr = `SELECT pg_catalog.sjis_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SjisToUTF8 calls the stored procedure 'pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func SjisToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.sjis_to_utf8
	const sqlstr = `SELECT pg_catalog.sjis_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Slope calls the stored procedure 'pg_catalog.slope(point, point) double precision' on db.
func Slope(ctx context.Context, db DB, v0, v1 pgtypes.Point) (float64, error) {
	// call pg_catalog.slope
	const sqlstr = `SELECT pg_catalog.slope($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// SpgBboxQuadConfig calls the stored procedure 'pg_catalog.spg_bbox_quad_config(internal, internal) void' on db.
func SpgBboxQuadConfig(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_bbox_quad_config
	const sqlstr = `SELECT pg_catalog.spg_bbox_quad_config($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgBoxQuadChoose calls the stored procedure 'pg_catalog.spg_box_quad_choose(internal, internal) void' on db.
func SpgBoxQuadChoose(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_box_quad_choose
	const sqlstr = `SELECT pg_catalog.spg_box_quad_choose($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgBoxQuadConfig calls the stored procedure 'pg_catalog.spg_box_quad_config(internal, internal) void' on db.
func SpgBoxQuadConfig(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_box_quad_config
	const sqlstr = `SELECT pg_catalog.spg_box_quad_config($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgBoxQuadInnerConsistent calls the stored procedure 'pg_catalog.spg_box_quad_inner_consistent(internal, internal) void' on db.
func SpgBoxQuadInnerConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_box_quad_inner_consistent
	const sqlstr = `SELECT pg_catalog.spg_box_quad_inner_consistent($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgBoxQuadLeafConsistent calls the stored procedure 'pg_catalog.spg_box_quad_leaf_consistent(internal, internal) boolean' on db.
func SpgBoxQuadLeafConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (bool, error) {
	// call pg_catalog.spg_box_quad_leaf_consistent
	const sqlstr = `SELECT pg_catalog.spg_box_quad_leaf_consistent($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// SpgBoxQuadPicksplit calls the stored procedure 'pg_catalog.spg_box_quad_picksplit(internal, internal) void' on db.
func SpgBoxQuadPicksplit(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_box_quad_picksplit
	const sqlstr = `SELECT pg_catalog.spg_box_quad_picksplit($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgKdChoose calls the stored procedure 'pg_catalog.spg_kd_choose(internal, internal) void' on db.
func SpgKdChoose(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_kd_choose
	const sqlstr = `SELECT pg_catalog.spg_kd_choose($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgKdConfig calls the stored procedure 'pg_catalog.spg_kd_config(internal, internal) void' on db.
func SpgKdConfig(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_kd_config
	const sqlstr = `SELECT pg_catalog.spg_kd_config($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgKdInnerConsistent calls the stored procedure 'pg_catalog.spg_kd_inner_consistent(internal, internal) void' on db.
func SpgKdInnerConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_kd_inner_consistent
	const sqlstr = `SELECT pg_catalog.spg_kd_inner_consistent($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgKdPicksplit calls the stored procedure 'pg_catalog.spg_kd_picksplit(internal, internal) void' on db.
func SpgKdPicksplit(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_kd_picksplit
	const sqlstr = `SELECT pg_catalog.spg_kd_picksplit($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgPolyQuadCompress calls the stored procedure 'pg_catalog.spg_poly_quad_compress(polygon) box' on db.
func SpgPolyQuadCompress(ctx context.Context, db DB, v0 pgtypes.Polygon) (pgtypes.Box, error) {
	// call pg_catalog.spg_poly_quad_compress
	const sqlstr = `SELECT pg_catalog.spg_poly_quad_compress($1)`
	// run
	var ret pgtypes.Box
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return ret, nil
}

// SpgQuadChoose calls the stored procedure 'pg_catalog.spg_quad_choose(internal, internal) void' on db.
func SpgQuadChoose(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_quad_choose
	const sqlstr = `SELECT pg_catalog.spg_quad_choose($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgQuadConfig calls the stored procedure 'pg_catalog.spg_quad_config(internal, internal) void' on db.
func SpgQuadConfig(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_quad_config
	const sqlstr = `SELECT pg_catalog.spg_quad_config($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgQuadInnerConsistent calls the stored procedure 'pg_catalog.spg_quad_inner_consistent(internal, internal) void' on db.
func SpgQuadInnerConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_quad_inner_consistent
	const sqlstr = `SELECT pg_catalog.spg_quad_inner_consistent($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgQuadLeafConsistent calls the stored procedure 'pg_catalog.spg_quad_leaf_consistent(internal, internal) boolean' on db.
func SpgQuadLeafConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (bool, error) {
	// call pg_catalog.spg_quad_leaf_consistent
	const sqlstr = `SELECT pg_catalog.spg_quad_leaf_consistent($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// SpgQuadPicksplit calls the stored procedure 'pg_catalog.spg_quad_picksplit(internal, internal) void' on db.
func SpgQuadPicksplit(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_quad_picksplit
	const sqlstr = `SELECT pg_catalog.spg_quad_picksplit($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgRangeQuadChoose calls the stored procedure 'pg_catalog.spg_range_quad_choose(internal, internal) void' on db.
func SpgRangeQuadChoose(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_range_quad_choose
	const sqlstr = `SELECT pg_catalog.spg_range_quad_choose($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgRangeQuadConfig calls the stored procedure 'pg_catalog.spg_range_quad_config(internal, internal) void' on db.
func SpgRangeQuadConfig(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_range_quad_config
	const sqlstr = `SELECT pg_catalog.spg_range_quad_config($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgRangeQuadInnerConsistent calls the stored procedure 'pg_catalog.spg_range_quad_inner_consistent(internal, internal) void' on db.
func SpgRangeQuadInnerConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_range_quad_inner_consistent
	const sqlstr = `SELECT pg_catalog.spg_range_quad_inner_consistent($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgRangeQuadLeafConsistent calls the stored procedure 'pg_catalog.spg_range_quad_leaf_consistent(internal, internal) boolean' on db.
func SpgRangeQuadLeafConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (bool, error) {
	// call pg_catalog.spg_range_quad_leaf_consistent
	const sqlstr = `SELECT pg_catalog.spg_range_quad_leaf_consistent($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// SpgRangeQuadPicksplit calls the stored procedure 'pg_catalog.spg_range_quad_picksplit(internal, internal) void' on db.
func SpgRangeQuadPicksplit(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_range_quad_picksplit
	const sqlstr = `SELECT pg_catalog.spg_range_quad_picksplit($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgTextChoose calls the stored procedure 'pg_catalog.spg_text_choose(internal, internal) void' on db.
func SpgTextChoose(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_text_choose
	const sqlstr = `SELECT pg_catalog.spg_text_choose($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgTextConfig calls the stored procedure 'pg_catalog.spg_text_config(internal, internal) void' on db.
func SpgTextConfig(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_text_config
	const sqlstr = `SELECT pg_catalog.spg_text_config($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgTextInnerConsistent calls the stored procedure 'pg_catalog.spg_text_inner_consistent(internal, internal) void' on db.
func SpgTextInnerConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_text_inner_consistent
	const sqlstr = `SELECT pg_catalog.spg_text_inner_consistent($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgTextLeafConsistent calls the stored procedure 'pg_catalog.spg_text_leaf_consistent(internal, internal) boolean' on db.
func SpgTextLeafConsistent(ctx context.Context, db DB, v0, v1 pgtypes.Internal) (bool, error) {
	// call pg_catalog.spg_text_leaf_consistent
	const sqlstr = `SELECT pg_catalog.spg_text_leaf_consistent($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// SpgTextPicksplit calls the stored procedure 'pg_catalog.spg_text_picksplit(internal, internal) void' on db.
func SpgTextPicksplit(ctx context.Context, db DB, v0, v1 pgtypes.Internal) error {
	// call pg_catalog.spg_text_picksplit
	const sqlstr = `SELECT pg_catalog.spg_text_picksplit($1, $2)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Spghandler calls the stored procedure 'pg_catalog.spghandler(internal) index_am_handler' on db.
func Spghandler(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.spghandler
	const sqlstr = `SELECT pg_catalog.spghandler($1)`
	// run
	var ret pgtypes.IndexAmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return ret, nil
}

// SplitPart calls the stored procedure 'pg_catalog.split_part(text, text, integer) text' on db.
func SplitPart(ctx context.Context, db DB, v0, v1 string, v2 int) (string, error) {
	// call pg_catalog.split_part
	const sqlstr = `SELECT pg_catalog.split_part($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Sqrt calls the stored procedure 'pg_catalog.sqrt(double precision, numeric) numeric' on db.
func Sqrt(ctx context.Context, db DB, v0, v1 float64) (float64, error) {
	// call pg_catalog.sqrt
	const sqlstr = `SELECT pg_catalog.sqrt($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// StartsWith calls the stored procedure 'pg_catalog.starts_with(text, text) boolean' on db.
func StartsWith(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.starts_with
	const sqlstr = `SELECT pg_catalog.starts_with($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// StatementTimestamp calls the stored procedure 'pg_catalog.statement_timestamp() timestamp with time zone' on db.
func StatementTimestamp(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.statement_timestamp
	const sqlstr = `SELECT pg_catalog.statement_timestamp()`
	// run
	var ret time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// Stddev calls the stored procedure 'pg_catalog.stddev(bigint, smallint, integer, real, double precision, numeric) numeric' on db.
func Stddev(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 float32, v4, v5 float64) (float64, error) {
	// call pg_catalog.stddev
	const sqlstr = `SELECT pg_catalog.stddev($1, $2, $3, $4, $5, $6)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// StddevPop calls the stored procedure 'pg_catalog.stddev_pop(bigint, smallint, integer, real, double precision, numeric) numeric' on db.
func StddevPop(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 float32, v4, v5 float64) (float64, error) {
	// call pg_catalog.stddev_pop
	const sqlstr = `SELECT pg_catalog.stddev_pop($1, $2, $3, $4, $5, $6)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// StddevSamp calls the stored procedure 'pg_catalog.stddev_samp(bigint, smallint, integer, real, double precision, numeric) numeric' on db.
func StddevSamp(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 float32, v4, v5 float64) (float64, error) {
	// call pg_catalog.stddev_samp
	const sqlstr = `SELECT pg_catalog.stddev_samp($1, $2, $3, $4, $5, $6)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// StringAgg calls the stored procedure 'pg_catalog.string_agg(bytea, bytea, text, text) bytea' on db.
func StringAgg(ctx context.Context, db DB, v0, v1 []byte, v2, v3 string) ([]byte, error) {
	// call pg_catalog.string_agg
	const sqlstr = `SELECT pg_catalog.string_agg($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// StringAggFinalfn calls the stored procedure 'pg_catalog.string_agg_finalfn(internal) text' on db.
func StringAggFinalfn(ctx context.Context, db DB, v0 pgtypes.Internal) (string, error) {
	// call pg_catalog.string_agg_finalfn
	const sqlstr = `SELECT pg_catalog.string_agg_finalfn($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// StringAggTransfn calls the stored procedure 'pg_catalog.string_agg_transfn(internal, text, text) internal' on db.
func StringAggTransfn(ctx context.Context, db DB, v0 pgtypes.Internal, v1, v2 string) (pgtypes.Internal, error) {
	// call pg_catalog.string_agg_transfn
	const sqlstr = `SELECT pg_catalog.string_agg_transfn($1, $2, $3)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// StringToArray calls the stored procedure 'pg_catalog.string_to_array(text, text, text, text, text) text[]' on db.
func StringToArray(ctx context.Context, db DB, v0, v1, v2, v3, v4 string) (StringSlice, error) {
	// call pg_catalog.string_to_array
	const sqlstr = `SELECT pg_catalog.string_to_array($1, $2, $3, $4, $5)`
	// run
	var ret StringSlice
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return StringSlice{}, logerror(err)
	}
	return ret, nil
}

// Strip calls the stored procedure 'pg_catalog.strip(tsvector) tsvector' on db.
func Strip(ctx context.Context, db DB, v0 pgtypes.Tsvector) (pgtypes.Tsvector, error) {
	// call pg_catalog.strip
	const sqlstr = `SELECT pg_catalog.strip($1)`
	// run
	var ret pgtypes.Tsvector
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return ret, nil
}

// Strpos calls the stored procedure 'pg_catalog.strpos(text, text) integer' on db.
func Strpos(ctx context.Context, db DB, v0, v1 string) (int, error) {
	// call pg_catalog.strpos
	const sqlstr = `SELECT pg_catalog.strpos($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Substr calls the stored procedure 'pg_catalog.substr(bytea, integer, text, integer, bytea, integer, integer, text, integer, integer) bytea' on db.
func Substr(ctx context.Context, db DB, v0 []byte, v1 int, v2 string, v3 int, v4 []byte, v5, v6 int, v7 string, v8, v9 int) ([]byte, error) {
	// call pg_catalog.substr
	const sqlstr = `SELECT pg_catalog.substr($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Substring calls the stored procedure 'pg_catalog.substring(bytea, integer, text, integer, text, text, bit, integer, bytea, integer, integer, text, integer, integer, text, text, text, bit, integer, integer) text' on db.
func Substring(ctx context.Context, db DB, v0 []byte, v1 int, v2 string, v3 int, v4, v5 string, v6 uint8, v7 int, v8 []byte, v9, v10 int, v11 string, v12, v13 int, v14, v15, v16 string, v17 uint8, v18, v19 int) (string, error) {
	// call pg_catalog.substring
	const sqlstr = `SELECT pg_catalog.substring($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Sum calls the stored procedure 'pg_catalog.sum(bigint, smallint, integer, real, double precision, money, interval, numeric) numeric' on db.
func Sum(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 float32, v4 float64, v5 string, v6 []byte, v7 float64) (float64, error) {
	// call pg_catalog.sum
	const sqlstr = `SELECT pg_catalog.sum($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// System calls the stored procedure 'pg_catalog.system(internal) tsm_handler' on db.
func System(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.TsmHandler, error) {
	// call pg_catalog.system
	const sqlstr = `SELECT pg_catalog.system($1)`
	// run
	var ret pgtypes.TsmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.TsmHandler{}, logerror(err)
	}
	return ret, nil
}

// TableAmHandlerIn calls the stored procedure 'pg_catalog.table_am_handler_in(cstring) table_am_handler' on db.
func TableAmHandlerIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.TableAmHandler, error) {
	// call pg_catalog.table_am_handler_in
	const sqlstr = `SELECT pg_catalog.table_am_handler_in($1)`
	// run
	var ret pgtypes.TableAmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.TableAmHandler{}, logerror(err)
	}
	return ret, nil
}

// TableAmHandlerOut calls the stored procedure 'pg_catalog.table_am_handler_out(table_am_handler) cstring' on db.
func TableAmHandlerOut(ctx context.Context, db DB, v0 pgtypes.TableAmHandler) (pgtypes.Cstring, error) {
	// call pg_catalog.table_am_handler_out
	const sqlstr = `SELECT pg_catalog.table_am_handler_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// TableToXML calls the stored procedure 'pg_catalog.table_to_xml(regclass, boolean, boolean, text) xml' on db.
func TableToXML(ctx context.Context, db DB, v0 pgtypes.Regclass, v1, v2 bool, v3 string) ([]byte, error) {
	// call pg_catalog.table_to_xml
	const sqlstr = `SELECT pg_catalog.table_to_xml($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TableToXMLAndXmlschema calls the stored procedure 'pg_catalog.table_to_xml_and_xmlschema(regclass, boolean, boolean, text) xml' on db.
func TableToXMLAndXmlschema(ctx context.Context, db DB, v0 pgtypes.Regclass, v1, v2 bool, v3 string) ([]byte, error) {
	// call pg_catalog.table_to_xml_and_xmlschema
	const sqlstr = `SELECT pg_catalog.table_to_xml_and_xmlschema($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TableToXmlschema calls the stored procedure 'pg_catalog.table_to_xmlschema(regclass, boolean, boolean, text) xml' on db.
func TableToXmlschema(ctx context.Context, db DB, v0 pgtypes.Regclass, v1, v2 bool, v3 string) ([]byte, error) {
	// call pg_catalog.table_to_xmlschema
	const sqlstr = `SELECT pg_catalog.table_to_xmlschema($1, $2, $3, $4)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Tan calls the stored procedure 'pg_catalog.tan(double precision) double precision' on db.
func Tan(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.tan
	const sqlstr = `SELECT pg_catalog.tan($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Tand calls the stored procedure 'pg_catalog.tand(double precision) double precision' on db.
func Tand(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.tand
	const sqlstr = `SELECT pg_catalog.tand($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Tanh calls the stored procedure 'pg_catalog.tanh(double precision) double precision' on db.
func Tanh(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.tanh
	const sqlstr = `SELECT pg_catalog.tanh($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Text calls the stored procedure 'pg_catalog.text(boolean, "char", name, xml, inet, character) text' on db.
func Text(ctx context.Context, db DB, v0 bool, v1 pgtypes.Char, v2 pgtypes.Name, v3 []byte, v4, v5 string) (string, error) {
	// call pg_catalog.text
	const sqlstr = `SELECT pg_catalog.text($1, $2, $3, $4, $5, $6)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// TextGe calls the stored procedure 'pg_catalog.text_ge(text, text) boolean' on db.
func TextGe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.text_ge
	const sqlstr = `SELECT pg_catalog.text_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TextGt calls the stored procedure 'pg_catalog.text_gt(text, text) boolean' on db.
func TextGt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.text_gt
	const sqlstr = `SELECT pg_catalog.text_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TextLarger calls the stored procedure 'pg_catalog.text_larger(text, text) text' on db.
func TextLarger(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.text_larger
	const sqlstr = `SELECT pg_catalog.text_larger($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// TextLe calls the stored procedure 'pg_catalog.text_le(text, text) boolean' on db.
func TextLe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.text_le
	const sqlstr = `SELECT pg_catalog.text_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TextLt calls the stored procedure 'pg_catalog.text_lt(text, text) boolean' on db.
func TextLt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.text_lt
	const sqlstr = `SELECT pg_catalog.text_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TextPatternGe calls the stored procedure 'pg_catalog.text_pattern_ge(text, text) boolean' on db.
func TextPatternGe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.text_pattern_ge
	const sqlstr = `SELECT pg_catalog.text_pattern_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TextPatternGt calls the stored procedure 'pg_catalog.text_pattern_gt(text, text) boolean' on db.
func TextPatternGt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.text_pattern_gt
	const sqlstr = `SELECT pg_catalog.text_pattern_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TextPatternLe calls the stored procedure 'pg_catalog.text_pattern_le(text, text) boolean' on db.
func TextPatternLe(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.text_pattern_le
	const sqlstr = `SELECT pg_catalog.text_pattern_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TextPatternLt calls the stored procedure 'pg_catalog.text_pattern_lt(text, text) boolean' on db.
func TextPatternLt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.text_pattern_lt
	const sqlstr = `SELECT pg_catalog.text_pattern_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TextSmaller calls the stored procedure 'pg_catalog.text_smaller(text, text) text' on db.
func TextSmaller(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.text_smaller
	const sqlstr = `SELECT pg_catalog.text_smaller($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Textanycat calls the stored procedure 'pg_catalog.textanycat(text, anynonarray) text' on db.
func Textanycat(ctx context.Context, db DB, v0 string, v1 pgtypes.Anynonarray) (string, error) {
	// call pg_catalog.textanycat
	const sqlstr = `SELECT pg_catalog.textanycat($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Textcat calls the stored procedure 'pg_catalog.textcat(text, text) text' on db.
func Textcat(ctx context.Context, db DB, v0, v1 string) (string, error) {
	// call pg_catalog.textcat
	const sqlstr = `SELECT pg_catalog.textcat($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Texteq calls the stored procedure 'pg_catalog.texteq(text, text) boolean' on db.
func Texteq(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.texteq
	const sqlstr = `SELECT pg_catalog.texteq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Texteqname calls the stored procedure 'pg_catalog.texteqname(text, name) boolean' on db.
func Texteqname(ctx context.Context, db DB, v0 string, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.texteqname
	const sqlstr = `SELECT pg_catalog.texteqname($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Textgename calls the stored procedure 'pg_catalog.textgename(text, name) boolean' on db.
func Textgename(ctx context.Context, db DB, v0 string, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.textgename
	const sqlstr = `SELECT pg_catalog.textgename($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Textgtname calls the stored procedure 'pg_catalog.textgtname(text, name) boolean' on db.
func Textgtname(ctx context.Context, db DB, v0 string, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.textgtname
	const sqlstr = `SELECT pg_catalog.textgtname($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Texticlike calls the stored procedure 'pg_catalog.texticlike(text, text) boolean' on db.
func Texticlike(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.texticlike
	const sqlstr = `SELECT pg_catalog.texticlike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TexticlikeSupport calls the stored procedure 'pg_catalog.texticlike_support(internal) internal' on db.
func TexticlikeSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.texticlike_support
	const sqlstr = `SELECT pg_catalog.texticlike_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Texticnlike calls the stored procedure 'pg_catalog.texticnlike(text, text) boolean' on db.
func Texticnlike(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.texticnlike
	const sqlstr = `SELECT pg_catalog.texticnlike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Texticregexeq calls the stored procedure 'pg_catalog.texticregexeq(text, text) boolean' on db.
func Texticregexeq(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.texticregexeq
	const sqlstr = `SELECT pg_catalog.texticregexeq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TexticregexeqSupport calls the stored procedure 'pg_catalog.texticregexeq_support(internal) internal' on db.
func TexticregexeqSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.texticregexeq_support
	const sqlstr = `SELECT pg_catalog.texticregexeq_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Texticregexne calls the stored procedure 'pg_catalog.texticregexne(text, text) boolean' on db.
func Texticregexne(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.texticregexne
	const sqlstr = `SELECT pg_catalog.texticregexne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Textin calls the stored procedure 'pg_catalog.textin(cstring) text' on db.
func Textin(ctx context.Context, db DB, v0 pgtypes.Cstring) (string, error) {
	// call pg_catalog.textin
	const sqlstr = `SELECT pg_catalog.textin($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Textlen calls the stored procedure 'pg_catalog.textlen(text) integer' on db.
func Textlen(ctx context.Context, db DB, v0 string) (int, error) {
	// call pg_catalog.textlen
	const sqlstr = `SELECT pg_catalog.textlen($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Textlename calls the stored procedure 'pg_catalog.textlename(text, name) boolean' on db.
func Textlename(ctx context.Context, db DB, v0 string, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.textlename
	const sqlstr = `SELECT pg_catalog.textlename($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Textlike calls the stored procedure 'pg_catalog.textlike(text, text) boolean' on db.
func Textlike(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.textlike
	const sqlstr = `SELECT pg_catalog.textlike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TextlikeSupport calls the stored procedure 'pg_catalog.textlike_support(internal) internal' on db.
func TextlikeSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.textlike_support
	const sqlstr = `SELECT pg_catalog.textlike_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Textltname calls the stored procedure 'pg_catalog.textltname(text, name) boolean' on db.
func Textltname(ctx context.Context, db DB, v0 string, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.textltname
	const sqlstr = `SELECT pg_catalog.textltname($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Textne calls the stored procedure 'pg_catalog.textne(text, text) boolean' on db.
func Textne(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.textne
	const sqlstr = `SELECT pg_catalog.textne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Textnename calls the stored procedure 'pg_catalog.textnename(text, name) boolean' on db.
func Textnename(ctx context.Context, db DB, v0 string, v1 pgtypes.Name) (bool, error) {
	// call pg_catalog.textnename
	const sqlstr = `SELECT pg_catalog.textnename($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Textnlike calls the stored procedure 'pg_catalog.textnlike(text, text) boolean' on db.
func Textnlike(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.textnlike
	const sqlstr = `SELECT pg_catalog.textnlike($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Textout calls the stored procedure 'pg_catalog.textout(text) cstring' on db.
func Textout(ctx context.Context, db DB, v0 string) (pgtypes.Cstring, error) {
	// call pg_catalog.textout
	const sqlstr = `SELECT pg_catalog.textout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Textrecv calls the stored procedure 'pg_catalog.textrecv(internal) text' on db.
func Textrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (string, error) {
	// call pg_catalog.textrecv
	const sqlstr = `SELECT pg_catalog.textrecv($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Textregexeq calls the stored procedure 'pg_catalog.textregexeq(text, text) boolean' on db.
func Textregexeq(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.textregexeq
	const sqlstr = `SELECT pg_catalog.textregexeq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TextregexeqSupport calls the stored procedure 'pg_catalog.textregexeq_support(internal) internal' on db.
func TextregexeqSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.textregexeq_support
	const sqlstr = `SELECT pg_catalog.textregexeq_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Textregexne calls the stored procedure 'pg_catalog.textregexne(text, text) boolean' on db.
func Textregexne(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.textregexne
	const sqlstr = `SELECT pg_catalog.textregexne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Textsend calls the stored procedure 'pg_catalog.textsend(text) bytea' on db.
func Textsend(ctx context.Context, db DB, v0 string) ([]byte, error) {
	// call pg_catalog.textsend
	const sqlstr = `SELECT pg_catalog.textsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// ThesaurusInit calls the stored procedure 'pg_catalog.thesaurus_init(internal) internal' on db.
func ThesaurusInit(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.thesaurus_init
	const sqlstr = `SELECT pg_catalog.thesaurus_init($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// ThesaurusLexize calls the stored procedure 'pg_catalog.thesaurus_lexize(internal, internal, internal, internal) internal' on db.
func ThesaurusLexize(ctx context.Context, db DB, v0, v1, v2, v3 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.thesaurus_lexize
	const sqlstr = `SELECT pg_catalog.thesaurus_lexize($1, $2, $3, $4)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Tideq calls the stored procedure 'pg_catalog.tideq(tid, tid) boolean' on db.
func Tideq(ctx context.Context, db DB, v0, v1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tideq
	const sqlstr = `SELECT pg_catalog.tideq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Tidge calls the stored procedure 'pg_catalog.tidge(tid, tid) boolean' on db.
func Tidge(ctx context.Context, db DB, v0, v1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tidge
	const sqlstr = `SELECT pg_catalog.tidge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Tidgt calls the stored procedure 'pg_catalog.tidgt(tid, tid) boolean' on db.
func Tidgt(ctx context.Context, db DB, v0, v1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tidgt
	const sqlstr = `SELECT pg_catalog.tidgt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Tidin calls the stored procedure 'pg_catalog.tidin(cstring) tid' on db.
func Tidin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Tid, error) {
	// call pg_catalog.tidin
	const sqlstr = `SELECT pg_catalog.tidin($1)`
	// run
	var ret pgtypes.Tid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Tid{}, logerror(err)
	}
	return ret, nil
}

// Tidlarger calls the stored procedure 'pg_catalog.tidlarger(tid, tid) tid' on db.
func Tidlarger(ctx context.Context, db DB, v0, v1 pgtypes.Tid) (pgtypes.Tid, error) {
	// call pg_catalog.tidlarger
	const sqlstr = `SELECT pg_catalog.tidlarger($1, $2)`
	// run
	var ret pgtypes.Tid
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Tid{}, logerror(err)
	}
	return ret, nil
}

// Tidle calls the stored procedure 'pg_catalog.tidle(tid, tid) boolean' on db.
func Tidle(ctx context.Context, db DB, v0, v1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tidle
	const sqlstr = `SELECT pg_catalog.tidle($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Tidlt calls the stored procedure 'pg_catalog.tidlt(tid, tid) boolean' on db.
func Tidlt(ctx context.Context, db DB, v0, v1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tidlt
	const sqlstr = `SELECT pg_catalog.tidlt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Tidne calls the stored procedure 'pg_catalog.tidne(tid, tid) boolean' on db.
func Tidne(ctx context.Context, db DB, v0, v1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tidne
	const sqlstr = `SELECT pg_catalog.tidne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Tidout calls the stored procedure 'pg_catalog.tidout(tid) cstring' on db.
func Tidout(ctx context.Context, db DB, v0 pgtypes.Tid) (pgtypes.Cstring, error) {
	// call pg_catalog.tidout
	const sqlstr = `SELECT pg_catalog.tidout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Tidrecv calls the stored procedure 'pg_catalog.tidrecv(internal) tid' on db.
func Tidrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Tid, error) {
	// call pg_catalog.tidrecv
	const sqlstr = `SELECT pg_catalog.tidrecv($1)`
	// run
	var ret pgtypes.Tid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Tid{}, logerror(err)
	}
	return ret, nil
}

// Tidsend calls the stored procedure 'pg_catalog.tidsend(tid) bytea' on db.
func Tidsend(ctx context.Context, db DB, v0 pgtypes.Tid) ([]byte, error) {
	// call pg_catalog.tidsend
	const sqlstr = `SELECT pg_catalog.tidsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Tidsmaller calls the stored procedure 'pg_catalog.tidsmaller(tid, tid) tid' on db.
func Tidsmaller(ctx context.Context, db DB, v0, v1 pgtypes.Tid) (pgtypes.Tid, error) {
	// call pg_catalog.tidsmaller
	const sqlstr = `SELECT pg_catalog.tidsmaller($1, $2)`
	// run
	var ret pgtypes.Tid
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Tid{}, logerror(err)
	}
	return ret, nil
}

// Time calls the stored procedure 'pg_catalog.time(timestamp without time zone, timestamp with time zone, interval, time with time zone, time without time zone, integer) time without time zone' on db.
func Time(ctx context.Context, db DB, v0, v1 time.Time, v2 []byte, v3, v4 time.Time, v5 int) (time.Time, error) {
	// call pg_catalog.time
	const sqlstr = `SELECT pg_catalog.time($1, $2, $3, $4, $5, $6)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimeCmp calls the stored procedure 'pg_catalog.time_cmp(time without time zone, time without time zone) integer' on db.
func TimeCmp(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.time_cmp
	const sqlstr = `SELECT pg_catalog.time_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimeEq calls the stored procedure 'pg_catalog.time_eq(time without time zone, time without time zone) boolean' on db.
func TimeEq(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.time_eq
	const sqlstr = `SELECT pg_catalog.time_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimeGe calls the stored procedure 'pg_catalog.time_ge(time without time zone, time without time zone) boolean' on db.
func TimeGe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.time_ge
	const sqlstr = `SELECT pg_catalog.time_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimeGt calls the stored procedure 'pg_catalog.time_gt(time without time zone, time without time zone) boolean' on db.
func TimeGt(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.time_gt
	const sqlstr = `SELECT pg_catalog.time_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimeHash calls the stored procedure 'pg_catalog.time_hash(time without time zone) integer' on db.
func TimeHash(ctx context.Context, db DB, v0 time.Time) (int, error) {
	// call pg_catalog.time_hash
	const sqlstr = `SELECT pg_catalog.time_hash($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimeHashExtended calls the stored procedure 'pg_catalog.time_hash_extended(time without time zone, bigint) bigint' on db.
func TimeHashExtended(ctx context.Context, db DB, v0 time.Time, v1 int64) (int64, error) {
	// call pg_catalog.time_hash_extended
	const sqlstr = `SELECT pg_catalog.time_hash_extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimeIn calls the stored procedure 'pg_catalog.time_in(cstring, oid, integer) time without time zone' on db.
func TimeIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (time.Time, error) {
	// call pg_catalog.time_in
	const sqlstr = `SELECT pg_catalog.time_in($1, $2, $3)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimeLarger calls the stored procedure 'pg_catalog.time_larger(time without time zone, time without time zone) time without time zone' on db.
func TimeLarger(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.time_larger
	const sqlstr = `SELECT pg_catalog.time_larger($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimeLe calls the stored procedure 'pg_catalog.time_le(time without time zone, time without time zone) boolean' on db.
func TimeLe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.time_le
	const sqlstr = `SELECT pg_catalog.time_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimeLt calls the stored procedure 'pg_catalog.time_lt(time without time zone, time without time zone) boolean' on db.
func TimeLt(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.time_lt
	const sqlstr = `SELECT pg_catalog.time_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimeMiInterval calls the stored procedure 'pg_catalog.time_mi_interval(time without time zone, interval) time without time zone' on db.
func TimeMiInterval(ctx context.Context, db DB, v0 time.Time, v1 []byte) (time.Time, error) {
	// call pg_catalog.time_mi_interval
	const sqlstr = `SELECT pg_catalog.time_mi_interval($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimeMiTime calls the stored procedure 'pg_catalog.time_mi_time(time without time zone, time without time zone) interval' on db.
func TimeMiTime(ctx context.Context, db DB, v0, v1 time.Time) ([]byte, error) {
	// call pg_catalog.time_mi_time
	const sqlstr = `SELECT pg_catalog.time_mi_time($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TimeNe calls the stored procedure 'pg_catalog.time_ne(time without time zone, time without time zone) boolean' on db.
func TimeNe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.time_ne
	const sqlstr = `SELECT pg_catalog.time_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimeOut calls the stored procedure 'pg_catalog.time_out(time without time zone) cstring' on db.
func TimeOut(ctx context.Context, db DB, v0 time.Time) (pgtypes.Cstring, error) {
	// call pg_catalog.time_out
	const sqlstr = `SELECT pg_catalog.time_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// TimePlInterval calls the stored procedure 'pg_catalog.time_pl_interval(time without time zone, interval) time without time zone' on db.
func TimePlInterval(ctx context.Context, db DB, v0 time.Time, v1 []byte) (time.Time, error) {
	// call pg_catalog.time_pl_interval
	const sqlstr = `SELECT pg_catalog.time_pl_interval($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimeRecv calls the stored procedure 'pg_catalog.time_recv(internal, oid, integer) time without time zone' on db.
func TimeRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (time.Time, error) {
	// call pg_catalog.time_recv
	const sqlstr = `SELECT pg_catalog.time_recv($1, $2, $3)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimeSend calls the stored procedure 'pg_catalog.time_send(time without time zone) bytea' on db.
func TimeSend(ctx context.Context, db DB, v0 time.Time) ([]byte, error) {
	// call pg_catalog.time_send
	const sqlstr = `SELECT pg_catalog.time_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TimeSmaller calls the stored procedure 'pg_catalog.time_smaller(time without time zone, time without time zone) time without time zone' on db.
func TimeSmaller(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.time_smaller
	const sqlstr = `SELECT pg_catalog.time_smaller($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimeSupport calls the stored procedure 'pg_catalog.time_support(internal) internal' on db.
func TimeSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.time_support
	const sqlstr = `SELECT pg_catalog.time_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// TimedatePl calls the stored procedure 'pg_catalog.timedate_pl(time without time zone, date) timestamp without time zone' on db.
func TimedatePl(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.timedate_pl
	const sqlstr = `SELECT pg_catalog.timedate_pl($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// Timeofday calls the stored procedure 'pg_catalog.timeofday() text' on db.
func Timeofday(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.timeofday
	const sqlstr = `SELECT pg_catalog.timeofday()`
	// run
	var ret string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Timestamp calls the stored procedure 'pg_catalog.timestamp(date, timestamp with time zone, date, time without time zone, timestamp without time zone, integer) timestamp without time zone' on db.
func Timestamp(ctx context.Context, db DB, v0, v1, v2, v3, v4 time.Time, v5 int) (time.Time, error) {
	// call pg_catalog.timestamp
	const sqlstr = `SELECT pg_catalog.timestamp($1, $2, $3, $4, $5, $6)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestampCmp calls the stored procedure 'pg_catalog.timestamp_cmp(timestamp without time zone, timestamp without time zone) integer' on db.
func TimestampCmp(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.timestamp_cmp
	const sqlstr = `SELECT pg_catalog.timestamp_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimestampCmpDate calls the stored procedure 'pg_catalog.timestamp_cmp_date(timestamp without time zone, date) integer' on db.
func TimestampCmpDate(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.timestamp_cmp_date
	const sqlstr = `SELECT pg_catalog.timestamp_cmp_date($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimestampCmpTimestamptz calls the stored procedure 'pg_catalog.timestamp_cmp_timestamptz(timestamp without time zone, timestamp with time zone) integer' on db.
func TimestampCmpTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.timestamp_cmp_timestamptz
	const sqlstr = `SELECT pg_catalog.timestamp_cmp_timestamptz($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimestampEq calls the stored procedure 'pg_catalog.timestamp_eq(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampEq(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_eq
	const sqlstr = `SELECT pg_catalog.timestamp_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampEqDate calls the stored procedure 'pg_catalog.timestamp_eq_date(timestamp without time zone, date) boolean' on db.
func TimestampEqDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_eq_date
	const sqlstr = `SELECT pg_catalog.timestamp_eq_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampEqTimestamptz calls the stored procedure 'pg_catalog.timestamp_eq_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampEqTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_eq_timestamptz
	const sqlstr = `SELECT pg_catalog.timestamp_eq_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampGe calls the stored procedure 'pg_catalog.timestamp_ge(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampGe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ge
	const sqlstr = `SELECT pg_catalog.timestamp_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampGeDate calls the stored procedure 'pg_catalog.timestamp_ge_date(timestamp without time zone, date) boolean' on db.
func TimestampGeDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ge_date
	const sqlstr = `SELECT pg_catalog.timestamp_ge_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampGeTimestamptz calls the stored procedure 'pg_catalog.timestamp_ge_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampGeTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ge_timestamptz
	const sqlstr = `SELECT pg_catalog.timestamp_ge_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampGt calls the stored procedure 'pg_catalog.timestamp_gt(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampGt(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_gt
	const sqlstr = `SELECT pg_catalog.timestamp_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampGtDate calls the stored procedure 'pg_catalog.timestamp_gt_date(timestamp without time zone, date) boolean' on db.
func TimestampGtDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_gt_date
	const sqlstr = `SELECT pg_catalog.timestamp_gt_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampGtTimestamptz calls the stored procedure 'pg_catalog.timestamp_gt_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampGtTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_gt_timestamptz
	const sqlstr = `SELECT pg_catalog.timestamp_gt_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampHash calls the stored procedure 'pg_catalog.timestamp_hash(timestamp without time zone) integer' on db.
func TimestampHash(ctx context.Context, db DB, v0 time.Time) (int, error) {
	// call pg_catalog.timestamp_hash
	const sqlstr = `SELECT pg_catalog.timestamp_hash($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimestampHashExtended calls the stored procedure 'pg_catalog.timestamp_hash_extended(timestamp without time zone, bigint) bigint' on db.
func TimestampHashExtended(ctx context.Context, db DB, v0 time.Time, v1 int64) (int64, error) {
	// call pg_catalog.timestamp_hash_extended
	const sqlstr = `SELECT pg_catalog.timestamp_hash_extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimestampIn calls the stored procedure 'pg_catalog.timestamp_in(cstring, oid, integer) timestamp without time zone' on db.
func TimestampIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (time.Time, error) {
	// call pg_catalog.timestamp_in
	const sqlstr = `SELECT pg_catalog.timestamp_in($1, $2, $3)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestampLarger calls the stored procedure 'pg_catalog.timestamp_larger(timestamp without time zone, timestamp without time zone) timestamp without time zone' on db.
func TimestampLarger(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.timestamp_larger
	const sqlstr = `SELECT pg_catalog.timestamp_larger($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestampLe calls the stored procedure 'pg_catalog.timestamp_le(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampLe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_le
	const sqlstr = `SELECT pg_catalog.timestamp_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampLeDate calls the stored procedure 'pg_catalog.timestamp_le_date(timestamp without time zone, date) boolean' on db.
func TimestampLeDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_le_date
	const sqlstr = `SELECT pg_catalog.timestamp_le_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampLeTimestamptz calls the stored procedure 'pg_catalog.timestamp_le_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampLeTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_le_timestamptz
	const sqlstr = `SELECT pg_catalog.timestamp_le_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampLt calls the stored procedure 'pg_catalog.timestamp_lt(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampLt(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_lt
	const sqlstr = `SELECT pg_catalog.timestamp_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampLtDate calls the stored procedure 'pg_catalog.timestamp_lt_date(timestamp without time zone, date) boolean' on db.
func TimestampLtDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_lt_date
	const sqlstr = `SELECT pg_catalog.timestamp_lt_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampLtTimestamptz calls the stored procedure 'pg_catalog.timestamp_lt_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampLtTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_lt_timestamptz
	const sqlstr = `SELECT pg_catalog.timestamp_lt_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampMi calls the stored procedure 'pg_catalog.timestamp_mi(timestamp without time zone, timestamp without time zone) interval' on db.
func TimestampMi(ctx context.Context, db DB, v0, v1 time.Time) ([]byte, error) {
	// call pg_catalog.timestamp_mi
	const sqlstr = `SELECT pg_catalog.timestamp_mi($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TimestampMiInterval calls the stored procedure 'pg_catalog.timestamp_mi_interval(timestamp without time zone, interval) timestamp without time zone' on db.
func TimestampMiInterval(ctx context.Context, db DB, v0 time.Time, v1 []byte) (time.Time, error) {
	// call pg_catalog.timestamp_mi_interval
	const sqlstr = `SELECT pg_catalog.timestamp_mi_interval($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestampNe calls the stored procedure 'pg_catalog.timestamp_ne(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampNe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ne
	const sqlstr = `SELECT pg_catalog.timestamp_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampNeDate calls the stored procedure 'pg_catalog.timestamp_ne_date(timestamp without time zone, date) boolean' on db.
func TimestampNeDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ne_date
	const sqlstr = `SELECT pg_catalog.timestamp_ne_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampNeTimestamptz calls the stored procedure 'pg_catalog.timestamp_ne_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampNeTimestamptz(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ne_timestamptz
	const sqlstr = `SELECT pg_catalog.timestamp_ne_timestamptz($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestampOut calls the stored procedure 'pg_catalog.timestamp_out(timestamp without time zone) cstring' on db.
func TimestampOut(ctx context.Context, db DB, v0 time.Time) (pgtypes.Cstring, error) {
	// call pg_catalog.timestamp_out
	const sqlstr = `SELECT pg_catalog.timestamp_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// TimestampPlInterval calls the stored procedure 'pg_catalog.timestamp_pl_interval(timestamp without time zone, interval) timestamp without time zone' on db.
func TimestampPlInterval(ctx context.Context, db DB, v0 time.Time, v1 []byte) (time.Time, error) {
	// call pg_catalog.timestamp_pl_interval
	const sqlstr = `SELECT pg_catalog.timestamp_pl_interval($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestampRecv calls the stored procedure 'pg_catalog.timestamp_recv(internal, oid, integer) timestamp without time zone' on db.
func TimestampRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (time.Time, error) {
	// call pg_catalog.timestamp_recv
	const sqlstr = `SELECT pg_catalog.timestamp_recv($1, $2, $3)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestampSend calls the stored procedure 'pg_catalog.timestamp_send(timestamp without time zone) bytea' on db.
func TimestampSend(ctx context.Context, db DB, v0 time.Time) ([]byte, error) {
	// call pg_catalog.timestamp_send
	const sqlstr = `SELECT pg_catalog.timestamp_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TimestampSmaller calls the stored procedure 'pg_catalog.timestamp_smaller(timestamp without time zone, timestamp without time zone) timestamp without time zone' on db.
func TimestampSmaller(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.timestamp_smaller
	const sqlstr = `SELECT pg_catalog.timestamp_smaller($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestampSortsupport calls the stored procedure 'pg_catalog.timestamp_sortsupport(internal) void' on db.
func TimestampSortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.timestamp_sortsupport
	const sqlstr = `SELECT pg_catalog.timestamp_sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// TimestampSupport calls the stored procedure 'pg_catalog.timestamp_support(internal) internal' on db.
func TimestampSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.timestamp_support
	const sqlstr = `SELECT pg_catalog.timestamp_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Timestamptypmodin calls the stored procedure 'pg_catalog.timestamptypmodin(cstring[]) integer' on db.
func Timestamptypmodin(ctx context.Context, db DB, v0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.timestamptypmodin
	const sqlstr = `SELECT pg_catalog.timestamptypmodin($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Timestamptypmodout calls the stored procedure 'pg_catalog.timestamptypmodout(integer) cstring' on db.
func Timestamptypmodout(ctx context.Context, db DB, v0 int) (pgtypes.Cstring, error) {
	// call pg_catalog.timestamptypmodout
	const sqlstr = `SELECT pg_catalog.timestamptypmodout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Timestamptz calls the stored procedure 'pg_catalog.timestamptz(date, timestamp without time zone, date, time without time zone, date, time with time zone, timestamp with time zone, integer) timestamp with time zone' on db.
func Timestamptz(ctx context.Context, db DB, v0, v1, v2, v3, v4, v5, v6 time.Time, v7 int) (time.Time, error) {
	// call pg_catalog.timestamptz
	const sqlstr = `SELECT pg_catalog.timestamptz($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestamptzCmp calls the stored procedure 'pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone) integer' on db.
func TimestamptzCmp(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.timestamptz_cmp
	const sqlstr = `SELECT pg_catalog.timestamptz_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimestamptzCmpDate calls the stored procedure 'pg_catalog.timestamptz_cmp_date(timestamp with time zone, date) integer' on db.
func TimestamptzCmpDate(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.timestamptz_cmp_date
	const sqlstr = `SELECT pg_catalog.timestamptz_cmp_date($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimestamptzCmpTimestamp calls the stored procedure 'pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp without time zone) integer' on db.
func TimestamptzCmpTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.timestamptz_cmp_timestamp
	const sqlstr = `SELECT pg_catalog.timestamptz_cmp_timestamp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimestamptzEq calls the stored procedure 'pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzEq(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_eq
	const sqlstr = `SELECT pg_catalog.timestamptz_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzEqDate calls the stored procedure 'pg_catalog.timestamptz_eq_date(timestamp with time zone, date) boolean' on db.
func TimestamptzEqDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_eq_date
	const sqlstr = `SELECT pg_catalog.timestamptz_eq_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzEqTimestamp calls the stored procedure 'pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzEqTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_eq_timestamp
	const sqlstr = `SELECT pg_catalog.timestamptz_eq_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzGe calls the stored procedure 'pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzGe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ge
	const sqlstr = `SELECT pg_catalog.timestamptz_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzGeDate calls the stored procedure 'pg_catalog.timestamptz_ge_date(timestamp with time zone, date) boolean' on db.
func TimestamptzGeDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ge_date
	const sqlstr = `SELECT pg_catalog.timestamptz_ge_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzGeTimestamp calls the stored procedure 'pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzGeTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ge_timestamp
	const sqlstr = `SELECT pg_catalog.timestamptz_ge_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzGt calls the stored procedure 'pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzGt(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_gt
	const sqlstr = `SELECT pg_catalog.timestamptz_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzGtDate calls the stored procedure 'pg_catalog.timestamptz_gt_date(timestamp with time zone, date) boolean' on db.
func TimestamptzGtDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_gt_date
	const sqlstr = `SELECT pg_catalog.timestamptz_gt_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzGtTimestamp calls the stored procedure 'pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzGtTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_gt_timestamp
	const sqlstr = `SELECT pg_catalog.timestamptz_gt_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzIn calls the stored procedure 'pg_catalog.timestamptz_in(cstring, oid, integer) timestamp with time zone' on db.
func TimestamptzIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (time.Time, error) {
	// call pg_catalog.timestamptz_in
	const sqlstr = `SELECT pg_catalog.timestamptz_in($1, $2, $3)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestamptzLarger calls the stored procedure 'pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone) timestamp with time zone' on db.
func TimestamptzLarger(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.timestamptz_larger
	const sqlstr = `SELECT pg_catalog.timestamptz_larger($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestamptzLe calls the stored procedure 'pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzLe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_le
	const sqlstr = `SELECT pg_catalog.timestamptz_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzLeDate calls the stored procedure 'pg_catalog.timestamptz_le_date(timestamp with time zone, date) boolean' on db.
func TimestamptzLeDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_le_date
	const sqlstr = `SELECT pg_catalog.timestamptz_le_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzLeTimestamp calls the stored procedure 'pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzLeTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_le_timestamp
	const sqlstr = `SELECT pg_catalog.timestamptz_le_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzLt calls the stored procedure 'pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzLt(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_lt
	const sqlstr = `SELECT pg_catalog.timestamptz_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzLtDate calls the stored procedure 'pg_catalog.timestamptz_lt_date(timestamp with time zone, date) boolean' on db.
func TimestamptzLtDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_lt_date
	const sqlstr = `SELECT pg_catalog.timestamptz_lt_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzLtTimestamp calls the stored procedure 'pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzLtTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_lt_timestamp
	const sqlstr = `SELECT pg_catalog.timestamptz_lt_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzMi calls the stored procedure 'pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone) interval' on db.
func TimestamptzMi(ctx context.Context, db DB, v0, v1 time.Time) ([]byte, error) {
	// call pg_catalog.timestamptz_mi
	const sqlstr = `SELECT pg_catalog.timestamptz_mi($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TimestamptzMiInterval calls the stored procedure 'pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval) timestamp with time zone' on db.
func TimestamptzMiInterval(ctx context.Context, db DB, v0 time.Time, v1 []byte) (time.Time, error) {
	// call pg_catalog.timestamptz_mi_interval
	const sqlstr = `SELECT pg_catalog.timestamptz_mi_interval($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestamptzNe calls the stored procedure 'pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzNe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ne
	const sqlstr = `SELECT pg_catalog.timestamptz_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzNeDate calls the stored procedure 'pg_catalog.timestamptz_ne_date(timestamp with time zone, date) boolean' on db.
func TimestamptzNeDate(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ne_date
	const sqlstr = `SELECT pg_catalog.timestamptz_ne_date($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzNeTimestamp calls the stored procedure 'pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzNeTimestamp(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ne_timestamp
	const sqlstr = `SELECT pg_catalog.timestamptz_ne_timestamp($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimestamptzOut calls the stored procedure 'pg_catalog.timestamptz_out(timestamp with time zone) cstring' on db.
func TimestamptzOut(ctx context.Context, db DB, v0 time.Time) (pgtypes.Cstring, error) {
	// call pg_catalog.timestamptz_out
	const sqlstr = `SELECT pg_catalog.timestamptz_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// TimestamptzPlInterval calls the stored procedure 'pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval) timestamp with time zone' on db.
func TimestamptzPlInterval(ctx context.Context, db DB, v0 time.Time, v1 []byte) (time.Time, error) {
	// call pg_catalog.timestamptz_pl_interval
	const sqlstr = `SELECT pg_catalog.timestamptz_pl_interval($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestamptzRecv calls the stored procedure 'pg_catalog.timestamptz_recv(internal, oid, integer) timestamp with time zone' on db.
func TimestamptzRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (time.Time, error) {
	// call pg_catalog.timestamptz_recv
	const sqlstr = `SELECT pg_catalog.timestamptz_recv($1, $2, $3)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimestamptzSend calls the stored procedure 'pg_catalog.timestamptz_send(timestamp with time zone) bytea' on db.
func TimestamptzSend(ctx context.Context, db DB, v0 time.Time) ([]byte, error) {
	// call pg_catalog.timestamptz_send
	const sqlstr = `SELECT pg_catalog.timestamptz_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TimestamptzSmaller calls the stored procedure 'pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone) timestamp with time zone' on db.
func TimestamptzSmaller(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.timestamptz_smaller
	const sqlstr = `SELECT pg_catalog.timestamptz_smaller($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// Timestamptztypmodin calls the stored procedure 'pg_catalog.timestamptztypmodin(cstring[]) integer' on db.
func Timestamptztypmodin(ctx context.Context, db DB, v0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.timestamptztypmodin
	const sqlstr = `SELECT pg_catalog.timestamptztypmodin($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Timestamptztypmodout calls the stored procedure 'pg_catalog.timestamptztypmodout(integer) cstring' on db.
func Timestamptztypmodout(ctx context.Context, db DB, v0 int) (pgtypes.Cstring, error) {
	// call pg_catalog.timestamptztypmodout
	const sqlstr = `SELECT pg_catalog.timestamptztypmodout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Timetypmodin calls the stored procedure 'pg_catalog.timetypmodin(cstring[]) integer' on db.
func Timetypmodin(ctx context.Context, db DB, v0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.timetypmodin
	const sqlstr = `SELECT pg_catalog.timetypmodin($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Timetypmodout calls the stored procedure 'pg_catalog.timetypmodout(integer) cstring' on db.
func Timetypmodout(ctx context.Context, db DB, v0 int) (pgtypes.Cstring, error) {
	// call pg_catalog.timetypmodout
	const sqlstr = `SELECT pg_catalog.timetypmodout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Timetz calls the stored procedure 'pg_catalog.timetz(time without time zone, timestamp with time zone, time with time zone, integer) time with time zone' on db.
func Timetz(ctx context.Context, db DB, v0, v1, v2 time.Time, v3 int) (time.Time, error) {
	// call pg_catalog.timetz
	const sqlstr = `SELECT pg_catalog.timetz($1, $2, $3, $4)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimetzCmp calls the stored procedure 'pg_catalog.timetz_cmp(time with time zone, time with time zone) integer' on db.
func TimetzCmp(ctx context.Context, db DB, v0, v1 time.Time) (int, error) {
	// call pg_catalog.timetz_cmp
	const sqlstr = `SELECT pg_catalog.timetz_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimetzEq calls the stored procedure 'pg_catalog.timetz_eq(time with time zone, time with time zone) boolean' on db.
func TimetzEq(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timetz_eq
	const sqlstr = `SELECT pg_catalog.timetz_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimetzGe calls the stored procedure 'pg_catalog.timetz_ge(time with time zone, time with time zone) boolean' on db.
func TimetzGe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timetz_ge
	const sqlstr = `SELECT pg_catalog.timetz_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimetzGt calls the stored procedure 'pg_catalog.timetz_gt(time with time zone, time with time zone) boolean' on db.
func TimetzGt(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timetz_gt
	const sqlstr = `SELECT pg_catalog.timetz_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimetzHash calls the stored procedure 'pg_catalog.timetz_hash(time with time zone) integer' on db.
func TimetzHash(ctx context.Context, db DB, v0 time.Time) (int, error) {
	// call pg_catalog.timetz_hash
	const sqlstr = `SELECT pg_catalog.timetz_hash($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimetzHashExtended calls the stored procedure 'pg_catalog.timetz_hash_extended(time with time zone, bigint) bigint' on db.
func TimetzHashExtended(ctx context.Context, db DB, v0 time.Time, v1 int64) (int64, error) {
	// call pg_catalog.timetz_hash_extended
	const sqlstr = `SELECT pg_catalog.timetz_hash_extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TimetzIn calls the stored procedure 'pg_catalog.timetz_in(cstring, oid, integer) time with time zone' on db.
func TimetzIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (time.Time, error) {
	// call pg_catalog.timetz_in
	const sqlstr = `SELECT pg_catalog.timetz_in($1, $2, $3)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimetzLarger calls the stored procedure 'pg_catalog.timetz_larger(time with time zone, time with time zone) time with time zone' on db.
func TimetzLarger(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.timetz_larger
	const sqlstr = `SELECT pg_catalog.timetz_larger($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimetzLe calls the stored procedure 'pg_catalog.timetz_le(time with time zone, time with time zone) boolean' on db.
func TimetzLe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timetz_le
	const sqlstr = `SELECT pg_catalog.timetz_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimetzLt calls the stored procedure 'pg_catalog.timetz_lt(time with time zone, time with time zone) boolean' on db.
func TimetzLt(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timetz_lt
	const sqlstr = `SELECT pg_catalog.timetz_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimetzMiInterval calls the stored procedure 'pg_catalog.timetz_mi_interval(time with time zone, interval) time with time zone' on db.
func TimetzMiInterval(ctx context.Context, db DB, v0 time.Time, v1 []byte) (time.Time, error) {
	// call pg_catalog.timetz_mi_interval
	const sqlstr = `SELECT pg_catalog.timetz_mi_interval($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimetzNe calls the stored procedure 'pg_catalog.timetz_ne(time with time zone, time with time zone) boolean' on db.
func TimetzNe(ctx context.Context, db DB, v0, v1 time.Time) (bool, error) {
	// call pg_catalog.timetz_ne
	const sqlstr = `SELECT pg_catalog.timetz_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TimetzOut calls the stored procedure 'pg_catalog.timetz_out(time with time zone) cstring' on db.
func TimetzOut(ctx context.Context, db DB, v0 time.Time) (pgtypes.Cstring, error) {
	// call pg_catalog.timetz_out
	const sqlstr = `SELECT pg_catalog.timetz_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// TimetzPlInterval calls the stored procedure 'pg_catalog.timetz_pl_interval(time with time zone, interval) time with time zone' on db.
func TimetzPlInterval(ctx context.Context, db DB, v0 time.Time, v1 []byte) (time.Time, error) {
	// call pg_catalog.timetz_pl_interval
	const sqlstr = `SELECT pg_catalog.timetz_pl_interval($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimetzRecv calls the stored procedure 'pg_catalog.timetz_recv(internal, oid, integer) time with time zone' on db.
func TimetzRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (time.Time, error) {
	// call pg_catalog.timetz_recv
	const sqlstr = `SELECT pg_catalog.timetz_recv($1, $2, $3)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimetzSend calls the stored procedure 'pg_catalog.timetz_send(time with time zone) bytea' on db.
func TimetzSend(ctx context.Context, db DB, v0 time.Time) ([]byte, error) {
	// call pg_catalog.timetz_send
	const sqlstr = `SELECT pg_catalog.timetz_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TimetzSmaller calls the stored procedure 'pg_catalog.timetz_smaller(time with time zone, time with time zone) time with time zone' on db.
func TimetzSmaller(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.timetz_smaller
	const sqlstr = `SELECT pg_catalog.timetz_smaller($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// TimetzdatePl calls the stored procedure 'pg_catalog.timetzdate_pl(time with time zone, date) timestamp with time zone' on db.
func TimetzdatePl(ctx context.Context, db DB, v0, v1 time.Time) (time.Time, error) {
	// call pg_catalog.timetzdate_pl
	const sqlstr = `SELECT pg_catalog.timetzdate_pl($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// Timetztypmodin calls the stored procedure 'pg_catalog.timetztypmodin(cstring[]) integer' on db.
func Timetztypmodin(ctx context.Context, db DB, v0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.timetztypmodin
	const sqlstr = `SELECT pg_catalog.timetztypmodin($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Timetztypmodout calls the stored procedure 'pg_catalog.timetztypmodout(integer) cstring' on db.
func Timetztypmodout(ctx context.Context, db DB, v0 int) (pgtypes.Cstring, error) {
	// call pg_catalog.timetztypmodout
	const sqlstr = `SELECT pg_catalog.timetztypmodout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Timezone calls the stored procedure 'pg_catalog.timezone(text, timestamp without time zone, text, timestamp with time zone, text, time with time zone, interval, timestamp without time zone, interval, timestamp with time zone, interval, time with time zone) timestamp with time zone' on db.
func Timezone(ctx context.Context, db DB, v0 string, v1 time.Time, v2 string, v3 time.Time, v4 string, v5 time.Time, v6 []byte, v7 time.Time, v8 []byte, v9 time.Time, v10 []byte, v11 time.Time) (time.Time, error) {
	// call pg_catalog.timezone
	const sqlstr = `SELECT pg_catalog.timezone($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// ToASCII calls the stored procedure 'pg_catalog.to_ascii(text, text, name, text, integer) text' on db.
func ToASCII(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Name, v3 string, v4 int) (string, error) {
	// call pg_catalog.to_ascii
	const sqlstr = `SELECT pg_catalog.to_ascii($1, $2, $3, $4, $5)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// ToChar calls the stored procedure 'pg_catalog.to_char(bigint, text, integer, text, real, text, double precision, text, timestamp without time zone, text, timestamp with time zone, text, interval, text, numeric, text) text' on db.
func ToChar(ctx context.Context, db DB, v0 int64, v1 string, v2 int, v3 string, v4 float32, v5 string, v6 float64, v7 string, v8 time.Time, v9 string, v10 time.Time, v11 string, v12 []byte, v13 string, v14 float64, v15 string) (string, error) {
	// call pg_catalog.to_char
	const sqlstr = `SELECT pg_catalog.to_char($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// ToDate calls the stored procedure 'pg_catalog.to_date(text, text) date' on db.
func ToDate(ctx context.Context, db DB, v0, v1 string) (time.Time, error) {
	// call pg_catalog.to_date
	const sqlstr = `SELECT pg_catalog.to_date($1, $2)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// ToHex calls the stored procedure 'pg_catalog.to_hex(bigint, integer) text' on db.
func ToHex(ctx context.Context, db DB, v0 int64, v1 int) (string, error) {
	// call pg_catalog.to_hex
	const sqlstr = `SELECT pg_catalog.to_hex($1, $2)`
	// run
	var ret string
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// ToJSON calls the stored procedure 'pg_catalog.to_json(anyelement) json' on db.
func ToJSON(ctx context.Context, db DB, v0 pgtypes.Anyelement) ([]byte, error) {
	// call pg_catalog.to_json
	const sqlstr = `SELECT pg_catalog.to_json($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// ToJsonb calls the stored procedure 'pg_catalog.to_jsonb(anyelement) jsonb' on db.
func ToJsonb(ctx context.Context, db DB, v0 pgtypes.Anyelement) ([]byte, error) {
	// call pg_catalog.to_jsonb
	const sqlstr = `SELECT pg_catalog.to_jsonb($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// ToNumber calls the stored procedure 'pg_catalog.to_number(text, text) numeric' on db.
func ToNumber(ctx context.Context, db DB, v0, v1 string) (float64, error) {
	// call pg_catalog.to_number
	const sqlstr = `SELECT pg_catalog.to_number($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// ToRegclass calls the stored procedure 'pg_catalog.to_regclass(text) regclass' on db.
func ToRegclass(ctx context.Context, db DB, v0 string) (pgtypes.Regclass, error) {
	// call pg_catalog.to_regclass
	const sqlstr = `SELECT pg_catalog.to_regclass($1)`
	// run
	var ret pgtypes.Regclass
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return ret, nil
}

// ToRegcollation calls the stored procedure 'pg_catalog.to_regcollation(text) regcollation' on db.
func ToRegcollation(ctx context.Context, db DB, v0 string) (pgtypes.Regcollation, error) {
	// call pg_catalog.to_regcollation
	const sqlstr = `SELECT pg_catalog.to_regcollation($1)`
	// run
	var ret pgtypes.Regcollation
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regcollation{}, logerror(err)
	}
	return ret, nil
}

// ToRegnamespace calls the stored procedure 'pg_catalog.to_regnamespace(text) regnamespace' on db.
func ToRegnamespace(ctx context.Context, db DB, v0 string) (pgtypes.Regnamespace, error) {
	// call pg_catalog.to_regnamespace
	const sqlstr = `SELECT pg_catalog.to_regnamespace($1)`
	// run
	var ret pgtypes.Regnamespace
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regnamespace{}, logerror(err)
	}
	return ret, nil
}

// ToRegoper calls the stored procedure 'pg_catalog.to_regoper(text) regoper' on db.
func ToRegoper(ctx context.Context, db DB, v0 string) (pgtypes.Regoper, error) {
	// call pg_catalog.to_regoper
	const sqlstr = `SELECT pg_catalog.to_regoper($1)`
	// run
	var ret pgtypes.Regoper
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regoper{}, logerror(err)
	}
	return ret, nil
}

// ToRegoperator calls the stored procedure 'pg_catalog.to_regoperator(text) regoperator' on db.
func ToRegoperator(ctx context.Context, db DB, v0 string) (pgtypes.Regoperator, error) {
	// call pg_catalog.to_regoperator
	const sqlstr = `SELECT pg_catalog.to_regoperator($1)`
	// run
	var ret pgtypes.Regoperator
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regoperator{}, logerror(err)
	}
	return ret, nil
}

// ToRegproc calls the stored procedure 'pg_catalog.to_regproc(text) regproc' on db.
func ToRegproc(ctx context.Context, db DB, v0 string) (pgtypes.Regproc, error) {
	// call pg_catalog.to_regproc
	const sqlstr = `SELECT pg_catalog.to_regproc($1)`
	// run
	var ret pgtypes.Regproc
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regproc{}, logerror(err)
	}
	return ret, nil
}

// ToRegprocedure calls the stored procedure 'pg_catalog.to_regprocedure(text) regprocedure' on db.
func ToRegprocedure(ctx context.Context, db DB, v0 string) (pgtypes.Regprocedure, error) {
	// call pg_catalog.to_regprocedure
	const sqlstr = `SELECT pg_catalog.to_regprocedure($1)`
	// run
	var ret pgtypes.Regprocedure
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regprocedure{}, logerror(err)
	}
	return ret, nil
}

// ToRegrole calls the stored procedure 'pg_catalog.to_regrole(text) regrole' on db.
func ToRegrole(ctx context.Context, db DB, v0 string) (pgtypes.Regrole, error) {
	// call pg_catalog.to_regrole
	const sqlstr = `SELECT pg_catalog.to_regrole($1)`
	// run
	var ret pgtypes.Regrole
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regrole{}, logerror(err)
	}
	return ret, nil
}

// ToRegtype calls the stored procedure 'pg_catalog.to_regtype(text) regtype' on db.
func ToRegtype(ctx context.Context, db DB, v0 string) (pgtypes.Regtype, error) {
	// call pg_catalog.to_regtype
	const sqlstr = `SELECT pg_catalog.to_regtype($1)`
	// run
	var ret pgtypes.Regtype
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Regtype{}, logerror(err)
	}
	return ret, nil
}

// ToTimestamp calls the stored procedure 'pg_catalog.to_timestamp(double precision, text, text) timestamp with time zone' on db.
func ToTimestamp(ctx context.Context, db DB, v0 float64, v1, v2 string) (time.Time, error) {
	// call pg_catalog.to_timestamp
	const sqlstr = `SELECT pg_catalog.to_timestamp($1, $2, $3)`
	// run
	var ret time.Time
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// ToTsquery calls the stored procedure 'pg_catalog.to_tsquery(text, regconfig, text) tsquery' on db.
func ToTsquery(ctx context.Context, db DB, v0 string, v1 pgtypes.Regconfig, v2 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.to_tsquery
	const sqlstr = `SELECT pg_catalog.to_tsquery($1, $2, $3)`
	// run
	var ret pgtypes.Tsquery
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return ret, nil
}

// ToTsvector calls the stored procedure 'pg_catalog.to_tsvector(text, json, jsonb, regconfig, text, regconfig, json, regconfig, jsonb) tsvector' on db.
func ToTsvector(ctx context.Context, db DB, v0 string, v1, v2 []byte, v3 pgtypes.Regconfig, v4 string, v5 pgtypes.Regconfig, v6 []byte, v7 pgtypes.Regconfig, v8 []byte) (pgtypes.Tsvector, error) {
	// call pg_catalog.to_tsvector
	const sqlstr = `SELECT pg_catalog.to_tsvector($1, $2, $3, $4, $5, $6, $7, $8, $9)`
	// run
	var ret pgtypes.Tsvector
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8).Scan(&ret); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return ret, nil
}

// TransactionTimestamp calls the stored procedure 'pg_catalog.transaction_timestamp() timestamp with time zone' on db.
func TransactionTimestamp(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.transaction_timestamp
	const sqlstr = `SELECT pg_catalog.transaction_timestamp()`
	// run
	var ret time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return time.Time{}, logerror(err)
	}
	return ret, nil
}

// Translate calls the stored procedure 'pg_catalog.translate(text, text, text) text' on db.
func Translate(ctx context.Context, db DB, v0, v1, v2 string) (string, error) {
	// call pg_catalog.translate
	const sqlstr = `SELECT pg_catalog.translate($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// TriggerOut calls the stored procedure 'pg_catalog.trigger_out(trigger) cstring' on db.
func TriggerOut(ctx context.Context, db DB, v0 pgtypes.Trigger) (pgtypes.Cstring, error) {
	// call pg_catalog.trigger_out
	const sqlstr = `SELECT pg_catalog.trigger_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// TrimScale calls the stored procedure 'pg_catalog.trim_scale(numeric) numeric' on db.
func TrimScale(ctx context.Context, db DB, v0 float64) (float64, error) {
	// call pg_catalog.trim_scale
	const sqlstr = `SELECT pg_catalog.trim_scale($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Trunc calls the stored procedure 'pg_catalog.trunc(double precision, macaddr8, macaddr, numeric, numeric, integer) numeric' on db.
func Trunc(ctx context.Context, db DB, v0 float64, v1 pgtypes.Macaddr8, v2 pgtypes.Macaddr, v3, v4 float64, v5 int) (float64, error) {
	// call pg_catalog.trunc
	const sqlstr = `SELECT pg_catalog.trunc($1, $2, $3, $4, $5, $6)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// TsDebug calls the stored procedure 'pg_catalog.ts_debug(text, regconfig, text) SETOF record' on db.
func TsDebug(ctx context.Context, db DB, v0 string, v1 pgtypes.Regconfig, v2 string) ([]pgtypes.Record, error) {
	// call pg_catalog.ts_debug
	const sqlstr = `SELECT pg_catalog.ts_debug($1, $2, $3)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TsDelete calls the stored procedure 'pg_catalog.ts_delete(tsvector, text, tsvector, text[]) tsvector' on db.
func TsDelete(ctx context.Context, db DB, v0 pgtypes.Tsvector, v1 string, v2 pgtypes.Tsvector, v3 StringSlice) (pgtypes.Tsvector, error) {
	// call pg_catalog.ts_delete
	const sqlstr = `SELECT pg_catalog.ts_delete($1, $2, $3, $4)`
	// run
	var ret pgtypes.Tsvector
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return ret, nil
}

// TsFilter calls the stored procedure 'pg_catalog.ts_filter(tsvector, "char"[]) tsvector' on db.
func TsFilter(ctx context.Context, db DB, v0 pgtypes.Tsvector, v1 []pgtypes.Char) (pgtypes.Tsvector, error) {
	// call pg_catalog.ts_filter
	const sqlstr = `SELECT pg_catalog.ts_filter($1, $2)`
	// run
	var ret pgtypes.Tsvector
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return ret, nil
}

// TsHeadline calls the stored procedure 'pg_catalog.ts_headline(text, tsquery, json, tsquery, jsonb, tsquery, text, tsquery, text, json, tsquery, text, regconfig, text, tsquery, regconfig, json, tsquery, regconfig, jsonb, tsquery, jsonb, tsquery, text, regconfig, text, tsquery, text, regconfig, json, tsquery, text, regconfig, jsonb, tsquery, text) json' on db.
func TsHeadline(ctx context.Context, db DB, v0 string, v1 pgtypes.Tsquery, v2 []byte, v3 pgtypes.Tsquery, v4 []byte, v5 pgtypes.Tsquery, v6 string, v7 pgtypes.Tsquery, v8 string, v9 []byte, v10 pgtypes.Tsquery, v11 string, v12 pgtypes.Regconfig, v13 string, v14 pgtypes.Tsquery, v15 pgtypes.Regconfig, v16 []byte, v17 pgtypes.Tsquery, v18 pgtypes.Regconfig, v19 []byte, v20 pgtypes.Tsquery, v21 []byte, v22 pgtypes.Tsquery, v23 string, v24 pgtypes.Regconfig, v25 string, v26 pgtypes.Tsquery, v27 string, v28 pgtypes.Regconfig, v29 []byte, v30 pgtypes.Tsquery, v31 string, v32 pgtypes.Regconfig, v33 []byte, v34 pgtypes.Tsquery, v35 string) ([]byte, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT pg_catalog.ts_headline($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TsLexize calls the stored procedure 'pg_catalog.ts_lexize(regdictionary, text) text[]' on db.
func TsLexize(ctx context.Context, db DB, v0 pgtypes.Regdictionary, v1 string) (StringSlice, error) {
	// call pg_catalog.ts_lexize
	const sqlstr = `SELECT pg_catalog.ts_lexize($1, $2)`
	// run
	var ret StringSlice
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return StringSlice{}, logerror(err)
	}
	return ret, nil
}

// TsMatchQv calls the stored procedure 'pg_catalog.ts_match_qv(tsquery, tsvector) boolean' on db.
func TsMatchQv(ctx context.Context, db DB, v0 pgtypes.Tsquery, v1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.ts_match_qv
	const sqlstr = `SELECT pg_catalog.ts_match_qv($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsMatchTq calls the stored procedure 'pg_catalog.ts_match_tq(text, tsquery) boolean' on db.
func TsMatchTq(ctx context.Context, db DB, v0 string, v1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.ts_match_tq
	const sqlstr = `SELECT pg_catalog.ts_match_tq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsMatchTt calls the stored procedure 'pg_catalog.ts_match_tt(text, text) boolean' on db.
func TsMatchTt(ctx context.Context, db DB, v0, v1 string) (bool, error) {
	// call pg_catalog.ts_match_tt
	const sqlstr = `SELECT pg_catalog.ts_match_tt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsMatchVq calls the stored procedure 'pg_catalog.ts_match_vq(tsvector, tsquery) boolean' on db.
func TsMatchVq(ctx context.Context, db DB, v0 pgtypes.Tsvector, v1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.ts_match_vq
	const sqlstr = `SELECT pg_catalog.ts_match_vq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsParse calls the stored procedure 'pg_catalog.ts_parse(text, text, oid, text) SETOF record' on db.
func TsParse(ctx context.Context, db DB, v0, v1 string, v2 pgtypes.Oid, v3 string) ([]pgtypes.Record, error) {
	// call pg_catalog.ts_parse
	const sqlstr = `SELECT pg_catalog.ts_parse($1, $2, $3, $4)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TsRank calls the stored procedure 'pg_catalog.ts_rank(tsvector, tsquery, real[], tsvector, tsquery, tsvector, tsquery, integer, real[], tsvector, tsquery, integer) real' on db.
func TsRank(ctx context.Context, db DB, v0 pgtypes.Tsvector, v1 pgtypes.Tsquery, v2 []float32, v3 pgtypes.Tsvector, v4 pgtypes.Tsquery, v5 pgtypes.Tsvector, v6 pgtypes.Tsquery, v7 int, v8 []float32, v9 pgtypes.Tsvector, v10 pgtypes.Tsquery, v11 int) (float32, error) {
	// call pg_catalog.ts_rank
	const sqlstr = `SELECT pg_catalog.ts_rank($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`
	// run
	var ret float32
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// TsRankCd calls the stored procedure 'pg_catalog.ts_rank_cd(tsvector, tsquery, real[], tsvector, tsquery, tsvector, tsquery, integer, real[], tsvector, tsquery, integer) real' on db.
func TsRankCd(ctx context.Context, db DB, v0 pgtypes.Tsvector, v1 pgtypes.Tsquery, v2 []float32, v3 pgtypes.Tsvector, v4 pgtypes.Tsquery, v5 pgtypes.Tsvector, v6 pgtypes.Tsquery, v7 int, v8 []float32, v9 pgtypes.Tsvector, v10 pgtypes.Tsquery, v11 int) (float32, error) {
	// call pg_catalog.ts_rank_cd
	const sqlstr = `SELECT pg_catalog.ts_rank_cd($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`
	// run
	var ret float32
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// TsRewrite calls the stored procedure 'pg_catalog.ts_rewrite(tsquery, text, tsquery, tsquery, tsquery) tsquery' on db.
func TsRewrite(ctx context.Context, db DB, v0 pgtypes.Tsquery, v1 string, v2, v3, v4 pgtypes.Tsquery) (pgtypes.Tsquery, error) {
	// call pg_catalog.ts_rewrite
	const sqlstr = `SELECT pg_catalog.ts_rewrite($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Tsquery
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return ret, nil
}

// TsStat calls the stored procedure 'pg_catalog.ts_stat(text, text, text) SETOF record' on db.
func TsStat(ctx context.Context, db DB, v0, v1, v2 string) ([]pgtypes.Record, error) {
	// call pg_catalog.ts_stat
	const sqlstr = `SELECT pg_catalog.ts_stat($1, $2, $3)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TsTokenType calls the stored procedure 'pg_catalog.ts_token_type(text, oid) SETOF record' on db.
func TsTokenType(ctx context.Context, db DB, v0 string, v1 pgtypes.Oid) ([]pgtypes.Record, error) {
	// call pg_catalog.ts_token_type
	const sqlstr = `SELECT pg_catalog.ts_token_type($1, $2)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TsTypanalyze calls the stored procedure 'pg_catalog.ts_typanalyze(internal) boolean' on db.
func TsTypanalyze(ctx context.Context, db DB, v0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.ts_typanalyze
	const sqlstr = `SELECT pg_catalog.ts_typanalyze($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsmHandlerIn calls the stored procedure 'pg_catalog.tsm_handler_in(cstring) tsm_handler' on db.
func TsmHandlerIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.TsmHandler, error) {
	// call pg_catalog.tsm_handler_in
	const sqlstr = `SELECT pg_catalog.tsm_handler_in($1)`
	// run
	var ret pgtypes.TsmHandler
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.TsmHandler{}, logerror(err)
	}
	return ret, nil
}

// TsmHandlerOut calls the stored procedure 'pg_catalog.tsm_handler_out(tsm_handler) cstring' on db.
func TsmHandlerOut(ctx context.Context, db DB, v0 pgtypes.TsmHandler) (pgtypes.Cstring, error) {
	// call pg_catalog.tsm_handler_out
	const sqlstr = `SELECT pg_catalog.tsm_handler_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Tsmatchjoinsel calls the stored procedure 'pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Tsmatchjoinsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int16, v4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.tsmatchjoinsel
	const sqlstr = `SELECT pg_catalog.tsmatchjoinsel($1, $2, $3, $4, $5)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Tsmatchsel calls the stored procedure 'pg_catalog.tsmatchsel(internal, oid, internal, integer) double precision' on db.
func Tsmatchsel(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 pgtypes.Internal, v3 int) (float64, error) {
	// call pg_catalog.tsmatchsel
	const sqlstr = `SELECT pg_catalog.tsmatchsel($1, $2, $3, $4)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// TsqMcontained calls the stored procedure 'pg_catalog.tsq_mcontained(tsquery, tsquery) boolean' on db.
func TsqMcontained(ctx context.Context, db DB, v0, v1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsq_mcontained
	const sqlstr = `SELECT pg_catalog.tsq_mcontained($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsqMcontains calls the stored procedure 'pg_catalog.tsq_mcontains(tsquery, tsquery) boolean' on db.
func TsqMcontains(ctx context.Context, db DB, v0, v1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsq_mcontains
	const sqlstr = `SELECT pg_catalog.tsq_mcontains($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsqueryAnd calls the stored procedure 'pg_catalog.tsquery_and(tsquery, tsquery) tsquery' on db.
func TsqueryAnd(ctx context.Context, db DB, v0, v1 pgtypes.Tsquery) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsquery_and
	const sqlstr = `SELECT pg_catalog.tsquery_and($1, $2)`
	// run
	var ret pgtypes.Tsquery
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return ret, nil
}

// TsqueryCmp calls the stored procedure 'pg_catalog.tsquery_cmp(tsquery, tsquery) integer' on db.
func TsqueryCmp(ctx context.Context, db DB, v0, v1 pgtypes.Tsquery) (int, error) {
	// call pg_catalog.tsquery_cmp
	const sqlstr = `SELECT pg_catalog.tsquery_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TsqueryEq calls the stored procedure 'pg_catalog.tsquery_eq(tsquery, tsquery) boolean' on db.
func TsqueryEq(ctx context.Context, db DB, v0, v1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_eq
	const sqlstr = `SELECT pg_catalog.tsquery_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsqueryGe calls the stored procedure 'pg_catalog.tsquery_ge(tsquery, tsquery) boolean' on db.
func TsqueryGe(ctx context.Context, db DB, v0, v1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_ge
	const sqlstr = `SELECT pg_catalog.tsquery_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsqueryGt calls the stored procedure 'pg_catalog.tsquery_gt(tsquery, tsquery) boolean' on db.
func TsqueryGt(ctx context.Context, db DB, v0, v1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_gt
	const sqlstr = `SELECT pg_catalog.tsquery_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsqueryLe calls the stored procedure 'pg_catalog.tsquery_le(tsquery, tsquery) boolean' on db.
func TsqueryLe(ctx context.Context, db DB, v0, v1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_le
	const sqlstr = `SELECT pg_catalog.tsquery_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsqueryLt calls the stored procedure 'pg_catalog.tsquery_lt(tsquery, tsquery) boolean' on db.
func TsqueryLt(ctx context.Context, db DB, v0, v1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_lt
	const sqlstr = `SELECT pg_catalog.tsquery_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsqueryNe calls the stored procedure 'pg_catalog.tsquery_ne(tsquery, tsquery) boolean' on db.
func TsqueryNe(ctx context.Context, db DB, v0, v1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_ne
	const sqlstr = `SELECT pg_catalog.tsquery_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsqueryNot calls the stored procedure 'pg_catalog.tsquery_not(tsquery) tsquery' on db.
func TsqueryNot(ctx context.Context, db DB, v0 pgtypes.Tsquery) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsquery_not
	const sqlstr = `SELECT pg_catalog.tsquery_not($1)`
	// run
	var ret pgtypes.Tsquery
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return ret, nil
}

// TsqueryOr calls the stored procedure 'pg_catalog.tsquery_or(tsquery, tsquery) tsquery' on db.
func TsqueryOr(ctx context.Context, db DB, v0, v1 pgtypes.Tsquery) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsquery_or
	const sqlstr = `SELECT pg_catalog.tsquery_or($1, $2)`
	// run
	var ret pgtypes.Tsquery
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return ret, nil
}

// TsqueryPhrase calls the stored procedure 'pg_catalog.tsquery_phrase(tsquery, tsquery, tsquery, tsquery, integer) tsquery' on db.
func TsqueryPhrase(ctx context.Context, db DB, v0, v1, v2, v3 pgtypes.Tsquery, v4 int) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsquery_phrase
	const sqlstr = `SELECT pg_catalog.tsquery_phrase($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Tsquery
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return ret, nil
}

// Tsqueryin calls the stored procedure 'pg_catalog.tsqueryin(cstring) tsquery' on db.
func Tsqueryin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsqueryin
	const sqlstr = `SELECT pg_catalog.tsqueryin($1)`
	// run
	var ret pgtypes.Tsquery
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return ret, nil
}

// Tsqueryout calls the stored procedure 'pg_catalog.tsqueryout(tsquery) cstring' on db.
func Tsqueryout(ctx context.Context, db DB, v0 pgtypes.Tsquery) (pgtypes.Cstring, error) {
	// call pg_catalog.tsqueryout
	const sqlstr = `SELECT pg_catalog.tsqueryout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Tsqueryrecv calls the stored procedure 'pg_catalog.tsqueryrecv(internal) tsquery' on db.
func Tsqueryrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsqueryrecv
	const sqlstr = `SELECT pg_catalog.tsqueryrecv($1)`
	// run
	var ret pgtypes.Tsquery
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return ret, nil
}

// Tsquerysend calls the stored procedure 'pg_catalog.tsquerysend(tsquery) bytea' on db.
func Tsquerysend(ctx context.Context, db DB, v0 pgtypes.Tsquery) ([]byte, error) {
	// call pg_catalog.tsquerysend
	const sqlstr = `SELECT pg_catalog.tsquerysend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Tsrange calls the stored procedure 'pg_catalog.tsrange(timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, text) tsrange' on db.
func Tsrange(ctx context.Context, db DB, v0, v1, v2, v3 time.Time, v4 string) (pgtypes.Tsrange, error) {
	// call pg_catalog.tsrange
	const sqlstr = `SELECT pg_catalog.tsrange($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Tsrange
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Tsrange{}, logerror(err)
	}
	return ret, nil
}

// TsrangeSubdiff calls the stored procedure 'pg_catalog.tsrange_subdiff(timestamp without time zone, timestamp without time zone) double precision' on db.
func TsrangeSubdiff(ctx context.Context, db DB, v0, v1 time.Time) (float64, error) {
	// call pg_catalog.tsrange_subdiff
	const sqlstr = `SELECT pg_catalog.tsrange_subdiff($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Tstzrange calls the stored procedure 'pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone, text) tstzrange' on db.
func Tstzrange(ctx context.Context, db DB, v0, v1, v2, v3 time.Time, v4 string) (pgtypes.Tstzrange, error) {
	// call pg_catalog.tstzrange
	const sqlstr = `SELECT pg_catalog.tstzrange($1, $2, $3, $4, $5)`
	// run
	var ret pgtypes.Tstzrange
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return pgtypes.Tstzrange{}, logerror(err)
	}
	return ret, nil
}

// TstzrangeSubdiff calls the stored procedure 'pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone) double precision' on db.
func TstzrangeSubdiff(ctx context.Context, db DB, v0, v1 time.Time) (float64, error) {
	// call pg_catalog.tstzrange_subdiff
	const sqlstr = `SELECT pg_catalog.tstzrange_subdiff($1, $2)`
	// run
	var ret float64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// TsvectorCmp calls the stored procedure 'pg_catalog.tsvector_cmp(tsvector, tsvector) integer' on db.
func TsvectorCmp(ctx context.Context, db DB, v0, v1 pgtypes.Tsvector) (int, error) {
	// call pg_catalog.tsvector_cmp
	const sqlstr = `SELECT pg_catalog.tsvector_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TsvectorConcat calls the stored procedure 'pg_catalog.tsvector_concat(tsvector, tsvector) tsvector' on db.
func TsvectorConcat(ctx context.Context, db DB, v0, v1 pgtypes.Tsvector) (pgtypes.Tsvector, error) {
	// call pg_catalog.tsvector_concat
	const sqlstr = `SELECT pg_catalog.tsvector_concat($1, $2)`
	// run
	var ret pgtypes.Tsvector
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return ret, nil
}

// TsvectorEq calls the stored procedure 'pg_catalog.tsvector_eq(tsvector, tsvector) boolean' on db.
func TsvectorEq(ctx context.Context, db DB, v0, v1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_eq
	const sqlstr = `SELECT pg_catalog.tsvector_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsvectorGe calls the stored procedure 'pg_catalog.tsvector_ge(tsvector, tsvector) boolean' on db.
func TsvectorGe(ctx context.Context, db DB, v0, v1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_ge
	const sqlstr = `SELECT pg_catalog.tsvector_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsvectorGt calls the stored procedure 'pg_catalog.tsvector_gt(tsvector, tsvector) boolean' on db.
func TsvectorGt(ctx context.Context, db DB, v0, v1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_gt
	const sqlstr = `SELECT pg_catalog.tsvector_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsvectorLe calls the stored procedure 'pg_catalog.tsvector_le(tsvector, tsvector) boolean' on db.
func TsvectorLe(ctx context.Context, db DB, v0, v1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_le
	const sqlstr = `SELECT pg_catalog.tsvector_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsvectorLt calls the stored procedure 'pg_catalog.tsvector_lt(tsvector, tsvector) boolean' on db.
func TsvectorLt(ctx context.Context, db DB, v0, v1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_lt
	const sqlstr = `SELECT pg_catalog.tsvector_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsvectorNe calls the stored procedure 'pg_catalog.tsvector_ne(tsvector, tsvector) boolean' on db.
func TsvectorNe(ctx context.Context, db DB, v0, v1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_ne
	const sqlstr = `SELECT pg_catalog.tsvector_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// TsvectorToArray calls the stored procedure 'pg_catalog.tsvector_to_array(tsvector) text[]' on db.
func TsvectorToArray(ctx context.Context, db DB, v0 pgtypes.Tsvector) (StringSlice, error) {
	// call pg_catalog.tsvector_to_array
	const sqlstr = `SELECT pg_catalog.tsvector_to_array($1)`
	// run
	var ret StringSlice
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return StringSlice{}, logerror(err)
	}
	return ret, nil
}

// Tsvectorin calls the stored procedure 'pg_catalog.tsvectorin(cstring) tsvector' on db.
func Tsvectorin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Tsvector, error) {
	// call pg_catalog.tsvectorin
	const sqlstr = `SELECT pg_catalog.tsvectorin($1)`
	// run
	var ret pgtypes.Tsvector
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return ret, nil
}

// Tsvectorout calls the stored procedure 'pg_catalog.tsvectorout(tsvector) cstring' on db.
func Tsvectorout(ctx context.Context, db DB, v0 pgtypes.Tsvector) (pgtypes.Cstring, error) {
	// call pg_catalog.tsvectorout
	const sqlstr = `SELECT pg_catalog.tsvectorout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Tsvectorrecv calls the stored procedure 'pg_catalog.tsvectorrecv(internal) tsvector' on db.
func Tsvectorrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Tsvector, error) {
	// call pg_catalog.tsvectorrecv
	const sqlstr = `SELECT pg_catalog.tsvectorrecv($1)`
	// run
	var ret pgtypes.Tsvector
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return ret, nil
}

// Tsvectorsend calls the stored procedure 'pg_catalog.tsvectorsend(tsvector) bytea' on db.
func Tsvectorsend(ctx context.Context, db DB, v0 pgtypes.Tsvector) ([]byte, error) {
	// call pg_catalog.tsvectorsend
	const sqlstr = `SELECT pg_catalog.tsvectorsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TxidCurrent calls the stored procedure 'pg_catalog.txid_current() bigint' on db.
func TxidCurrent(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.txid_current
	const sqlstr = `SELECT pg_catalog.txid_current()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TxidCurrentIfAssigned calls the stored procedure 'pg_catalog.txid_current_if_assigned() bigint' on db.
func TxidCurrentIfAssigned(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.txid_current_if_assigned
	const sqlstr = `SELECT pg_catalog.txid_current_if_assigned()`
	// run
	var ret int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TxidCurrentSnapshot calls the stored procedure 'pg_catalog.txid_current_snapshot() txid_snapshot' on db.
func TxidCurrentSnapshot(ctx context.Context, db DB) (pgtypes.TxidSnapshot, error) {
	// call pg_catalog.txid_current_snapshot
	const sqlstr = `SELECT pg_catalog.txid_current_snapshot()`
	// run
	var ret pgtypes.TxidSnapshot
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return pgtypes.TxidSnapshot{}, logerror(err)
	}
	return ret, nil
}

// TxidSnapshotIn calls the stored procedure 'pg_catalog.txid_snapshot_in(cstring) txid_snapshot' on db.
func TxidSnapshotIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.TxidSnapshot, error) {
	// call pg_catalog.txid_snapshot_in
	const sqlstr = `SELECT pg_catalog.txid_snapshot_in($1)`
	// run
	var ret pgtypes.TxidSnapshot
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.TxidSnapshot{}, logerror(err)
	}
	return ret, nil
}

// TxidSnapshotOut calls the stored procedure 'pg_catalog.txid_snapshot_out(txid_snapshot) cstring' on db.
func TxidSnapshotOut(ctx context.Context, db DB, v0 pgtypes.TxidSnapshot) (pgtypes.Cstring, error) {
	// call pg_catalog.txid_snapshot_out
	const sqlstr = `SELECT pg_catalog.txid_snapshot_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// TxidSnapshotRecv calls the stored procedure 'pg_catalog.txid_snapshot_recv(internal) txid_snapshot' on db.
func TxidSnapshotRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.TxidSnapshot, error) {
	// call pg_catalog.txid_snapshot_recv
	const sqlstr = `SELECT pg_catalog.txid_snapshot_recv($1)`
	// run
	var ret pgtypes.TxidSnapshot
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.TxidSnapshot{}, logerror(err)
	}
	return ret, nil
}

// TxidSnapshotSend calls the stored procedure 'pg_catalog.txid_snapshot_send(txid_snapshot) bytea' on db.
func TxidSnapshotSend(ctx context.Context, db DB, v0 pgtypes.TxidSnapshot) ([]byte, error) {
	// call pg_catalog.txid_snapshot_send
	const sqlstr = `SELECT pg_catalog.txid_snapshot_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TxidSnapshotXip calls the stored procedure 'pg_catalog.txid_snapshot_xip(txid_snapshot) SETOF bigint' on db.
func TxidSnapshotXip(ctx context.Context, db DB, v0 pgtypes.TxidSnapshot) ([]int64, error) {
	// call pg_catalog.txid_snapshot_xip
	const sqlstr = `SELECT pg_catalog.txid_snapshot_xip($1)`
	// run
	var ret []int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// TxidSnapshotXmax calls the stored procedure 'pg_catalog.txid_snapshot_xmax(txid_snapshot) bigint' on db.
func TxidSnapshotXmax(ctx context.Context, db DB, v0 pgtypes.TxidSnapshot) (int64, error) {
	// call pg_catalog.txid_snapshot_xmax
	const sqlstr = `SELECT pg_catalog.txid_snapshot_xmax($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TxidSnapshotXmin calls the stored procedure 'pg_catalog.txid_snapshot_xmin(txid_snapshot) bigint' on db.
func TxidSnapshotXmin(ctx context.Context, db DB, v0 pgtypes.TxidSnapshot) (int64, error) {
	// call pg_catalog.txid_snapshot_xmin
	const sqlstr = `SELECT pg_catalog.txid_snapshot_xmin($1)`
	// run
	var ret int64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// TxidStatus calls the stored procedure 'pg_catalog.txid_status(bigint) text' on db.
func TxidStatus(ctx context.Context, db DB, v0 int64) (string, error) {
	// call pg_catalog.txid_status
	const sqlstr = `SELECT pg_catalog.txid_status($1)`
	// run
	var ret string
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// TxidVisibleInSnapshot calls the stored procedure 'pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot) boolean' on db.
func TxidVisibleInSnapshot(ctx context.Context, db DB, v0 int64, v1 pgtypes.TxidSnapshot) (bool, error) {
	// call pg_catalog.txid_visible_in_snapshot
	const sqlstr = `SELECT pg_catalog.txid_visible_in_snapshot($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// UTF8ToBig5 calls the stored procedure 'pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToBig5(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_big5
	const sqlstr = `SELECT pg_catalog.utf8_to_big5($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToEucCn calls the stored procedure 'pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToEucCn(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_euc_cn
	const sqlstr = `SELECT pg_catalog.utf8_to_euc_cn($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToEucJis2004 calls the stored procedure 'pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToEucJis2004(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_euc_jis_2004
	const sqlstr = `SELECT pg_catalog.utf8_to_euc_jis_2004($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToEucJp calls the stored procedure 'pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToEucJp(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_euc_jp
	const sqlstr = `SELECT pg_catalog.utf8_to_euc_jp($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToEucKr calls the stored procedure 'pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToEucKr(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_euc_kr
	const sqlstr = `SELECT pg_catalog.utf8_to_euc_kr($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToEucTw calls the stored procedure 'pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToEucTw(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_euc_tw
	const sqlstr = `SELECT pg_catalog.utf8_to_euc_tw($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToGb18030 calls the stored procedure 'pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToGb18030(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_gb18030
	const sqlstr = `SELECT pg_catalog.utf8_to_gb18030($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToGbk calls the stored procedure 'pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToGbk(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_gbk
	const sqlstr = `SELECT pg_catalog.utf8_to_gbk($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToIso8859 calls the stored procedure 'pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToIso8859(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_iso8859
	const sqlstr = `SELECT pg_catalog.utf8_to_iso8859($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToIso88591 calls the stored procedure 'pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToIso88591(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_iso8859_1
	const sqlstr = `SELECT pg_catalog.utf8_to_iso8859_1($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToJohab calls the stored procedure 'pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToJohab(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_johab
	const sqlstr = `SELECT pg_catalog.utf8_to_johab($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToKoi8r calls the stored procedure 'pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToKoi8r(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_koi8r
	const sqlstr = `SELECT pg_catalog.utf8_to_koi8r($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToKoi8u calls the stored procedure 'pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToKoi8u(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_koi8u
	const sqlstr = `SELECT pg_catalog.utf8_to_koi8u($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToShiftJis2004 calls the stored procedure 'pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToShiftJis2004(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_shift_jis_2004
	const sqlstr = `SELECT pg_catalog.utf8_to_shift_jis_2004($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToSjis calls the stored procedure 'pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToSjis(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_sjis
	const sqlstr = `SELECT pg_catalog.utf8_to_sjis($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToUhc calls the stored procedure 'pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToUhc(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_uhc
	const sqlstr = `SELECT pg_catalog.utf8_to_uhc($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToWin calls the stored procedure 'pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer) void' on db.
func UTF8ToWin(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.utf8_to_win
	const sqlstr = `SELECT pg_catalog.utf8_to_win($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UUIDCmp calls the stored procedure 'pg_catalog.uuid_cmp(uuid, uuid) integer' on db.
func UUIDCmp(ctx context.Context, db DB, v0, v1 uuid.UUID) (int, error) {
	// call pg_catalog.uuid_cmp
	const sqlstr = `SELECT pg_catalog.uuid_cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// UUIDEq calls the stored procedure 'pg_catalog.uuid_eq(uuid, uuid) boolean' on db.
func UUIDEq(ctx context.Context, db DB, v0, v1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_eq
	const sqlstr = `SELECT pg_catalog.uuid_eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// UUIDGe calls the stored procedure 'pg_catalog.uuid_ge(uuid, uuid) boolean' on db.
func UUIDGe(ctx context.Context, db DB, v0, v1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_ge
	const sqlstr = `SELECT pg_catalog.uuid_ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// UUIDGt calls the stored procedure 'pg_catalog.uuid_gt(uuid, uuid) boolean' on db.
func UUIDGt(ctx context.Context, db DB, v0, v1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_gt
	const sqlstr = `SELECT pg_catalog.uuid_gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// UUIDHash calls the stored procedure 'pg_catalog.uuid_hash(uuid) integer' on db.
func UUIDHash(ctx context.Context, db DB, v0 uuid.UUID) (int, error) {
	// call pg_catalog.uuid_hash
	const sqlstr = `SELECT pg_catalog.uuid_hash($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// UUIDHashExtended calls the stored procedure 'pg_catalog.uuid_hash_extended(uuid, bigint) bigint' on db.
func UUIDHashExtended(ctx context.Context, db DB, v0 uuid.UUID, v1 int64) (int64, error) {
	// call pg_catalog.uuid_hash_extended
	const sqlstr = `SELECT pg_catalog.uuid_hash_extended($1, $2)`
	// run
	var ret int64
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// UUIDIn calls the stored procedure 'pg_catalog.uuid_in(cstring) uuid' on db.
func UUIDIn(ctx context.Context, db DB, v0 pgtypes.Cstring) (uuid.UUID, error) {
	// call pg_catalog.uuid_in
	const sqlstr = `SELECT pg_catalog.uuid_in($1)`
	// run
	var ret uuid.UUID
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return uuid.UUID{}, logerror(err)
	}
	return ret, nil
}

// UUIDLe calls the stored procedure 'pg_catalog.uuid_le(uuid, uuid) boolean' on db.
func UUIDLe(ctx context.Context, db DB, v0, v1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_le
	const sqlstr = `SELECT pg_catalog.uuid_le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// UUIDLt calls the stored procedure 'pg_catalog.uuid_lt(uuid, uuid) boolean' on db.
func UUIDLt(ctx context.Context, db DB, v0, v1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_lt
	const sqlstr = `SELECT pg_catalog.uuid_lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// UUIDNe calls the stored procedure 'pg_catalog.uuid_ne(uuid, uuid) boolean' on db.
func UUIDNe(ctx context.Context, db DB, v0, v1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_ne
	const sqlstr = `SELECT pg_catalog.uuid_ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// UUIDOut calls the stored procedure 'pg_catalog.uuid_out(uuid) cstring' on db.
func UUIDOut(ctx context.Context, db DB, v0 uuid.UUID) (pgtypes.Cstring, error) {
	// call pg_catalog.uuid_out
	const sqlstr = `SELECT pg_catalog.uuid_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// UUIDRecv calls the stored procedure 'pg_catalog.uuid_recv(internal) uuid' on db.
func UUIDRecv(ctx context.Context, db DB, v0 pgtypes.Internal) (uuid.UUID, error) {
	// call pg_catalog.uuid_recv
	const sqlstr = `SELECT pg_catalog.uuid_recv($1)`
	// run
	var ret uuid.UUID
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return uuid.UUID{}, logerror(err)
	}
	return ret, nil
}

// UUIDSend calls the stored procedure 'pg_catalog.uuid_send(uuid) bytea' on db.
func UUIDSend(ctx context.Context, db DB, v0 uuid.UUID) ([]byte, error) {
	// call pg_catalog.uuid_send
	const sqlstr = `SELECT pg_catalog.uuid_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// UUIDSortsupport calls the stored procedure 'pg_catalog.uuid_sortsupport(internal) void' on db.
func UUIDSortsupport(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.uuid_sortsupport
	const sqlstr = `SELECT pg_catalog.uuid_sortsupport($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// UhcToUTF8 calls the stored procedure 'pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func UhcToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.uhc_to_utf8
	const sqlstr = `SELECT pg_catalog.uhc_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Unknownin calls the stored procedure 'pg_catalog.unknownin(cstring) unknown' on db.
func Unknownin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Unknown, error) {
	// call pg_catalog.unknownin
	const sqlstr = `SELECT pg_catalog.unknownin($1)`
	// run
	var ret pgtypes.Unknown
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Unknown{}, logerror(err)
	}
	return ret, nil
}

// Unknownout calls the stored procedure 'pg_catalog.unknownout(unknown) cstring' on db.
func Unknownout(ctx context.Context, db DB, v0 pgtypes.Unknown) (pgtypes.Cstring, error) {
	// call pg_catalog.unknownout
	const sqlstr = `SELECT pg_catalog.unknownout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Unknownrecv calls the stored procedure 'pg_catalog.unknownrecv(internal) unknown' on db.
func Unknownrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Unknown, error) {
	// call pg_catalog.unknownrecv
	const sqlstr = `SELECT pg_catalog.unknownrecv($1)`
	// run
	var ret pgtypes.Unknown
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Unknown{}, logerror(err)
	}
	return ret, nil
}

// Unknownsend calls the stored procedure 'pg_catalog.unknownsend(unknown) bytea' on db.
func Unknownsend(ctx context.Context, db DB, v0 pgtypes.Unknown) ([]byte, error) {
	// call pg_catalog.unknownsend
	const sqlstr = `SELECT pg_catalog.unknownsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Unnest calls the stored procedure 'pg_catalog.unnest(anyarray, tsvector) SETOF record' on db.
func Unnest(ctx context.Context, db DB, v0 pgtypes.Anyarray, v1 pgtypes.Tsvector) ([]pgtypes.Record, error) {
	// call pg_catalog.unnest
	const sqlstr = `SELECT pg_catalog.unnest($1, $2)`
	// run
	var ret []pgtypes.Record
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Upper calls the stored procedure 'pg_catalog.upper(text, anyrange) anyelement' on db.
func Upper(ctx context.Context, db DB, v0 string, v1 pgtypes.Anyrange) (pgtypes.Anyelement, error) {
	// call pg_catalog.upper
	const sqlstr = `SELECT pg_catalog.upper($1, $2)`
	// run
	var ret pgtypes.Anyelement
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return ret, nil
}

// UpperInc calls the stored procedure 'pg_catalog.upper_inc(anyrange) boolean' on db.
func UpperInc(ctx context.Context, db DB, v0 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.upper_inc
	const sqlstr = `SELECT pg_catalog.upper_inc($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// UpperInf calls the stored procedure 'pg_catalog.upper_inf(anyrange) boolean' on db.
func UpperInf(ctx context.Context, db DB, v0 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.upper_inf
	const sqlstr = `SELECT pg_catalog.upper_inf($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// VarPop calls the stored procedure 'pg_catalog.var_pop(bigint, smallint, integer, real, double precision, numeric) numeric' on db.
func VarPop(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 float32, v4, v5 float64) (float64, error) {
	// call pg_catalog.var_pop
	const sqlstr = `SELECT pg_catalog.var_pop($1, $2, $3, $4, $5, $6)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// VarSamp calls the stored procedure 'pg_catalog.var_samp(bigint, smallint, integer, real, double precision, numeric) numeric' on db.
func VarSamp(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 float32, v4, v5 float64) (float64, error) {
	// call pg_catalog.var_samp
	const sqlstr = `SELECT pg_catalog.var_samp($1, $2, $3, $4, $5, $6)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Varbit calls the stored procedure 'pg_catalog.varbit(bit varying, integer, boolean) bit varying' on db.
func Varbit(ctx context.Context, db DB, v0 []byte, v1 int, v2 bool) ([]byte, error) {
	// call pg_catalog.varbit
	const sqlstr = `SELECT pg_catalog.varbit($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// VarbitIn calls the stored procedure 'pg_catalog.varbit_in(cstring, oid, integer) bit varying' on db.
func VarbitIn(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) ([]byte, error) {
	// call pg_catalog.varbit_in
	const sqlstr = `SELECT pg_catalog.varbit_in($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// VarbitOut calls the stored procedure 'pg_catalog.varbit_out(bit varying) cstring' on db.
func VarbitOut(ctx context.Context, db DB, v0 []byte) (pgtypes.Cstring, error) {
	// call pg_catalog.varbit_out
	const sqlstr = `SELECT pg_catalog.varbit_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// VarbitRecv calls the stored procedure 'pg_catalog.varbit_recv(internal, oid, integer) bit varying' on db.
func VarbitRecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) ([]byte, error) {
	// call pg_catalog.varbit_recv
	const sqlstr = `SELECT pg_catalog.varbit_recv($1, $2, $3)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// VarbitSend calls the stored procedure 'pg_catalog.varbit_send(bit varying) bytea' on db.
func VarbitSend(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.varbit_send
	const sqlstr = `SELECT pg_catalog.varbit_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// VarbitSupport calls the stored procedure 'pg_catalog.varbit_support(internal) internal' on db.
func VarbitSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.varbit_support
	const sqlstr = `SELECT pg_catalog.varbit_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Varbitcmp calls the stored procedure 'pg_catalog.varbitcmp(bit varying, bit varying) integer' on db.
func Varbitcmp(ctx context.Context, db DB, v0, v1 []byte) (int, error) {
	// call pg_catalog.varbitcmp
	const sqlstr = `SELECT pg_catalog.varbitcmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Varbiteq calls the stored procedure 'pg_catalog.varbiteq(bit varying, bit varying) boolean' on db.
func Varbiteq(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.varbiteq
	const sqlstr = `SELECT pg_catalog.varbiteq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Varbitge calls the stored procedure 'pg_catalog.varbitge(bit varying, bit varying) boolean' on db.
func Varbitge(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.varbitge
	const sqlstr = `SELECT pg_catalog.varbitge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Varbitgt calls the stored procedure 'pg_catalog.varbitgt(bit varying, bit varying) boolean' on db.
func Varbitgt(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.varbitgt
	const sqlstr = `SELECT pg_catalog.varbitgt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Varbitle calls the stored procedure 'pg_catalog.varbitle(bit varying, bit varying) boolean' on db.
func Varbitle(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.varbitle
	const sqlstr = `SELECT pg_catalog.varbitle($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Varbitlt calls the stored procedure 'pg_catalog.varbitlt(bit varying, bit varying) boolean' on db.
func Varbitlt(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.varbitlt
	const sqlstr = `SELECT pg_catalog.varbitlt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Varbitne calls the stored procedure 'pg_catalog.varbitne(bit varying, bit varying) boolean' on db.
func Varbitne(ctx context.Context, db DB, v0, v1 []byte) (bool, error) {
	// call pg_catalog.varbitne
	const sqlstr = `SELECT pg_catalog.varbitne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Varbittypmodin calls the stored procedure 'pg_catalog.varbittypmodin(cstring[]) integer' on db.
func Varbittypmodin(ctx context.Context, db DB, v0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.varbittypmodin
	const sqlstr = `SELECT pg_catalog.varbittypmodin($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Varbittypmodout calls the stored procedure 'pg_catalog.varbittypmodout(integer) cstring' on db.
func Varbittypmodout(ctx context.Context, db DB, v0 int) (pgtypes.Cstring, error) {
	// call pg_catalog.varbittypmodout
	const sqlstr = `SELECT pg_catalog.varbittypmodout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Varchar calls the stored procedure 'pg_catalog.varchar(name, character varying, integer, boolean) character varying' on db.
func Varchar(ctx context.Context, db DB, v0 pgtypes.Name, v1 string, v2 int, v3 bool) (string, error) {
	// call pg_catalog.varchar
	const sqlstr = `SELECT pg_catalog.varchar($1, $2, $3, $4)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2, v3)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// VarcharSupport calls the stored procedure 'pg_catalog.varchar_support(internal) internal' on db.
func VarcharSupport(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.varchar_support
	const sqlstr = `SELECT pg_catalog.varchar_support($1)`
	// run
	var ret pgtypes.Internal
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return ret, nil
}

// Varcharin calls the stored procedure 'pg_catalog.varcharin(cstring, oid, integer) character varying' on db.
func Varcharin(ctx context.Context, db DB, v0 pgtypes.Cstring, v1 pgtypes.Oid, v2 int) (string, error) {
	// call pg_catalog.varcharin
	const sqlstr = `SELECT pg_catalog.varcharin($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Varcharout calls the stored procedure 'pg_catalog.varcharout(character varying) cstring' on db.
func Varcharout(ctx context.Context, db DB, v0 string) (pgtypes.Cstring, error) {
	// call pg_catalog.varcharout
	const sqlstr = `SELECT pg_catalog.varcharout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Varcharrecv calls the stored procedure 'pg_catalog.varcharrecv(internal, oid, integer) character varying' on db.
func Varcharrecv(ctx context.Context, db DB, v0 pgtypes.Internal, v1 pgtypes.Oid, v2 int) (string, error) {
	// call pg_catalog.varcharrecv
	const sqlstr = `SELECT pg_catalog.varcharrecv($1, $2, $3)`
	// run
	var ret string
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// Varcharsend calls the stored procedure 'pg_catalog.varcharsend(character varying) bytea' on db.
func Varcharsend(ctx context.Context, db DB, v0 string) ([]byte, error) {
	// call pg_catalog.varcharsend
	const sqlstr = `SELECT pg_catalog.varcharsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Varchartypmodin calls the stored procedure 'pg_catalog.varchartypmodin(cstring[]) integer' on db.
func Varchartypmodin(ctx context.Context, db DB, v0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.varchartypmodin
	const sqlstr = `SELECT pg_catalog.varchartypmodin($1)`
	// run
	var ret int
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Varchartypmodout calls the stored procedure 'pg_catalog.varchartypmodout(integer) cstring' on db.
func Varchartypmodout(ctx context.Context, db DB, v0 int) (pgtypes.Cstring, error) {
	// call pg_catalog.varchartypmodout
	const sqlstr = `SELECT pg_catalog.varchartypmodout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Variance calls the stored procedure 'pg_catalog.variance(bigint, smallint, integer, real, double precision, numeric) numeric' on db.
func Variance(ctx context.Context, db DB, v0 int64, v1 int16, v2 int, v3 float32, v4, v5 float64) (float64, error) {
	// call pg_catalog.variance
	const sqlstr = `SELECT pg_catalog.variance($1, $2, $3, $4, $5, $6)`
	// run
	var ret float64
	logf(sqlstr, v0, v1, v2, v3, v4, v5)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// Version calls the stored procedure 'pg_catalog.version() text' on db.
func Version(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.version
	const sqlstr = `SELECT pg_catalog.version()`
	// run
	var ret string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&ret); err != nil {
		return "", logerror(err)
	}
	return ret, nil
}

// VoidIn calls the stored procedure 'pg_catalog.void_in(cstring) void' on db.
func VoidIn(ctx context.Context, db DB, v0 pgtypes.Cstring) error {
	// call pg_catalog.void_in
	const sqlstr = `SELECT pg_catalog.void_in($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// VoidOut calls the stored procedure 'pg_catalog.void_out(void) cstring' on db.
func VoidOut(ctx context.Context, db DB, v0 pgtypes.Void) (pgtypes.Cstring, error) {
	// call pg_catalog.void_out
	const sqlstr = `SELECT pg_catalog.void_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// VoidRecv calls the stored procedure 'pg_catalog.void_recv(internal) void' on db.
func VoidRecv(ctx context.Context, db DB, v0 pgtypes.Internal) error {
	// call pg_catalog.void_recv
	const sqlstr = `SELECT pg_catalog.void_recv($1)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// VoidSend calls the stored procedure 'pg_catalog.void_send(void) bytea' on db.
func VoidSend(ctx context.Context, db DB, v0 pgtypes.Void) ([]byte, error) {
	// call pg_catalog.void_send
	const sqlstr = `SELECT pg_catalog.void_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// WebsearchToTsquery calls the stored procedure 'pg_catalog.websearch_to_tsquery(text, regconfig, text) tsquery' on db.
func WebsearchToTsquery(ctx context.Context, db DB, v0 string, v1 pgtypes.Regconfig, v2 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.websearch_to_tsquery
	const sqlstr = `SELECT pg_catalog.websearch_to_tsquery($1, $2, $3)`
	// run
	var ret pgtypes.Tsquery
	logf(sqlstr, v0, v1, v2)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2).Scan(&ret); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return ret, nil
}

// Width calls the stored procedure 'pg_catalog.width(box) double precision' on db.
func Width(ctx context.Context, db DB, v0 pgtypes.Box) (float64, error) {
	// call pg_catalog.width
	const sqlstr = `SELECT pg_catalog.width($1)`
	// run
	var ret float64
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return 0.0, logerror(err)
	}
	return ret, nil
}

// WidthBucket calls the stored procedure 'pg_catalog.width_bucket(anyelement, anyarray, double precision, double precision, double precision, integer, numeric, numeric, numeric, integer) integer' on db.
func WidthBucket(ctx context.Context, db DB, v0 pgtypes.Anyelement, v1 pgtypes.Anyarray, v2, v3, v4 float64, v5 int, v6, v7, v8 float64, v9 int) (int, error) {
	// call pg_catalog.width_bucket
	const sqlstr = `SELECT pg_catalog.width_bucket($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`
	// run
	var ret int
	logf(sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Win1250ToLatin2 calls the stored procedure 'pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer) void' on db.
func Win1250ToLatin2(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.win1250_to_latin2
	const sqlstr = `SELECT pg_catalog.win1250_to_latin2($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Win1250ToMic calls the stored procedure 'pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer) void' on db.
func Win1250ToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.win1250_to_mic
	const sqlstr = `SELECT pg_catalog.win1250_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Win1251ToIso calls the stored procedure 'pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer) void' on db.
func Win1251ToIso(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.win1251_to_iso
	const sqlstr = `SELECT pg_catalog.win1251_to_iso($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Win1251ToKoi8r calls the stored procedure 'pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer) void' on db.
func Win1251ToKoi8r(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.win1251_to_koi8r
	const sqlstr = `SELECT pg_catalog.win1251_to_koi8r($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Win1251ToMic calls the stored procedure 'pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer) void' on db.
func Win1251ToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.win1251_to_mic
	const sqlstr = `SELECT pg_catalog.win1251_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Win1251ToWin866 calls the stored procedure 'pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer) void' on db.
func Win1251ToWin866(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.win1251_to_win866
	const sqlstr = `SELECT pg_catalog.win1251_to_win866($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Win866ToIso calls the stored procedure 'pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer) void' on db.
func Win866ToIso(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.win866_to_iso
	const sqlstr = `SELECT pg_catalog.win866_to_iso($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Win866ToKoi8r calls the stored procedure 'pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer) void' on db.
func Win866ToKoi8r(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.win866_to_koi8r
	const sqlstr = `SELECT pg_catalog.win866_to_koi8r($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Win866ToMic calls the stored procedure 'pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer) void' on db.
func Win866ToMic(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.win866_to_mic
	const sqlstr = `SELECT pg_catalog.win866_to_mic($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// Win866ToWin1251 calls the stored procedure 'pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer) void' on db.
func Win866ToWin1251(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.win866_to_win1251
	const sqlstr = `SELECT pg_catalog.win866_to_win1251($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// WinToUTF8 calls the stored procedure 'pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer) void' on db.
func WinToUTF8(ctx context.Context, db DB, v0, v1 int, v2 pgtypes.Cstring, v3 pgtypes.Internal, v4 int) error {
	// call pg_catalog.win_to_utf8
	const sqlstr = `SELECT pg_catalog.win_to_utf8($1, $2, $3, $4, $5)`
	// run
	logf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// XML calls the stored procedure 'pg_catalog.xml(text) xml' on db.
func XML(ctx context.Context, db DB, v0 string) ([]byte, error) {
	// call pg_catalog.xml
	const sqlstr = `SELECT pg_catalog.xml($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// XMLIn calls the stored procedure 'pg_catalog.xml_in(cstring) xml' on db.
func XMLIn(ctx context.Context, db DB, v0 pgtypes.Cstring) ([]byte, error) {
	// call pg_catalog.xml_in
	const sqlstr = `SELECT pg_catalog.xml_in($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// XMLIsWellFormed calls the stored procedure 'pg_catalog.xml_is_well_formed(text) boolean' on db.
func XMLIsWellFormed(ctx context.Context, db DB, v0 string) (bool, error) {
	// call pg_catalog.xml_is_well_formed
	const sqlstr = `SELECT pg_catalog.xml_is_well_formed($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// XMLIsWellFormedContent calls the stored procedure 'pg_catalog.xml_is_well_formed_content(text) boolean' on db.
func XMLIsWellFormedContent(ctx context.Context, db DB, v0 string) (bool, error) {
	// call pg_catalog.xml_is_well_formed_content
	const sqlstr = `SELECT pg_catalog.xml_is_well_formed_content($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// XMLIsWellFormedDocument calls the stored procedure 'pg_catalog.xml_is_well_formed_document(text) boolean' on db.
func XMLIsWellFormedDocument(ctx context.Context, db DB, v0 string) (bool, error) {
	// call pg_catalog.xml_is_well_formed_document
	const sqlstr = `SELECT pg_catalog.xml_is_well_formed_document($1)`
	// run
	var ret bool
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// XMLOut calls the stored procedure 'pg_catalog.xml_out(xml) cstring' on db.
func XMLOut(ctx context.Context, db DB, v0 []byte) (pgtypes.Cstring, error) {
	// call pg_catalog.xml_out
	const sqlstr = `SELECT pg_catalog.xml_out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// XMLRecv calls the stored procedure 'pg_catalog.xml_recv(internal) xml' on db.
func XMLRecv(ctx context.Context, db DB, v0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.xml_recv
	const sqlstr = `SELECT pg_catalog.xml_recv($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// XMLSend calls the stored procedure 'pg_catalog.xml_send(xml) bytea' on db.
func XMLSend(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.xml_send
	const sqlstr = `SELECT pg_catalog.xml_send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Xid calls the stored procedure 'pg_catalog.xid(xid8) xid' on db.
func Xid(ctx context.Context, db DB, v0 pgtypes.Xid8) (pgtypes.Xid, error) {
	// call pg_catalog.xid
	const sqlstr = `SELECT pg_catalog.xid($1)`
	// run
	var ret pgtypes.Xid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Xid{}, logerror(err)
	}
	return ret, nil
}

// Xid8cmp calls the stored procedure 'pg_catalog.xid8cmp(xid8, xid8) integer' on db.
func Xid8cmp(ctx context.Context, db DB, v0, v1 pgtypes.Xid8) (int, error) {
	// call pg_catalog.xid8cmp
	const sqlstr = `SELECT pg_catalog.xid8cmp($1, $2)`
	// run
	var ret int
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return 0, logerror(err)
	}
	return ret, nil
}

// Xid8eq calls the stored procedure 'pg_catalog.xid8eq(xid8, xid8) boolean' on db.
func Xid8eq(ctx context.Context, db DB, v0, v1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8eq
	const sqlstr = `SELECT pg_catalog.xid8eq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xid8ge calls the stored procedure 'pg_catalog.xid8ge(xid8, xid8) boolean' on db.
func Xid8ge(ctx context.Context, db DB, v0, v1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8ge
	const sqlstr = `SELECT pg_catalog.xid8ge($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xid8gt calls the stored procedure 'pg_catalog.xid8gt(xid8, xid8) boolean' on db.
func Xid8gt(ctx context.Context, db DB, v0, v1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8gt
	const sqlstr = `SELECT pg_catalog.xid8gt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xid8in calls the stored procedure 'pg_catalog.xid8in(cstring) xid8' on db.
func Xid8in(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Xid8, error) {
	// call pg_catalog.xid8in
	const sqlstr = `SELECT pg_catalog.xid8in($1)`
	// run
	var ret pgtypes.Xid8
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return ret, nil
}

// Xid8le calls the stored procedure 'pg_catalog.xid8le(xid8, xid8) boolean' on db.
func Xid8le(ctx context.Context, db DB, v0, v1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8le
	const sqlstr = `SELECT pg_catalog.xid8le($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xid8lt calls the stored procedure 'pg_catalog.xid8lt(xid8, xid8) boolean' on db.
func Xid8lt(ctx context.Context, db DB, v0, v1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8lt
	const sqlstr = `SELECT pg_catalog.xid8lt($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xid8ne calls the stored procedure 'pg_catalog.xid8ne(xid8, xid8) boolean' on db.
func Xid8ne(ctx context.Context, db DB, v0, v1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8ne
	const sqlstr = `SELECT pg_catalog.xid8ne($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xid8out calls the stored procedure 'pg_catalog.xid8out(xid8) cstring' on db.
func Xid8out(ctx context.Context, db DB, v0 pgtypes.Xid8) (pgtypes.Cstring, error) {
	// call pg_catalog.xid8out
	const sqlstr = `SELECT pg_catalog.xid8out($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Xid8recv calls the stored procedure 'pg_catalog.xid8recv(internal) xid8' on db.
func Xid8recv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Xid8, error) {
	// call pg_catalog.xid8recv
	const sqlstr = `SELECT pg_catalog.xid8recv($1)`
	// run
	var ret pgtypes.Xid8
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return ret, nil
}

// Xid8send calls the stored procedure 'pg_catalog.xid8send(xid8) bytea' on db.
func Xid8send(ctx context.Context, db DB, v0 pgtypes.Xid8) ([]byte, error) {
	// call pg_catalog.xid8send
	const sqlstr = `SELECT pg_catalog.xid8send($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Xideq calls the stored procedure 'pg_catalog.xideq(xid, xid) boolean' on db.
func Xideq(ctx context.Context, db DB, v0, v1 pgtypes.Xid) (bool, error) {
	// call pg_catalog.xideq
	const sqlstr = `SELECT pg_catalog.xideq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xideqint4 calls the stored procedure 'pg_catalog.xideqint4(xid, integer) boolean' on db.
func Xideqint4(ctx context.Context, db DB, v0 pgtypes.Xid, v1 int) (bool, error) {
	// call pg_catalog.xideqint4
	const sqlstr = `SELECT pg_catalog.xideqint4($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xidin calls the stored procedure 'pg_catalog.xidin(cstring) xid' on db.
func Xidin(ctx context.Context, db DB, v0 pgtypes.Cstring) (pgtypes.Xid, error) {
	// call pg_catalog.xidin
	const sqlstr = `SELECT pg_catalog.xidin($1)`
	// run
	var ret pgtypes.Xid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Xid{}, logerror(err)
	}
	return ret, nil
}

// Xidneq calls the stored procedure 'pg_catalog.xidneq(xid, xid) boolean' on db.
func Xidneq(ctx context.Context, db DB, v0, v1 pgtypes.Xid) (bool, error) {
	// call pg_catalog.xidneq
	const sqlstr = `SELECT pg_catalog.xidneq($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xidneqint4 calls the stored procedure 'pg_catalog.xidneqint4(xid, integer) boolean' on db.
func Xidneqint4(ctx context.Context, db DB, v0 pgtypes.Xid, v1 int) (bool, error) {
	// call pg_catalog.xidneqint4
	const sqlstr = `SELECT pg_catalog.xidneqint4($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xidout calls the stored procedure 'pg_catalog.xidout(xid) cstring' on db.
func Xidout(ctx context.Context, db DB, v0 pgtypes.Xid) (pgtypes.Cstring, error) {
	// call pg_catalog.xidout
	const sqlstr = `SELECT pg_catalog.xidout($1)`
	// run
	var ret pgtypes.Cstring
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Cstring{}, logerror(err)
	}
	return ret, nil
}

// Xidrecv calls the stored procedure 'pg_catalog.xidrecv(internal) xid' on db.
func Xidrecv(ctx context.Context, db DB, v0 pgtypes.Internal) (pgtypes.Xid, error) {
	// call pg_catalog.xidrecv
	const sqlstr = `SELECT pg_catalog.xidrecv($1)`
	// run
	var ret pgtypes.Xid
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return pgtypes.Xid{}, logerror(err)
	}
	return ret, nil
}

// Xidsend calls the stored procedure 'pg_catalog.xidsend(xid) bytea' on db.
func Xidsend(ctx context.Context, db DB, v0 pgtypes.Xid) ([]byte, error) {
	// call pg_catalog.xidsend
	const sqlstr = `SELECT pg_catalog.xidsend($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Xmlagg calls the stored procedure 'pg_catalog.xmlagg(xml) xml' on db.
func Xmlagg(ctx context.Context, db DB, v0 []byte) ([]byte, error) {
	// call pg_catalog.xmlagg
	const sqlstr = `SELECT pg_catalog.xmlagg($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Xmlcomment calls the stored procedure 'pg_catalog.xmlcomment(text) xml' on db.
func Xmlcomment(ctx context.Context, db DB, v0 string) ([]byte, error) {
	// call pg_catalog.xmlcomment
	const sqlstr = `SELECT pg_catalog.xmlcomment($1)`
	// run
	var ret []byte
	logf(sqlstr, v0)
	if err := db.QueryRowContext(ctx, sqlstr, v0).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Xmlconcat2 calls the stored procedure 'pg_catalog.xmlconcat2(xml, xml) xml' on db.
func Xmlconcat2(ctx context.Context, db DB, v0, v1 []byte) ([]byte, error) {
	// call pg_catalog.xmlconcat2
	const sqlstr = `SELECT pg_catalog.xmlconcat2($1, $2)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// Xmlexists calls the stored procedure 'pg_catalog.xmlexists(text, xml) boolean' on db.
func Xmlexists(ctx context.Context, db DB, v0 string, v1 []byte) (bool, error) {
	// call pg_catalog.xmlexists
	const sqlstr = `SELECT pg_catalog.xmlexists($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xmlvalidate calls the stored procedure 'pg_catalog.xmlvalidate(xml, text) boolean' on db.
func Xmlvalidate(ctx context.Context, db DB, v0 []byte, v1 string) (bool, error) {
	// call pg_catalog.xmlvalidate
	const sqlstr = `SELECT pg_catalog.xmlvalidate($1, $2)`
	// run
	var ret bool
	logf(sqlstr, v0, v1)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}

// Xpath calls the stored procedure 'pg_catalog.xpath(text, xml, text, xml, text[]) xml[]' on db.
func Xpath(ctx context.Context, db DB, v0 string, v1 []byte, v2 string, v3 []byte, v4 StringSlice) ([]byte, error) {
	// call pg_catalog.xpath
	const sqlstr = `SELECT pg_catalog.xpath($1, $2, $3, $4, $5)`
	// run
	var ret []byte
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return nil, logerror(err)
	}
	return ret, nil
}

// XpathExists calls the stored procedure 'pg_catalog.xpath_exists(text, xml, text, xml, text[]) boolean' on db.
func XpathExists(ctx context.Context, db DB, v0 string, v1 []byte, v2 string, v3 []byte, v4 StringSlice) (bool, error) {
	// call pg_catalog.xpath_exists
	const sqlstr = `SELECT pg_catalog.xpath_exists($1, $2, $3, $4, $5)`
	// run
	var ret bool
	logf(sqlstr, v0, v1, v2, v3, v4)
	if err := db.QueryRowContext(ctx, sqlstr, v0, v1, v2, v3, v4).Scan(&ret); err != nil {
		return false, logerror(err)
	}
	return ret, nil
}
