// Package pgcatalog contains generated code for schema 'pg_catalog'.
package pgcatalog

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"encoding/csv"
	"fmt"
	"io"
	"regexp"
	"strings"
	"time"

	"github.com/xo/xo/_examples/pgcatalog/pgtypes"

	"github.com/google/uuid"
)

var (
	// logf is used by generated code to log SQL queries.
	logf = func(string, ...interface{}) {}
	// errf is used by generated code to log SQL errors.
	errf = func(string, ...interface{}) {}
)

// logerror logs the error and returns it.
func logerror(err error) error {
	errf("ERROR: %v", err)
	return err
}

// Logf logs a message using the package logger.
func Logf(s string, v ...interface{}) {
	logf(s, v...)
}

// SetLogger sets the package logger. Valid logger types:
//
//     io.Writer
//     func(string, ...interface{}) (int, error) // fmt.Printf
//     func(string, ...interface{}) // log.Printf
//
func SetLogger(logger interface{}) {
	logf = convLogger(logger)
}

// Errorf logs an error message using the package error logger.
func Errorf(s string, v ...interface{}) {
	errf(s, v...)
}

// SetErrorLogger sets the package error logger. Valid logger types:
//
//     io.Writer
//     func(string, ...interface{}) (int, error) // fmt.Printf
//     func(string, ...interface{}) // log.Printf
//
func SetErrorLogger(logger interface{}) {
	errf = convLogger(logger)
}

// convLogger converts logger to the standard logger interface.
func convLogger(logger interface{}) func(string, ...interface{}) {
	switch z := logger.(type) {
	case io.Writer:
		return func(s string, v ...interface{}) {
			fmt.Fprintf(z, s, v...)
		}
	case func(string, ...interface{}) (int, error): // fmt.Printf
		return func(s string, v ...interface{}) {
			_, _ = z(s, v...)
		}
	case func(string, ...interface{}): // log.Printf
		return z
	}
	panic(fmt.Sprintf("unsupported logger type %T", logger))
}

// DB is the common interface for database operations that can be used with
// types from schema 'pg_catalog'.
//
// This works with both database/sql.DB and database/sql.Tx.
type DB interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

// Error is an error.
type Error string

// Error satisfies the error interface.
func (err Error) Error() string {
	return string(err)
}

// Error values.
const (
	// ErrAlreadyExists is the already exists error.
	ErrAlreadyExists Error = "already exists"
	// ErrDoesNotExist is the does not exist error.
	ErrDoesNotExist Error = "does not exist"
	// ErrMarkedForDeletion is the marked for deletion error.
	ErrMarkedForDeletion Error = "marked for deletion"
)

// ErrInsertFailed is the insert failed error.
type ErrInsertFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrInsertFailed) Error() string {
	return fmt.Sprintf("insert failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrInsertFailed) Unwrap() error {
	return err.Err
}

// ErrUpdateFailed is the update failed error.
type ErrUpdateFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrUpdateFailed) Error() string {
	return fmt.Sprintf("update failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrUpdateFailed) Unwrap() error {
	return err.Err
}

// ErrUpsertFailed is the upsert failed error.
type ErrUpsertFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrUpsertFailed) Error() string {
	return fmt.Sprintf("upsert failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrUpsertFailed) Unwrap() error {
	return err.Err
}

// ErrDecodeFailed is the decode failed error.
type ErrDecodeFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrDecodeFailed) Error() string {
	return fmt.Sprintf("unable to decode: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrDecodeFailed) Unwrap() error {
	return err.Err
}

// ErrInvalidStringSlice is the invalid StringSlice error.
const ErrInvalidStringSlice Error = "invalid StringSlice"

// StringSlice is a slice of strings.
type StringSlice []string

// Scan satisfies the sql.Scanner interface for StringSlice.
func (ss *StringSlice) Scan(v interface{}) error {
	buf, ok := v.([]byte)
	if !ok {
		return logerror(ErrInvalidStringSlice)
	}
	// change quote escapes for csv parser
	str := strings.Replace(quoteEscRE.ReplaceAllString(string(buf), `$1""`), `\\`, `\`, -1)
	str = str[1 : len(str)-1]
	// bail if only one
	if len(str) == 0 {
		return nil
	}
	// parse with csv reader
	r := csv.NewReader(strings.NewReader(str))
	line, err := r.Read()
	if err != nil {
		return logerror(&ErrDecodeFailed{err})
	}
	*ss = StringSlice(line)
	return nil
}

// quoteEscRE matches escaped characters in a string.
var quoteEscRE = regexp.MustCompile(`([^\\]([\\]{2})*)\\"`)

// Value satisfies the sql/driver.Valuer interface.
func (ss StringSlice) Value() (driver.Value, error) {
	v := make([]string, len(ss))
	for i, s := range ss {
		v[i] = `"` + strings.Replace(strings.Replace(s, `\`, `\\\`, -1), `"`, `\"`, -1) + `"`
	}
	return "{" + strings.Join(v, ",") + "}", nil
}

// PgAggregate represents a row from 'pg_catalog.pg_aggregate'.
type PgAggregate struct {
	Tableoid         pgtypes.Oid     `json:"tableoid"`         // tableoid
	Cmax             pgtypes.Cid     `json:"cmax"`             // cmax
	Xmax             pgtypes.Xid     `json:"xmax"`             // xmax
	Cmin             pgtypes.Cid     `json:"cmin"`             // cmin
	Xmin             pgtypes.Xid     `json:"xmin"`             // xmin
	Ctid             pgtypes.Tid     `json:"ctid"`             // ctid
	Aggfnoid         pgtypes.Regproc `json:"aggfnoid"`         // aggfnoid
	Aggkind          pgtypes.Char    `json:"aggkind"`          // aggkind
	Aggnumdirectargs int16           `json:"aggnumdirectargs"` // aggnumdirectargs
	Aggtransfn       pgtypes.Regproc `json:"aggtransfn"`       // aggtransfn
	Aggfinalfn       pgtypes.Regproc `json:"aggfinalfn"`       // aggfinalfn
	Aggcombinefn     pgtypes.Regproc `json:"aggcombinefn"`     // aggcombinefn
	Aggserialfn      pgtypes.Regproc `json:"aggserialfn"`      // aggserialfn
	Aggdeserialfn    pgtypes.Regproc `json:"aggdeserialfn"`    // aggdeserialfn
	Aggmtransfn      pgtypes.Regproc `json:"aggmtransfn"`      // aggmtransfn
	Aggminvtransfn   pgtypes.Regproc `json:"aggminvtransfn"`   // aggminvtransfn
	Aggmfinalfn      pgtypes.Regproc `json:"aggmfinalfn"`      // aggmfinalfn
	Aggfinalextra    bool            `json:"aggfinalextra"`    // aggfinalextra
	Aggmfinalextra   bool            `json:"aggmfinalextra"`   // aggmfinalextra
	Aggfinalmodify   pgtypes.Char    `json:"aggfinalmodify"`   // aggfinalmodify
	Aggmfinalmodify  pgtypes.Char    `json:"aggmfinalmodify"`  // aggmfinalmodify
	Aggsortop        pgtypes.Oid     `json:"aggsortop"`        // aggsortop
	Aggtranstype     pgtypes.Oid     `json:"aggtranstype"`     // aggtranstype
	Aggtransspace    int             `json:"aggtransspace"`    // aggtransspace
	Aggmtranstype    pgtypes.Oid     `json:"aggmtranstype"`    // aggmtranstype
	Aggmtransspace   int             `json:"aggmtransspace"`   // aggmtransspace
	Agginitval       sql.NullString  `json:"agginitval"`       // agginitval
	Aggminitval      sql.NullString  `json:"aggminitval"`      // aggminitval
}

// PgAm represents a row from 'pg_catalog.pg_am'.
type PgAm struct {
	Tableoid  pgtypes.Oid     `json:"tableoid"`  // tableoid
	Cmax      pgtypes.Cid     `json:"cmax"`      // cmax
	Xmax      pgtypes.Xid     `json:"xmax"`      // xmax
	Cmin      pgtypes.Cid     `json:"cmin"`      // cmin
	Xmin      pgtypes.Xid     `json:"xmin"`      // xmin
	Ctid      pgtypes.Tid     `json:"ctid"`      // ctid
	Oid       pgtypes.Oid     `json:"oid"`       // oid
	Amname    string          `json:"amname"`    // amname
	Amhandler pgtypes.Regproc `json:"amhandler"` // amhandler
	Amtype    pgtypes.Char    `json:"amtype"`    // amtype
}

// PgAmop represents a row from 'pg_catalog.pg_amop'.
type PgAmop struct {
	Tableoid       pgtypes.Oid  `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid  `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid  `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid  `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid  `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid  `json:"ctid"`           // ctid
	Oid            pgtypes.Oid  `json:"oid"`            // oid
	Amopfamily     pgtypes.Oid  `json:"amopfamily"`     // amopfamily
	Amoplefttype   pgtypes.Oid  `json:"amoplefttype"`   // amoplefttype
	Amoprighttype  pgtypes.Oid  `json:"amoprighttype"`  // amoprighttype
	Amopstrategy   int16        `json:"amopstrategy"`   // amopstrategy
	Amoppurpose    pgtypes.Char `json:"amoppurpose"`    // amoppurpose
	Amopopr        pgtypes.Oid  `json:"amopopr"`        // amopopr
	Amopmethod     pgtypes.Oid  `json:"amopmethod"`     // amopmethod
	Amopsortfamily pgtypes.Oid  `json:"amopsortfamily"` // amopsortfamily
}

// PgAmproc represents a row from 'pg_catalog.pg_amproc'.
type PgAmproc struct {
	Tableoid        pgtypes.Oid     `json:"tableoid"`        // tableoid
	Cmax            pgtypes.Cid     `json:"cmax"`            // cmax
	Xmax            pgtypes.Xid     `json:"xmax"`            // xmax
	Cmin            pgtypes.Cid     `json:"cmin"`            // cmin
	Xmin            pgtypes.Xid     `json:"xmin"`            // xmin
	Ctid            pgtypes.Tid     `json:"ctid"`            // ctid
	Oid             pgtypes.Oid     `json:"oid"`             // oid
	Amprocfamily    pgtypes.Oid     `json:"amprocfamily"`    // amprocfamily
	Amproclefttype  pgtypes.Oid     `json:"amproclefttype"`  // amproclefttype
	Amprocrighttype pgtypes.Oid     `json:"amprocrighttype"` // amprocrighttype
	Amprocnum       int16           `json:"amprocnum"`       // amprocnum
	Amproc          pgtypes.Regproc `json:"amproc"`          // amproc
}

// PgAttrdef represents a row from 'pg_catalog.pg_attrdef'.
type PgAttrdef struct {
	Tableoid pgtypes.Oid        `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid        `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid        `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid        `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid        `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid        `json:"ctid"`     // ctid
	Oid      pgtypes.Oid        `json:"oid"`      // oid
	Adrelid  pgtypes.Oid        `json:"adrelid"`  // adrelid
	Adnum    int16              `json:"adnum"`    // adnum
	Adbin    pgtypes.PgNodeTree `json:"adbin"`    // adbin
}

// PgAttribute represents a row from 'pg_catalog.pg_attribute'.
type PgAttribute struct {
	Tableoid      pgtypes.Oid           `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid           `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid           `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid           `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid           `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid           `json:"ctid"`          // ctid
	Attrelid      pgtypes.Oid           `json:"attrelid"`      // attrelid
	Attname       string                `json:"attname"`       // attname
	Atttypid      pgtypes.Oid           `json:"atttypid"`      // atttypid
	Attstattarget int                   `json:"attstattarget"` // attstattarget
	Attlen        int16                 `json:"attlen"`        // attlen
	Attnum        int16                 `json:"attnum"`        // attnum
	Attndims      int                   `json:"attndims"`      // attndims
	Attcacheoff   int                   `json:"attcacheoff"`   // attcacheoff
	Atttypmod     int                   `json:"atttypmod"`     // atttypmod
	Attbyval      bool                  `json:"attbyval"`      // attbyval
	Attstorage    pgtypes.Char          `json:"attstorage"`    // attstorage
	Attalign      pgtypes.Char          `json:"attalign"`      // attalign
	Attnotnull    bool                  `json:"attnotnull"`    // attnotnull
	Atthasdef     bool                  `json:"atthasdef"`     // atthasdef
	Atthasmissing bool                  `json:"atthasmissing"` // atthasmissing
	Attidentity   pgtypes.Char          `json:"attidentity"`   // attidentity
	Attgenerated  pgtypes.Char          `json:"attgenerated"`  // attgenerated
	Attisdropped  bool                  `json:"attisdropped"`  // attisdropped
	Attislocal    bool                  `json:"attislocal"`    // attislocal
	Attinhcount   int                   `json:"attinhcount"`   // attinhcount
	Attcollation  pgtypes.Oid           `json:"attcollation"`  // attcollation
	Attacl        []pgtypes.NullAclitem `json:"attacl"`        // attacl
	Attoptions    []sql.NullString      `json:"attoptions"`    // attoptions
	Attfdwoptions []sql.NullString      `json:"attfdwoptions"` // attfdwoptions
	Attmissingval pgtypes.NullAnyarray  `json:"attmissingval"` // attmissingval
}

// PgAuthMember represents a row from 'pg_catalog.pg_auth_members'.
type PgAuthMember struct {
	Tableoid    pgtypes.Oid `json:"tableoid"`     // tableoid
	Cmax        pgtypes.Cid `json:"cmax"`         // cmax
	Xmax        pgtypes.Xid `json:"xmax"`         // xmax
	Cmin        pgtypes.Cid `json:"cmin"`         // cmin
	Xmin        pgtypes.Xid `json:"xmin"`         // xmin
	Ctid        pgtypes.Tid `json:"ctid"`         // ctid
	Roleid      pgtypes.Oid `json:"roleid"`       // roleid
	Member      pgtypes.Oid `json:"member"`       // member
	Grantor     pgtypes.Oid `json:"grantor"`      // grantor
	AdminOption bool        `json:"admin_option"` // admin_option
}

// PgAuthid represents a row from 'pg_catalog.pg_authid'.
type PgAuthid struct {
	Tableoid       pgtypes.Oid    `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid    `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid    `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid    `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid    `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid    `json:"ctid"`           // ctid
	Oid            pgtypes.Oid    `json:"oid"`            // oid
	Rolname        string         `json:"rolname"`        // rolname
	Rolsuper       bool           `json:"rolsuper"`       // rolsuper
	Rolinherit     bool           `json:"rolinherit"`     // rolinherit
	Rolcreaterole  bool           `json:"rolcreaterole"`  // rolcreaterole
	Rolcreatedb    bool           `json:"rolcreatedb"`    // rolcreatedb
	Rolcanlogin    bool           `json:"rolcanlogin"`    // rolcanlogin
	Rolreplication bool           `json:"rolreplication"` // rolreplication
	Rolbypassrls   bool           `json:"rolbypassrls"`   // rolbypassrls
	Rolconnlimit   int            `json:"rolconnlimit"`   // rolconnlimit
	Rolpassword    sql.NullString `json:"rolpassword"`    // rolpassword
	Rolvaliduntil  sql.NullTime   `json:"rolvaliduntil"`  // rolvaliduntil
}

// PgAvailableExtension represents a row from 'pg_catalog.pg_available_extensions'.
type PgAvailableExtension struct {
	Name             sql.NullString `json:"name"`              // name
	DefaultVersion   sql.NullString `json:"default_version"`   // default_version
	InstalledVersion sql.NullString `json:"installed_version"` // installed_version
	Comment          sql.NullString `json:"comment"`           // comment
}

// PgAvailableExtensionVersion represents a row from 'pg_catalog.pg_available_extension_versions'.
type PgAvailableExtensionVersion struct {
	Name        sql.NullString   `json:"name"`        // name
	Version     sql.NullString   `json:"version"`     // version
	Installed   sql.NullBool     `json:"installed"`   // installed
	Superuser   sql.NullBool     `json:"superuser"`   // superuser
	Trusted     sql.NullBool     `json:"trusted"`     // trusted
	Relocatable sql.NullBool     `json:"relocatable"` // relocatable
	Schema      sql.NullString   `json:"schema"`      // schema
	Requires    []sql.NullString `json:"requires"`    // requires
	Comment     sql.NullString   `json:"comment"`     // comment
}

// PgCast represents a row from 'pg_catalog.pg_cast'.
type PgCast struct {
	Tableoid    pgtypes.Oid  `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid  `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid  `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid  `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid  `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid  `json:"ctid"`        // ctid
	Oid         pgtypes.Oid  `json:"oid"`         // oid
	Castsource  pgtypes.Oid  `json:"castsource"`  // castsource
	Casttarget  pgtypes.Oid  `json:"casttarget"`  // casttarget
	Castfunc    pgtypes.Oid  `json:"castfunc"`    // castfunc
	Castcontext pgtypes.Char `json:"castcontext"` // castcontext
	Castmethod  pgtypes.Char `json:"castmethod"`  // castmethod
}

// PgClass represents a row from 'pg_catalog.pg_class'.
type PgClass struct {
	Tableoid            pgtypes.Oid            `json:"tableoid"`            // tableoid
	Cmax                pgtypes.Cid            `json:"cmax"`                // cmax
	Xmax                pgtypes.Xid            `json:"xmax"`                // xmax
	Cmin                pgtypes.Cid            `json:"cmin"`                // cmin
	Xmin                pgtypes.Xid            `json:"xmin"`                // xmin
	Ctid                pgtypes.Tid            `json:"ctid"`                // ctid
	Oid                 pgtypes.Oid            `json:"oid"`                 // oid
	Relname             string                 `json:"relname"`             // relname
	Relnamespace        pgtypes.Oid            `json:"relnamespace"`        // relnamespace
	Reltype             pgtypes.Oid            `json:"reltype"`             // reltype
	Reloftype           pgtypes.Oid            `json:"reloftype"`           // reloftype
	Relowner            pgtypes.Oid            `json:"relowner"`            // relowner
	Relam               pgtypes.Oid            `json:"relam"`               // relam
	Relfilenode         pgtypes.Oid            `json:"relfilenode"`         // relfilenode
	Reltablespace       pgtypes.Oid            `json:"reltablespace"`       // reltablespace
	Relpages            int                    `json:"relpages"`            // relpages
	Reltuples           float32                `json:"reltuples"`           // reltuples
	Relallvisible       int                    `json:"relallvisible"`       // relallvisible
	Reltoastrelid       pgtypes.Oid            `json:"reltoastrelid"`       // reltoastrelid
	Relhasindex         bool                   `json:"relhasindex"`         // relhasindex
	Relisshared         bool                   `json:"relisshared"`         // relisshared
	Relpersistence      pgtypes.Char           `json:"relpersistence"`      // relpersistence
	Relkind             pgtypes.Char           `json:"relkind"`             // relkind
	Relnatts            int16                  `json:"relnatts"`            // relnatts
	Relchecks           int16                  `json:"relchecks"`           // relchecks
	Relhasrules         bool                   `json:"relhasrules"`         // relhasrules
	Relhastriggers      bool                   `json:"relhastriggers"`      // relhastriggers
	Relhassubclass      bool                   `json:"relhassubclass"`      // relhassubclass
	Relrowsecurity      bool                   `json:"relrowsecurity"`      // relrowsecurity
	Relforcerowsecurity bool                   `json:"relforcerowsecurity"` // relforcerowsecurity
	Relispopulated      bool                   `json:"relispopulated"`      // relispopulated
	Relreplident        pgtypes.Char           `json:"relreplident"`        // relreplident
	Relispartition      bool                   `json:"relispartition"`      // relispartition
	Relrewrite          pgtypes.Oid            `json:"relrewrite"`          // relrewrite
	Relfrozenxid        pgtypes.Xid            `json:"relfrozenxid"`        // relfrozenxid
	Relminmxid          pgtypes.Xid            `json:"relminmxid"`          // relminmxid
	Relacl              []pgtypes.NullAclitem  `json:"relacl"`              // relacl
	Reloptions          []sql.NullString       `json:"reloptions"`          // reloptions
	Relpartbound        pgtypes.NullPgNodeTree `json:"relpartbound"`        // relpartbound
}

// PgCollation represents a row from 'pg_catalog.pg_collation'.
type PgCollation struct {
	Tableoid            pgtypes.Oid    `json:"tableoid"`            // tableoid
	Cmax                pgtypes.Cid    `json:"cmax"`                // cmax
	Xmax                pgtypes.Xid    `json:"xmax"`                // xmax
	Cmin                pgtypes.Cid    `json:"cmin"`                // cmin
	Xmin                pgtypes.Xid    `json:"xmin"`                // xmin
	Ctid                pgtypes.Tid    `json:"ctid"`                // ctid
	Oid                 pgtypes.Oid    `json:"oid"`                 // oid
	Collname            string         `json:"collname"`            // collname
	Collnamespace       pgtypes.Oid    `json:"collnamespace"`       // collnamespace
	Collowner           pgtypes.Oid    `json:"collowner"`           // collowner
	Collprovider        pgtypes.Char   `json:"collprovider"`        // collprovider
	Collisdeterministic bool           `json:"collisdeterministic"` // collisdeterministic
	Collencoding        int            `json:"collencoding"`        // collencoding
	Collcollate         string         `json:"collcollate"`         // collcollate
	Collctype           string         `json:"collctype"`           // collctype
	Collversion         sql.NullString `json:"collversion"`         // collversion
}

// PgConfig represents a row from 'pg_catalog.pg_config'.
type PgConfig struct {
	Name    sql.NullString `json:"name"`    // name
	Setting sql.NullString `json:"setting"` // setting
}

// PgConstraint represents a row from 'pg_catalog.pg_constraint'.
type PgConstraint struct {
	Tableoid      pgtypes.Oid            `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid            `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid            `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid            `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid            `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid            `json:"ctid"`          // ctid
	Oid           pgtypes.Oid            `json:"oid"`           // oid
	Conname       string                 `json:"conname"`       // conname
	Connamespace  pgtypes.Oid            `json:"connamespace"`  // connamespace
	Contype       pgtypes.Char           `json:"contype"`       // contype
	Condeferrable bool                   `json:"condeferrable"` // condeferrable
	Condeferred   bool                   `json:"condeferred"`   // condeferred
	Convalidated  bool                   `json:"convalidated"`  // convalidated
	Conrelid      pgtypes.Oid            `json:"conrelid"`      // conrelid
	Contypid      pgtypes.Oid            `json:"contypid"`      // contypid
	Conindid      pgtypes.Oid            `json:"conindid"`      // conindid
	Conparentid   pgtypes.Oid            `json:"conparentid"`   // conparentid
	Confrelid     pgtypes.Oid            `json:"confrelid"`     // confrelid
	Confupdtype   pgtypes.Char           `json:"confupdtype"`   // confupdtype
	Confdeltype   pgtypes.Char           `json:"confdeltype"`   // confdeltype
	Confmatchtype pgtypes.Char           `json:"confmatchtype"` // confmatchtype
	Conislocal    bool                   `json:"conislocal"`    // conislocal
	Coninhcount   int                    `json:"coninhcount"`   // coninhcount
	Connoinherit  bool                   `json:"connoinherit"`  // connoinherit
	Conkey        []sql.NullInt64        `json:"conkey"`        // conkey
	Confkey       []sql.NullInt64        `json:"confkey"`       // confkey
	Conpfeqop     []pgtypes.NullOid      `json:"conpfeqop"`     // conpfeqop
	Conppeqop     []pgtypes.NullOid      `json:"conppeqop"`     // conppeqop
	Conffeqop     []pgtypes.NullOid      `json:"conffeqop"`     // conffeqop
	Conexclop     []pgtypes.NullOid      `json:"conexclop"`     // conexclop
	Conbin        pgtypes.NullPgNodeTree `json:"conbin"`        // conbin
}

// PgConversion represents a row from 'pg_catalog.pg_conversion'.
type PgConversion struct {
	Tableoid       pgtypes.Oid     `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid     `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid     `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid     `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid     `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid     `json:"ctid"`           // ctid
	Oid            pgtypes.Oid     `json:"oid"`            // oid
	Conname        string          `json:"conname"`        // conname
	Connamespace   pgtypes.Oid     `json:"connamespace"`   // connamespace
	Conowner       pgtypes.Oid     `json:"conowner"`       // conowner
	Conforencoding int             `json:"conforencoding"` // conforencoding
	Contoencoding  int             `json:"contoencoding"`  // contoencoding
	Conproc        pgtypes.Regproc `json:"conproc"`        // conproc
	Condefault     bool            `json:"condefault"`     // condefault
}

// PgCursor represents a row from 'pg_catalog.pg_cursors'.
type PgCursor struct {
	Name         sql.NullString `json:"name"`          // name
	Statement    sql.NullString `json:"statement"`     // statement
	IsHoldable   sql.NullBool   `json:"is_holdable"`   // is_holdable
	IsBinary     sql.NullBool   `json:"is_binary"`     // is_binary
	IsScrollable sql.NullBool   `json:"is_scrollable"` // is_scrollable
	CreationTime sql.NullTime   `json:"creation_time"` // creation_time
}

// PgDatabase represents a row from 'pg_catalog.pg_database'.
type PgDatabase struct {
	Tableoid      pgtypes.Oid           `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid           `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid           `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid           `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid           `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid           `json:"ctid"`          // ctid
	Oid           pgtypes.Oid           `json:"oid"`           // oid
	Datname       string                `json:"datname"`       // datname
	Datdba        pgtypes.Oid           `json:"datdba"`        // datdba
	Encoding      int                   `json:"encoding"`      // encoding
	Datcollate    string                `json:"datcollate"`    // datcollate
	Datctype      string                `json:"datctype"`      // datctype
	Datistemplate bool                  `json:"datistemplate"` // datistemplate
	Datallowconn  bool                  `json:"datallowconn"`  // datallowconn
	Datconnlimit  int                   `json:"datconnlimit"`  // datconnlimit
	Datlastsysoid pgtypes.Oid           `json:"datlastsysoid"` // datlastsysoid
	Datfrozenxid  pgtypes.Xid           `json:"datfrozenxid"`  // datfrozenxid
	Datminmxid    pgtypes.Xid           `json:"datminmxid"`    // datminmxid
	Dattablespace pgtypes.Oid           `json:"dattablespace"` // dattablespace
	Datacl        []pgtypes.NullAclitem `json:"datacl"`        // datacl
}

// PgDbRoleSetting represents a row from 'pg_catalog.pg_db_role_setting'.
type PgDbRoleSetting struct {
	Tableoid    pgtypes.Oid      `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid      `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid      `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid      `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid      `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid      `json:"ctid"`        // ctid
	Setdatabase pgtypes.Oid      `json:"setdatabase"` // setdatabase
	Setrole     pgtypes.Oid      `json:"setrole"`     // setrole
	Setconfig   []sql.NullString `json:"setconfig"`   // setconfig
}

// PgDefaultACL represents a row from 'pg_catalog.pg_default_acl'.
type PgDefaultACL struct {
	Tableoid        pgtypes.Oid       `json:"tableoid"`        // tableoid
	Cmax            pgtypes.Cid       `json:"cmax"`            // cmax
	Xmax            pgtypes.Xid       `json:"xmax"`            // xmax
	Cmin            pgtypes.Cid       `json:"cmin"`            // cmin
	Xmin            pgtypes.Xid       `json:"xmin"`            // xmin
	Ctid            pgtypes.Tid       `json:"ctid"`            // ctid
	Oid             pgtypes.Oid       `json:"oid"`             // oid
	Defaclrole      pgtypes.Oid       `json:"defaclrole"`      // defaclrole
	Defaclnamespace pgtypes.Oid       `json:"defaclnamespace"` // defaclnamespace
	Defaclobjtype   pgtypes.Char      `json:"defaclobjtype"`   // defaclobjtype
	Defaclacl       []pgtypes.Aclitem `json:"defaclacl"`       // defaclacl
}

// PgDepend represents a row from 'pg_catalog.pg_depend'.
type PgDepend struct {
	Tableoid    pgtypes.Oid  `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid  `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid  `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid  `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid  `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid  `json:"ctid"`        // ctid
	Classid     pgtypes.Oid  `json:"classid"`     // classid
	Objid       pgtypes.Oid  `json:"objid"`       // objid
	Objsubid    int          `json:"objsubid"`    // objsubid
	Refclassid  pgtypes.Oid  `json:"refclassid"`  // refclassid
	Refobjid    pgtypes.Oid  `json:"refobjid"`    // refobjid
	Refobjsubid int          `json:"refobjsubid"` // refobjsubid
	Deptype     pgtypes.Char `json:"deptype"`     // deptype
}

// PgDescription represents a row from 'pg_catalog.pg_description'.
type PgDescription struct {
	Tableoid    pgtypes.Oid `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid `json:"ctid"`        // ctid
	Objoid      pgtypes.Oid `json:"objoid"`      // objoid
	Classoid    pgtypes.Oid `json:"classoid"`    // classoid
	Objsubid    int         `json:"objsubid"`    // objsubid
	Description string      `json:"description"` // description
}

// PgEnum represents a row from 'pg_catalog.pg_enum'.
type PgEnum struct {
	Tableoid      pgtypes.Oid `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid `json:"ctid"`          // ctid
	Oid           pgtypes.Oid `json:"oid"`           // oid
	Enumtypid     pgtypes.Oid `json:"enumtypid"`     // enumtypid
	Enumsortorder float32     `json:"enumsortorder"` // enumsortorder
	Enumlabel     string      `json:"enumlabel"`     // enumlabel
}

// PgEventTrigger represents a row from 'pg_catalog.pg_event_trigger'.
type PgEventTrigger struct {
	Tableoid   pgtypes.Oid      `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid      `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid      `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid      `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid      `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid      `json:"ctid"`       // ctid
	Oid        pgtypes.Oid      `json:"oid"`        // oid
	Evtname    string           `json:"evtname"`    // evtname
	Evtevent   string           `json:"evtevent"`   // evtevent
	Evtowner   pgtypes.Oid      `json:"evtowner"`   // evtowner
	Evtfoid    pgtypes.Oid      `json:"evtfoid"`    // evtfoid
	Evtenabled pgtypes.Char     `json:"evtenabled"` // evtenabled
	Evttags    []sql.NullString `json:"evttags"`    // evttags
}

// PgExtension represents a row from 'pg_catalog.pg_extension'.
type PgExtension struct {
	Tableoid       pgtypes.Oid       `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid       `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid       `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid       `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid       `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid       `json:"ctid"`           // ctid
	Oid            pgtypes.Oid       `json:"oid"`            // oid
	Extname        string            `json:"extname"`        // extname
	Extowner       pgtypes.Oid       `json:"extowner"`       // extowner
	Extnamespace   pgtypes.Oid       `json:"extnamespace"`   // extnamespace
	Extrelocatable bool              `json:"extrelocatable"` // extrelocatable
	Extversion     string            `json:"extversion"`     // extversion
	Extconfig      []pgtypes.NullOid `json:"extconfig"`      // extconfig
	Extcondition   []sql.NullString  `json:"extcondition"`   // extcondition
}

// PgFileSetting represents a row from 'pg_catalog.pg_file_settings'.
type PgFileSetting struct {
	Sourcefile sql.NullString `json:"sourcefile"` // sourcefile
	Sourceline sql.NullInt64  `json:"sourceline"` // sourceline
	Seqno      sql.NullInt64  `json:"seqno"`      // seqno
	Name       sql.NullString `json:"name"`       // name
	Setting    sql.NullString `json:"setting"`    // setting
	Applied    sql.NullBool   `json:"applied"`    // applied
	Error      sql.NullString `json:"error"`      // error
}

// PgForeignDataWrapper represents a row from 'pg_catalog.pg_foreign_data_wrapper'.
type PgForeignDataWrapper struct {
	Tableoid     pgtypes.Oid           `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid           `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid           `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid           `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid           `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid           `json:"ctid"`         // ctid
	Oid          pgtypes.Oid           `json:"oid"`          // oid
	Fdwname      string                `json:"fdwname"`      // fdwname
	Fdwowner     pgtypes.Oid           `json:"fdwowner"`     // fdwowner
	Fdwhandler   pgtypes.Oid           `json:"fdwhandler"`   // fdwhandler
	Fdwvalidator pgtypes.Oid           `json:"fdwvalidator"` // fdwvalidator
	Fdwacl       []pgtypes.NullAclitem `json:"fdwacl"`       // fdwacl
	Fdwoptions   []sql.NullString      `json:"fdwoptions"`   // fdwoptions
}

// PgForeignServer represents a row from 'pg_catalog.pg_foreign_server'.
type PgForeignServer struct {
	Tableoid   pgtypes.Oid           `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid           `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid           `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid           `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid           `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid           `json:"ctid"`       // ctid
	Oid        pgtypes.Oid           `json:"oid"`        // oid
	Srvname    string                `json:"srvname"`    // srvname
	Srvowner   pgtypes.Oid           `json:"srvowner"`   // srvowner
	Srvfdw     pgtypes.Oid           `json:"srvfdw"`     // srvfdw
	Srvtype    sql.NullString        `json:"srvtype"`    // srvtype
	Srvversion sql.NullString        `json:"srvversion"` // srvversion
	Srvacl     []pgtypes.NullAclitem `json:"srvacl"`     // srvacl
	Srvoptions []sql.NullString      `json:"srvoptions"` // srvoptions
}

// PgForeignTable represents a row from 'pg_catalog.pg_foreign_table'.
type PgForeignTable struct {
	Tableoid  pgtypes.Oid      `json:"tableoid"`  // tableoid
	Cmax      pgtypes.Cid      `json:"cmax"`      // cmax
	Xmax      pgtypes.Xid      `json:"xmax"`      // xmax
	Cmin      pgtypes.Cid      `json:"cmin"`      // cmin
	Xmin      pgtypes.Xid      `json:"xmin"`      // xmin
	Ctid      pgtypes.Tid      `json:"ctid"`      // ctid
	Ftrelid   pgtypes.Oid      `json:"ftrelid"`   // ftrelid
	Ftserver  pgtypes.Oid      `json:"ftserver"`  // ftserver
	Ftoptions []sql.NullString `json:"ftoptions"` // ftoptions
}

// PgGroup represents a row from 'pg_catalog.pg_group'.
type PgGroup struct {
	Groname  sql.NullString    `json:"groname"`  // groname
	Grosysid pgtypes.NullOid   `json:"grosysid"` // grosysid
	Grolist  []pgtypes.NullOid `json:"grolist"`  // grolist
}

// PgHbaFileRule represents a row from 'pg_catalog.pg_hba_file_rules'.
type PgHbaFileRule struct {
	LineNumber sql.NullInt64    `json:"line_number"` // line_number
	Type       sql.NullString   `json:"type"`        // type
	Database   []sql.NullString `json:"database"`    // database
	UserName   []sql.NullString `json:"user_name"`   // user_name
	Address    sql.NullString   `json:"address"`     // address
	Netmask    sql.NullString   `json:"netmask"`     // netmask
	AuthMethod sql.NullString   `json:"auth_method"` // auth_method
	Options    []sql.NullString `json:"options"`     // options
	Error      sql.NullString   `json:"error"`       // error
}

// PgIndex represents a row from 'pg_catalog.pg_indexes'.
type PgIndex struct {
	Schemaname sql.NullString `json:"schemaname"` // schemaname
	Tablename  sql.NullString `json:"tablename"`  // tablename
	Indexname  sql.NullString `json:"indexname"`  // indexname
	Tablespace sql.NullString `json:"tablespace"` // tablespace
	Indexdef   sql.NullString `json:"indexdef"`   // indexdef
}

// PgIndex represents a row from 'pg_catalog.pg_index'.
type PgIndex struct {
	Tableoid       pgtypes.Oid            `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid            `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid            `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid            `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid            `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid            `json:"ctid"`           // ctid
	Indexrelid     pgtypes.Oid            `json:"indexrelid"`     // indexrelid
	Indrelid       pgtypes.Oid            `json:"indrelid"`       // indrelid
	Indnatts       int16                  `json:"indnatts"`       // indnatts
	Indnkeyatts    int16                  `json:"indnkeyatts"`    // indnkeyatts
	Indisunique    bool                   `json:"indisunique"`    // indisunique
	Indisprimary   bool                   `json:"indisprimary"`   // indisprimary
	Indisexclusion bool                   `json:"indisexclusion"` // indisexclusion
	Indimmediate   bool                   `json:"indimmediate"`   // indimmediate
	Indisclustered bool                   `json:"indisclustered"` // indisclustered
	Indisvalid     bool                   `json:"indisvalid"`     // indisvalid
	Indcheckxmin   bool                   `json:"indcheckxmin"`   // indcheckxmin
	Indisready     bool                   `json:"indisready"`     // indisready
	Indislive      bool                   `json:"indislive"`      // indislive
	Indisreplident bool                   `json:"indisreplident"` // indisreplident
	Indkey         pgtypes.Int2vector     `json:"indkey"`         // indkey
	Indcollation   pgtypes.Oidvector      `json:"indcollation"`   // indcollation
	Indclass       pgtypes.Oidvector      `json:"indclass"`       // indclass
	Indoption      pgtypes.Int2vector     `json:"indoption"`      // indoption
	Indexprs       pgtypes.NullPgNodeTree `json:"indexprs"`       // indexprs
	Indpred        pgtypes.NullPgNodeTree `json:"indpred"`        // indpred
}

// PgInherit represents a row from 'pg_catalog.pg_inherits'.
type PgInherit struct {
	Tableoid  pgtypes.Oid `json:"tableoid"`  // tableoid
	Cmax      pgtypes.Cid `json:"cmax"`      // cmax
	Xmax      pgtypes.Xid `json:"xmax"`      // xmax
	Cmin      pgtypes.Cid `json:"cmin"`      // cmin
	Xmin      pgtypes.Xid `json:"xmin"`      // xmin
	Ctid      pgtypes.Tid `json:"ctid"`      // ctid
	Inhrelid  pgtypes.Oid `json:"inhrelid"`  // inhrelid
	Inhparent pgtypes.Oid `json:"inhparent"` // inhparent
	Inhseqno  int         `json:"inhseqno"`  // inhseqno
}

// PgInitPriv represents a row from 'pg_catalog.pg_init_privs'.
type PgInitPriv struct {
	Tableoid  pgtypes.Oid       `json:"tableoid"`  // tableoid
	Cmax      pgtypes.Cid       `json:"cmax"`      // cmax
	Xmax      pgtypes.Xid       `json:"xmax"`      // xmax
	Cmin      pgtypes.Cid       `json:"cmin"`      // cmin
	Xmin      pgtypes.Xid       `json:"xmin"`      // xmin
	Ctid      pgtypes.Tid       `json:"ctid"`      // ctid
	Objoid    pgtypes.Oid       `json:"objoid"`    // objoid
	Classoid  pgtypes.Oid       `json:"classoid"`  // classoid
	Objsubid  int               `json:"objsubid"`  // objsubid
	Privtype  pgtypes.Char      `json:"privtype"`  // privtype
	Initprivs []pgtypes.Aclitem `json:"initprivs"` // initprivs
}

// PgLanguage represents a row from 'pg_catalog.pg_language'.
type PgLanguage struct {
	Tableoid      pgtypes.Oid           `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid           `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid           `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid           `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid           `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid           `json:"ctid"`          // ctid
	Oid           pgtypes.Oid           `json:"oid"`           // oid
	Lanname       string                `json:"lanname"`       // lanname
	Lanowner      pgtypes.Oid           `json:"lanowner"`      // lanowner
	Lanispl       bool                  `json:"lanispl"`       // lanispl
	Lanpltrusted  bool                  `json:"lanpltrusted"`  // lanpltrusted
	Lanplcallfoid pgtypes.Oid           `json:"lanplcallfoid"` // lanplcallfoid
	Laninline     pgtypes.Oid           `json:"laninline"`     // laninline
	Lanvalidator  pgtypes.Oid           `json:"lanvalidator"`  // lanvalidator
	Lanacl        []pgtypes.NullAclitem `json:"lanacl"`        // lanacl
}

// PgLargeobject represents a row from 'pg_catalog.pg_largeobject'.
type PgLargeobject struct {
	Tableoid pgtypes.Oid `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid `json:"ctid"`     // ctid
	Loid     pgtypes.Oid `json:"loid"`     // loid
	Pageno   int         `json:"pageno"`   // pageno
	Data     []byte      `json:"data"`     // data
}

// PgLargeobjectMetadatum represents a row from 'pg_catalog.pg_largeobject_metadata'.
type PgLargeobjectMetadatum struct {
	Tableoid pgtypes.Oid           `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid           `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid           `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid           `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid           `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid           `json:"ctid"`     // ctid
	Oid      pgtypes.Oid           `json:"oid"`      // oid
	Lomowner pgtypes.Oid           `json:"lomowner"` // lomowner
	Lomacl   []pgtypes.NullAclitem `json:"lomacl"`   // lomacl
}

// PgLock represents a row from 'pg_catalog.pg_locks'.
type PgLock struct {
	Locktype           sql.NullString  `json:"locktype"`           // locktype
	Database           pgtypes.NullOid `json:"database"`           // database
	Relation           pgtypes.NullOid `json:"relation"`           // relation
	Page               sql.NullInt64   `json:"page"`               // page
	Tuple              sql.NullInt64   `json:"tuple"`              // tuple
	Virtualxid         sql.NullString  `json:"virtualxid"`         // virtualxid
	Transactionid      pgtypes.NullXid `json:"transactionid"`      // transactionid
	Classid            pgtypes.NullOid `json:"classid"`            // classid
	Objid              pgtypes.NullOid `json:"objid"`              // objid
	Objsubid           sql.NullInt64   `json:"objsubid"`           // objsubid
	Virtualtransaction sql.NullString  `json:"virtualtransaction"` // virtualtransaction
	Pid                sql.NullInt64   `json:"pid"`                // pid
	Mode               sql.NullString  `json:"mode"`               // mode
	Granted            sql.NullBool    `json:"granted"`            // granted
	Fastpath           sql.NullBool    `json:"fastpath"`           // fastpath
}

// PgMatview represents a row from 'pg_catalog.pg_matviews'.
type PgMatview struct {
	Schemaname   sql.NullString `json:"schemaname"`   // schemaname
	Matviewname  sql.NullString `json:"matviewname"`  // matviewname
	Matviewowner sql.NullString `json:"matviewowner"` // matviewowner
	Tablespace   sql.NullString `json:"tablespace"`   // tablespace
	Hasindexes   sql.NullBool   `json:"hasindexes"`   // hasindexes
	Ispopulated  sql.NullBool   `json:"ispopulated"`  // ispopulated
	Definition   sql.NullString `json:"definition"`   // definition
}

// PgNamespace represents a row from 'pg_catalog.pg_namespace'.
type PgNamespace struct {
	Tableoid pgtypes.Oid           `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid           `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid           `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid           `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid           `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid           `json:"ctid"`     // ctid
	Oid      pgtypes.Oid           `json:"oid"`      // oid
	Nspname  string                `json:"nspname"`  // nspname
	Nspowner pgtypes.Oid           `json:"nspowner"` // nspowner
	Nspacl   []pgtypes.NullAclitem `json:"nspacl"`   // nspacl
}

// PgOpclass represents a row from 'pg_catalog.pg_opclass'.
type PgOpclass struct {
	Tableoid     pgtypes.Oid `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid `json:"ctid"`         // ctid
	Oid          pgtypes.Oid `json:"oid"`          // oid
	Opcmethod    pgtypes.Oid `json:"opcmethod"`    // opcmethod
	Opcname      string      `json:"opcname"`      // opcname
	Opcnamespace pgtypes.Oid `json:"opcnamespace"` // opcnamespace
	Opcowner     pgtypes.Oid `json:"opcowner"`     // opcowner
	Opcfamily    pgtypes.Oid `json:"opcfamily"`    // opcfamily
	Opcintype    pgtypes.Oid `json:"opcintype"`    // opcintype
	Opcdefault   bool        `json:"opcdefault"`   // opcdefault
	Opckeytype   pgtypes.Oid `json:"opckeytype"`   // opckeytype
}

// PgOperator represents a row from 'pg_catalog.pg_operator'.
type PgOperator struct {
	Tableoid     pgtypes.Oid     `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid     `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid     `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid     `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid     `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid     `json:"ctid"`         // ctid
	Oid          pgtypes.Oid     `json:"oid"`          // oid
	Oprname      string          `json:"oprname"`      // oprname
	Oprnamespace pgtypes.Oid     `json:"oprnamespace"` // oprnamespace
	Oprowner     pgtypes.Oid     `json:"oprowner"`     // oprowner
	Oprkind      pgtypes.Char    `json:"oprkind"`      // oprkind
	Oprcanmerge  bool            `json:"oprcanmerge"`  // oprcanmerge
	Oprcanhash   bool            `json:"oprcanhash"`   // oprcanhash
	Oprleft      pgtypes.Oid     `json:"oprleft"`      // oprleft
	Oprright     pgtypes.Oid     `json:"oprright"`     // oprright
	Oprresult    pgtypes.Oid     `json:"oprresult"`    // oprresult
	Oprcom       pgtypes.Oid     `json:"oprcom"`       // oprcom
	Oprnegate    pgtypes.Oid     `json:"oprnegate"`    // oprnegate
	Oprcode      pgtypes.Regproc `json:"oprcode"`      // oprcode
	Oprrest      pgtypes.Regproc `json:"oprrest"`      // oprrest
	Oprjoin      pgtypes.Regproc `json:"oprjoin"`      // oprjoin
}

// PgOpfamily represents a row from 'pg_catalog.pg_opfamily'.
type PgOpfamily struct {
	Tableoid     pgtypes.Oid `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid `json:"ctid"`         // ctid
	Oid          pgtypes.Oid `json:"oid"`          // oid
	Opfmethod    pgtypes.Oid `json:"opfmethod"`    // opfmethod
	Opfname      string      `json:"opfname"`      // opfname
	Opfnamespace pgtypes.Oid `json:"opfnamespace"` // opfnamespace
	Opfowner     pgtypes.Oid `json:"opfowner"`     // opfowner
}

// PgPartitionedTable represents a row from 'pg_catalog.pg_partitioned_table'.
type PgPartitionedTable struct {
	Tableoid      pgtypes.Oid            `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid            `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid            `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid            `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid            `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid            `json:"ctid"`          // ctid
	Partrelid     pgtypes.Oid            `json:"partrelid"`     // partrelid
	Partstrat     pgtypes.Char           `json:"partstrat"`     // partstrat
	Partnatts     int16                  `json:"partnatts"`     // partnatts
	Partdefid     pgtypes.Oid            `json:"partdefid"`     // partdefid
	Partattrs     pgtypes.Int2vector     `json:"partattrs"`     // partattrs
	Partclass     pgtypes.Oidvector      `json:"partclass"`     // partclass
	Partcollation pgtypes.Oidvector      `json:"partcollation"` // partcollation
	Partexprs     pgtypes.NullPgNodeTree `json:"partexprs"`     // partexprs
}

// PgPolicy represents a row from 'pg_catalog.pg_policies'.
type PgPolicy struct {
	Schemaname sql.NullString   `json:"schemaname"` // schemaname
	Tablename  sql.NullString   `json:"tablename"`  // tablename
	Policyname sql.NullString   `json:"policyname"` // policyname
	Permissive sql.NullString   `json:"permissive"` // permissive
	Roles      []sql.NullString `json:"roles"`      // roles
	Cmd        sql.NullString   `json:"cmd"`        // cmd
	Qual       sql.NullString   `json:"qual"`       // qual
	WithCheck  sql.NullString   `json:"with_check"` // with_check
}

// PgPolicy represents a row from 'pg_catalog.pg_policy'.
type PgPolicy struct {
	Tableoid      pgtypes.Oid            `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid            `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid            `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid            `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid            `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid            `json:"ctid"`          // ctid
	Oid           pgtypes.Oid            `json:"oid"`           // oid
	Polname       string                 `json:"polname"`       // polname
	Polrelid      pgtypes.Oid            `json:"polrelid"`      // polrelid
	Polcmd        pgtypes.Char           `json:"polcmd"`        // polcmd
	Polpermissive bool                   `json:"polpermissive"` // polpermissive
	Polroles      []pgtypes.Oid          `json:"polroles"`      // polroles
	Polqual       pgtypes.NullPgNodeTree `json:"polqual"`       // polqual
	Polwithcheck  pgtypes.NullPgNodeTree `json:"polwithcheck"`  // polwithcheck
}

// PgPreparedStatement represents a row from 'pg_catalog.pg_prepared_statements'.
type PgPreparedStatement struct {
	Name           sql.NullString        `json:"name"`            // name
	Statement      sql.NullString        `json:"statement"`       // statement
	PrepareTime    sql.NullTime          `json:"prepare_time"`    // prepare_time
	ParameterTypes []pgtypes.NullRegtype `json:"parameter_types"` // parameter_types
	FromSQL        sql.NullBool          `json:"from_sql"`        // from_sql
}

// PgPreparedXact represents a row from 'pg_catalog.pg_prepared_xacts'.
type PgPreparedXact struct {
	Transaction pgtypes.NullXid `json:"transaction"` // transaction
	Gid         sql.NullString  `json:"gid"`         // gid
	Prepared    sql.NullTime    `json:"prepared"`    // prepared
	Owner       sql.NullString  `json:"owner"`       // owner
	Database    sql.NullString  `json:"database"`    // database
}

// PgProc represents a row from 'pg_catalog.pg_proc'.
type PgProc struct {
	Tableoid        pgtypes.Oid            `json:"tableoid"`        // tableoid
	Cmax            pgtypes.Cid            `json:"cmax"`            // cmax
	Xmax            pgtypes.Xid            `json:"xmax"`            // xmax
	Cmin            pgtypes.Cid            `json:"cmin"`            // cmin
	Xmin            pgtypes.Xid            `json:"xmin"`            // xmin
	Ctid            pgtypes.Tid            `json:"ctid"`            // ctid
	Oid             pgtypes.Oid            `json:"oid"`             // oid
	Proname         string                 `json:"proname"`         // proname
	Pronamespace    pgtypes.Oid            `json:"pronamespace"`    // pronamespace
	Proowner        pgtypes.Oid            `json:"proowner"`        // proowner
	Prolang         pgtypes.Oid            `json:"prolang"`         // prolang
	Procost         float32                `json:"procost"`         // procost
	Prorows         float32                `json:"prorows"`         // prorows
	Provariadic     pgtypes.Oid            `json:"provariadic"`     // provariadic
	Prosupport      pgtypes.Regproc        `json:"prosupport"`      // prosupport
	Prokind         pgtypes.Char           `json:"prokind"`         // prokind
	Prosecdef       bool                   `json:"prosecdef"`       // prosecdef
	Proleakproof    bool                   `json:"proleakproof"`    // proleakproof
	Proisstrict     bool                   `json:"proisstrict"`     // proisstrict
	Proretset       bool                   `json:"proretset"`       // proretset
	Provolatile     pgtypes.Char           `json:"provolatile"`     // provolatile
	Proparallel     pgtypes.Char           `json:"proparallel"`     // proparallel
	Pronargs        int16                  `json:"pronargs"`        // pronargs
	Pronargdefaults int16                  `json:"pronargdefaults"` // pronargdefaults
	Prorettype      pgtypes.Oid            `json:"prorettype"`      // prorettype
	Proargtypes     pgtypes.Oidvector      `json:"proargtypes"`     // proargtypes
	Proallargtypes  []pgtypes.NullOid      `json:"proallargtypes"`  // proallargtypes
	Proargmodes     []pgtypes.NullChar     `json:"proargmodes"`     // proargmodes
	Proargnames     []sql.NullString       `json:"proargnames"`     // proargnames
	Proargdefaults  pgtypes.NullPgNodeTree `json:"proargdefaults"`  // proargdefaults
	Protrftypes     []pgtypes.NullOid      `json:"protrftypes"`     // protrftypes
	Prosrc          string                 `json:"prosrc"`          // prosrc
	Probin          sql.NullString         `json:"probin"`          // probin
	Proconfig       []sql.NullString       `json:"proconfig"`       // proconfig
	Proacl          []pgtypes.NullAclitem  `json:"proacl"`          // proacl
}

// PgPublication represents a row from 'pg_catalog.pg_publication'.
type PgPublication struct {
	Tableoid     pgtypes.Oid `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid `json:"ctid"`         // ctid
	Oid          pgtypes.Oid `json:"oid"`          // oid
	Pubname      string      `json:"pubname"`      // pubname
	Pubowner     pgtypes.Oid `json:"pubowner"`     // pubowner
	Puballtables bool        `json:"puballtables"` // puballtables
	Pubinsert    bool        `json:"pubinsert"`    // pubinsert
	Pubupdate    bool        `json:"pubupdate"`    // pubupdate
	Pubdelete    bool        `json:"pubdelete"`    // pubdelete
	Pubtruncate  bool        `json:"pubtruncate"`  // pubtruncate
	Pubviaroot   bool        `json:"pubviaroot"`   // pubviaroot
}

// PgPublicationRel represents a row from 'pg_catalog.pg_publication_rel'.
type PgPublicationRel struct {
	Tableoid pgtypes.Oid `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid `json:"ctid"`     // ctid
	Oid      pgtypes.Oid `json:"oid"`      // oid
	Prpubid  pgtypes.Oid `json:"prpubid"`  // prpubid
	Prrelid  pgtypes.Oid `json:"prrelid"`  // prrelid
}

// PgPublicationTable represents a row from 'pg_catalog.pg_publication_tables'.
type PgPublicationTable struct {
	Pubname    sql.NullString `json:"pubname"`    // pubname
	Schemaname sql.NullString `json:"schemaname"` // schemaname
	Tablename  sql.NullString `json:"tablename"`  // tablename
}

// PgRange represents a row from 'pg_catalog.pg_range'.
type PgRange struct {
	Tableoid     pgtypes.Oid     `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid     `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid     `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid     `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid     `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid     `json:"ctid"`         // ctid
	Rngtypid     pgtypes.Oid     `json:"rngtypid"`     // rngtypid
	Rngsubtype   pgtypes.Oid     `json:"rngsubtype"`   // rngsubtype
	Rngcollation pgtypes.Oid     `json:"rngcollation"` // rngcollation
	Rngsubopc    pgtypes.Oid     `json:"rngsubopc"`    // rngsubopc
	Rngcanonical pgtypes.Regproc `json:"rngcanonical"` // rngcanonical
	Rngsubdiff   pgtypes.Regproc `json:"rngsubdiff"`   // rngsubdiff
}

// PgReplicationOrigin represents a row from 'pg_catalog.pg_replication_origin'.
type PgReplicationOrigin struct {
	Tableoid pgtypes.Oid `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid `json:"ctid"`     // ctid
	Roident  pgtypes.Oid `json:"roident"`  // roident
	Roname   string      `json:"roname"`   // roname
}

// PgReplicationOriginStatus represents a row from 'pg_catalog.pg_replication_origin_status'.
type PgReplicationOriginStatus struct {
	LocalID    pgtypes.NullOid   `json:"local_id"`    // local_id
	ExternalID sql.NullString    `json:"external_id"` // external_id
	RemoteLsn  pgtypes.NullPgLsn `json:"remote_lsn"`  // remote_lsn
	LocalLsn   pgtypes.NullPgLsn `json:"local_lsn"`   // local_lsn
}

// PgReplicationSlot represents a row from 'pg_catalog.pg_replication_slots'.
type PgReplicationSlot struct {
	SlotName          sql.NullString    `json:"slot_name"`           // slot_name
	Plugin            sql.NullString    `json:"plugin"`              // plugin
	SlotType          sql.NullString    `json:"slot_type"`           // slot_type
	Datoid            pgtypes.NullOid   `json:"datoid"`              // datoid
	Database          sql.NullString    `json:"database"`            // database
	Temporary         sql.NullBool      `json:"temporary"`           // temporary
	Active            sql.NullBool      `json:"active"`              // active
	ActivePid         sql.NullInt64     `json:"active_pid"`          // active_pid
	Xmin              pgtypes.NullXid   `json:"xmin"`                // xmin
	CatalogXmin       pgtypes.NullXid   `json:"catalog_xmin"`        // catalog_xmin
	RestartLsn        pgtypes.NullPgLsn `json:"restart_lsn"`         // restart_lsn
	ConfirmedFlushLsn pgtypes.NullPgLsn `json:"confirmed_flush_lsn"` // confirmed_flush_lsn
	WalStatus         sql.NullString    `json:"wal_status"`          // wal_status
	SafeWalSize       sql.NullInt64     `json:"safe_wal_size"`       // safe_wal_size
}

// PgRewrite represents a row from 'pg_catalog.pg_rewrite'.
type PgRewrite struct {
	Tableoid  pgtypes.Oid        `json:"tableoid"`   // tableoid
	Cmax      pgtypes.Cid        `json:"cmax"`       // cmax
	Xmax      pgtypes.Xid        `json:"xmax"`       // xmax
	Cmin      pgtypes.Cid        `json:"cmin"`       // cmin
	Xmin      pgtypes.Xid        `json:"xmin"`       // xmin
	Ctid      pgtypes.Tid        `json:"ctid"`       // ctid
	Oid       pgtypes.Oid        `json:"oid"`        // oid
	Rulename  string             `json:"rulename"`   // rulename
	EvClass   pgtypes.Oid        `json:"ev_class"`   // ev_class
	EvType    pgtypes.Char       `json:"ev_type"`    // ev_type
	EvEnabled pgtypes.Char       `json:"ev_enabled"` // ev_enabled
	IsInstead bool               `json:"is_instead"` // is_instead
	EvQual    pgtypes.PgNodeTree `json:"ev_qual"`    // ev_qual
	EvAction  pgtypes.PgNodeTree `json:"ev_action"`  // ev_action
}

// PgRole represents a row from 'pg_catalog.pg_roles'.
type PgRole struct {
	Rolname        sql.NullString   `json:"rolname"`        // rolname
	Rolsuper       sql.NullBool     `json:"rolsuper"`       // rolsuper
	Rolinherit     sql.NullBool     `json:"rolinherit"`     // rolinherit
	Rolcreaterole  sql.NullBool     `json:"rolcreaterole"`  // rolcreaterole
	Rolcreatedb    sql.NullBool     `json:"rolcreatedb"`    // rolcreatedb
	Rolcanlogin    sql.NullBool     `json:"rolcanlogin"`    // rolcanlogin
	Rolreplication sql.NullBool     `json:"rolreplication"` // rolreplication
	Rolconnlimit   sql.NullInt64    `json:"rolconnlimit"`   // rolconnlimit
	Rolpassword    sql.NullString   `json:"rolpassword"`    // rolpassword
	Rolvaliduntil  sql.NullTime     `json:"rolvaliduntil"`  // rolvaliduntil
	Rolbypassrls   sql.NullBool     `json:"rolbypassrls"`   // rolbypassrls
	Rolconfig      []sql.NullString `json:"rolconfig"`      // rolconfig
	Oid            pgtypes.NullOid  `json:"oid"`            // oid
}

// PgRule represents a row from 'pg_catalog.pg_rules'.
type PgRule struct {
	Schemaname sql.NullString `json:"schemaname"` // schemaname
	Tablename  sql.NullString `json:"tablename"`  // tablename
	Rulename   sql.NullString `json:"rulename"`   // rulename
	Definition sql.NullString `json:"definition"` // definition
}

// PgSeclabel represents a row from 'pg_catalog.pg_seclabel'.
type PgSeclabel struct {
	Tableoid pgtypes.Oid `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid `json:"ctid"`     // ctid
	Objoid   pgtypes.Oid `json:"objoid"`   // objoid
	Classoid pgtypes.Oid `json:"classoid"` // classoid
	Objsubid int         `json:"objsubid"` // objsubid
	Provider string      `json:"provider"` // provider
	Label    string      `json:"label"`    // label
}

// PgSeclabel represents a row from 'pg_catalog.pg_seclabels'.
type PgSeclabel struct {
	Objoid       pgtypes.NullOid `json:"objoid"`       // objoid
	Classoid     pgtypes.NullOid `json:"classoid"`     // classoid
	Objsubid     sql.NullInt64   `json:"objsubid"`     // objsubid
	Objtype      sql.NullString  `json:"objtype"`      // objtype
	Objnamespace pgtypes.NullOid `json:"objnamespace"` // objnamespace
	Objname      sql.NullString  `json:"objname"`      // objname
	Provider     sql.NullString  `json:"provider"`     // provider
	Label        sql.NullString  `json:"label"`        // label
}

// PgSequence represents a row from 'pg_catalog.pg_sequence'.
type PgSequence struct {
	Tableoid     pgtypes.Oid `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid `json:"ctid"`         // ctid
	Seqrelid     pgtypes.Oid `json:"seqrelid"`     // seqrelid
	Seqtypid     pgtypes.Oid `json:"seqtypid"`     // seqtypid
	Seqstart     int64       `json:"seqstart"`     // seqstart
	Seqincrement int64       `json:"seqincrement"` // seqincrement
	Seqmax       int64       `json:"seqmax"`       // seqmax
	Seqmin       int64       `json:"seqmin"`       // seqmin
	Seqcache     int64       `json:"seqcache"`     // seqcache
	Seqcycle     bool        `json:"seqcycle"`     // seqcycle
}

// PgSequence represents a row from 'pg_catalog.pg_sequences'.
type PgSequence struct {
	Schemaname    sql.NullString      `json:"schemaname"`    // schemaname
	Sequencename  sql.NullString      `json:"sequencename"`  // sequencename
	Sequenceowner sql.NullString      `json:"sequenceowner"` // sequenceowner
	DataType      pgtypes.NullRegtype `json:"data_type"`     // data_type
	StartValue    sql.NullInt64       `json:"start_value"`   // start_value
	MinValue      sql.NullInt64       `json:"min_value"`     // min_value
	MaxValue      sql.NullInt64       `json:"max_value"`     // max_value
	IncrementBy   sql.NullInt64       `json:"increment_by"`  // increment_by
	Cycle         sql.NullBool        `json:"cycle"`         // cycle
	CacheSize     sql.NullInt64       `json:"cache_size"`    // cache_size
	LastValue     sql.NullInt64       `json:"last_value"`    // last_value
}

// PgSetting represents a row from 'pg_catalog.pg_settings'.
type PgSetting struct {
	Name           sql.NullString   `json:"name"`            // name
	Setting        sql.NullString   `json:"setting"`         // setting
	Unit           sql.NullString   `json:"unit"`            // unit
	Category       sql.NullString   `json:"category"`        // category
	ShortDesc      sql.NullString   `json:"short_desc"`      // short_desc
	ExtraDesc      sql.NullString   `json:"extra_desc"`      // extra_desc
	Context        sql.NullString   `json:"context"`         // context
	Vartype        sql.NullString   `json:"vartype"`         // vartype
	Source         sql.NullString   `json:"source"`          // source
	MinVal         sql.NullString   `json:"min_val"`         // min_val
	MaxVal         sql.NullString   `json:"max_val"`         // max_val
	Enumvals       []sql.NullString `json:"enumvals"`        // enumvals
	BootVal        sql.NullString   `json:"boot_val"`        // boot_val
	ResetVal       sql.NullString   `json:"reset_val"`       // reset_val
	Sourcefile     sql.NullString   `json:"sourcefile"`      // sourcefile
	Sourceline     sql.NullInt64    `json:"sourceline"`      // sourceline
	PendingRestart sql.NullBool     `json:"pending_restart"` // pending_restart
}

// PgShadow represents a row from 'pg_catalog.pg_shadow'.
type PgShadow struct {
	Usename      sql.NullString   `json:"usename"`      // usename
	Usesysid     pgtypes.NullOid  `json:"usesysid"`     // usesysid
	Usecreatedb  sql.NullBool     `json:"usecreatedb"`  // usecreatedb
	Usesuper     sql.NullBool     `json:"usesuper"`     // usesuper
	Userepl      sql.NullBool     `json:"userepl"`      // userepl
	Usebypassrls sql.NullBool     `json:"usebypassrls"` // usebypassrls
	Passwd       sql.NullString   `json:"passwd"`       // passwd
	Valuntil     sql.NullTime     `json:"valuntil"`     // valuntil
	Useconfig    []sql.NullString `json:"useconfig"`    // useconfig
}

// PgShdepend represents a row from 'pg_catalog.pg_shdepend'.
type PgShdepend struct {
	Tableoid   pgtypes.Oid  `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid  `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid  `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid  `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid  `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid  `json:"ctid"`       // ctid
	Dbid       pgtypes.Oid  `json:"dbid"`       // dbid
	Classid    pgtypes.Oid  `json:"classid"`    // classid
	Objid      pgtypes.Oid  `json:"objid"`      // objid
	Objsubid   int          `json:"objsubid"`   // objsubid
	Refclassid pgtypes.Oid  `json:"refclassid"` // refclassid
	Refobjid   pgtypes.Oid  `json:"refobjid"`   // refobjid
	Deptype    pgtypes.Char `json:"deptype"`    // deptype
}

// PgShdescription represents a row from 'pg_catalog.pg_shdescription'.
type PgShdescription struct {
	Tableoid    pgtypes.Oid `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid `json:"ctid"`        // ctid
	Objoid      pgtypes.Oid `json:"objoid"`      // objoid
	Classoid    pgtypes.Oid `json:"classoid"`    // classoid
	Description string      `json:"description"` // description
}

// PgShmemAllocation represents a row from 'pg_catalog.pg_shmem_allocations'.
type PgShmemAllocation struct {
	Name          sql.NullString `json:"name"`           // name
	Off           sql.NullInt64  `json:"off"`            // off
	Size          sql.NullInt64  `json:"size"`           // size
	AllocatedSize sql.NullInt64  `json:"allocated_size"` // allocated_size
}

// PgShseclabel represents a row from 'pg_catalog.pg_shseclabel'.
type PgShseclabel struct {
	Tableoid pgtypes.Oid `json:"tableoid"` // tableoid
	Cmax     pgtypes.Cid `json:"cmax"`     // cmax
	Xmax     pgtypes.Xid `json:"xmax"`     // xmax
	Cmin     pgtypes.Cid `json:"cmin"`     // cmin
	Xmin     pgtypes.Xid `json:"xmin"`     // xmin
	Ctid     pgtypes.Tid `json:"ctid"`     // ctid
	Objoid   pgtypes.Oid `json:"objoid"`   // objoid
	Classoid pgtypes.Oid `json:"classoid"` // classoid
	Provider string      `json:"provider"` // provider
	Label    string      `json:"label"`    // label
}

// PgStat represents a row from 'pg_catalog.pg_stats'.
type PgStat struct {
	Schemaname          sql.NullString       `json:"schemaname"`             // schemaname
	Tablename           sql.NullString       `json:"tablename"`              // tablename
	Attname             sql.NullString       `json:"attname"`                // attname
	Inherited           sql.NullBool         `json:"inherited"`              // inherited
	NullFrac            sql.NullFloat64      `json:"null_frac"`              // null_frac
	AvgWidth            sql.NullInt64        `json:"avg_width"`              // avg_width
	NDistinct           sql.NullFloat64      `json:"n_distinct"`             // n_distinct
	MostCommonVals      pgtypes.NullAnyarray `json:"most_common_vals"`       // most_common_vals
	MostCommonFreqs     []sql.NullFloat64    `json:"most_common_freqs"`      // most_common_freqs
	HistogramBounds     pgtypes.NullAnyarray `json:"histogram_bounds"`       // histogram_bounds
	Correlation         sql.NullFloat64      `json:"correlation"`            // correlation
	MostCommonElems     pgtypes.NullAnyarray `json:"most_common_elems"`      // most_common_elems
	MostCommonElemFreqs []sql.NullFloat64    `json:"most_common_elem_freqs"` // most_common_elem_freqs
	ElemCountHistogram  []sql.NullFloat64    `json:"elem_count_histogram"`   // elem_count_histogram
}

// PgStatActivity represents a row from 'pg_catalog.pg_stat_activity'.
type PgStatActivity struct {
	Datid           pgtypes.NullOid `json:"datid"`            // datid
	Datname         sql.NullString  `json:"datname"`          // datname
	Pid             sql.NullInt64   `json:"pid"`              // pid
	LeaderPid       sql.NullInt64   `json:"leader_pid"`       // leader_pid
	Usesysid        pgtypes.NullOid `json:"usesysid"`         // usesysid
	Usename         sql.NullString  `json:"usename"`          // usename
	ApplicationName sql.NullString  `json:"application_name"` // application_name
	ClientAddr      sql.NullString  `json:"client_addr"`      // client_addr
	ClientHostname  sql.NullString  `json:"client_hostname"`  // client_hostname
	ClientPort      sql.NullInt64   `json:"client_port"`      // client_port
	BackendStart    sql.NullTime    `json:"backend_start"`    // backend_start
	XactStart       sql.NullTime    `json:"xact_start"`       // xact_start
	QueryStart      sql.NullTime    `json:"query_start"`      // query_start
	StateChange     sql.NullTime    `json:"state_change"`     // state_change
	WaitEventType   sql.NullString  `json:"wait_event_type"`  // wait_event_type
	WaitEvent       sql.NullString  `json:"wait_event"`       // wait_event
	State           sql.NullString  `json:"state"`            // state
	BackendXid      pgtypes.NullXid `json:"backend_xid"`      // backend_xid
	BackendXmin     pgtypes.NullXid `json:"backend_xmin"`     // backend_xmin
	Query           sql.NullString  `json:"query"`            // query
	BackendType     sql.NullString  `json:"backend_type"`     // backend_type
}

// PgStatAllIndex represents a row from 'pg_catalog.pg_stat_all_indexes'.
type PgStatAllIndex struct {
	Relid        pgtypes.NullOid `json:"relid"`         // relid
	Indexrelid   pgtypes.NullOid `json:"indexrelid"`    // indexrelid
	Schemaname   sql.NullString  `json:"schemaname"`    // schemaname
	Relname      sql.NullString  `json:"relname"`       // relname
	Indexrelname sql.NullString  `json:"indexrelname"`  // indexrelname
	IdxScan      sql.NullInt64   `json:"idx_scan"`      // idx_scan
	IdxTupRead   sql.NullInt64   `json:"idx_tup_read"`  // idx_tup_read
	IdxTupFetch  sql.NullInt64   `json:"idx_tup_fetch"` // idx_tup_fetch
}

// PgStatAllTable represents a row from 'pg_catalog.pg_stat_all_tables'.
type PgStatAllTable struct {
	Relid            pgtypes.NullOid `json:"relid"`               // relid
	Schemaname       sql.NullString  `json:"schemaname"`          // schemaname
	Relname          sql.NullString  `json:"relname"`             // relname
	SeqScan          sql.NullInt64   `json:"seq_scan"`            // seq_scan
	SeqTupRead       sql.NullInt64   `json:"seq_tup_read"`        // seq_tup_read
	IdxScan          sql.NullInt64   `json:"idx_scan"`            // idx_scan
	IdxTupFetch      sql.NullInt64   `json:"idx_tup_fetch"`       // idx_tup_fetch
	NTupIns          sql.NullInt64   `json:"n_tup_ins"`           // n_tup_ins
	NTupUpd          sql.NullInt64   `json:"n_tup_upd"`           // n_tup_upd
	NTupDel          sql.NullInt64   `json:"n_tup_del"`           // n_tup_del
	NTupHotUpd       sql.NullInt64   `json:"n_tup_hot_upd"`       // n_tup_hot_upd
	NLiveTup         sql.NullInt64   `json:"n_live_tup"`          // n_live_tup
	NDeadTup         sql.NullInt64   `json:"n_dead_tup"`          // n_dead_tup
	NModSinceAnalyze sql.NullInt64   `json:"n_mod_since_analyze"` // n_mod_since_analyze
	NInsSinceVacuum  sql.NullInt64   `json:"n_ins_since_vacuum"`  // n_ins_since_vacuum
	LastVacuum       sql.NullTime    `json:"last_vacuum"`         // last_vacuum
	LastAutovacuum   sql.NullTime    `json:"last_autovacuum"`     // last_autovacuum
	LastAnalyze      sql.NullTime    `json:"last_analyze"`        // last_analyze
	LastAutoanalyze  sql.NullTime    `json:"last_autoanalyze"`    // last_autoanalyze
	VacuumCount      sql.NullInt64   `json:"vacuum_count"`        // vacuum_count
	AutovacuumCount  sql.NullInt64   `json:"autovacuum_count"`    // autovacuum_count
	AnalyzeCount     sql.NullInt64   `json:"analyze_count"`       // analyze_count
	AutoanalyzeCount sql.NullInt64   `json:"autoanalyze_count"`   // autoanalyze_count
}

// PgStatArchiver represents a row from 'pg_catalog.pg_stat_archiver'.
type PgStatArchiver struct {
	ArchivedCount    sql.NullInt64  `json:"archived_count"`     // archived_count
	LastArchivedWal  sql.NullString `json:"last_archived_wal"`  // last_archived_wal
	LastArchivedTime sql.NullTime   `json:"last_archived_time"` // last_archived_time
	FailedCount      sql.NullInt64  `json:"failed_count"`       // failed_count
	LastFailedWal    sql.NullString `json:"last_failed_wal"`    // last_failed_wal
	LastFailedTime   sql.NullTime   `json:"last_failed_time"`   // last_failed_time
	StatsReset       sql.NullTime   `json:"stats_reset"`        // stats_reset
}

// PgStatBgwriter represents a row from 'pg_catalog.pg_stat_bgwriter'.
type PgStatBgwriter struct {
	CheckpointsTimed    sql.NullInt64   `json:"checkpoints_timed"`     // checkpoints_timed
	CheckpointsReq      sql.NullInt64   `json:"checkpoints_req"`       // checkpoints_req
	CheckpointWriteTime sql.NullFloat64 `json:"checkpoint_write_time"` // checkpoint_write_time
	CheckpointSyncTime  sql.NullFloat64 `json:"checkpoint_sync_time"`  // checkpoint_sync_time
	BuffersCheckpoint   sql.NullInt64   `json:"buffers_checkpoint"`    // buffers_checkpoint
	BuffersClean        sql.NullInt64   `json:"buffers_clean"`         // buffers_clean
	MaxwrittenClean     sql.NullInt64   `json:"maxwritten_clean"`      // maxwritten_clean
	BuffersBackend      sql.NullInt64   `json:"buffers_backend"`       // buffers_backend
	BuffersBackendFsync sql.NullInt64   `json:"buffers_backend_fsync"` // buffers_backend_fsync
	BuffersAlloc        sql.NullInt64   `json:"buffers_alloc"`         // buffers_alloc
	StatsReset          sql.NullTime    `json:"stats_reset"`           // stats_reset
}

// PgStatDatabase represents a row from 'pg_catalog.pg_stat_database'.
type PgStatDatabase struct {
	Datid               pgtypes.NullOid `json:"datid"`                 // datid
	Datname             sql.NullString  `json:"datname"`               // datname
	Numbackends         sql.NullInt64   `json:"numbackends"`           // numbackends
	XactCommit          sql.NullInt64   `json:"xact_commit"`           // xact_commit
	XactRollback        sql.NullInt64   `json:"xact_rollback"`         // xact_rollback
	BlksRead            sql.NullInt64   `json:"blks_read"`             // blks_read
	BlksHit             sql.NullInt64   `json:"blks_hit"`              // blks_hit
	TupReturned         sql.NullInt64   `json:"tup_returned"`          // tup_returned
	TupFetched          sql.NullInt64   `json:"tup_fetched"`           // tup_fetched
	TupInserted         sql.NullInt64   `json:"tup_inserted"`          // tup_inserted
	TupUpdated          sql.NullInt64   `json:"tup_updated"`           // tup_updated
	TupDeleted          sql.NullInt64   `json:"tup_deleted"`           // tup_deleted
	Conflicts           sql.NullInt64   `json:"conflicts"`             // conflicts
	TempFiles           sql.NullInt64   `json:"temp_files"`            // temp_files
	TempBytes           sql.NullInt64   `json:"temp_bytes"`            // temp_bytes
	Deadlocks           sql.NullInt64   `json:"deadlocks"`             // deadlocks
	ChecksumFailures    sql.NullInt64   `json:"checksum_failures"`     // checksum_failures
	ChecksumLastFailure sql.NullTime    `json:"checksum_last_failure"` // checksum_last_failure
	BlkReadTime         sql.NullFloat64 `json:"blk_read_time"`         // blk_read_time
	BlkWriteTime        sql.NullFloat64 `json:"blk_write_time"`        // blk_write_time
	StatsReset          sql.NullTime    `json:"stats_reset"`           // stats_reset
}

// PgStatDatabaseConflict represents a row from 'pg_catalog.pg_stat_database_conflicts'.
type PgStatDatabaseConflict struct {
	Datid           pgtypes.NullOid `json:"datid"`            // datid
	Datname         sql.NullString  `json:"datname"`          // datname
	ConflTablespace sql.NullInt64   `json:"confl_tablespace"` // confl_tablespace
	ConflLock       sql.NullInt64   `json:"confl_lock"`       // confl_lock
	ConflSnapshot   sql.NullInt64   `json:"confl_snapshot"`   // confl_snapshot
	ConflBufferpin  sql.NullInt64   `json:"confl_bufferpin"`  // confl_bufferpin
	ConflDeadlock   sql.NullInt64   `json:"confl_deadlock"`   // confl_deadlock
}

// PgStatGssapi represents a row from 'pg_catalog.pg_stat_gssapi'.
type PgStatGssapi struct {
	Pid              sql.NullInt64  `json:"pid"`               // pid
	GssAuthenticated sql.NullBool   `json:"gss_authenticated"` // gss_authenticated
	Principal        sql.NullString `json:"principal"`         // principal
	Encrypted        sql.NullBool   `json:"encrypted"`         // encrypted
}

// PgStatProgressAnalyze represents a row from 'pg_catalog.pg_stat_progress_analyze'.
type PgStatProgressAnalyze struct {
	Pid                    sql.NullInt64   `json:"pid"`                       // pid
	Datid                  pgtypes.NullOid `json:"datid"`                     // datid
	Datname                sql.NullString  `json:"datname"`                   // datname
	Relid                  pgtypes.NullOid `json:"relid"`                     // relid
	Phase                  sql.NullString  `json:"phase"`                     // phase
	SampleBlksTotal        sql.NullInt64   `json:"sample_blks_total"`         // sample_blks_total
	SampleBlksScanned      sql.NullInt64   `json:"sample_blks_scanned"`       // sample_blks_scanned
	ExtStatsTotal          sql.NullInt64   `json:"ext_stats_total"`           // ext_stats_total
	ExtStatsComputed       sql.NullInt64   `json:"ext_stats_computed"`        // ext_stats_computed
	ChildTablesTotal       sql.NullInt64   `json:"child_tables_total"`        // child_tables_total
	ChildTablesDone        sql.NullInt64   `json:"child_tables_done"`         // child_tables_done
	CurrentChildTableRelid pgtypes.NullOid `json:"current_child_table_relid"` // current_child_table_relid
}

// PgStatProgressBasebackup represents a row from 'pg_catalog.pg_stat_progress_basebackup'.
type PgStatProgressBasebackup struct {
	Pid                 sql.NullInt64  `json:"pid"`                  // pid
	Phase               sql.NullString `json:"phase"`                // phase
	BackupTotal         sql.NullInt64  `json:"backup_total"`         // backup_total
	BackupStreamed      sql.NullInt64  `json:"backup_streamed"`      // backup_streamed
	TablespacesTotal    sql.NullInt64  `json:"tablespaces_total"`    // tablespaces_total
	TablespacesStreamed sql.NullInt64  `json:"tablespaces_streamed"` // tablespaces_streamed
}

// PgStatProgressCluster represents a row from 'pg_catalog.pg_stat_progress_cluster'.
type PgStatProgressCluster struct {
	Pid               sql.NullInt64   `json:"pid"`                 // pid
	Datid             pgtypes.NullOid `json:"datid"`               // datid
	Datname           sql.NullString  `json:"datname"`             // datname
	Relid             pgtypes.NullOid `json:"relid"`               // relid
	Command           sql.NullString  `json:"command"`             // command
	Phase             sql.NullString  `json:"phase"`               // phase
	ClusterIndexRelid pgtypes.NullOid `json:"cluster_index_relid"` // cluster_index_relid
	HeapTuplesScanned sql.NullInt64   `json:"heap_tuples_scanned"` // heap_tuples_scanned
	HeapTuplesWritten sql.NullInt64   `json:"heap_tuples_written"` // heap_tuples_written
	HeapBlksTotal     sql.NullInt64   `json:"heap_blks_total"`     // heap_blks_total
	HeapBlksScanned   sql.NullInt64   `json:"heap_blks_scanned"`   // heap_blks_scanned
	IndexRebuildCount sql.NullInt64   `json:"index_rebuild_count"` // index_rebuild_count
}

// PgStatProgressCreateIndex represents a row from 'pg_catalog.pg_stat_progress_create_index'.
type PgStatProgressCreateIndex struct {
	Pid              sql.NullInt64   `json:"pid"`                // pid
	Datid            pgtypes.NullOid `json:"datid"`              // datid
	Datname          sql.NullString  `json:"datname"`            // datname
	Relid            pgtypes.NullOid `json:"relid"`              // relid
	IndexRelid       pgtypes.NullOid `json:"index_relid"`        // index_relid
	Command          sql.NullString  `json:"command"`            // command
	Phase            sql.NullString  `json:"phase"`              // phase
	LockersTotal     sql.NullInt64   `json:"lockers_total"`      // lockers_total
	LockersDone      sql.NullInt64   `json:"lockers_done"`       // lockers_done
	CurrentLockerPid sql.NullInt64   `json:"current_locker_pid"` // current_locker_pid
	BlocksTotal      sql.NullInt64   `json:"blocks_total"`       // blocks_total
	BlocksDone       sql.NullInt64   `json:"blocks_done"`        // blocks_done
	TuplesTotal      sql.NullInt64   `json:"tuples_total"`       // tuples_total
	TuplesDone       sql.NullInt64   `json:"tuples_done"`        // tuples_done
	PartitionsTotal  sql.NullInt64   `json:"partitions_total"`   // partitions_total
	PartitionsDone   sql.NullInt64   `json:"partitions_done"`    // partitions_done
}

// PgStatProgressVacuum represents a row from 'pg_catalog.pg_stat_progress_vacuum'.
type PgStatProgressVacuum struct {
	Pid              sql.NullInt64   `json:"pid"`                // pid
	Datid            pgtypes.NullOid `json:"datid"`              // datid
	Datname          sql.NullString  `json:"datname"`            // datname
	Relid            pgtypes.NullOid `json:"relid"`              // relid
	Phase            sql.NullString  `json:"phase"`              // phase
	HeapBlksTotal    sql.NullInt64   `json:"heap_blks_total"`    // heap_blks_total
	HeapBlksScanned  sql.NullInt64   `json:"heap_blks_scanned"`  // heap_blks_scanned
	HeapBlksVacuumed sql.NullInt64   `json:"heap_blks_vacuumed"` // heap_blks_vacuumed
	IndexVacuumCount sql.NullInt64   `json:"index_vacuum_count"` // index_vacuum_count
	MaxDeadTuples    sql.NullInt64   `json:"max_dead_tuples"`    // max_dead_tuples
	NumDeadTuples    sql.NullInt64   `json:"num_dead_tuples"`    // num_dead_tuples
}

// PgStatReplication represents a row from 'pg_catalog.pg_stat_replication'.
type PgStatReplication struct {
	Pid             sql.NullInt64     `json:"pid"`              // pid
	Usesysid        pgtypes.NullOid   `json:"usesysid"`         // usesysid
	Usename         sql.NullString    `json:"usename"`          // usename
	ApplicationName sql.NullString    `json:"application_name"` // application_name
	ClientAddr      sql.NullString    `json:"client_addr"`      // client_addr
	ClientHostname  sql.NullString    `json:"client_hostname"`  // client_hostname
	ClientPort      sql.NullInt64     `json:"client_port"`      // client_port
	BackendStart    sql.NullTime      `json:"backend_start"`    // backend_start
	BackendXmin     pgtypes.NullXid   `json:"backend_xmin"`     // backend_xmin
	State           sql.NullString    `json:"state"`            // state
	SentLsn         pgtypes.NullPgLsn `json:"sent_lsn"`         // sent_lsn
	WriteLsn        pgtypes.NullPgLsn `json:"write_lsn"`        // write_lsn
	FlushLsn        pgtypes.NullPgLsn `json:"flush_lsn"`        // flush_lsn
	ReplayLsn       pgtypes.NullPgLsn `json:"replay_lsn"`       // replay_lsn
	WriteLag        []byte            `json:"write_lag"`        // write_lag
	FlushLag        []byte            `json:"flush_lag"`        // flush_lag
	ReplayLag       []byte            `json:"replay_lag"`       // replay_lag
	SyncPriority    sql.NullInt64     `json:"sync_priority"`    // sync_priority
	SyncState       sql.NullString    `json:"sync_state"`       // sync_state
	ReplyTime       sql.NullTime      `json:"reply_time"`       // reply_time
}

// PgStatSlru represents a row from 'pg_catalog.pg_stat_slru'.
type PgStatSlru struct {
	Name        sql.NullString `json:"name"`         // name
	BlksZeroed  sql.NullInt64  `json:"blks_zeroed"`  // blks_zeroed
	BlksHit     sql.NullInt64  `json:"blks_hit"`     // blks_hit
	BlksRead    sql.NullInt64  `json:"blks_read"`    // blks_read
	BlksWritten sql.NullInt64  `json:"blks_written"` // blks_written
	BlksExists  sql.NullInt64  `json:"blks_exists"`  // blks_exists
	Flushes     sql.NullInt64  `json:"flushes"`      // flushes
	Truncates   sql.NullInt64  `json:"truncates"`    // truncates
	StatsReset  sql.NullTime   `json:"stats_reset"`  // stats_reset
}

// PgStatSsl represents a row from 'pg_catalog.pg_stat_ssl'.
type PgStatSsl struct {
	Pid          sql.NullInt64   `json:"pid"`           // pid
	Ssl          sql.NullBool    `json:"ssl"`           // ssl
	Version      sql.NullString  `json:"version"`       // version
	Cipher       sql.NullString  `json:"cipher"`        // cipher
	Bits         sql.NullInt64   `json:"bits"`          // bits
	Compression  sql.NullBool    `json:"compression"`   // compression
	ClientDn     sql.NullString  `json:"client_dn"`     // client_dn
	ClientSerial sql.NullFloat64 `json:"client_serial"` // client_serial
	IssuerDn     sql.NullString  `json:"issuer_dn"`     // issuer_dn
}

// PgStatSubscription represents a row from 'pg_catalog.pg_stat_subscription'.
type PgStatSubscription struct {
	Subid              pgtypes.NullOid   `json:"subid"`                 // subid
	Subname            sql.NullString    `json:"subname"`               // subname
	Pid                sql.NullInt64     `json:"pid"`                   // pid
	Relid              pgtypes.NullOid   `json:"relid"`                 // relid
	ReceivedLsn        pgtypes.NullPgLsn `json:"received_lsn"`          // received_lsn
	LastMsgSendTime    sql.NullTime      `json:"last_msg_send_time"`    // last_msg_send_time
	LastMsgReceiptTime sql.NullTime      `json:"last_msg_receipt_time"` // last_msg_receipt_time
	LatestEndLsn       pgtypes.NullPgLsn `json:"latest_end_lsn"`        // latest_end_lsn
	LatestEndTime      sql.NullTime      `json:"latest_end_time"`       // latest_end_time
}

// PgStatSysIndex represents a row from 'pg_catalog.pg_stat_sys_indexes'.
type PgStatSysIndex struct {
	Relid        pgtypes.NullOid `json:"relid"`         // relid
	Indexrelid   pgtypes.NullOid `json:"indexrelid"`    // indexrelid
	Schemaname   sql.NullString  `json:"schemaname"`    // schemaname
	Relname      sql.NullString  `json:"relname"`       // relname
	Indexrelname sql.NullString  `json:"indexrelname"`  // indexrelname
	IdxScan      sql.NullInt64   `json:"idx_scan"`      // idx_scan
	IdxTupRead   sql.NullInt64   `json:"idx_tup_read"`  // idx_tup_read
	IdxTupFetch  sql.NullInt64   `json:"idx_tup_fetch"` // idx_tup_fetch
}

// PgStatSysTable represents a row from 'pg_catalog.pg_stat_sys_tables'.
type PgStatSysTable struct {
	Relid            pgtypes.NullOid `json:"relid"`               // relid
	Schemaname       sql.NullString  `json:"schemaname"`          // schemaname
	Relname          sql.NullString  `json:"relname"`             // relname
	SeqScan          sql.NullInt64   `json:"seq_scan"`            // seq_scan
	SeqTupRead       sql.NullInt64   `json:"seq_tup_read"`        // seq_tup_read
	IdxScan          sql.NullInt64   `json:"idx_scan"`            // idx_scan
	IdxTupFetch      sql.NullInt64   `json:"idx_tup_fetch"`       // idx_tup_fetch
	NTupIns          sql.NullInt64   `json:"n_tup_ins"`           // n_tup_ins
	NTupUpd          sql.NullInt64   `json:"n_tup_upd"`           // n_tup_upd
	NTupDel          sql.NullInt64   `json:"n_tup_del"`           // n_tup_del
	NTupHotUpd       sql.NullInt64   `json:"n_tup_hot_upd"`       // n_tup_hot_upd
	NLiveTup         sql.NullInt64   `json:"n_live_tup"`          // n_live_tup
	NDeadTup         sql.NullInt64   `json:"n_dead_tup"`          // n_dead_tup
	NModSinceAnalyze sql.NullInt64   `json:"n_mod_since_analyze"` // n_mod_since_analyze
	NInsSinceVacuum  sql.NullInt64   `json:"n_ins_since_vacuum"`  // n_ins_since_vacuum
	LastVacuum       sql.NullTime    `json:"last_vacuum"`         // last_vacuum
	LastAutovacuum   sql.NullTime    `json:"last_autovacuum"`     // last_autovacuum
	LastAnalyze      sql.NullTime    `json:"last_analyze"`        // last_analyze
	LastAutoanalyze  sql.NullTime    `json:"last_autoanalyze"`    // last_autoanalyze
	VacuumCount      sql.NullInt64   `json:"vacuum_count"`        // vacuum_count
	AutovacuumCount  sql.NullInt64   `json:"autovacuum_count"`    // autovacuum_count
	AnalyzeCount     sql.NullInt64   `json:"analyze_count"`       // analyze_count
	AutoanalyzeCount sql.NullInt64   `json:"autoanalyze_count"`   // autoanalyze_count
}

// PgStatUserFunction represents a row from 'pg_catalog.pg_stat_user_functions'.
type PgStatUserFunction struct {
	Funcid     pgtypes.NullOid `json:"funcid"`     // funcid
	Schemaname sql.NullString  `json:"schemaname"` // schemaname
	Funcname   sql.NullString  `json:"funcname"`   // funcname
	Calls      sql.NullInt64   `json:"calls"`      // calls
	TotalTime  sql.NullFloat64 `json:"total_time"` // total_time
	SelfTime   sql.NullFloat64 `json:"self_time"`  // self_time
}

// PgStatUserIndex represents a row from 'pg_catalog.pg_stat_user_indexes'.
type PgStatUserIndex struct {
	Relid        pgtypes.NullOid `json:"relid"`         // relid
	Indexrelid   pgtypes.NullOid `json:"indexrelid"`    // indexrelid
	Schemaname   sql.NullString  `json:"schemaname"`    // schemaname
	Relname      sql.NullString  `json:"relname"`       // relname
	Indexrelname sql.NullString  `json:"indexrelname"`  // indexrelname
	IdxScan      sql.NullInt64   `json:"idx_scan"`      // idx_scan
	IdxTupRead   sql.NullInt64   `json:"idx_tup_read"`  // idx_tup_read
	IdxTupFetch  sql.NullInt64   `json:"idx_tup_fetch"` // idx_tup_fetch
}

// PgStatUserTable represents a row from 'pg_catalog.pg_stat_user_tables'.
type PgStatUserTable struct {
	Relid            pgtypes.NullOid `json:"relid"`               // relid
	Schemaname       sql.NullString  `json:"schemaname"`          // schemaname
	Relname          sql.NullString  `json:"relname"`             // relname
	SeqScan          sql.NullInt64   `json:"seq_scan"`            // seq_scan
	SeqTupRead       sql.NullInt64   `json:"seq_tup_read"`        // seq_tup_read
	IdxScan          sql.NullInt64   `json:"idx_scan"`            // idx_scan
	IdxTupFetch      sql.NullInt64   `json:"idx_tup_fetch"`       // idx_tup_fetch
	NTupIns          sql.NullInt64   `json:"n_tup_ins"`           // n_tup_ins
	NTupUpd          sql.NullInt64   `json:"n_tup_upd"`           // n_tup_upd
	NTupDel          sql.NullInt64   `json:"n_tup_del"`           // n_tup_del
	NTupHotUpd       sql.NullInt64   `json:"n_tup_hot_upd"`       // n_tup_hot_upd
	NLiveTup         sql.NullInt64   `json:"n_live_tup"`          // n_live_tup
	NDeadTup         sql.NullInt64   `json:"n_dead_tup"`          // n_dead_tup
	NModSinceAnalyze sql.NullInt64   `json:"n_mod_since_analyze"` // n_mod_since_analyze
	NInsSinceVacuum  sql.NullInt64   `json:"n_ins_since_vacuum"`  // n_ins_since_vacuum
	LastVacuum       sql.NullTime    `json:"last_vacuum"`         // last_vacuum
	LastAutovacuum   sql.NullTime    `json:"last_autovacuum"`     // last_autovacuum
	LastAnalyze      sql.NullTime    `json:"last_analyze"`        // last_analyze
	LastAutoanalyze  sql.NullTime    `json:"last_autoanalyze"`    // last_autoanalyze
	VacuumCount      sql.NullInt64   `json:"vacuum_count"`        // vacuum_count
	AutovacuumCount  sql.NullInt64   `json:"autovacuum_count"`    // autovacuum_count
	AnalyzeCount     sql.NullInt64   `json:"analyze_count"`       // analyze_count
	AutoanalyzeCount sql.NullInt64   `json:"autoanalyze_count"`   // autoanalyze_count
}

// PgStatWalReceiver represents a row from 'pg_catalog.pg_stat_wal_receiver'.
type PgStatWalReceiver struct {
	Pid                sql.NullInt64     `json:"pid"`                   // pid
	Status             sql.NullString    `json:"status"`                // status
	ReceiveStartLsn    pgtypes.NullPgLsn `json:"receive_start_lsn"`     // receive_start_lsn
	ReceiveStartTli    sql.NullInt64     `json:"receive_start_tli"`     // receive_start_tli
	WrittenLsn         pgtypes.NullPgLsn `json:"written_lsn"`           // written_lsn
	FlushedLsn         pgtypes.NullPgLsn `json:"flushed_lsn"`           // flushed_lsn
	ReceivedTli        sql.NullInt64     `json:"received_tli"`          // received_tli
	LastMsgSendTime    sql.NullTime      `json:"last_msg_send_time"`    // last_msg_send_time
	LastMsgReceiptTime sql.NullTime      `json:"last_msg_receipt_time"` // last_msg_receipt_time
	LatestEndLsn       pgtypes.NullPgLsn `json:"latest_end_lsn"`        // latest_end_lsn
	LatestEndTime      sql.NullTime      `json:"latest_end_time"`       // latest_end_time
	SlotName           sql.NullString    `json:"slot_name"`             // slot_name
	SenderHost         sql.NullString    `json:"sender_host"`           // sender_host
	SenderPort         sql.NullInt64     `json:"sender_port"`           // sender_port
	Conninfo           sql.NullString    `json:"conninfo"`              // conninfo
}

// PgStatXactAllTable represents a row from 'pg_catalog.pg_stat_xact_all_tables'.
type PgStatXactAllTable struct {
	Relid       pgtypes.NullOid `json:"relid"`         // relid
	Schemaname  sql.NullString  `json:"schemaname"`    // schemaname
	Relname     sql.NullString  `json:"relname"`       // relname
	SeqScan     sql.NullInt64   `json:"seq_scan"`      // seq_scan
	SeqTupRead  sql.NullInt64   `json:"seq_tup_read"`  // seq_tup_read
	IdxScan     sql.NullInt64   `json:"idx_scan"`      // idx_scan
	IdxTupFetch sql.NullInt64   `json:"idx_tup_fetch"` // idx_tup_fetch
	NTupIns     sql.NullInt64   `json:"n_tup_ins"`     // n_tup_ins
	NTupUpd     sql.NullInt64   `json:"n_tup_upd"`     // n_tup_upd
	NTupDel     sql.NullInt64   `json:"n_tup_del"`     // n_tup_del
	NTupHotUpd  sql.NullInt64   `json:"n_tup_hot_upd"` // n_tup_hot_upd
}

// PgStatXactSysTable represents a row from 'pg_catalog.pg_stat_xact_sys_tables'.
type PgStatXactSysTable struct {
	Relid       pgtypes.NullOid `json:"relid"`         // relid
	Schemaname  sql.NullString  `json:"schemaname"`    // schemaname
	Relname     sql.NullString  `json:"relname"`       // relname
	SeqScan     sql.NullInt64   `json:"seq_scan"`      // seq_scan
	SeqTupRead  sql.NullInt64   `json:"seq_tup_read"`  // seq_tup_read
	IdxScan     sql.NullInt64   `json:"idx_scan"`      // idx_scan
	IdxTupFetch sql.NullInt64   `json:"idx_tup_fetch"` // idx_tup_fetch
	NTupIns     sql.NullInt64   `json:"n_tup_ins"`     // n_tup_ins
	NTupUpd     sql.NullInt64   `json:"n_tup_upd"`     // n_tup_upd
	NTupDel     sql.NullInt64   `json:"n_tup_del"`     // n_tup_del
	NTupHotUpd  sql.NullInt64   `json:"n_tup_hot_upd"` // n_tup_hot_upd
}

// PgStatXactUserFunction represents a row from 'pg_catalog.pg_stat_xact_user_functions'.
type PgStatXactUserFunction struct {
	Funcid     pgtypes.NullOid `json:"funcid"`     // funcid
	Schemaname sql.NullString  `json:"schemaname"` // schemaname
	Funcname   sql.NullString  `json:"funcname"`   // funcname
	Calls      sql.NullInt64   `json:"calls"`      // calls
	TotalTime  sql.NullFloat64 `json:"total_time"` // total_time
	SelfTime   sql.NullFloat64 `json:"self_time"`  // self_time
}

// PgStatXactUserTable represents a row from 'pg_catalog.pg_stat_xact_user_tables'.
type PgStatXactUserTable struct {
	Relid       pgtypes.NullOid `json:"relid"`         // relid
	Schemaname  sql.NullString  `json:"schemaname"`    // schemaname
	Relname     sql.NullString  `json:"relname"`       // relname
	SeqScan     sql.NullInt64   `json:"seq_scan"`      // seq_scan
	SeqTupRead  sql.NullInt64   `json:"seq_tup_read"`  // seq_tup_read
	IdxScan     sql.NullInt64   `json:"idx_scan"`      // idx_scan
	IdxTupFetch sql.NullInt64   `json:"idx_tup_fetch"` // idx_tup_fetch
	NTupIns     sql.NullInt64   `json:"n_tup_ins"`     // n_tup_ins
	NTupUpd     sql.NullInt64   `json:"n_tup_upd"`     // n_tup_upd
	NTupDel     sql.NullInt64   `json:"n_tup_del"`     // n_tup_del
	NTupHotUpd  sql.NullInt64   `json:"n_tup_hot_upd"` // n_tup_hot_upd
}

// PgStatioAllIndex represents a row from 'pg_catalog.pg_statio_all_indexes'.
type PgStatioAllIndex struct {
	Relid        pgtypes.NullOid `json:"relid"`         // relid
	Indexrelid   pgtypes.NullOid `json:"indexrelid"`    // indexrelid
	Schemaname   sql.NullString  `json:"schemaname"`    // schemaname
	Relname      sql.NullString  `json:"relname"`       // relname
	Indexrelname sql.NullString  `json:"indexrelname"`  // indexrelname
	IdxBlksRead  sql.NullInt64   `json:"idx_blks_read"` // idx_blks_read
	IdxBlksHit   sql.NullInt64   `json:"idx_blks_hit"`  // idx_blks_hit
}

// PgStatioAllSequence represents a row from 'pg_catalog.pg_statio_all_sequences'.
type PgStatioAllSequence struct {
	Relid      pgtypes.NullOid `json:"relid"`      // relid
	Schemaname sql.NullString  `json:"schemaname"` // schemaname
	Relname    sql.NullString  `json:"relname"`    // relname
	BlksRead   sql.NullInt64   `json:"blks_read"`  // blks_read
	BlksHit    sql.NullInt64   `json:"blks_hit"`   // blks_hit
}

// PgStatioAllTable represents a row from 'pg_catalog.pg_statio_all_tables'.
type PgStatioAllTable struct {
	Relid         pgtypes.NullOid `json:"relid"`           // relid
	Schemaname    sql.NullString  `json:"schemaname"`      // schemaname
	Relname       sql.NullString  `json:"relname"`         // relname
	HeapBlksRead  sql.NullInt64   `json:"heap_blks_read"`  // heap_blks_read
	HeapBlksHit   sql.NullInt64   `json:"heap_blks_hit"`   // heap_blks_hit
	IdxBlksRead   sql.NullInt64   `json:"idx_blks_read"`   // idx_blks_read
	IdxBlksHit    sql.NullInt64   `json:"idx_blks_hit"`    // idx_blks_hit
	ToastBlksRead sql.NullInt64   `json:"toast_blks_read"` // toast_blks_read
	ToastBlksHit  sql.NullInt64   `json:"toast_blks_hit"`  // toast_blks_hit
	TidxBlksRead  sql.NullInt64   `json:"tidx_blks_read"`  // tidx_blks_read
	TidxBlksHit   sql.NullInt64   `json:"tidx_blks_hit"`   // tidx_blks_hit
}

// PgStatioSysIndex represents a row from 'pg_catalog.pg_statio_sys_indexes'.
type PgStatioSysIndex struct {
	Relid        pgtypes.NullOid `json:"relid"`         // relid
	Indexrelid   pgtypes.NullOid `json:"indexrelid"`    // indexrelid
	Schemaname   sql.NullString  `json:"schemaname"`    // schemaname
	Relname      sql.NullString  `json:"relname"`       // relname
	Indexrelname sql.NullString  `json:"indexrelname"`  // indexrelname
	IdxBlksRead  sql.NullInt64   `json:"idx_blks_read"` // idx_blks_read
	IdxBlksHit   sql.NullInt64   `json:"idx_blks_hit"`  // idx_blks_hit
}

// PgStatioSysSequence represents a row from 'pg_catalog.pg_statio_sys_sequences'.
type PgStatioSysSequence struct {
	Relid      pgtypes.NullOid `json:"relid"`      // relid
	Schemaname sql.NullString  `json:"schemaname"` // schemaname
	Relname    sql.NullString  `json:"relname"`    // relname
	BlksRead   sql.NullInt64   `json:"blks_read"`  // blks_read
	BlksHit    sql.NullInt64   `json:"blks_hit"`   // blks_hit
}

// PgStatioSysTable represents a row from 'pg_catalog.pg_statio_sys_tables'.
type PgStatioSysTable struct {
	Relid         pgtypes.NullOid `json:"relid"`           // relid
	Schemaname    sql.NullString  `json:"schemaname"`      // schemaname
	Relname       sql.NullString  `json:"relname"`         // relname
	HeapBlksRead  sql.NullInt64   `json:"heap_blks_read"`  // heap_blks_read
	HeapBlksHit   sql.NullInt64   `json:"heap_blks_hit"`   // heap_blks_hit
	IdxBlksRead   sql.NullInt64   `json:"idx_blks_read"`   // idx_blks_read
	IdxBlksHit    sql.NullInt64   `json:"idx_blks_hit"`    // idx_blks_hit
	ToastBlksRead sql.NullInt64   `json:"toast_blks_read"` // toast_blks_read
	ToastBlksHit  sql.NullInt64   `json:"toast_blks_hit"`  // toast_blks_hit
	TidxBlksRead  sql.NullInt64   `json:"tidx_blks_read"`  // tidx_blks_read
	TidxBlksHit   sql.NullInt64   `json:"tidx_blks_hit"`   // tidx_blks_hit
}

// PgStatioUserIndex represents a row from 'pg_catalog.pg_statio_user_indexes'.
type PgStatioUserIndex struct {
	Relid        pgtypes.NullOid `json:"relid"`         // relid
	Indexrelid   pgtypes.NullOid `json:"indexrelid"`    // indexrelid
	Schemaname   sql.NullString  `json:"schemaname"`    // schemaname
	Relname      sql.NullString  `json:"relname"`       // relname
	Indexrelname sql.NullString  `json:"indexrelname"`  // indexrelname
	IdxBlksRead  sql.NullInt64   `json:"idx_blks_read"` // idx_blks_read
	IdxBlksHit   sql.NullInt64   `json:"idx_blks_hit"`  // idx_blks_hit
}

// PgStatioUserSequence represents a row from 'pg_catalog.pg_statio_user_sequences'.
type PgStatioUserSequence struct {
	Relid      pgtypes.NullOid `json:"relid"`      // relid
	Schemaname sql.NullString  `json:"schemaname"` // schemaname
	Relname    sql.NullString  `json:"relname"`    // relname
	BlksRead   sql.NullInt64   `json:"blks_read"`  // blks_read
	BlksHit    sql.NullInt64   `json:"blks_hit"`   // blks_hit
}

// PgStatioUserTable represents a row from 'pg_catalog.pg_statio_user_tables'.
type PgStatioUserTable struct {
	Relid         pgtypes.NullOid `json:"relid"`           // relid
	Schemaname    sql.NullString  `json:"schemaname"`      // schemaname
	Relname       sql.NullString  `json:"relname"`         // relname
	HeapBlksRead  sql.NullInt64   `json:"heap_blks_read"`  // heap_blks_read
	HeapBlksHit   sql.NullInt64   `json:"heap_blks_hit"`   // heap_blks_hit
	IdxBlksRead   sql.NullInt64   `json:"idx_blks_read"`   // idx_blks_read
	IdxBlksHit    sql.NullInt64   `json:"idx_blks_hit"`    // idx_blks_hit
	ToastBlksRead sql.NullInt64   `json:"toast_blks_read"` // toast_blks_read
	ToastBlksHit  sql.NullInt64   `json:"toast_blks_hit"`  // toast_blks_hit
	TidxBlksRead  sql.NullInt64   `json:"tidx_blks_read"`  // tidx_blks_read
	TidxBlksHit   sql.NullInt64   `json:"tidx_blks_hit"`   // tidx_blks_hit
}

// PgStatistic represents a row from 'pg_catalog.pg_statistic'.
type PgStatistic struct {
	Tableoid    pgtypes.Oid          `json:"tableoid"`    // tableoid
	Cmax        pgtypes.Cid          `json:"cmax"`        // cmax
	Xmax        pgtypes.Xid          `json:"xmax"`        // xmax
	Cmin        pgtypes.Cid          `json:"cmin"`        // cmin
	Xmin        pgtypes.Xid          `json:"xmin"`        // xmin
	Ctid        pgtypes.Tid          `json:"ctid"`        // ctid
	Starelid    pgtypes.Oid          `json:"starelid"`    // starelid
	Staattnum   int16                `json:"staattnum"`   // staattnum
	Stainherit  bool                 `json:"stainherit"`  // stainherit
	Stanullfrac float32              `json:"stanullfrac"` // stanullfrac
	Stawidth    int                  `json:"stawidth"`    // stawidth
	Stadistinct float32              `json:"stadistinct"` // stadistinct
	Stakind1    int16                `json:"stakind1"`    // stakind1
	Stakind2    int16                `json:"stakind2"`    // stakind2
	Stakind3    int16                `json:"stakind3"`    // stakind3
	Stakind4    int16                `json:"stakind4"`    // stakind4
	Stakind5    int16                `json:"stakind5"`    // stakind5
	Staop1      pgtypes.Oid          `json:"staop1"`      // staop1
	Staop2      pgtypes.Oid          `json:"staop2"`      // staop2
	Staop3      pgtypes.Oid          `json:"staop3"`      // staop3
	Staop4      pgtypes.Oid          `json:"staop4"`      // staop4
	Staop5      pgtypes.Oid          `json:"staop5"`      // staop5
	Stacoll1    pgtypes.Oid          `json:"stacoll1"`    // stacoll1
	Stacoll2    pgtypes.Oid          `json:"stacoll2"`    // stacoll2
	Stacoll3    pgtypes.Oid          `json:"stacoll3"`    // stacoll3
	Stacoll4    pgtypes.Oid          `json:"stacoll4"`    // stacoll4
	Stacoll5    pgtypes.Oid          `json:"stacoll5"`    // stacoll5
	Stanumbers1 []sql.NullFloat64    `json:"stanumbers1"` // stanumbers1
	Stanumbers2 []sql.NullFloat64    `json:"stanumbers2"` // stanumbers2
	Stanumbers3 []sql.NullFloat64    `json:"stanumbers3"` // stanumbers3
	Stanumbers4 []sql.NullFloat64    `json:"stanumbers4"` // stanumbers4
	Stanumbers5 []sql.NullFloat64    `json:"stanumbers5"` // stanumbers5
	Stavalues1  pgtypes.NullAnyarray `json:"stavalues1"`  // stavalues1
	Stavalues2  pgtypes.NullAnyarray `json:"stavalues2"`  // stavalues2
	Stavalues3  pgtypes.NullAnyarray `json:"stavalues3"`  // stavalues3
	Stavalues4  pgtypes.NullAnyarray `json:"stavalues4"`  // stavalues4
	Stavalues5  pgtypes.NullAnyarray `json:"stavalues5"`  // stavalues5
}

// PgStatisticExt represents a row from 'pg_catalog.pg_statistic_ext'.
type PgStatisticExt struct {
	Tableoid      pgtypes.Oid        `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid        `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid        `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid        `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid        `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid        `json:"ctid"`          // ctid
	Oid           pgtypes.Oid        `json:"oid"`           // oid
	Stxrelid      pgtypes.Oid        `json:"stxrelid"`      // stxrelid
	Stxname       string             `json:"stxname"`       // stxname
	Stxnamespace  pgtypes.Oid        `json:"stxnamespace"`  // stxnamespace
	Stxowner      pgtypes.Oid        `json:"stxowner"`      // stxowner
	Stxstattarget int                `json:"stxstattarget"` // stxstattarget
	Stxkeys       pgtypes.Int2vector `json:"stxkeys"`       // stxkeys
	Stxkind       []pgtypes.Char     `json:"stxkind"`       // stxkind
}

// PgStatisticExtDatum represents a row from 'pg_catalog.pg_statistic_ext_data'.
type PgStatisticExtDatum struct {
	Tableoid         pgtypes.Oid                `json:"tableoid"`         // tableoid
	Cmax             pgtypes.Cid                `json:"cmax"`             // cmax
	Xmax             pgtypes.Xid                `json:"xmax"`             // xmax
	Cmin             pgtypes.Cid                `json:"cmin"`             // cmin
	Xmin             pgtypes.Xid                `json:"xmin"`             // xmin
	Ctid             pgtypes.Tid                `json:"ctid"`             // ctid
	Stxoid           pgtypes.Oid                `json:"stxoid"`           // stxoid
	Stxdndistinct    pgtypes.NullPgNdistinct    `json:"stxdndistinct"`    // stxdndistinct
	Stxddependencies pgtypes.NullPgDependencies `json:"stxddependencies"` // stxddependencies
	Stxdmcv          pgtypes.NullPgMcvList      `json:"stxdmcv"`          // stxdmcv
}

// PgStatsExt represents a row from 'pg_catalog.pg_stats_ext'.
type PgStatsExt struct {
	Schemaname           sql.NullString             `json:"schemaname"`             // schemaname
	Tablename            sql.NullString             `json:"tablename"`              // tablename
	StatisticsSchemaname sql.NullString             `json:"statistics_schemaname"`  // statistics_schemaname
	StatisticsName       sql.NullString             `json:"statistics_name"`        // statistics_name
	StatisticsOwner      sql.NullString             `json:"statistics_owner"`       // statistics_owner
	Attnames             []sql.NullString           `json:"attnames"`               // attnames
	Kinds                []pgtypes.NullChar         `json:"kinds"`                  // kinds
	NDistinct            pgtypes.NullPgNdistinct    `json:"n_distinct"`             // n_distinct
	Dependencies         pgtypes.NullPgDependencies `json:"dependencies"`           // dependencies
	MostCommonVals       []sql.NullString           `json:"most_common_vals"`       // most_common_vals
	MostCommonValNulls   []sql.NullBool             `json:"most_common_val_nulls"`  // most_common_val_nulls
	MostCommonFreqs      []sql.NullFloat64          `json:"most_common_freqs"`      // most_common_freqs
	MostCommonBaseFreqs  []sql.NullFloat64          `json:"most_common_base_freqs"` // most_common_base_freqs
}

// PgSubscription represents a row from 'pg_catalog.pg_subscription'.
type PgSubscription struct {
	Tableoid        pgtypes.Oid    `json:"tableoid"`        // tableoid
	Cmax            pgtypes.Cid    `json:"cmax"`            // cmax
	Xmax            pgtypes.Xid    `json:"xmax"`            // xmax
	Cmin            pgtypes.Cid    `json:"cmin"`            // cmin
	Xmin            pgtypes.Xid    `json:"xmin"`            // xmin
	Ctid            pgtypes.Tid    `json:"ctid"`            // ctid
	Oid             pgtypes.Oid    `json:"oid"`             // oid
	Subdbid         pgtypes.Oid    `json:"subdbid"`         // subdbid
	Subname         string         `json:"subname"`         // subname
	Subowner        pgtypes.Oid    `json:"subowner"`        // subowner
	Subenabled      bool           `json:"subenabled"`      // subenabled
	Subconninfo     string         `json:"subconninfo"`     // subconninfo
	Subslotname     sql.NullString `json:"subslotname"`     // subslotname
	Subsynccommit   string         `json:"subsynccommit"`   // subsynccommit
	Subpublications StringSlice    `json:"subpublications"` // subpublications
}

// PgSubscriptionRel represents a row from 'pg_catalog.pg_subscription_rel'.
type PgSubscriptionRel struct {
	Tableoid   pgtypes.Oid       `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid       `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid       `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid       `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid       `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid       `json:"ctid"`       // ctid
	Srsubid    pgtypes.Oid       `json:"srsubid"`    // srsubid
	Srrelid    pgtypes.Oid       `json:"srrelid"`    // srrelid
	Srsubstate pgtypes.Char      `json:"srsubstate"` // srsubstate
	Srsublsn   pgtypes.NullPgLsn `json:"srsublsn"`   // srsublsn
}

// PgTable represents a row from 'pg_catalog.pg_tables'.
type PgTable struct {
	Schemaname  sql.NullString `json:"schemaname"`  // schemaname
	Tablename   sql.NullString `json:"tablename"`   // tablename
	Tableowner  sql.NullString `json:"tableowner"`  // tableowner
	Tablespace  sql.NullString `json:"tablespace"`  // tablespace
	Hasindexes  sql.NullBool   `json:"hasindexes"`  // hasindexes
	Hasrules    sql.NullBool   `json:"hasrules"`    // hasrules
	Hastriggers sql.NullBool   `json:"hastriggers"` // hastriggers
	Rowsecurity sql.NullBool   `json:"rowsecurity"` // rowsecurity
}

// PgTablespace represents a row from 'pg_catalog.pg_tablespace'.
type PgTablespace struct {
	Tableoid   pgtypes.Oid           `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid           `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid           `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid           `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid           `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid           `json:"ctid"`       // ctid
	Oid        pgtypes.Oid           `json:"oid"`        // oid
	Spcname    string                `json:"spcname"`    // spcname
	Spcowner   pgtypes.Oid           `json:"spcowner"`   // spcowner
	Spcacl     []pgtypes.NullAclitem `json:"spcacl"`     // spcacl
	Spcoptions []sql.NullString      `json:"spcoptions"` // spcoptions
}

// PgTimezoneAbbrev represents a row from 'pg_catalog.pg_timezone_abbrevs'.
type PgTimezoneAbbrev struct {
	Abbrev    sql.NullString `json:"abbrev"`     // abbrev
	UTCOffset []byte         `json:"utc_offset"` // utc_offset
	IsDst     sql.NullBool   `json:"is_dst"`     // is_dst
}

// PgTimezoneName represents a row from 'pg_catalog.pg_timezone_names'.
type PgTimezoneName struct {
	Name      sql.NullString `json:"name"`       // name
	Abbrev    sql.NullString `json:"abbrev"`     // abbrev
	UTCOffset []byte         `json:"utc_offset"` // utc_offset
	IsDst     sql.NullBool   `json:"is_dst"`     // is_dst
}

// PgTransform represents a row from 'pg_catalog.pg_transform'.
type PgTransform struct {
	Tableoid   pgtypes.Oid     `json:"tableoid"`   // tableoid
	Cmax       pgtypes.Cid     `json:"cmax"`       // cmax
	Xmax       pgtypes.Xid     `json:"xmax"`       // xmax
	Cmin       pgtypes.Cid     `json:"cmin"`       // cmin
	Xmin       pgtypes.Xid     `json:"xmin"`       // xmin
	Ctid       pgtypes.Tid     `json:"ctid"`       // ctid
	Oid        pgtypes.Oid     `json:"oid"`        // oid
	Trftype    pgtypes.Oid     `json:"trftype"`    // trftype
	Trflang    pgtypes.Oid     `json:"trflang"`    // trflang
	Trffromsql pgtypes.Regproc `json:"trffromsql"` // trffromsql
	Trftosql   pgtypes.Regproc `json:"trftosql"`   // trftosql
}

// PgTrigger represents a row from 'pg_catalog.pg_trigger'.
type PgTrigger struct {
	Tableoid       pgtypes.Oid            `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid            `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid            `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid            `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid            `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid            `json:"ctid"`           // ctid
	Oid            pgtypes.Oid            `json:"oid"`            // oid
	Tgrelid        pgtypes.Oid            `json:"tgrelid"`        // tgrelid
	Tgparentid     pgtypes.Oid            `json:"tgparentid"`     // tgparentid
	Tgname         string                 `json:"tgname"`         // tgname
	Tgfoid         pgtypes.Oid            `json:"tgfoid"`         // tgfoid
	Tgtype         int16                  `json:"tgtype"`         // tgtype
	Tgenabled      pgtypes.Char           `json:"tgenabled"`      // tgenabled
	Tgisinternal   bool                   `json:"tgisinternal"`   // tgisinternal
	Tgconstrrelid  pgtypes.Oid            `json:"tgconstrrelid"`  // tgconstrrelid
	Tgconstrindid  pgtypes.Oid            `json:"tgconstrindid"`  // tgconstrindid
	Tgconstraint   pgtypes.Oid            `json:"tgconstraint"`   // tgconstraint
	Tgdeferrable   bool                   `json:"tgdeferrable"`   // tgdeferrable
	Tginitdeferred bool                   `json:"tginitdeferred"` // tginitdeferred
	Tgnargs        int16                  `json:"tgnargs"`        // tgnargs
	Tgattr         pgtypes.Int2vector     `json:"tgattr"`         // tgattr
	Tgargs         []byte                 `json:"tgargs"`         // tgargs
	Tgqual         pgtypes.NullPgNodeTree `json:"tgqual"`         // tgqual
	Tgoldtable     sql.NullString         `json:"tgoldtable"`     // tgoldtable
	Tgnewtable     sql.NullString         `json:"tgnewtable"`     // tgnewtable
}

// PgTsConfig represents a row from 'pg_catalog.pg_ts_config'.
type PgTsConfig struct {
	Tableoid     pgtypes.Oid `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid `json:"ctid"`         // ctid
	Oid          pgtypes.Oid `json:"oid"`          // oid
	Cfgname      string      `json:"cfgname"`      // cfgname
	Cfgnamespace pgtypes.Oid `json:"cfgnamespace"` // cfgnamespace
	Cfgowner     pgtypes.Oid `json:"cfgowner"`     // cfgowner
	Cfgparser    pgtypes.Oid `json:"cfgparser"`    // cfgparser
}

// PgTsConfigMap represents a row from 'pg_catalog.pg_ts_config_map'.
type PgTsConfigMap struct {
	Tableoid     pgtypes.Oid `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid `json:"ctid"`         // ctid
	Mapcfg       pgtypes.Oid `json:"mapcfg"`       // mapcfg
	Maptokentype int         `json:"maptokentype"` // maptokentype
	Mapseqno     int         `json:"mapseqno"`     // mapseqno
	Mapdict      pgtypes.Oid `json:"mapdict"`      // mapdict
}

// PgTsDict represents a row from 'pg_catalog.pg_ts_dict'.
type PgTsDict struct {
	Tableoid       pgtypes.Oid    `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid    `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid    `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid    `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid    `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid    `json:"ctid"`           // ctid
	Oid            pgtypes.Oid    `json:"oid"`            // oid
	Dictname       string         `json:"dictname"`       // dictname
	Dictnamespace  pgtypes.Oid    `json:"dictnamespace"`  // dictnamespace
	Dictowner      pgtypes.Oid    `json:"dictowner"`      // dictowner
	Dicttemplate   pgtypes.Oid    `json:"dicttemplate"`   // dicttemplate
	Dictinitoption sql.NullString `json:"dictinitoption"` // dictinitoption
}

// PgTsParser represents a row from 'pg_catalog.pg_ts_parser'.
type PgTsParser struct {
	Tableoid     pgtypes.Oid     `json:"tableoid"`     // tableoid
	Cmax         pgtypes.Cid     `json:"cmax"`         // cmax
	Xmax         pgtypes.Xid     `json:"xmax"`         // xmax
	Cmin         pgtypes.Cid     `json:"cmin"`         // cmin
	Xmin         pgtypes.Xid     `json:"xmin"`         // xmin
	Ctid         pgtypes.Tid     `json:"ctid"`         // ctid
	Oid          pgtypes.Oid     `json:"oid"`          // oid
	Prsname      string          `json:"prsname"`      // prsname
	Prsnamespace pgtypes.Oid     `json:"prsnamespace"` // prsnamespace
	Prsstart     pgtypes.Regproc `json:"prsstart"`     // prsstart
	Prstoken     pgtypes.Regproc `json:"prstoken"`     // prstoken
	Prsend       pgtypes.Regproc `json:"prsend"`       // prsend
	Prsheadline  pgtypes.Regproc `json:"prsheadline"`  // prsheadline
	Prslextype   pgtypes.Regproc `json:"prslextype"`   // prslextype
}

// PgTsTemplate represents a row from 'pg_catalog.pg_ts_template'.
type PgTsTemplate struct {
	Tableoid      pgtypes.Oid     `json:"tableoid"`      // tableoid
	Cmax          pgtypes.Cid     `json:"cmax"`          // cmax
	Xmax          pgtypes.Xid     `json:"xmax"`          // xmax
	Cmin          pgtypes.Cid     `json:"cmin"`          // cmin
	Xmin          pgtypes.Xid     `json:"xmin"`          // xmin
	Ctid          pgtypes.Tid     `json:"ctid"`          // ctid
	Oid           pgtypes.Oid     `json:"oid"`           // oid
	Tmplname      string          `json:"tmplname"`      // tmplname
	Tmplnamespace pgtypes.Oid     `json:"tmplnamespace"` // tmplnamespace
	Tmplinit      pgtypes.Regproc `json:"tmplinit"`      // tmplinit
	Tmpllexize    pgtypes.Regproc `json:"tmpllexize"`    // tmpllexize
}

// PgType represents a row from 'pg_catalog.pg_type'.
type PgType struct {
	Tableoid       pgtypes.Oid            `json:"tableoid"`       // tableoid
	Cmax           pgtypes.Cid            `json:"cmax"`           // cmax
	Xmax           pgtypes.Xid            `json:"xmax"`           // xmax
	Cmin           pgtypes.Cid            `json:"cmin"`           // cmin
	Xmin           pgtypes.Xid            `json:"xmin"`           // xmin
	Ctid           pgtypes.Tid            `json:"ctid"`           // ctid
	Oid            pgtypes.Oid            `json:"oid"`            // oid
	Typname        string                 `json:"typname"`        // typname
	Typnamespace   pgtypes.Oid            `json:"typnamespace"`   // typnamespace
	Typowner       pgtypes.Oid            `json:"typowner"`       // typowner
	Typlen         int16                  `json:"typlen"`         // typlen
	Typbyval       bool                   `json:"typbyval"`       // typbyval
	Typtype        pgtypes.Char           `json:"typtype"`        // typtype
	Typcategory    pgtypes.Char           `json:"typcategory"`    // typcategory
	Typispreferred bool                   `json:"typispreferred"` // typispreferred
	Typisdefined   bool                   `json:"typisdefined"`   // typisdefined
	Typdelim       pgtypes.Char           `json:"typdelim"`       // typdelim
	Typrelid       pgtypes.Oid            `json:"typrelid"`       // typrelid
	Typelem        pgtypes.Oid            `json:"typelem"`        // typelem
	Typarray       pgtypes.Oid            `json:"typarray"`       // typarray
	Typinput       pgtypes.Regproc        `json:"typinput"`       // typinput
	Typoutput      pgtypes.Regproc        `json:"typoutput"`      // typoutput
	Typreceive     pgtypes.Regproc        `json:"typreceive"`     // typreceive
	Typsend        pgtypes.Regproc        `json:"typsend"`        // typsend
	Typmodin       pgtypes.Regproc        `json:"typmodin"`       // typmodin
	Typmodout      pgtypes.Regproc        `json:"typmodout"`      // typmodout
	Typanalyze     pgtypes.Regproc        `json:"typanalyze"`     // typanalyze
	Typalign       pgtypes.Char           `json:"typalign"`       // typalign
	Typstorage     pgtypes.Char           `json:"typstorage"`     // typstorage
	Typnotnull     bool                   `json:"typnotnull"`     // typnotnull
	Typbasetype    pgtypes.Oid            `json:"typbasetype"`    // typbasetype
	Typtypmod      int                    `json:"typtypmod"`      // typtypmod
	Typndims       int                    `json:"typndims"`       // typndims
	Typcollation   pgtypes.Oid            `json:"typcollation"`   // typcollation
	Typdefaultbin  pgtypes.NullPgNodeTree `json:"typdefaultbin"`  // typdefaultbin
	Typdefault     sql.NullString         `json:"typdefault"`     // typdefault
	Typacl         []pgtypes.NullAclitem  `json:"typacl"`         // typacl
}

// PgUser represents a row from 'pg_catalog.pg_user'.
type PgUser struct {
	Usename      sql.NullString   `json:"usename"`      // usename
	Usesysid     pgtypes.NullOid  `json:"usesysid"`     // usesysid
	Usecreatedb  sql.NullBool     `json:"usecreatedb"`  // usecreatedb
	Usesuper     sql.NullBool     `json:"usesuper"`     // usesuper
	Userepl      sql.NullBool     `json:"userepl"`      // userepl
	Usebypassrls sql.NullBool     `json:"usebypassrls"` // usebypassrls
	Passwd       sql.NullString   `json:"passwd"`       // passwd
	Valuntil     sql.NullTime     `json:"valuntil"`     // valuntil
	Useconfig    []sql.NullString `json:"useconfig"`    // useconfig
}

// PgUserMapping represents a row from 'pg_catalog.pg_user_mapping'.
type PgUserMapping struct {
	Tableoid  pgtypes.Oid      `json:"tableoid"`  // tableoid
	Cmax      pgtypes.Cid      `json:"cmax"`      // cmax
	Xmax      pgtypes.Xid      `json:"xmax"`      // xmax
	Cmin      pgtypes.Cid      `json:"cmin"`      // cmin
	Xmin      pgtypes.Xid      `json:"xmin"`      // xmin
	Ctid      pgtypes.Tid      `json:"ctid"`      // ctid
	Oid       pgtypes.Oid      `json:"oid"`       // oid
	Umuser    pgtypes.Oid      `json:"umuser"`    // umuser
	Umserver  pgtypes.Oid      `json:"umserver"`  // umserver
	Umoptions []sql.NullString `json:"umoptions"` // umoptions
}

// PgUserMapping represents a row from 'pg_catalog.pg_user_mappings'.
type PgUserMapping struct {
	Umid      pgtypes.NullOid  `json:"umid"`      // umid
	Srvid     pgtypes.NullOid  `json:"srvid"`     // srvid
	Srvname   sql.NullString   `json:"srvname"`   // srvname
	Umuser    pgtypes.NullOid  `json:"umuser"`    // umuser
	Usename   sql.NullString   `json:"usename"`   // usename
	Umoptions []sql.NullString `json:"umoptions"` // umoptions
}

// PgView represents a row from 'pg_catalog.pg_views'.
type PgView struct {
	Schemaname sql.NullString `json:"schemaname"` // schemaname
	Viewname   sql.NullString `json:"viewname"`   // viewname
	Viewowner  sql.NullString `json:"viewowner"`  // viewowner
	Definition sql.NullString `json:"definition"` // definition
}

// PgAggregateByAggfnoid retrieves a row from 'pg_catalog.pg_aggregate' as a PgAggregate.
//
// Generated from index 'pg_aggregate_fnoid_index'.
func PgAggregateByAggfnoid(ctx context.Context, db DB, aggfnoid pgtypes.Regproc) (*PgAggregate, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, aggfnoid, aggkind, aggnumdirectargs, aggtransfn, aggfinalfn, aggcombinefn, aggserialfn, aggdeserialfn, aggmtransfn, aggminvtransfn, aggmfinalfn, aggfinalextra, aggmfinalextra, aggfinalmodify, aggmfinalmodify, aggsortop, aggtranstype, aggtransspace, aggmtranstype, aggmtransspace, agginitval, aggminitval ` +
		`FROM pg_catalog.pg_aggregate ` +
		`WHERE aggfnoid = $1`
	// run
	logf(sqlstr, aggfnoid)
	pa := PgAggregate{}
	if err := db.QueryRowContext(ctx, sqlstr, aggfnoid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Aggfnoid, &pa.Aggkind, &pa.Aggnumdirectargs, &pa.Aggtransfn, &pa.Aggfinalfn, &pa.Aggcombinefn, &pa.Aggserialfn, &pa.Aggdeserialfn, &pa.Aggmtransfn, &pa.Aggminvtransfn, &pa.Aggmfinalfn, &pa.Aggfinalextra, &pa.Aggmfinalextra, &pa.Aggfinalmodify, &pa.Aggmfinalmodify, &pa.Aggsortop, &pa.Aggtranstype, &pa.Aggtransspace, &pa.Aggmtranstype, &pa.Aggmtransspace, &pa.Agginitval, &pa.Aggminitval); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmByAmname retrieves a row from 'pg_catalog.pg_am' as a PgAm.
//
// Generated from index 'pg_am_name_index'.
func PgAmByAmname(ctx context.Context, db DB, amname string) (*PgAm, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amname, amhandler, amtype ` +
		`FROM pg_catalog.pg_am ` +
		`WHERE amname = $1`
	// run
	logf(sqlstr, amname)
	pa := PgAm{}
	if err := db.QueryRowContext(ctx, sqlstr, amname).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amname, &pa.Amhandler, &pa.Amtype); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmByOid retrieves a row from 'pg_catalog.pg_am' as a PgAm.
//
// Generated from index 'pg_am_oid_index'.
func PgAmByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgAm, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amname, amhandler, amtype ` +
		`FROM pg_catalog.pg_am ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pa := PgAm{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amname, &pa.Amhandler, &pa.Amtype); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmopByAmopfamilyAmoplefttypeAmoprighttypeAmopstrategy retrieves a row from 'pg_catalog.pg_amop' as a PgAmop.
//
// Generated from index 'pg_amop_fam_strat_index'.
func PgAmopByAmopfamilyAmoplefttypeAmoprighttypeAmopstrategy(ctx context.Context, db DB, amopfamily, amoplefttype, amoprighttype pgtypes.Oid, amopstrategy int16) (*PgAmop, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amopfamily, amoplefttype, amoprighttype, amopstrategy, amoppurpose, amopopr, amopmethod, amopsortfamily ` +
		`FROM pg_catalog.pg_amop ` +
		`WHERE amopfamily = $1 AND amoplefttype = $2 AND amoprighttype = $3 AND amopstrategy = $4`
	// run
	logf(sqlstr, amopfamily, amoplefttype, amoprighttype, amopstrategy)
	pa := PgAmop{}
	if err := db.QueryRowContext(ctx, sqlstr, amopfamily, amoplefttype, amoprighttype, amopstrategy).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amopfamily, &pa.Amoplefttype, &pa.Amoprighttype, &pa.Amopstrategy, &pa.Amoppurpose, &pa.Amopopr, &pa.Amopmethod, &pa.Amopsortfamily); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmopByOid retrieves a row from 'pg_catalog.pg_amop' as a PgAmop.
//
// Generated from index 'pg_amop_oid_index'.
func PgAmopByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgAmop, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amopfamily, amoplefttype, amoprighttype, amopstrategy, amoppurpose, amopopr, amopmethod, amopsortfamily ` +
		`FROM pg_catalog.pg_amop ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pa := PgAmop{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amopfamily, &pa.Amoplefttype, &pa.Amoprighttype, &pa.Amopstrategy, &pa.Amoppurpose, &pa.Amopopr, &pa.Amopmethod, &pa.Amopsortfamily); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmopByAmopoprAmoppurposeAmopfamily retrieves a row from 'pg_catalog.pg_amop' as a PgAmop.
//
// Generated from index 'pg_amop_opr_fam_index'.
func PgAmopByAmopoprAmoppurposeAmopfamily(ctx context.Context, db DB, amopopr pgtypes.Oid, amoppurpose pgtypes.Char, amopfamily pgtypes.Oid) (*PgAmop, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amopfamily, amoplefttype, amoprighttype, amopstrategy, amoppurpose, amopopr, amopmethod, amopsortfamily ` +
		`FROM pg_catalog.pg_amop ` +
		`WHERE amopopr = $1 AND amoppurpose = $2 AND amopfamily = $3`
	// run
	logf(sqlstr, amopopr, amoppurpose, amopfamily)
	pa := PgAmop{}
	if err := db.QueryRowContext(ctx, sqlstr, amopopr, amoppurpose, amopfamily).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amopfamily, &pa.Amoplefttype, &pa.Amoprighttype, &pa.Amopstrategy, &pa.Amoppurpose, &pa.Amopopr, &pa.Amopmethod, &pa.Amopsortfamily); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmprocByAmprocfamilyAmproclefttypeAmprocrighttypeAmprocnum retrieves a row from 'pg_catalog.pg_amproc' as a PgAmproc.
//
// Generated from index 'pg_amproc_fam_proc_index'.
func PgAmprocByAmprocfamilyAmproclefttypeAmprocrighttypeAmprocnum(ctx context.Context, db DB, amprocfamily, amproclefttype, amprocrighttype pgtypes.Oid, amprocnum int16) (*PgAmproc, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amprocfamily, amproclefttype, amprocrighttype, amprocnum, amproc ` +
		`FROM pg_catalog.pg_amproc ` +
		`WHERE amprocfamily = $1 AND amproclefttype = $2 AND amprocrighttype = $3 AND amprocnum = $4`
	// run
	logf(sqlstr, amprocfamily, amproclefttype, amprocrighttype, amprocnum)
	pa := PgAmproc{}
	if err := db.QueryRowContext(ctx, sqlstr, amprocfamily, amproclefttype, amprocrighttype, amprocnum).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amprocfamily, &pa.Amproclefttype, &pa.Amprocrighttype, &pa.Amprocnum, &pa.Amproc); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAmprocByOid retrieves a row from 'pg_catalog.pg_amproc' as a PgAmproc.
//
// Generated from index 'pg_amproc_oid_index'.
func PgAmprocByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgAmproc, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, amprocfamily, amproclefttype, amprocrighttype, amprocnum, amproc ` +
		`FROM pg_catalog.pg_amproc ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pa := PgAmproc{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Amprocfamily, &pa.Amproclefttype, &pa.Amprocrighttype, &pa.Amprocnum, &pa.Amproc); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAttrdefByAdrelidAdnum retrieves a row from 'pg_catalog.pg_attrdef' as a PgAttrdef.
//
// Generated from index 'pg_attrdef_adrelid_adnum_index'.
func PgAttrdefByAdrelidAdnum(ctx context.Context, db DB, adrelid pgtypes.Oid, adnum int16) (*PgAttrdef, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, adrelid, adnum, adbin ` +
		`FROM pg_catalog.pg_attrdef ` +
		`WHERE adrelid = $1 AND adnum = $2`
	// run
	logf(sqlstr, adrelid, adnum)
	pa := PgAttrdef{}
	if err := db.QueryRowContext(ctx, sqlstr, adrelid, adnum).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Adrelid, &pa.Adnum, &pa.Adbin); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAttrdefByOid retrieves a row from 'pg_catalog.pg_attrdef' as a PgAttrdef.
//
// Generated from index 'pg_attrdef_oid_index'.
func PgAttrdefByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgAttrdef, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, adrelid, adnum, adbin ` +
		`FROM pg_catalog.pg_attrdef ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pa := PgAttrdef{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Adrelid, &pa.Adnum, &pa.Adbin); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAttributeByAttrelidAttname retrieves a row from 'pg_catalog.pg_attribute' as a PgAttribute.
//
// Generated from index 'pg_attribute_relid_attnam_index'.
func PgAttributeByAttrelidAttname(ctx context.Context, db DB, attrelid pgtypes.Oid, attname string) (*PgAttribute, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, attrelid, attname, atttypid, attstattarget, attlen, attnum, attndims, attcacheoff, atttypmod, attbyval, attstorage, attalign, attnotnull, atthasdef, atthasmissing, attidentity, attgenerated, attisdropped, attislocal, attinhcount, attcollation, attacl, attoptions, attfdwoptions, attmissingval ` +
		`FROM pg_catalog.pg_attribute ` +
		`WHERE attrelid = $1 AND attname = $2`
	// run
	logf(sqlstr, attrelid, attname)
	pa := PgAttribute{}
	if err := db.QueryRowContext(ctx, sqlstr, attrelid, attname).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Attrelid, &pa.Attname, &pa.Atttypid, &pa.Attstattarget, &pa.Attlen, &pa.Attnum, &pa.Attndims, &pa.Attcacheoff, &pa.Atttypmod, &pa.Attbyval, &pa.Attstorage, &pa.Attalign, &pa.Attnotnull, &pa.Atthasdef, &pa.Atthasmissing, &pa.Attidentity, &pa.Attgenerated, &pa.Attisdropped, &pa.Attislocal, &pa.Attinhcount, &pa.Attcollation, &pa.Attacl, &pa.Attoptions, &pa.Attfdwoptions, &pa.Attmissingval); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAttributeByAttrelidAttnum retrieves a row from 'pg_catalog.pg_attribute' as a PgAttribute.
//
// Generated from index 'pg_attribute_relid_attnum_index'.
func PgAttributeByAttrelidAttnum(ctx context.Context, db DB, attrelid pgtypes.Oid, attnum int16) (*PgAttribute, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, attrelid, attname, atttypid, attstattarget, attlen, attnum, attndims, attcacheoff, atttypmod, attbyval, attstorage, attalign, attnotnull, atthasdef, atthasmissing, attidentity, attgenerated, attisdropped, attislocal, attinhcount, attcollation, attacl, attoptions, attfdwoptions, attmissingval ` +
		`FROM pg_catalog.pg_attribute ` +
		`WHERE attrelid = $1 AND attnum = $2`
	// run
	logf(sqlstr, attrelid, attnum)
	pa := PgAttribute{}
	if err := db.QueryRowContext(ctx, sqlstr, attrelid, attnum).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Attrelid, &pa.Attname, &pa.Atttypid, &pa.Attstattarget, &pa.Attlen, &pa.Attnum, &pa.Attndims, &pa.Attcacheoff, &pa.Atttypmod, &pa.Attbyval, &pa.Attstorage, &pa.Attalign, &pa.Attnotnull, &pa.Atthasdef, &pa.Atthasmissing, &pa.Attidentity, &pa.Attgenerated, &pa.Attisdropped, &pa.Attislocal, &pa.Attinhcount, &pa.Attcollation, &pa.Attacl, &pa.Attoptions, &pa.Attfdwoptions, &pa.Attmissingval); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAuthMemberByMemberRoleid retrieves a row from 'pg_catalog.pg_auth_members' as a PgAuthMember.
//
// Generated from index 'pg_auth_members_member_role_index'.
func PgAuthMemberByMemberRoleid(ctx context.Context, db DB, member, roleid pgtypes.Oid) (*PgAuthMember, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, roleid, member, grantor, admin_option ` +
		`FROM pg_catalog.pg_auth_members ` +
		`WHERE member = $1 AND roleid = $2`
	// run
	logf(sqlstr, member, roleid)
	pam := PgAuthMember{}
	if err := db.QueryRowContext(ctx, sqlstr, member, roleid).Scan(&pam.Tableoid, &pam.Cmax, &pam.Xmax, &pam.Cmin, &pam.Xmin, &pam.Ctid, &pam.Roleid, &pam.Member, &pam.Grantor, &pam.AdminOption); err != nil {
		return nil, logerror(err)
	}
	return &pam, nil
}

// PgAuthMemberByRoleidMember retrieves a row from 'pg_catalog.pg_auth_members' as a PgAuthMember.
//
// Generated from index 'pg_auth_members_role_member_index'.
func PgAuthMemberByRoleidMember(ctx context.Context, db DB, roleid, member pgtypes.Oid) (*PgAuthMember, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, roleid, member, grantor, admin_option ` +
		`FROM pg_catalog.pg_auth_members ` +
		`WHERE roleid = $1 AND member = $2`
	// run
	logf(sqlstr, roleid, member)
	pam := PgAuthMember{}
	if err := db.QueryRowContext(ctx, sqlstr, roleid, member).Scan(&pam.Tableoid, &pam.Cmax, &pam.Xmax, &pam.Cmin, &pam.Xmin, &pam.Ctid, &pam.Roleid, &pam.Member, &pam.Grantor, &pam.AdminOption); err != nil {
		return nil, logerror(err)
	}
	return &pam, nil
}

// PgAuthidByOid retrieves a row from 'pg_catalog.pg_authid' as a PgAuthid.
//
// Generated from index 'pg_authid_oid_index'.
func PgAuthidByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgAuthid, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb, rolcanlogin, rolreplication, rolbypassrls, rolconnlimit, rolpassword, rolvaliduntil ` +
		`FROM pg_catalog.pg_authid ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pa := PgAuthid{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Rolname, &pa.Rolsuper, &pa.Rolinherit, &pa.Rolcreaterole, &pa.Rolcreatedb, &pa.Rolcanlogin, &pa.Rolreplication, &pa.Rolbypassrls, &pa.Rolconnlimit, &pa.Rolpassword, &pa.Rolvaliduntil); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgAuthidByRolname retrieves a row from 'pg_catalog.pg_authid' as a PgAuthid.
//
// Generated from index 'pg_authid_rolname_index'.
func PgAuthidByRolname(ctx context.Context, db DB, rolname string) (*PgAuthid, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb, rolcanlogin, rolreplication, rolbypassrls, rolconnlimit, rolpassword, rolvaliduntil ` +
		`FROM pg_catalog.pg_authid ` +
		`WHERE rolname = $1`
	// run
	logf(sqlstr, rolname)
	pa := PgAuthid{}
	if err := db.QueryRowContext(ctx, sqlstr, rolname).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Oid, &pa.Rolname, &pa.Rolsuper, &pa.Rolinherit, &pa.Rolcreaterole, &pa.Rolcreatedb, &pa.Rolcanlogin, &pa.Rolreplication, &pa.Rolbypassrls, &pa.Rolconnlimit, &pa.Rolpassword, &pa.Rolvaliduntil); err != nil {
		return nil, logerror(err)
	}
	return &pa, nil
}

// PgCastByOid retrieves a row from 'pg_catalog.pg_cast' as a PgCast.
//
// Generated from index 'pg_cast_oid_index'.
func PgCastByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgCast, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, castsource, casttarget, castfunc, castcontext, castmethod ` +
		`FROM pg_catalog.pg_cast ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pc := PgCast{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Castsource, &pc.Casttarget, &pc.Castfunc, &pc.Castcontext, &pc.Castmethod); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgCastByCastsourceCasttarget retrieves a row from 'pg_catalog.pg_cast' as a PgCast.
//
// Generated from index 'pg_cast_source_target_index'.
func PgCastByCastsourceCasttarget(ctx context.Context, db DB, castsource, casttarget pgtypes.Oid) (*PgCast, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, castsource, casttarget, castfunc, castcontext, castmethod ` +
		`FROM pg_catalog.pg_cast ` +
		`WHERE castsource = $1 AND casttarget = $2`
	// run
	logf(sqlstr, castsource, casttarget)
	pc := PgCast{}
	if err := db.QueryRowContext(ctx, sqlstr, castsource, casttarget).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Castsource, &pc.Casttarget, &pc.Castfunc, &pc.Castcontext, &pc.Castmethod); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgClassByOid retrieves a row from 'pg_catalog.pg_class' as a PgClass.
//
// Generated from index 'pg_class_oid_index'.
func PgClassByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgClass, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, relname, relnamespace, reltype, reloftype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, relallvisible, reltoastrelid, relhasindex, relisshared, relpersistence, relkind, relnatts, relchecks, relhasrules, relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity, relispopulated, relreplident, relispartition, relrewrite, relfrozenxid, relminmxid, relacl, reloptions, relpartbound ` +
		`FROM pg_catalog.pg_class ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pc := PgClass{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Relname, &pc.Relnamespace, &pc.Reltype, &pc.Reloftype, &pc.Relowner, &pc.Relam, &pc.Relfilenode, &pc.Reltablespace, &pc.Relpages, &pc.Reltuples, &pc.Relallvisible, &pc.Reltoastrelid, &pc.Relhasindex, &pc.Relisshared, &pc.Relpersistence, &pc.Relkind, &pc.Relnatts, &pc.Relchecks, &pc.Relhasrules, &pc.Relhastriggers, &pc.Relhassubclass, &pc.Relrowsecurity, &pc.Relforcerowsecurity, &pc.Relispopulated, &pc.Relreplident, &pc.Relispartition, &pc.Relrewrite, &pc.Relfrozenxid, &pc.Relminmxid, &pc.Relacl, &pc.Reloptions, &pc.Relpartbound); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgClassByRelnameRelnamespace retrieves a row from 'pg_catalog.pg_class' as a PgClass.
//
// Generated from index 'pg_class_relname_nsp_index'.
func PgClassByRelnameRelnamespace(ctx context.Context, db DB, relname string, relnamespace pgtypes.Oid) (*PgClass, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, relname, relnamespace, reltype, reloftype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, relallvisible, reltoastrelid, relhasindex, relisshared, relpersistence, relkind, relnatts, relchecks, relhasrules, relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity, relispopulated, relreplident, relispartition, relrewrite, relfrozenxid, relminmxid, relacl, reloptions, relpartbound ` +
		`FROM pg_catalog.pg_class ` +
		`WHERE relname = $1 AND relnamespace = $2`
	// run
	logf(sqlstr, relname, relnamespace)
	pc := PgClass{}
	if err := db.QueryRowContext(ctx, sqlstr, relname, relnamespace).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Relname, &pc.Relnamespace, &pc.Reltype, &pc.Reloftype, &pc.Relowner, &pc.Relam, &pc.Relfilenode, &pc.Reltablespace, &pc.Relpages, &pc.Reltuples, &pc.Relallvisible, &pc.Reltoastrelid, &pc.Relhasindex, &pc.Relisshared, &pc.Relpersistence, &pc.Relkind, &pc.Relnatts, &pc.Relchecks, &pc.Relhasrules, &pc.Relhastriggers, &pc.Relhassubclass, &pc.Relrowsecurity, &pc.Relforcerowsecurity, &pc.Relispopulated, &pc.Relreplident, &pc.Relispartition, &pc.Relrewrite, &pc.Relfrozenxid, &pc.Relminmxid, &pc.Relacl, &pc.Reloptions, &pc.Relpartbound); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgClassByReltablespaceRelfilenode retrieves a row from 'pg_catalog.pg_class' as a PgClass.
//
// Generated from index 'pg_class_tblspc_relfilenode_index'.
func PgClassByReltablespaceRelfilenode(ctx context.Context, db DB, reltablespace, relfilenode pgtypes.Oid) ([]*PgClass, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, relname, relnamespace, reltype, reloftype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, relallvisible, reltoastrelid, relhasindex, relisshared, relpersistence, relkind, relnatts, relchecks, relhasrules, relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity, relispopulated, relreplident, relispartition, relrewrite, relfrozenxid, relminmxid, relacl, reloptions, relpartbound ` +
		`FROM pg_catalog.pg_class ` +
		`WHERE reltablespace = $1 AND relfilenode = $2`
	// run
	logf(sqlstr, reltablespace, relfilenode)
	rows, err := db.QueryContext(ctx, sqlstr, reltablespace, relfilenode)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgClass
	for rows.Next() {
		pc := PgClass{}
		// scan
		if err := rows.Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Relname, &pc.Relnamespace, &pc.Reltype, &pc.Reloftype, &pc.Relowner, &pc.Relam, &pc.Relfilenode, &pc.Reltablespace, &pc.Relpages, &pc.Reltuples, &pc.Relallvisible, &pc.Reltoastrelid, &pc.Relhasindex, &pc.Relisshared, &pc.Relpersistence, &pc.Relkind, &pc.Relnatts, &pc.Relchecks, &pc.Relhasrules, &pc.Relhastriggers, &pc.Relhassubclass, &pc.Relrowsecurity, &pc.Relforcerowsecurity, &pc.Relispopulated, &pc.Relreplident, &pc.Relispartition, &pc.Relrewrite, &pc.Relfrozenxid, &pc.Relminmxid, &pc.Relacl, &pc.Reloptions, &pc.Relpartbound); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgCollationByCollnameCollencodingCollnamespace retrieves a row from 'pg_catalog.pg_collation' as a PgCollation.
//
// Generated from index 'pg_collation_name_enc_nsp_index'.
func PgCollationByCollnameCollencodingCollnamespace(ctx context.Context, db DB, collname string, collencoding int, collnamespace pgtypes.Oid) (*PgCollation, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype, collversion ` +
		`FROM pg_catalog.pg_collation ` +
		`WHERE collname = $1 AND collencoding = $2 AND collnamespace = $3`
	// run
	logf(sqlstr, collname, collencoding, collnamespace)
	pc := PgCollation{}
	if err := db.QueryRowContext(ctx, sqlstr, collname, collencoding, collnamespace).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Collname, &pc.Collnamespace, &pc.Collowner, &pc.Collprovider, &pc.Collisdeterministic, &pc.Collencoding, &pc.Collcollate, &pc.Collctype, &pc.Collversion); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgCollationByOid retrieves a row from 'pg_catalog.pg_collation' as a PgCollation.
//
// Generated from index 'pg_collation_oid_index'.
func PgCollationByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgCollation, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype, collversion ` +
		`FROM pg_catalog.pg_collation ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pc := PgCollation{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Collname, &pc.Collnamespace, &pc.Collowner, &pc.Collprovider, &pc.Collisdeterministic, &pc.Collencoding, &pc.Collcollate, &pc.Collctype, &pc.Collversion); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgConstraintByConnameConnamespace retrieves a row from 'pg_catalog.pg_constraint' as a PgConstraint.
//
// Generated from index 'pg_constraint_conname_nsp_index'.
func PgConstraintByConnameConnamespace(ctx context.Context, db DB, conname string, connamespace pgtypes.Oid) ([]*PgConstraint, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, contype, condeferrable, condeferred, convalidated, conrelid, contypid, conindid, conparentid, confrelid, confupdtype, confdeltype, confmatchtype, conislocal, coninhcount, connoinherit, conkey, confkey, conpfeqop, conppeqop, conffeqop, conexclop, conbin ` +
		`FROM pg_catalog.pg_constraint ` +
		`WHERE conname = $1 AND connamespace = $2`
	// run
	logf(sqlstr, conname, connamespace)
	rows, err := db.QueryContext(ctx, sqlstr, conname, connamespace)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgConstraint
	for rows.Next() {
		pc := PgConstraint{}
		// scan
		if err := rows.Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Contype, &pc.Condeferrable, &pc.Condeferred, &pc.Convalidated, &pc.Conrelid, &pc.Contypid, &pc.Conindid, &pc.Conparentid, &pc.Confrelid, &pc.Confupdtype, &pc.Confdeltype, &pc.Confmatchtype, &pc.Conislocal, &pc.Coninhcount, &pc.Connoinherit, &pc.Conkey, &pc.Confkey, &pc.Conpfeqop, &pc.Conppeqop, &pc.Conffeqop, &pc.Conexclop, &pc.Conbin); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgConstraintByConparentid retrieves a row from 'pg_catalog.pg_constraint' as a PgConstraint.
//
// Generated from index 'pg_constraint_conparentid_index'.
func PgConstraintByConparentid(ctx context.Context, db DB, conparentid pgtypes.Oid) ([]*PgConstraint, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, contype, condeferrable, condeferred, convalidated, conrelid, contypid, conindid, conparentid, confrelid, confupdtype, confdeltype, confmatchtype, conislocal, coninhcount, connoinherit, conkey, confkey, conpfeqop, conppeqop, conffeqop, conexclop, conbin ` +
		`FROM pg_catalog.pg_constraint ` +
		`WHERE conparentid = $1`
	// run
	logf(sqlstr, conparentid)
	rows, err := db.QueryContext(ctx, sqlstr, conparentid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgConstraint
	for rows.Next() {
		pc := PgConstraint{}
		// scan
		if err := rows.Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Contype, &pc.Condeferrable, &pc.Condeferred, &pc.Convalidated, &pc.Conrelid, &pc.Contypid, &pc.Conindid, &pc.Conparentid, &pc.Confrelid, &pc.Confupdtype, &pc.Confdeltype, &pc.Confmatchtype, &pc.Conislocal, &pc.Coninhcount, &pc.Connoinherit, &pc.Conkey, &pc.Confkey, &pc.Conpfeqop, &pc.Conppeqop, &pc.Conffeqop, &pc.Conexclop, &pc.Conbin); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgConstraintByConrelidContypidConname retrieves a row from 'pg_catalog.pg_constraint' as a PgConstraint.
//
// Generated from index 'pg_constraint_conrelid_contypid_conname_index'.
func PgConstraintByConrelidContypidConname(ctx context.Context, db DB, conrelid, contypid pgtypes.Oid, conname string) (*PgConstraint, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, contype, condeferrable, condeferred, convalidated, conrelid, contypid, conindid, conparentid, confrelid, confupdtype, confdeltype, confmatchtype, conislocal, coninhcount, connoinherit, conkey, confkey, conpfeqop, conppeqop, conffeqop, conexclop, conbin ` +
		`FROM pg_catalog.pg_constraint ` +
		`WHERE conrelid = $1 AND contypid = $2 AND conname = $3`
	// run
	logf(sqlstr, conrelid, contypid, conname)
	pc := PgConstraint{}
	if err := db.QueryRowContext(ctx, sqlstr, conrelid, contypid, conname).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Contype, &pc.Condeferrable, &pc.Condeferred, &pc.Convalidated, &pc.Conrelid, &pc.Contypid, &pc.Conindid, &pc.Conparentid, &pc.Confrelid, &pc.Confupdtype, &pc.Confdeltype, &pc.Confmatchtype, &pc.Conislocal, &pc.Coninhcount, &pc.Connoinherit, &pc.Conkey, &pc.Confkey, &pc.Conpfeqop, &pc.Conppeqop, &pc.Conffeqop, &pc.Conexclop, &pc.Conbin); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgConstraintByContypid retrieves a row from 'pg_catalog.pg_constraint' as a PgConstraint.
//
// Generated from index 'pg_constraint_contypid_index'.
func PgConstraintByContypid(ctx context.Context, db DB, contypid pgtypes.Oid) ([]*PgConstraint, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, contype, condeferrable, condeferred, convalidated, conrelid, contypid, conindid, conparentid, confrelid, confupdtype, confdeltype, confmatchtype, conislocal, coninhcount, connoinherit, conkey, confkey, conpfeqop, conppeqop, conffeqop, conexclop, conbin ` +
		`FROM pg_catalog.pg_constraint ` +
		`WHERE contypid = $1`
	// run
	logf(sqlstr, contypid)
	rows, err := db.QueryContext(ctx, sqlstr, contypid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgConstraint
	for rows.Next() {
		pc := PgConstraint{}
		// scan
		if err := rows.Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Contype, &pc.Condeferrable, &pc.Condeferred, &pc.Convalidated, &pc.Conrelid, &pc.Contypid, &pc.Conindid, &pc.Conparentid, &pc.Confrelid, &pc.Confupdtype, &pc.Confdeltype, &pc.Confmatchtype, &pc.Conislocal, &pc.Coninhcount, &pc.Connoinherit, &pc.Conkey, &pc.Confkey, &pc.Conpfeqop, &pc.Conppeqop, &pc.Conffeqop, &pc.Conexclop, &pc.Conbin); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgConstraintByOid retrieves a row from 'pg_catalog.pg_constraint' as a PgConstraint.
//
// Generated from index 'pg_constraint_oid_index'.
func PgConstraintByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgConstraint, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, contype, condeferrable, condeferred, convalidated, conrelid, contypid, conindid, conparentid, confrelid, confupdtype, confdeltype, confmatchtype, conislocal, coninhcount, connoinherit, conkey, confkey, conpfeqop, conppeqop, conffeqop, conexclop, conbin ` +
		`FROM pg_catalog.pg_constraint ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pc := PgConstraint{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Contype, &pc.Condeferrable, &pc.Condeferred, &pc.Convalidated, &pc.Conrelid, &pc.Contypid, &pc.Conindid, &pc.Conparentid, &pc.Confrelid, &pc.Confupdtype, &pc.Confdeltype, &pc.Confmatchtype, &pc.Conislocal, &pc.Coninhcount, &pc.Connoinherit, &pc.Conkey, &pc.Confkey, &pc.Conpfeqop, &pc.Conppeqop, &pc.Conffeqop, &pc.Conexclop, &pc.Conbin); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgConversionByConnamespaceConforencodingContoencodingOid retrieves a row from 'pg_catalog.pg_conversion' as a PgConversion.
//
// Generated from index 'pg_conversion_default_index'.
func PgConversionByConnamespaceConforencodingContoencodingOid(ctx context.Context, db DB, connamespace pgtypes.Oid, conforencoding, contoencoding int, oid pgtypes.Oid) (*PgConversion, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, conowner, conforencoding, contoencoding, conproc, condefault ` +
		`FROM pg_catalog.pg_conversion ` +
		`WHERE connamespace = $1 AND conforencoding = $2 AND contoencoding = $3 AND oid = $4`
	// run
	logf(sqlstr, connamespace, conforencoding, contoencoding, oid)
	pc := PgConversion{}
	if err := db.QueryRowContext(ctx, sqlstr, connamespace, conforencoding, contoencoding, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Conowner, &pc.Conforencoding, &pc.Contoencoding, &pc.Conproc, &pc.Condefault); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgConversionByConnameConnamespace retrieves a row from 'pg_catalog.pg_conversion' as a PgConversion.
//
// Generated from index 'pg_conversion_name_nsp_index'.
func PgConversionByConnameConnamespace(ctx context.Context, db DB, conname string, connamespace pgtypes.Oid) (*PgConversion, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, conowner, conforencoding, contoencoding, conproc, condefault ` +
		`FROM pg_catalog.pg_conversion ` +
		`WHERE conname = $1 AND connamespace = $2`
	// run
	logf(sqlstr, conname, connamespace)
	pc := PgConversion{}
	if err := db.QueryRowContext(ctx, sqlstr, conname, connamespace).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Conowner, &pc.Conforencoding, &pc.Contoencoding, &pc.Conproc, &pc.Condefault); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgConversionByOid retrieves a row from 'pg_catalog.pg_conversion' as a PgConversion.
//
// Generated from index 'pg_conversion_oid_index'.
func PgConversionByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgConversion, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, conname, connamespace, conowner, conforencoding, contoencoding, conproc, condefault ` +
		`FROM pg_catalog.pg_conversion ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pc := PgConversion{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Ctid, &pc.Oid, &pc.Conname, &pc.Connamespace, &pc.Conowner, &pc.Conforencoding, &pc.Contoencoding, &pc.Conproc, &pc.Condefault); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}

// PgDatabaseByDatname retrieves a row from 'pg_catalog.pg_database' as a PgDatabase.
//
// Generated from index 'pg_database_datname_index'.
func PgDatabaseByDatname(ctx context.Context, db DB, datname string) (*PgDatabase, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, datname, datdba, encoding, datcollate, datctype, datistemplate, datallowconn, datconnlimit, datlastsysoid, datfrozenxid, datminmxid, dattablespace, datacl ` +
		`FROM pg_catalog.pg_database ` +
		`WHERE datname = $1`
	// run
	logf(sqlstr, datname)
	pd := PgDatabase{}
	if err := db.QueryRowContext(ctx, sqlstr, datname).Scan(&pd.Tableoid, &pd.Cmax, &pd.Xmax, &pd.Cmin, &pd.Xmin, &pd.Ctid, &pd.Oid, &pd.Datname, &pd.Datdba, &pd.Encoding, &pd.Datcollate, &pd.Datctype, &pd.Datistemplate, &pd.Datallowconn, &pd.Datconnlimit, &pd.Datlastsysoid, &pd.Datfrozenxid, &pd.Datminmxid, &pd.Dattablespace, &pd.Datacl); err != nil {
		return nil, logerror(err)
	}
	return &pd, nil
}

// PgDatabaseByOid retrieves a row from 'pg_catalog.pg_database' as a PgDatabase.
//
// Generated from index 'pg_database_oid_index'.
func PgDatabaseByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgDatabase, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, datname, datdba, encoding, datcollate, datctype, datistemplate, datallowconn, datconnlimit, datlastsysoid, datfrozenxid, datminmxid, dattablespace, datacl ` +
		`FROM pg_catalog.pg_database ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pd := PgDatabase{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pd.Tableoid, &pd.Cmax, &pd.Xmax, &pd.Cmin, &pd.Xmin, &pd.Ctid, &pd.Oid, &pd.Datname, &pd.Datdba, &pd.Encoding, &pd.Datcollate, &pd.Datctype, &pd.Datistemplate, &pd.Datallowconn, &pd.Datconnlimit, &pd.Datlastsysoid, &pd.Datfrozenxid, &pd.Datminmxid, &pd.Dattablespace, &pd.Datacl); err != nil {
		return nil, logerror(err)
	}
	return &pd, nil
}

// PgDbRoleSettingBySetdatabaseSetrole retrieves a row from 'pg_catalog.pg_db_role_setting' as a PgDbRoleSetting.
//
// Generated from index 'pg_db_role_setting_databaseid_rol_index'.
func PgDbRoleSettingBySetdatabaseSetrole(ctx context.Context, db DB, setdatabase, setrole pgtypes.Oid) (*PgDbRoleSetting, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, setdatabase, setrole, setconfig ` +
		`FROM pg_catalog.pg_db_role_setting ` +
		`WHERE setdatabase = $1 AND setrole = $2`
	// run
	logf(sqlstr, setdatabase, setrole)
	pdrs := PgDbRoleSetting{}
	if err := db.QueryRowContext(ctx, sqlstr, setdatabase, setrole).Scan(&pdrs.Tableoid, &pdrs.Cmax, &pdrs.Xmax, &pdrs.Cmin, &pdrs.Xmin, &pdrs.Ctid, &pdrs.Setdatabase, &pdrs.Setrole, &pdrs.Setconfig); err != nil {
		return nil, logerror(err)
	}
	return &pdrs, nil
}

// PgDefaultACLByOid retrieves a row from 'pg_catalog.pg_default_acl' as a PgDefaultACL.
//
// Generated from index 'pg_default_acl_oid_index'.
func PgDefaultACLByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgDefaultACL, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, defaclrole, defaclnamespace, defaclobjtype, defaclacl ` +
		`FROM pg_catalog.pg_default_acl ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pda := PgDefaultACL{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pda.Tableoid, &pda.Cmax, &pda.Xmax, &pda.Cmin, &pda.Xmin, &pda.Ctid, &pda.Oid, &pda.Defaclrole, &pda.Defaclnamespace, &pda.Defaclobjtype, &pda.Defaclacl); err != nil {
		return nil, logerror(err)
	}
	return &pda, nil
}

// PgDefaultACLByDefaclroleDefaclnamespaceDefaclobjtype retrieves a row from 'pg_catalog.pg_default_acl' as a PgDefaultACL.
//
// Generated from index 'pg_default_acl_role_nsp_obj_index'.
func PgDefaultACLByDefaclroleDefaclnamespaceDefaclobjtype(ctx context.Context, db DB, defaclrole, defaclnamespace pgtypes.Oid, defaclobjtype pgtypes.Char) (*PgDefaultACL, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, defaclrole, defaclnamespace, defaclobjtype, defaclacl ` +
		`FROM pg_catalog.pg_default_acl ` +
		`WHERE defaclrole = $1 AND defaclnamespace = $2 AND defaclobjtype = $3`
	// run
	logf(sqlstr, defaclrole, defaclnamespace, defaclobjtype)
	pda := PgDefaultACL{}
	if err := db.QueryRowContext(ctx, sqlstr, defaclrole, defaclnamespace, defaclobjtype).Scan(&pda.Tableoid, &pda.Cmax, &pda.Xmax, &pda.Cmin, &pda.Xmin, &pda.Ctid, &pda.Oid, &pda.Defaclrole, &pda.Defaclnamespace, &pda.Defaclobjtype, &pda.Defaclacl); err != nil {
		return nil, logerror(err)
	}
	return &pda, nil
}

// PgDependByClassidObjidObjsubid retrieves a row from 'pg_catalog.pg_depend' as a PgDepend.
//
// Generated from index 'pg_depend_depender_index'.
func PgDependByClassidObjidObjsubid(ctx context.Context, db DB, classid, objid pgtypes.Oid, objsubid int) ([]*PgDepend, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, classid, objid, objsubid, refclassid, refobjid, refobjsubid, deptype ` +
		`FROM pg_catalog.pg_depend ` +
		`WHERE classid = $1 AND objid = $2 AND objsubid = $3`
	// run
	logf(sqlstr, classid, objid, objsubid)
	rows, err := db.QueryContext(ctx, sqlstr, classid, objid, objsubid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgDepend
	for rows.Next() {
		pd := PgDepend{}
		// scan
		if err := rows.Scan(&pd.Tableoid, &pd.Cmax, &pd.Xmax, &pd.Cmin, &pd.Xmin, &pd.Ctid, &pd.Classid, &pd.Objid, &pd.Objsubid, &pd.Refclassid, &pd.Refobjid, &pd.Refobjsubid, &pd.Deptype); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pd)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgDependByRefclassidRefobjidRefobjsubid retrieves a row from 'pg_catalog.pg_depend' as a PgDepend.
//
// Generated from index 'pg_depend_reference_index'.
func PgDependByRefclassidRefobjidRefobjsubid(ctx context.Context, db DB, refclassid, refobjid pgtypes.Oid, refobjsubid int) ([]*PgDepend, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, classid, objid, objsubid, refclassid, refobjid, refobjsubid, deptype ` +
		`FROM pg_catalog.pg_depend ` +
		`WHERE refclassid = $1 AND refobjid = $2 AND refobjsubid = $3`
	// run
	logf(sqlstr, refclassid, refobjid, refobjsubid)
	rows, err := db.QueryContext(ctx, sqlstr, refclassid, refobjid, refobjsubid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgDepend
	for rows.Next() {
		pd := PgDepend{}
		// scan
		if err := rows.Scan(&pd.Tableoid, &pd.Cmax, &pd.Xmax, &pd.Cmin, &pd.Xmin, &pd.Ctid, &pd.Classid, &pd.Objid, &pd.Objsubid, &pd.Refclassid, &pd.Refobjid, &pd.Refobjsubid, &pd.Deptype); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pd)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgDescriptionByObjoidClassoidObjsubid retrieves a row from 'pg_catalog.pg_description' as a PgDescription.
//
// Generated from index 'pg_description_o_c_o_index'.
func PgDescriptionByObjoidClassoidObjsubid(ctx context.Context, db DB, objoid, classoid pgtypes.Oid, objsubid int) (*PgDescription, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, objoid, classoid, objsubid, description ` +
		`FROM pg_catalog.pg_description ` +
		`WHERE objoid = $1 AND classoid = $2 AND objsubid = $3`
	// run
	logf(sqlstr, objoid, classoid, objsubid)
	pd := PgDescription{}
	if err := db.QueryRowContext(ctx, sqlstr, objoid, classoid, objsubid).Scan(&pd.Tableoid, &pd.Cmax, &pd.Xmax, &pd.Cmin, &pd.Xmin, &pd.Ctid, &pd.Objoid, &pd.Classoid, &pd.Objsubid, &pd.Description); err != nil {
		return nil, logerror(err)
	}
	return &pd, nil
}

// PgEnumByOid retrieves a row from 'pg_catalog.pg_enum' as a PgEnum.
//
// Generated from index 'pg_enum_oid_index'.
func PgEnumByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgEnum, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, enumtypid, enumsortorder, enumlabel ` +
		`FROM pg_catalog.pg_enum ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pe := PgEnum{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Ctid, &pe.Oid, &pe.Enumtypid, &pe.Enumsortorder, &pe.Enumlabel); err != nil {
		return nil, logerror(err)
	}
	return &pe, nil
}

// PgEnumByEnumtypidEnumlabel retrieves a row from 'pg_catalog.pg_enum' as a PgEnum.
//
// Generated from index 'pg_enum_typid_label_index'.
func PgEnumByEnumtypidEnumlabel(ctx context.Context, db DB, enumtypid pgtypes.Oid, enumlabel string) (*PgEnum, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, enumtypid, enumsortorder, enumlabel ` +
		`FROM pg_catalog.pg_enum ` +
		`WHERE enumtypid = $1 AND enumlabel = $2`
	// run
	logf(sqlstr, enumtypid, enumlabel)
	pe := PgEnum{}
	if err := db.QueryRowContext(ctx, sqlstr, enumtypid, enumlabel).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Ctid, &pe.Oid, &pe.Enumtypid, &pe.Enumsortorder, &pe.Enumlabel); err != nil {
		return nil, logerror(err)
	}
	return &pe, nil
}

// PgEnumByEnumtypidEnumsortorder retrieves a row from 'pg_catalog.pg_enum' as a PgEnum.
//
// Generated from index 'pg_enum_typid_sortorder_index'.
func PgEnumByEnumtypidEnumsortorder(ctx context.Context, db DB, enumtypid pgtypes.Oid, enumsortorder float32) (*PgEnum, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, enumtypid, enumsortorder, enumlabel ` +
		`FROM pg_catalog.pg_enum ` +
		`WHERE enumtypid = $1 AND enumsortorder = $2`
	// run
	logf(sqlstr, enumtypid, enumsortorder)
	pe := PgEnum{}
	if err := db.QueryRowContext(ctx, sqlstr, enumtypid, enumsortorder).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Ctid, &pe.Oid, &pe.Enumtypid, &pe.Enumsortorder, &pe.Enumlabel); err != nil {
		return nil, logerror(err)
	}
	return &pe, nil
}

// PgEventTriggerByEvtname retrieves a row from 'pg_catalog.pg_event_trigger' as a PgEventTrigger.
//
// Generated from index 'pg_event_trigger_evtname_index'.
func PgEventTriggerByEvtname(ctx context.Context, db DB, evtname string) (*PgEventTrigger, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, evtname, evtevent, evtowner, evtfoid, evtenabled, evttags ` +
		`FROM pg_catalog.pg_event_trigger ` +
		`WHERE evtname = $1`
	// run
	logf(sqlstr, evtname)
	pet := PgEventTrigger{}
	if err := db.QueryRowContext(ctx, sqlstr, evtname).Scan(&pet.Tableoid, &pet.Cmax, &pet.Xmax, &pet.Cmin, &pet.Xmin, &pet.Ctid, &pet.Oid, &pet.Evtname, &pet.Evtevent, &pet.Evtowner, &pet.Evtfoid, &pet.Evtenabled, &pet.Evttags); err != nil {
		return nil, logerror(err)
	}
	return &pet, nil
}

// PgEventTriggerByOid retrieves a row from 'pg_catalog.pg_event_trigger' as a PgEventTrigger.
//
// Generated from index 'pg_event_trigger_oid_index'.
func PgEventTriggerByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgEventTrigger, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, evtname, evtevent, evtowner, evtfoid, evtenabled, evttags ` +
		`FROM pg_catalog.pg_event_trigger ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pet := PgEventTrigger{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pet.Tableoid, &pet.Cmax, &pet.Xmax, &pet.Cmin, &pet.Xmin, &pet.Ctid, &pet.Oid, &pet.Evtname, &pet.Evtevent, &pet.Evtowner, &pet.Evtfoid, &pet.Evtenabled, &pet.Evttags); err != nil {
		return nil, logerror(err)
	}
	return &pet, nil
}

// PgExtensionByExtname retrieves a row from 'pg_catalog.pg_extension' as a PgExtension.
//
// Generated from index 'pg_extension_name_index'.
func PgExtensionByExtname(ctx context.Context, db DB, extname string) (*PgExtension, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, extname, extowner, extnamespace, extrelocatable, extversion, extconfig, extcondition ` +
		`FROM pg_catalog.pg_extension ` +
		`WHERE extname = $1`
	// run
	logf(sqlstr, extname)
	pe := PgExtension{}
	if err := db.QueryRowContext(ctx, sqlstr, extname).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Ctid, &pe.Oid, &pe.Extname, &pe.Extowner, &pe.Extnamespace, &pe.Extrelocatable, &pe.Extversion, &pe.Extconfig, &pe.Extcondition); err != nil {
		return nil, logerror(err)
	}
	return &pe, nil
}

// PgExtensionByOid retrieves a row from 'pg_catalog.pg_extension' as a PgExtension.
//
// Generated from index 'pg_extension_oid_index'.
func PgExtensionByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgExtension, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, extname, extowner, extnamespace, extrelocatable, extversion, extconfig, extcondition ` +
		`FROM pg_catalog.pg_extension ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pe := PgExtension{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Ctid, &pe.Oid, &pe.Extname, &pe.Extowner, &pe.Extnamespace, &pe.Extrelocatable, &pe.Extversion, &pe.Extconfig, &pe.Extcondition); err != nil {
		return nil, logerror(err)
	}
	return &pe, nil
}

// PgForeignDataWrapperByFdwname retrieves a row from 'pg_catalog.pg_foreign_data_wrapper' as a PgForeignDataWrapper.
//
// Generated from index 'pg_foreign_data_wrapper_name_index'.
func PgForeignDataWrapperByFdwname(ctx context.Context, db DB, fdwname string) (*PgForeignDataWrapper, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, fdwname, fdwowner, fdwhandler, fdwvalidator, fdwacl, fdwoptions ` +
		`FROM pg_catalog.pg_foreign_data_wrapper ` +
		`WHERE fdwname = $1`
	// run
	logf(sqlstr, fdwname)
	pfdw := PgForeignDataWrapper{}
	if err := db.QueryRowContext(ctx, sqlstr, fdwname).Scan(&pfdw.Tableoid, &pfdw.Cmax, &pfdw.Xmax, &pfdw.Cmin, &pfdw.Xmin, &pfdw.Ctid, &pfdw.Oid, &pfdw.Fdwname, &pfdw.Fdwowner, &pfdw.Fdwhandler, &pfdw.Fdwvalidator, &pfdw.Fdwacl, &pfdw.Fdwoptions); err != nil {
		return nil, logerror(err)
	}
	return &pfdw, nil
}

// PgForeignDataWrapperByOid retrieves a row from 'pg_catalog.pg_foreign_data_wrapper' as a PgForeignDataWrapper.
//
// Generated from index 'pg_foreign_data_wrapper_oid_index'.
func PgForeignDataWrapperByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgForeignDataWrapper, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, fdwname, fdwowner, fdwhandler, fdwvalidator, fdwacl, fdwoptions ` +
		`FROM pg_catalog.pg_foreign_data_wrapper ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pfdw := PgForeignDataWrapper{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pfdw.Tableoid, &pfdw.Cmax, &pfdw.Xmax, &pfdw.Cmin, &pfdw.Xmin, &pfdw.Ctid, &pfdw.Oid, &pfdw.Fdwname, &pfdw.Fdwowner, &pfdw.Fdwhandler, &pfdw.Fdwvalidator, &pfdw.Fdwacl, &pfdw.Fdwoptions); err != nil {
		return nil, logerror(err)
	}
	return &pfdw, nil
}

// PgForeignServerBySrvname retrieves a row from 'pg_catalog.pg_foreign_server' as a PgForeignServer.
//
// Generated from index 'pg_foreign_server_name_index'.
func PgForeignServerBySrvname(ctx context.Context, db DB, srvname string) (*PgForeignServer, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, srvoptions ` +
		`FROM pg_catalog.pg_foreign_server ` +
		`WHERE srvname = $1`
	// run
	logf(sqlstr, srvname)
	pfs := PgForeignServer{}
	if err := db.QueryRowContext(ctx, sqlstr, srvname).Scan(&pfs.Tableoid, &pfs.Cmax, &pfs.Xmax, &pfs.Cmin, &pfs.Xmin, &pfs.Ctid, &pfs.Oid, &pfs.Srvname, &pfs.Srvowner, &pfs.Srvfdw, &pfs.Srvtype, &pfs.Srvversion, &pfs.Srvacl, &pfs.Srvoptions); err != nil {
		return nil, logerror(err)
	}
	return &pfs, nil
}

// PgForeignServerByOid retrieves a row from 'pg_catalog.pg_foreign_server' as a PgForeignServer.
//
// Generated from index 'pg_foreign_server_oid_index'.
func PgForeignServerByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgForeignServer, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, srvoptions ` +
		`FROM pg_catalog.pg_foreign_server ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pfs := PgForeignServer{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pfs.Tableoid, &pfs.Cmax, &pfs.Xmax, &pfs.Cmin, &pfs.Xmin, &pfs.Ctid, &pfs.Oid, &pfs.Srvname, &pfs.Srvowner, &pfs.Srvfdw, &pfs.Srvtype, &pfs.Srvversion, &pfs.Srvacl, &pfs.Srvoptions); err != nil {
		return nil, logerror(err)
	}
	return &pfs, nil
}

// PgForeignTableByFtrelid retrieves a row from 'pg_catalog.pg_foreign_table' as a PgForeignTable.
//
// Generated from index 'pg_foreign_table_relid_index'.
func PgForeignTableByFtrelid(ctx context.Context, db DB, ftrelid pgtypes.Oid) (*PgForeignTable, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, ftrelid, ftserver, ftoptions ` +
		`FROM pg_catalog.pg_foreign_table ` +
		`WHERE ftrelid = $1`
	// run
	logf(sqlstr, ftrelid)
	pft := PgForeignTable{}
	if err := db.QueryRowContext(ctx, sqlstr, ftrelid).Scan(&pft.Tableoid, &pft.Cmax, &pft.Xmax, &pft.Cmin, &pft.Xmin, &pft.Ctid, &pft.Ftrelid, &pft.Ftserver, &pft.Ftoptions); err != nil {
		return nil, logerror(err)
	}
	return &pft, nil
}

// PgIndexByIndexrelid retrieves a row from 'pg_catalog.pg_index' as a PgIndex.
//
// Generated from index 'pg_index_indexrelid_index'.
func PgIndexByIndexrelid(ctx context.Context, db DB, indexrelid pgtypes.Oid) (*PgIndex, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, indexrelid, indrelid, indnatts, indnkeyatts, indisunique, indisprimary, indisexclusion, indimmediate, indisclustered, indisvalid, indcheckxmin, indisready, indislive, indisreplident, indkey, indcollation, indclass, indoption, indexprs, indpred ` +
		`FROM pg_catalog.pg_index ` +
		`WHERE indexrelid = $1`
	// run
	logf(sqlstr, indexrelid)
	pi := PgIndex{}
	if err := db.QueryRowContext(ctx, sqlstr, indexrelid).Scan(&pi.Tableoid, &pi.Cmax, &pi.Xmax, &pi.Cmin, &pi.Xmin, &pi.Ctid, &pi.Indexrelid, &pi.Indrelid, &pi.Indnatts, &pi.Indnkeyatts, &pi.Indisunique, &pi.Indisprimary, &pi.Indisexclusion, &pi.Indimmediate, &pi.Indisclustered, &pi.Indisvalid, &pi.Indcheckxmin, &pi.Indisready, &pi.Indislive, &pi.Indisreplident, &pi.Indkey, &pi.Indcollation, &pi.Indclass, &pi.Indoption, &pi.Indexprs, &pi.Indpred); err != nil {
		return nil, logerror(err)
	}
	return &pi, nil
}

// PgIndexByIndrelid retrieves a row from 'pg_catalog.pg_index' as a PgIndex.
//
// Generated from index 'pg_index_indrelid_index'.
func PgIndexByIndrelid(ctx context.Context, db DB, indrelid pgtypes.Oid) ([]*PgIndex, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, indexrelid, indrelid, indnatts, indnkeyatts, indisunique, indisprimary, indisexclusion, indimmediate, indisclustered, indisvalid, indcheckxmin, indisready, indislive, indisreplident, indkey, indcollation, indclass, indoption, indexprs, indpred ` +
		`FROM pg_catalog.pg_index ` +
		`WHERE indrelid = $1`
	// run
	logf(sqlstr, indrelid)
	rows, err := db.QueryContext(ctx, sqlstr, indrelid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgIndex
	for rows.Next() {
		pi := PgIndex{}
		// scan
		if err := rows.Scan(&pi.Tableoid, &pi.Cmax, &pi.Xmax, &pi.Cmin, &pi.Xmin, &pi.Ctid, &pi.Indexrelid, &pi.Indrelid, &pi.Indnatts, &pi.Indnkeyatts, &pi.Indisunique, &pi.Indisprimary, &pi.Indisexclusion, &pi.Indimmediate, &pi.Indisclustered, &pi.Indisvalid, &pi.Indcheckxmin, &pi.Indisready, &pi.Indislive, &pi.Indisreplident, &pi.Indkey, &pi.Indcollation, &pi.Indclass, &pi.Indoption, &pi.Indexprs, &pi.Indpred); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pi)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgInheritsByInhparent retrieves a row from 'pg_catalog.pg_inherits' as a PgInherit.
//
// Generated from index 'pg_inherits_parent_index'.
func PgInheritsByInhparent(ctx context.Context, db DB, inhparent pgtypes.Oid) ([]*PgInherit, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, inhrelid, inhparent, inhseqno ` +
		`FROM pg_catalog.pg_inherits ` +
		`WHERE inhparent = $1`
	// run
	logf(sqlstr, inhparent)
	rows, err := db.QueryContext(ctx, sqlstr, inhparent)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgInherit
	for rows.Next() {
		pi := PgInherit{}
		// scan
		if err := rows.Scan(&pi.Tableoid, &pi.Cmax, &pi.Xmax, &pi.Cmin, &pi.Xmin, &pi.Ctid, &pi.Inhrelid, &pi.Inhparent, &pi.Inhseqno); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pi)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgInheritByInhrelidInhseqno retrieves a row from 'pg_catalog.pg_inherits' as a PgInherit.
//
// Generated from index 'pg_inherits_relid_seqno_index'.
func PgInheritByInhrelidInhseqno(ctx context.Context, db DB, inhrelid pgtypes.Oid, inhseqno int) (*PgInherit, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, inhrelid, inhparent, inhseqno ` +
		`FROM pg_catalog.pg_inherits ` +
		`WHERE inhrelid = $1 AND inhseqno = $2`
	// run
	logf(sqlstr, inhrelid, inhseqno)
	pi := PgInherit{}
	if err := db.QueryRowContext(ctx, sqlstr, inhrelid, inhseqno).Scan(&pi.Tableoid, &pi.Cmax, &pi.Xmax, &pi.Cmin, &pi.Xmin, &pi.Ctid, &pi.Inhrelid, &pi.Inhparent, &pi.Inhseqno); err != nil {
		return nil, logerror(err)
	}
	return &pi, nil
}

// PgInitPrivByObjoidClassoidObjsubid retrieves a row from 'pg_catalog.pg_init_privs' as a PgInitPriv.
//
// Generated from index 'pg_init_privs_o_c_o_index'.
func PgInitPrivByObjoidClassoidObjsubid(ctx context.Context, db DB, objoid, classoid pgtypes.Oid, objsubid int) (*PgInitPriv, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, objoid, classoid, objsubid, privtype, initprivs ` +
		`FROM pg_catalog.pg_init_privs ` +
		`WHERE objoid = $1 AND classoid = $2 AND objsubid = $3`
	// run
	logf(sqlstr, objoid, classoid, objsubid)
	pip := PgInitPriv{}
	if err := db.QueryRowContext(ctx, sqlstr, objoid, classoid, objsubid).Scan(&pip.Tableoid, &pip.Cmax, &pip.Xmax, &pip.Cmin, &pip.Xmin, &pip.Ctid, &pip.Objoid, &pip.Classoid, &pip.Objsubid, &pip.Privtype, &pip.Initprivs); err != nil {
		return nil, logerror(err)
	}
	return &pip, nil
}

// PgLanguageByLanname retrieves a row from 'pg_catalog.pg_language' as a PgLanguage.
//
// Generated from index 'pg_language_name_index'.
func PgLanguageByLanname(ctx context.Context, db DB, lanname string) (*PgLanguage, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, lanname, lanowner, lanispl, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl ` +
		`FROM pg_catalog.pg_language ` +
		`WHERE lanname = $1`
	// run
	logf(sqlstr, lanname)
	pl := PgLanguage{}
	if err := db.QueryRowContext(ctx, sqlstr, lanname).Scan(&pl.Tableoid, &pl.Cmax, &pl.Xmax, &pl.Cmin, &pl.Xmin, &pl.Ctid, &pl.Oid, &pl.Lanname, &pl.Lanowner, &pl.Lanispl, &pl.Lanpltrusted, &pl.Lanplcallfoid, &pl.Laninline, &pl.Lanvalidator, &pl.Lanacl); err != nil {
		return nil, logerror(err)
	}
	return &pl, nil
}

// PgLanguageByOid retrieves a row from 'pg_catalog.pg_language' as a PgLanguage.
//
// Generated from index 'pg_language_oid_index'.
func PgLanguageByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgLanguage, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, lanname, lanowner, lanispl, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl ` +
		`FROM pg_catalog.pg_language ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pl := PgLanguage{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pl.Tableoid, &pl.Cmax, &pl.Xmax, &pl.Cmin, &pl.Xmin, &pl.Ctid, &pl.Oid, &pl.Lanname, &pl.Lanowner, &pl.Lanispl, &pl.Lanpltrusted, &pl.Lanplcallfoid, &pl.Laninline, &pl.Lanvalidator, &pl.Lanacl); err != nil {
		return nil, logerror(err)
	}
	return &pl, nil
}

// PgLargeobjectByLoidPageno retrieves a row from 'pg_catalog.pg_largeobject' as a PgLargeobject.
//
// Generated from index 'pg_largeobject_loid_pn_index'.
func PgLargeobjectByLoidPageno(ctx context.Context, db DB, loid pgtypes.Oid, pageno int) (*PgLargeobject, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, loid, pageno, data ` +
		`FROM pg_catalog.pg_largeobject ` +
		`WHERE loid = $1 AND pageno = $2`
	// run
	logf(sqlstr, loid, pageno)
	pl := PgLargeobject{}
	if err := db.QueryRowContext(ctx, sqlstr, loid, pageno).Scan(&pl.Tableoid, &pl.Cmax, &pl.Xmax, &pl.Cmin, &pl.Xmin, &pl.Ctid, &pl.Loid, &pl.Pageno, &pl.Data); err != nil {
		return nil, logerror(err)
	}
	return &pl, nil
}

// PgLargeobjectMetadatumByOid retrieves a row from 'pg_catalog.pg_largeobject_metadata' as a PgLargeobjectMetadatum.
//
// Generated from index 'pg_largeobject_metadata_oid_index'.
func PgLargeobjectMetadatumByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgLargeobjectMetadatum, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, lomowner, lomacl ` +
		`FROM pg_catalog.pg_largeobject_metadata ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	plm := PgLargeobjectMetadatum{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&plm.Tableoid, &plm.Cmax, &plm.Xmax, &plm.Cmin, &plm.Xmin, &plm.Ctid, &plm.Oid, &plm.Lomowner, &plm.Lomacl); err != nil {
		return nil, logerror(err)
	}
	return &plm, nil
}

// PgNamespaceByNspname retrieves a row from 'pg_catalog.pg_namespace' as a PgNamespace.
//
// Generated from index 'pg_namespace_nspname_index'.
func PgNamespaceByNspname(ctx context.Context, db DB, nspname string) (*PgNamespace, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, nspname, nspowner, nspacl ` +
		`FROM pg_catalog.pg_namespace ` +
		`WHERE nspname = $1`
	// run
	logf(sqlstr, nspname)
	pn := PgNamespace{}
	if err := db.QueryRowContext(ctx, sqlstr, nspname).Scan(&pn.Tableoid, &pn.Cmax, &pn.Xmax, &pn.Cmin, &pn.Xmin, &pn.Ctid, &pn.Oid, &pn.Nspname, &pn.Nspowner, &pn.Nspacl); err != nil {
		return nil, logerror(err)
	}
	return &pn, nil
}

// PgNamespaceByOid retrieves a row from 'pg_catalog.pg_namespace' as a PgNamespace.
//
// Generated from index 'pg_namespace_oid_index'.
func PgNamespaceByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgNamespace, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, nspname, nspowner, nspacl ` +
		`FROM pg_catalog.pg_namespace ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pn := PgNamespace{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pn.Tableoid, &pn.Cmax, &pn.Xmax, &pn.Cmin, &pn.Xmin, &pn.Ctid, &pn.Oid, &pn.Nspname, &pn.Nspowner, &pn.Nspacl); err != nil {
		return nil, logerror(err)
	}
	return &pn, nil
}

// PgOpclassByOpcmethodOpcnameOpcnamespace retrieves a row from 'pg_catalog.pg_opclass' as a PgOpclass.
//
// Generated from index 'pg_opclass_am_name_nsp_index'.
func PgOpclassByOpcmethodOpcnameOpcnamespace(ctx context.Context, db DB, opcmethod pgtypes.Oid, opcname string, opcnamespace pgtypes.Oid) (*PgOpclass, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, opcmethod, opcname, opcnamespace, opcowner, opcfamily, opcintype, opcdefault, opckeytype ` +
		`FROM pg_catalog.pg_opclass ` +
		`WHERE opcmethod = $1 AND opcname = $2 AND opcnamespace = $3`
	// run
	logf(sqlstr, opcmethod, opcname, opcnamespace)
	po := PgOpclass{}
	if err := db.QueryRowContext(ctx, sqlstr, opcmethod, opcname, opcnamespace).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Opcmethod, &po.Opcname, &po.Opcnamespace, &po.Opcowner, &po.Opcfamily, &po.Opcintype, &po.Opcdefault, &po.Opckeytype); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgOpclassByOid retrieves a row from 'pg_catalog.pg_opclass' as a PgOpclass.
//
// Generated from index 'pg_opclass_oid_index'.
func PgOpclassByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgOpclass, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, opcmethod, opcname, opcnamespace, opcowner, opcfamily, opcintype, opcdefault, opckeytype ` +
		`FROM pg_catalog.pg_opclass ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	po := PgOpclass{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Opcmethod, &po.Opcname, &po.Opcnamespace, &po.Opcowner, &po.Opcfamily, &po.Opcintype, &po.Opcdefault, &po.Opckeytype); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgOperatorByOid retrieves a row from 'pg_catalog.pg_operator' as a PgOperator.
//
// Generated from index 'pg_operator_oid_index'.
func PgOperatorByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgOperator, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, oprname, oprnamespace, oprowner, oprkind, oprcanmerge, oprcanhash, oprleft, oprright, oprresult, oprcom, oprnegate, oprcode, oprrest, oprjoin ` +
		`FROM pg_catalog.pg_operator ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	po := PgOperator{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Oprname, &po.Oprnamespace, &po.Oprowner, &po.Oprkind, &po.Oprcanmerge, &po.Oprcanhash, &po.Oprleft, &po.Oprright, &po.Oprresult, &po.Oprcom, &po.Oprnegate, &po.Oprcode, &po.Oprrest, &po.Oprjoin); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgOperatorByOprnameOprleftOprrightOprnamespace retrieves a row from 'pg_catalog.pg_operator' as a PgOperator.
//
// Generated from index 'pg_operator_oprname_l_r_n_index'.
func PgOperatorByOprnameOprleftOprrightOprnamespace(ctx context.Context, db DB, oprname string, oprleft, oprright, oprnamespace pgtypes.Oid) (*PgOperator, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, oprname, oprnamespace, oprowner, oprkind, oprcanmerge, oprcanhash, oprleft, oprright, oprresult, oprcom, oprnegate, oprcode, oprrest, oprjoin ` +
		`FROM pg_catalog.pg_operator ` +
		`WHERE oprname = $1 AND oprleft = $2 AND oprright = $3 AND oprnamespace = $4`
	// run
	logf(sqlstr, oprname, oprleft, oprright, oprnamespace)
	po := PgOperator{}
	if err := db.QueryRowContext(ctx, sqlstr, oprname, oprleft, oprright, oprnamespace).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Oprname, &po.Oprnamespace, &po.Oprowner, &po.Oprkind, &po.Oprcanmerge, &po.Oprcanhash, &po.Oprleft, &po.Oprright, &po.Oprresult, &po.Oprcom, &po.Oprnegate, &po.Oprcode, &po.Oprrest, &po.Oprjoin); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgOpfamilyByOpfmethodOpfnameOpfnamespace retrieves a row from 'pg_catalog.pg_opfamily' as a PgOpfamily.
//
// Generated from index 'pg_opfamily_am_name_nsp_index'.
func PgOpfamilyByOpfmethodOpfnameOpfnamespace(ctx context.Context, db DB, opfmethod pgtypes.Oid, opfname string, opfnamespace pgtypes.Oid) (*PgOpfamily, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, opfmethod, opfname, opfnamespace, opfowner ` +
		`FROM pg_catalog.pg_opfamily ` +
		`WHERE opfmethod = $1 AND opfname = $2 AND opfnamespace = $3`
	// run
	logf(sqlstr, opfmethod, opfname, opfnamespace)
	po := PgOpfamily{}
	if err := db.QueryRowContext(ctx, sqlstr, opfmethod, opfname, opfnamespace).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Opfmethod, &po.Opfname, &po.Opfnamespace, &po.Opfowner); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgOpfamilyByOid retrieves a row from 'pg_catalog.pg_opfamily' as a PgOpfamily.
//
// Generated from index 'pg_opfamily_oid_index'.
func PgOpfamilyByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgOpfamily, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, opfmethod, opfname, opfnamespace, opfowner ` +
		`FROM pg_catalog.pg_opfamily ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	po := PgOpfamily{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Ctid, &po.Oid, &po.Opfmethod, &po.Opfname, &po.Opfnamespace, &po.Opfowner); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// PgPartitionedTableByPartrelid retrieves a row from 'pg_catalog.pg_partitioned_table' as a PgPartitionedTable.
//
// Generated from index 'pg_partitioned_table_partrelid_index'.
func PgPartitionedTableByPartrelid(ctx context.Context, db DB, partrelid pgtypes.Oid) (*PgPartitionedTable, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, partrelid, partstrat, partnatts, partdefid, partattrs, partclass, partcollation, partexprs ` +
		`FROM pg_catalog.pg_partitioned_table ` +
		`WHERE partrelid = $1`
	// run
	logf(sqlstr, partrelid)
	ppt := PgPartitionedTable{}
	if err := db.QueryRowContext(ctx, sqlstr, partrelid).Scan(&ppt.Tableoid, &ppt.Cmax, &ppt.Xmax, &ppt.Cmin, &ppt.Xmin, &ppt.Ctid, &ppt.Partrelid, &ppt.Partstrat, &ppt.Partnatts, &ppt.Partdefid, &ppt.Partattrs, &ppt.Partclass, &ppt.Partcollation, &ppt.Partexprs); err != nil {
		return nil, logerror(err)
	}
	return &ppt, nil
}

// PgPolicyByOid retrieves a row from 'pg_catalog.pg_policy' as a PgPolicy.
//
// Generated from index 'pg_policy_oid_index'.
func PgPolicyByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgPolicy, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, polname, polrelid, polcmd, polpermissive, polroles, polqual, polwithcheck ` +
		`FROM pg_catalog.pg_policy ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pp := PgPolicy{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Polname, &pp.Polrelid, &pp.Polcmd, &pp.Polpermissive, &pp.Polroles, &pp.Polqual, &pp.Polwithcheck); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgPolicyByPolrelidPolname retrieves a row from 'pg_catalog.pg_policy' as a PgPolicy.
//
// Generated from index 'pg_policy_polrelid_polname_index'.
func PgPolicyByPolrelidPolname(ctx context.Context, db DB, polrelid pgtypes.Oid, polname string) (*PgPolicy, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, polname, polrelid, polcmd, polpermissive, polroles, polqual, polwithcheck ` +
		`FROM pg_catalog.pg_policy ` +
		`WHERE polrelid = $1 AND polname = $2`
	// run
	logf(sqlstr, polrelid, polname)
	pp := PgPolicy{}
	if err := db.QueryRowContext(ctx, sqlstr, polrelid, polname).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Polname, &pp.Polrelid, &pp.Polcmd, &pp.Polpermissive, &pp.Polroles, &pp.Polqual, &pp.Polwithcheck); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgProcByOid retrieves a row from 'pg_catalog.pg_proc' as a PgProc.
//
// Generated from index 'pg_proc_oid_index'.
func PgProcByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgProc, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, proname, pronamespace, proowner, prolang, procost, prorows, provariadic, prosupport, prokind, prosecdef, proleakproof, proisstrict, proretset, provolatile, proparallel, pronargs, pronargdefaults, prorettype, proargtypes, proallargtypes, proargmodes, proargnames, proargdefaults, protrftypes, prosrc, probin, proconfig, proacl ` +
		`FROM pg_catalog.pg_proc ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pp := PgProc{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Proname, &pp.Pronamespace, &pp.Proowner, &pp.Prolang, &pp.Procost, &pp.Prorows, &pp.Provariadic, &pp.Prosupport, &pp.Prokind, &pp.Prosecdef, &pp.Proleakproof, &pp.Proisstrict, &pp.Proretset, &pp.Provolatile, &pp.Proparallel, &pp.Pronargs, &pp.Pronargdefaults, &pp.Prorettype, &pp.Proargtypes, &pp.Proallargtypes, &pp.Proargmodes, &pp.Proargnames, &pp.Proargdefaults, &pp.Protrftypes, &pp.Prosrc, &pp.Probin, &pp.Proconfig, &pp.Proacl); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgProcByPronameProargtypesPronamespace retrieves a row from 'pg_catalog.pg_proc' as a PgProc.
//
// Generated from index 'pg_proc_proname_args_nsp_index'.
func PgProcByPronameProargtypesPronamespace(ctx context.Context, db DB, proname string, proargtypes pgtypes.Oidvector, pronamespace pgtypes.Oid) (*PgProc, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, proname, pronamespace, proowner, prolang, procost, prorows, provariadic, prosupport, prokind, prosecdef, proleakproof, proisstrict, proretset, provolatile, proparallel, pronargs, pronargdefaults, prorettype, proargtypes, proallargtypes, proargmodes, proargnames, proargdefaults, protrftypes, prosrc, probin, proconfig, proacl ` +
		`FROM pg_catalog.pg_proc ` +
		`WHERE proname = $1 AND proargtypes = $2 AND pronamespace = $3`
	// run
	logf(sqlstr, proname, proargtypes, pronamespace)
	pp := PgProc{}
	if err := db.QueryRowContext(ctx, sqlstr, proname, proargtypes, pronamespace).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Proname, &pp.Pronamespace, &pp.Proowner, &pp.Prolang, &pp.Procost, &pp.Prorows, &pp.Provariadic, &pp.Prosupport, &pp.Prokind, &pp.Prosecdef, &pp.Proleakproof, &pp.Proisstrict, &pp.Proretset, &pp.Provolatile, &pp.Proparallel, &pp.Pronargs, &pp.Pronargdefaults, &pp.Prorettype, &pp.Proargtypes, &pp.Proallargtypes, &pp.Proargmodes, &pp.Proargnames, &pp.Proargdefaults, &pp.Protrftypes, &pp.Prosrc, &pp.Probin, &pp.Proconfig, &pp.Proacl); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgPublicationByOid retrieves a row from 'pg_catalog.pg_publication' as a PgPublication.
//
// Generated from index 'pg_publication_oid_index'.
func PgPublicationByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgPublication, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, pubname, pubowner, puballtables, pubinsert, pubupdate, pubdelete, pubtruncate, pubviaroot ` +
		`FROM pg_catalog.pg_publication ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pp := PgPublication{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Pubname, &pp.Pubowner, &pp.Puballtables, &pp.Pubinsert, &pp.Pubupdate, &pp.Pubdelete, &pp.Pubtruncate, &pp.Pubviaroot); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgPublicationByPubname retrieves a row from 'pg_catalog.pg_publication' as a PgPublication.
//
// Generated from index 'pg_publication_pubname_index'.
func PgPublicationByPubname(ctx context.Context, db DB, pubname string) (*PgPublication, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, pubname, pubowner, puballtables, pubinsert, pubupdate, pubdelete, pubtruncate, pubviaroot ` +
		`FROM pg_catalog.pg_publication ` +
		`WHERE pubname = $1`
	// run
	logf(sqlstr, pubname)
	pp := PgPublication{}
	if err := db.QueryRowContext(ctx, sqlstr, pubname).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Ctid, &pp.Oid, &pp.Pubname, &pp.Pubowner, &pp.Puballtables, &pp.Pubinsert, &pp.Pubupdate, &pp.Pubdelete, &pp.Pubtruncate, &pp.Pubviaroot); err != nil {
		return nil, logerror(err)
	}
	return &pp, nil
}

// PgPublicationRelByOid retrieves a row from 'pg_catalog.pg_publication_rel' as a PgPublicationRel.
//
// Generated from index 'pg_publication_rel_oid_index'.
func PgPublicationRelByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgPublicationRel, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, prpubid, prrelid ` +
		`FROM pg_catalog.pg_publication_rel ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ppr := PgPublicationRel{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ppr.Tableoid, &ppr.Cmax, &ppr.Xmax, &ppr.Cmin, &ppr.Xmin, &ppr.Ctid, &ppr.Oid, &ppr.Prpubid, &ppr.Prrelid); err != nil {
		return nil, logerror(err)
	}
	return &ppr, nil
}

// PgPublicationRelByPrrelidPrpubid retrieves a row from 'pg_catalog.pg_publication_rel' as a PgPublicationRel.
//
// Generated from index 'pg_publication_rel_prrelid_prpubid_index'.
func PgPublicationRelByPrrelidPrpubid(ctx context.Context, db DB, prrelid, prpubid pgtypes.Oid) (*PgPublicationRel, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, prpubid, prrelid ` +
		`FROM pg_catalog.pg_publication_rel ` +
		`WHERE prrelid = $1 AND prpubid = $2`
	// run
	logf(sqlstr, prrelid, prpubid)
	ppr := PgPublicationRel{}
	if err := db.QueryRowContext(ctx, sqlstr, prrelid, prpubid).Scan(&ppr.Tableoid, &ppr.Cmax, &ppr.Xmax, &ppr.Cmin, &ppr.Xmin, &ppr.Ctid, &ppr.Oid, &ppr.Prpubid, &ppr.Prrelid); err != nil {
		return nil, logerror(err)
	}
	return &ppr, nil
}

// PgRangeByRngtypid retrieves a row from 'pg_catalog.pg_range' as a PgRange.
//
// Generated from index 'pg_range_rngtypid_index'.
func PgRangeByRngtypid(ctx context.Context, db DB, rngtypid pgtypes.Oid) (*PgRange, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, rngtypid, rngsubtype, rngcollation, rngsubopc, rngcanonical, rngsubdiff ` +
		`FROM pg_catalog.pg_range ` +
		`WHERE rngtypid = $1`
	// run
	logf(sqlstr, rngtypid)
	pr := PgRange{}
	if err := db.QueryRowContext(ctx, sqlstr, rngtypid).Scan(&pr.Tableoid, &pr.Cmax, &pr.Xmax, &pr.Cmin, &pr.Xmin, &pr.Ctid, &pr.Rngtypid, &pr.Rngsubtype, &pr.Rngcollation, &pr.Rngsubopc, &pr.Rngcanonical, &pr.Rngsubdiff); err != nil {
		return nil, logerror(err)
	}
	return &pr, nil
}

// PgReplicationOriginByRoident retrieves a row from 'pg_catalog.pg_replication_origin' as a PgReplicationOrigin.
//
// Generated from index 'pg_replication_origin_roiident_index'.
func PgReplicationOriginByRoident(ctx context.Context, db DB, roident pgtypes.Oid) (*PgReplicationOrigin, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, roident, roname ` +
		`FROM pg_catalog.pg_replication_origin ` +
		`WHERE roident = $1`
	// run
	logf(sqlstr, roident)
	pro := PgReplicationOrigin{}
	if err := db.QueryRowContext(ctx, sqlstr, roident).Scan(&pro.Tableoid, &pro.Cmax, &pro.Xmax, &pro.Cmin, &pro.Xmin, &pro.Ctid, &pro.Roident, &pro.Roname); err != nil {
		return nil, logerror(err)
	}
	return &pro, nil
}

// PgReplicationOriginByRoname retrieves a row from 'pg_catalog.pg_replication_origin' as a PgReplicationOrigin.
//
// Generated from index 'pg_replication_origin_roname_index'.
func PgReplicationOriginByRoname(ctx context.Context, db DB, roname string) (*PgReplicationOrigin, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, roident, roname ` +
		`FROM pg_catalog.pg_replication_origin ` +
		`WHERE roname = $1`
	// run
	logf(sqlstr, roname)
	pro := PgReplicationOrigin{}
	if err := db.QueryRowContext(ctx, sqlstr, roname).Scan(&pro.Tableoid, &pro.Cmax, &pro.Xmax, &pro.Cmin, &pro.Xmin, &pro.Ctid, &pro.Roident, &pro.Roname); err != nil {
		return nil, logerror(err)
	}
	return &pro, nil
}

// PgRewriteByOid retrieves a row from 'pg_catalog.pg_rewrite' as a PgRewrite.
//
// Generated from index 'pg_rewrite_oid_index'.
func PgRewriteByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgRewrite, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, rulename, ev_class, ev_type, ev_enabled, is_instead, ev_qual, ev_action ` +
		`FROM pg_catalog.pg_rewrite ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pr := PgRewrite{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pr.Tableoid, &pr.Cmax, &pr.Xmax, &pr.Cmin, &pr.Xmin, &pr.Ctid, &pr.Oid, &pr.Rulename, &pr.EvClass, &pr.EvType, &pr.EvEnabled, &pr.IsInstead, &pr.EvQual, &pr.EvAction); err != nil {
		return nil, logerror(err)
	}
	return &pr, nil
}

// PgRewriteByEvClassRulename retrieves a row from 'pg_catalog.pg_rewrite' as a PgRewrite.
//
// Generated from index 'pg_rewrite_rel_rulename_index'.
func PgRewriteByEvClassRulename(ctx context.Context, db DB, evClass pgtypes.Oid, rulename string) (*PgRewrite, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, rulename, ev_class, ev_type, ev_enabled, is_instead, ev_qual, ev_action ` +
		`FROM pg_catalog.pg_rewrite ` +
		`WHERE ev_class = $1 AND rulename = $2`
	// run
	logf(sqlstr, evClass, rulename)
	pr := PgRewrite{}
	if err := db.QueryRowContext(ctx, sqlstr, evClass, rulename).Scan(&pr.Tableoid, &pr.Cmax, &pr.Xmax, &pr.Cmin, &pr.Xmin, &pr.Ctid, &pr.Oid, &pr.Rulename, &pr.EvClass, &pr.EvType, &pr.EvEnabled, &pr.IsInstead, &pr.EvQual, &pr.EvAction); err != nil {
		return nil, logerror(err)
	}
	return &pr, nil
}

// PgSeclabelByObjoidClassoidObjsubidProvider retrieves a row from 'pg_catalog.pg_seclabel' as a PgSeclabel.
//
// Generated from index 'pg_seclabel_object_index'.
func PgSeclabelByObjoidClassoidObjsubidProvider(ctx context.Context, db DB, objoid, classoid pgtypes.Oid, objsubid int, provider string) (*PgSeclabel, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, objoid, classoid, objsubid, provider, label ` +
		`FROM pg_catalog.pg_seclabel ` +
		`WHERE objoid = $1 AND classoid = $2 AND objsubid = $3 AND provider = $4`
	// run
	logf(sqlstr, objoid, classoid, objsubid, provider)
	ps := PgSeclabel{}
	if err := db.QueryRowContext(ctx, sqlstr, objoid, classoid, objsubid, provider).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Objoid, &ps.Classoid, &ps.Objsubid, &ps.Provider, &ps.Label); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgSequenceBySeqrelid retrieves a row from 'pg_catalog.pg_sequence' as a PgSequence.
//
// Generated from index 'pg_sequence_seqrelid_index'.
func PgSequenceBySeqrelid(ctx context.Context, db DB, seqrelid pgtypes.Oid) (*PgSequence, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, seqrelid, seqtypid, seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle ` +
		`FROM pg_catalog.pg_sequence ` +
		`WHERE seqrelid = $1`
	// run
	logf(sqlstr, seqrelid)
	ps := PgSequence{}
	if err := db.QueryRowContext(ctx, sqlstr, seqrelid).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Seqrelid, &ps.Seqtypid, &ps.Seqstart, &ps.Seqincrement, &ps.Seqmax, &ps.Seqmin, &ps.Seqcache, &ps.Seqcycle); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgShdependByDbidClassidObjidObjsubid retrieves a row from 'pg_catalog.pg_shdepend' as a PgShdepend.
//
// Generated from index 'pg_shdepend_depender_index'.
func PgShdependByDbidClassidObjidObjsubid(ctx context.Context, db DB, dbid, classid, objid pgtypes.Oid, objsubid int) ([]*PgShdepend, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, dbid, classid, objid, objsubid, refclassid, refobjid, deptype ` +
		`FROM pg_catalog.pg_shdepend ` +
		`WHERE dbid = $1 AND classid = $2 AND objid = $3 AND objsubid = $4`
	// run
	logf(sqlstr, dbid, classid, objid, objsubid)
	rows, err := db.QueryContext(ctx, sqlstr, dbid, classid, objid, objsubid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgShdepend
	for rows.Next() {
		ps := PgShdepend{}
		// scan
		if err := rows.Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Dbid, &ps.Classid, &ps.Objid, &ps.Objsubid, &ps.Refclassid, &ps.Refobjid, &ps.Deptype); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ps)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgShdependByRefclassidRefobjid retrieves a row from 'pg_catalog.pg_shdepend' as a PgShdepend.
//
// Generated from index 'pg_shdepend_reference_index'.
func PgShdependByRefclassidRefobjid(ctx context.Context, db DB, refclassid, refobjid pgtypes.Oid) ([]*PgShdepend, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, dbid, classid, objid, objsubid, refclassid, refobjid, deptype ` +
		`FROM pg_catalog.pg_shdepend ` +
		`WHERE refclassid = $1 AND refobjid = $2`
	// run
	logf(sqlstr, refclassid, refobjid)
	rows, err := db.QueryContext(ctx, sqlstr, refclassid, refobjid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgShdepend
	for rows.Next() {
		ps := PgShdepend{}
		// scan
		if err := rows.Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Dbid, &ps.Classid, &ps.Objid, &ps.Objsubid, &ps.Refclassid, &ps.Refobjid, &ps.Deptype); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ps)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgShdescriptionByObjoidClassoid retrieves a row from 'pg_catalog.pg_shdescription' as a PgShdescription.
//
// Generated from index 'pg_shdescription_o_c_index'.
func PgShdescriptionByObjoidClassoid(ctx context.Context, db DB, objoid, classoid pgtypes.Oid) (*PgShdescription, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, objoid, classoid, description ` +
		`FROM pg_catalog.pg_shdescription ` +
		`WHERE objoid = $1 AND classoid = $2`
	// run
	logf(sqlstr, objoid, classoid)
	ps := PgShdescription{}
	if err := db.QueryRowContext(ctx, sqlstr, objoid, classoid).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Objoid, &ps.Classoid, &ps.Description); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgShseclabelByObjoidClassoidProvider retrieves a row from 'pg_catalog.pg_shseclabel' as a PgShseclabel.
//
// Generated from index 'pg_shseclabel_object_index'.
func PgShseclabelByObjoidClassoidProvider(ctx context.Context, db DB, objoid, classoid pgtypes.Oid, provider string) (*PgShseclabel, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, objoid, classoid, provider, label ` +
		`FROM pg_catalog.pg_shseclabel ` +
		`WHERE objoid = $1 AND classoid = $2 AND provider = $3`
	// run
	logf(sqlstr, objoid, classoid, provider)
	ps := PgShseclabel{}
	if err := db.QueryRowContext(ctx, sqlstr, objoid, classoid, provider).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Objoid, &ps.Classoid, &ps.Provider, &ps.Label); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgStatisticByStarelidStaattnumStainherit retrieves a row from 'pg_catalog.pg_statistic' as a PgStatistic.
//
// Generated from index 'pg_statistic_relid_att_inh_index'.
func PgStatisticByStarelidStaattnumStainherit(ctx context.Context, db DB, starelid pgtypes.Oid, staattnum int16, stainherit bool) (*PgStatistic, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, starelid, staattnum, stainherit, stanullfrac, stawidth, stadistinct, stakind1, stakind2, stakind3, stakind4, stakind5, staop1, staop2, staop3, staop4, staop5, stacoll1, stacoll2, stacoll3, stacoll4, stacoll5, stanumbers1, stanumbers2, stanumbers3, stanumbers4, stanumbers5, stavalues1, stavalues2, stavalues3, stavalues4, stavalues5 ` +
		`FROM pg_catalog.pg_statistic ` +
		`WHERE starelid = $1 AND staattnum = $2 AND stainherit = $3`
	// run
	logf(sqlstr, starelid, staattnum, stainherit)
	ps := PgStatistic{}
	if err := db.QueryRowContext(ctx, sqlstr, starelid, staattnum, stainherit).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Starelid, &ps.Staattnum, &ps.Stainherit, &ps.Stanullfrac, &ps.Stawidth, &ps.Stadistinct, &ps.Stakind1, &ps.Stakind2, &ps.Stakind3, &ps.Stakind4, &ps.Stakind5, &ps.Staop1, &ps.Staop2, &ps.Staop3, &ps.Staop4, &ps.Staop5, &ps.Stacoll1, &ps.Stacoll2, &ps.Stacoll3, &ps.Stacoll4, &ps.Stacoll5, &ps.Stanumbers1, &ps.Stanumbers2, &ps.Stanumbers3, &ps.Stanumbers4, &ps.Stanumbers5, &ps.Stavalues1, &ps.Stavalues2, &ps.Stavalues3, &ps.Stavalues4, &ps.Stavalues5); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgStatisticExtByStxnameStxnamespace retrieves a row from 'pg_catalog.pg_statistic_ext' as a PgStatisticExt.
//
// Generated from index 'pg_statistic_ext_name_index'.
func PgStatisticExtByStxnameStxnamespace(ctx context.Context, db DB, stxname string, stxnamespace pgtypes.Oid) (*PgStatisticExt, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, stxrelid, stxname, stxnamespace, stxowner, stxstattarget, stxkeys, stxkind ` +
		`FROM pg_catalog.pg_statistic_ext ` +
		`WHERE stxname = $1 AND stxnamespace = $2`
	// run
	logf(sqlstr, stxname, stxnamespace)
	pse := PgStatisticExt{}
	if err := db.QueryRowContext(ctx, sqlstr, stxname, stxnamespace).Scan(&pse.Tableoid, &pse.Cmax, &pse.Xmax, &pse.Cmin, &pse.Xmin, &pse.Ctid, &pse.Oid, &pse.Stxrelid, &pse.Stxname, &pse.Stxnamespace, &pse.Stxowner, &pse.Stxstattarget, &pse.Stxkeys, &pse.Stxkind); err != nil {
		return nil, logerror(err)
	}
	return &pse, nil
}

// PgStatisticExtByOid retrieves a row from 'pg_catalog.pg_statistic_ext' as a PgStatisticExt.
//
// Generated from index 'pg_statistic_ext_oid_index'.
func PgStatisticExtByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgStatisticExt, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, stxrelid, stxname, stxnamespace, stxowner, stxstattarget, stxkeys, stxkind ` +
		`FROM pg_catalog.pg_statistic_ext ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pse := PgStatisticExt{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pse.Tableoid, &pse.Cmax, &pse.Xmax, &pse.Cmin, &pse.Xmin, &pse.Ctid, &pse.Oid, &pse.Stxrelid, &pse.Stxname, &pse.Stxnamespace, &pse.Stxowner, &pse.Stxstattarget, &pse.Stxkeys, &pse.Stxkind); err != nil {
		return nil, logerror(err)
	}
	return &pse, nil
}

// PgStatisticExtByStxrelid retrieves a row from 'pg_catalog.pg_statistic_ext' as a PgStatisticExt.
//
// Generated from index 'pg_statistic_ext_relid_index'.
func PgStatisticExtByStxrelid(ctx context.Context, db DB, stxrelid pgtypes.Oid) ([]*PgStatisticExt, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, stxrelid, stxname, stxnamespace, stxowner, stxstattarget, stxkeys, stxkind ` +
		`FROM pg_catalog.pg_statistic_ext ` +
		`WHERE stxrelid = $1`
	// run
	logf(sqlstr, stxrelid)
	rows, err := db.QueryContext(ctx, sqlstr, stxrelid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgStatisticExt
	for rows.Next() {
		pse := PgStatisticExt{}
		// scan
		if err := rows.Scan(&pse.Tableoid, &pse.Cmax, &pse.Xmax, &pse.Cmin, &pse.Xmin, &pse.Ctid, &pse.Oid, &pse.Stxrelid, &pse.Stxname, &pse.Stxnamespace, &pse.Stxowner, &pse.Stxstattarget, &pse.Stxkeys, &pse.Stxkind); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pse)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgStatisticExtDatumByStxoid retrieves a row from 'pg_catalog.pg_statistic_ext_data' as a PgStatisticExtDatum.
//
// Generated from index 'pg_statistic_ext_data_stxoid_index'.
func PgStatisticExtDatumByStxoid(ctx context.Context, db DB, stxoid pgtypes.Oid) (*PgStatisticExtDatum, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, stxoid, stxdndistinct, stxddependencies, stxdmcv ` +
		`FROM pg_catalog.pg_statistic_ext_data ` +
		`WHERE stxoid = $1`
	// run
	logf(sqlstr, stxoid)
	psed := PgStatisticExtDatum{}
	if err := db.QueryRowContext(ctx, sqlstr, stxoid).Scan(&psed.Tableoid, &psed.Cmax, &psed.Xmax, &psed.Cmin, &psed.Xmin, &psed.Ctid, &psed.Stxoid, &psed.Stxdndistinct, &psed.Stxddependencies, &psed.Stxdmcv); err != nil {
		return nil, logerror(err)
	}
	return &psed, nil
}

// PgSubscriptionByOid retrieves a row from 'pg_catalog.pg_subscription' as a PgSubscription.
//
// Generated from index 'pg_subscription_oid_index'.
func PgSubscriptionByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgSubscription, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, subdbid, subname, subowner, subenabled, subconninfo, subslotname, subsynccommit, subpublications ` +
		`FROM pg_catalog.pg_subscription ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ps := PgSubscription{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Oid, &ps.Subdbid, &ps.Subname, &ps.Subowner, &ps.Subenabled, &ps.Subconninfo, &ps.Subslotname, &ps.Subsynccommit, &ps.Subpublications); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgSubscriptionBySubdbidSubname retrieves a row from 'pg_catalog.pg_subscription' as a PgSubscription.
//
// Generated from index 'pg_subscription_subname_index'.
func PgSubscriptionBySubdbidSubname(ctx context.Context, db DB, subdbid pgtypes.Oid, subname string) (*PgSubscription, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, subdbid, subname, subowner, subenabled, subconninfo, subslotname, subsynccommit, subpublications ` +
		`FROM pg_catalog.pg_subscription ` +
		`WHERE subdbid = $1 AND subname = $2`
	// run
	logf(sqlstr, subdbid, subname)
	ps := PgSubscription{}
	if err := db.QueryRowContext(ctx, sqlstr, subdbid, subname).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Oid, &ps.Subdbid, &ps.Subname, &ps.Subowner, &ps.Subenabled, &ps.Subconninfo, &ps.Subslotname, &ps.Subsynccommit, &ps.Subpublications); err != nil {
		return nil, logerror(err)
	}
	return &ps, nil
}

// PgSubscriptionRelBySrrelidSrsubid retrieves a row from 'pg_catalog.pg_subscription_rel' as a PgSubscriptionRel.
//
// Generated from index 'pg_subscription_rel_srrelid_srsubid_index'.
func PgSubscriptionRelBySrrelidSrsubid(ctx context.Context, db DB, srrelid, srsubid pgtypes.Oid) (*PgSubscriptionRel, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, srsubid, srrelid, srsubstate, srsublsn ` +
		`FROM pg_catalog.pg_subscription_rel ` +
		`WHERE srrelid = $1 AND srsubid = $2`
	// run
	logf(sqlstr, srrelid, srsubid)
	psr := PgSubscriptionRel{}
	if err := db.QueryRowContext(ctx, sqlstr, srrelid, srsubid).Scan(&psr.Tableoid, &psr.Cmax, &psr.Xmax, &psr.Cmin, &psr.Xmin, &psr.Ctid, &psr.Srsubid, &psr.Srrelid, &psr.Srsubstate, &psr.Srsublsn); err != nil {
		return nil, logerror(err)
	}
	return &psr, nil
}

// PgTablespaceByOid retrieves a row from 'pg_catalog.pg_tablespace' as a PgTablespace.
//
// Generated from index 'pg_tablespace_oid_index'.
func PgTablespaceByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTablespace, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, spcname, spcowner, spcacl, spcoptions ` +
		`FROM pg_catalog.pg_tablespace ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pt := PgTablespace{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Spcname, &pt.Spcowner, &pt.Spcacl, &pt.Spcoptions); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTablespaceBySpcname retrieves a row from 'pg_catalog.pg_tablespace' as a PgTablespace.
//
// Generated from index 'pg_tablespace_spcname_index'.
func PgTablespaceBySpcname(ctx context.Context, db DB, spcname string) (*PgTablespace, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, spcname, spcowner, spcacl, spcoptions ` +
		`FROM pg_catalog.pg_tablespace ` +
		`WHERE spcname = $1`
	// run
	logf(sqlstr, spcname)
	pt := PgTablespace{}
	if err := db.QueryRowContext(ctx, sqlstr, spcname).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Spcname, &pt.Spcowner, &pt.Spcacl, &pt.Spcoptions); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTransformByOid retrieves a row from 'pg_catalog.pg_transform' as a PgTransform.
//
// Generated from index 'pg_transform_oid_index'.
func PgTransformByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTransform, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, trftype, trflang, trffromsql, trftosql ` +
		`FROM pg_catalog.pg_transform ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pt := PgTransform{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Trftype, &pt.Trflang, &pt.Trffromsql, &pt.Trftosql); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTransformByTrftypeTrflang retrieves a row from 'pg_catalog.pg_transform' as a PgTransform.
//
// Generated from index 'pg_transform_type_lang_index'.
func PgTransformByTrftypeTrflang(ctx context.Context, db DB, trftype, trflang pgtypes.Oid) (*PgTransform, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, trftype, trflang, trffromsql, trftosql ` +
		`FROM pg_catalog.pg_transform ` +
		`WHERE trftype = $1 AND trflang = $2`
	// run
	logf(sqlstr, trftype, trflang)
	pt := PgTransform{}
	if err := db.QueryRowContext(ctx, sqlstr, trftype, trflang).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Trftype, &pt.Trflang, &pt.Trffromsql, &pt.Trftosql); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTriggerByOid retrieves a row from 'pg_catalog.pg_trigger' as a PgTrigger.
//
// Generated from index 'pg_trigger_oid_index'.
func PgTriggerByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTrigger, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, tgrelid, tgparentid, tgname, tgfoid, tgtype, tgenabled, tgisinternal, tgconstrrelid, tgconstrindid, tgconstraint, tgdeferrable, tginitdeferred, tgnargs, tgattr, tgargs, tgqual, tgoldtable, tgnewtable ` +
		`FROM pg_catalog.pg_trigger ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pt := PgTrigger{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Tgrelid, &pt.Tgparentid, &pt.Tgname, &pt.Tgfoid, &pt.Tgtype, &pt.Tgenabled, &pt.Tgisinternal, &pt.Tgconstrrelid, &pt.Tgconstrindid, &pt.Tgconstraint, &pt.Tgdeferrable, &pt.Tginitdeferred, &pt.Tgnargs, &pt.Tgattr, &pt.Tgargs, &pt.Tgqual, &pt.Tgoldtable, &pt.Tgnewtable); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTriggerByTgconstraint retrieves a row from 'pg_catalog.pg_trigger' as a PgTrigger.
//
// Generated from index 'pg_trigger_tgconstraint_index'.
func PgTriggerByTgconstraint(ctx context.Context, db DB, tgconstraint pgtypes.Oid) ([]*PgTrigger, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, tgrelid, tgparentid, tgname, tgfoid, tgtype, tgenabled, tgisinternal, tgconstrrelid, tgconstrindid, tgconstraint, tgdeferrable, tginitdeferred, tgnargs, tgattr, tgargs, tgqual, tgoldtable, tgnewtable ` +
		`FROM pg_catalog.pg_trigger ` +
		`WHERE tgconstraint = $1`
	// run
	logf(sqlstr, tgconstraint)
	rows, err := db.QueryContext(ctx, sqlstr, tgconstraint)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PgTrigger
	for rows.Next() {
		pt := PgTrigger{}
		// scan
		if err := rows.Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Tgrelid, &pt.Tgparentid, &pt.Tgname, &pt.Tgfoid, &pt.Tgtype, &pt.Tgenabled, &pt.Tgisinternal, &pt.Tgconstrrelid, &pt.Tgconstrindid, &pt.Tgconstraint, &pt.Tgdeferrable, &pt.Tginitdeferred, &pt.Tgnargs, &pt.Tgattr, &pt.Tgargs, &pt.Tgqual, &pt.Tgoldtable, &pt.Tgnewtable); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PgTriggerByTgrelidTgname retrieves a row from 'pg_catalog.pg_trigger' as a PgTrigger.
//
// Generated from index 'pg_trigger_tgrelid_tgname_index'.
func PgTriggerByTgrelidTgname(ctx context.Context, db DB, tgrelid pgtypes.Oid, tgname string) (*PgTrigger, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, tgrelid, tgparentid, tgname, tgfoid, tgtype, tgenabled, tgisinternal, tgconstrrelid, tgconstrindid, tgconstraint, tgdeferrable, tginitdeferred, tgnargs, tgattr, tgargs, tgqual, tgoldtable, tgnewtable ` +
		`FROM pg_catalog.pg_trigger ` +
		`WHERE tgrelid = $1 AND tgname = $2`
	// run
	logf(sqlstr, tgrelid, tgname)
	pt := PgTrigger{}
	if err := db.QueryRowContext(ctx, sqlstr, tgrelid, tgname).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Tgrelid, &pt.Tgparentid, &pt.Tgname, &pt.Tgfoid, &pt.Tgtype, &pt.Tgenabled, &pt.Tgisinternal, &pt.Tgconstrrelid, &pt.Tgconstrindid, &pt.Tgconstraint, &pt.Tgdeferrable, &pt.Tginitdeferred, &pt.Tgnargs, &pt.Tgattr, &pt.Tgargs, &pt.Tgqual, &pt.Tgoldtable, &pt.Tgnewtable); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTsConfigByCfgnameCfgnamespace retrieves a row from 'pg_catalog.pg_ts_config' as a PgTsConfig.
//
// Generated from index 'pg_ts_config_cfgname_index'.
func PgTsConfigByCfgnameCfgnamespace(ctx context.Context, db DB, cfgname string, cfgnamespace pgtypes.Oid) (*PgTsConfig, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, cfgname, cfgnamespace, cfgowner, cfgparser ` +
		`FROM pg_catalog.pg_ts_config ` +
		`WHERE cfgname = $1 AND cfgnamespace = $2`
	// run
	logf(sqlstr, cfgname, cfgnamespace)
	ptc := PgTsConfig{}
	if err := db.QueryRowContext(ctx, sqlstr, cfgname, cfgnamespace).Scan(&ptc.Tableoid, &ptc.Cmax, &ptc.Xmax, &ptc.Cmin, &ptc.Xmin, &ptc.Ctid, &ptc.Oid, &ptc.Cfgname, &ptc.Cfgnamespace, &ptc.Cfgowner, &ptc.Cfgparser); err != nil {
		return nil, logerror(err)
	}
	return &ptc, nil
}

// PgTsConfigByOid retrieves a row from 'pg_catalog.pg_ts_config' as a PgTsConfig.
//
// Generated from index 'pg_ts_config_oid_index'.
func PgTsConfigByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTsConfig, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, cfgname, cfgnamespace, cfgowner, cfgparser ` +
		`FROM pg_catalog.pg_ts_config ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ptc := PgTsConfig{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ptc.Tableoid, &ptc.Cmax, &ptc.Xmax, &ptc.Cmin, &ptc.Xmin, &ptc.Ctid, &ptc.Oid, &ptc.Cfgname, &ptc.Cfgnamespace, &ptc.Cfgowner, &ptc.Cfgparser); err != nil {
		return nil, logerror(err)
	}
	return &ptc, nil
}

// PgTsConfigMapByMapcfgMaptokentypeMapseqno retrieves a row from 'pg_catalog.pg_ts_config_map' as a PgTsConfigMap.
//
// Generated from index 'pg_ts_config_map_index'.
func PgTsConfigMapByMapcfgMaptokentypeMapseqno(ctx context.Context, db DB, mapcfg pgtypes.Oid, maptokentype, mapseqno int) (*PgTsConfigMap, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, mapcfg, maptokentype, mapseqno, mapdict ` +
		`FROM pg_catalog.pg_ts_config_map ` +
		`WHERE mapcfg = $1 AND maptokentype = $2 AND mapseqno = $3`
	// run
	logf(sqlstr, mapcfg, maptokentype, mapseqno)
	ptcm := PgTsConfigMap{}
	if err := db.QueryRowContext(ctx, sqlstr, mapcfg, maptokentype, mapseqno).Scan(&ptcm.Tableoid, &ptcm.Cmax, &ptcm.Xmax, &ptcm.Cmin, &ptcm.Xmin, &ptcm.Ctid, &ptcm.Mapcfg, &ptcm.Maptokentype, &ptcm.Mapseqno, &ptcm.Mapdict); err != nil {
		return nil, logerror(err)
	}
	return &ptcm, nil
}

// PgTsDictByDictnameDictnamespace retrieves a row from 'pg_catalog.pg_ts_dict' as a PgTsDict.
//
// Generated from index 'pg_ts_dict_dictname_index'.
func PgTsDictByDictnameDictnamespace(ctx context.Context, db DB, dictname string, dictnamespace pgtypes.Oid) (*PgTsDict, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption ` +
		`FROM pg_catalog.pg_ts_dict ` +
		`WHERE dictname = $1 AND dictnamespace = $2`
	// run
	logf(sqlstr, dictname, dictnamespace)
	ptd := PgTsDict{}
	if err := db.QueryRowContext(ctx, sqlstr, dictname, dictnamespace).Scan(&ptd.Tableoid, &ptd.Cmax, &ptd.Xmax, &ptd.Cmin, &ptd.Xmin, &ptd.Ctid, &ptd.Oid, &ptd.Dictname, &ptd.Dictnamespace, &ptd.Dictowner, &ptd.Dicttemplate, &ptd.Dictinitoption); err != nil {
		return nil, logerror(err)
	}
	return &ptd, nil
}

// PgTsDictByOid retrieves a row from 'pg_catalog.pg_ts_dict' as a PgTsDict.
//
// Generated from index 'pg_ts_dict_oid_index'.
func PgTsDictByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTsDict, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption ` +
		`FROM pg_catalog.pg_ts_dict ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ptd := PgTsDict{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ptd.Tableoid, &ptd.Cmax, &ptd.Xmax, &ptd.Cmin, &ptd.Xmin, &ptd.Ctid, &ptd.Oid, &ptd.Dictname, &ptd.Dictnamespace, &ptd.Dictowner, &ptd.Dicttemplate, &ptd.Dictinitoption); err != nil {
		return nil, logerror(err)
	}
	return &ptd, nil
}

// PgTsParserByOid retrieves a row from 'pg_catalog.pg_ts_parser' as a PgTsParser.
//
// Generated from index 'pg_ts_parser_oid_index'.
func PgTsParserByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTsParser, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, prsname, prsnamespace, prsstart, prstoken, prsend, prsheadline, prslextype ` +
		`FROM pg_catalog.pg_ts_parser ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ptp := PgTsParser{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ptp.Tableoid, &ptp.Cmax, &ptp.Xmax, &ptp.Cmin, &ptp.Xmin, &ptp.Ctid, &ptp.Oid, &ptp.Prsname, &ptp.Prsnamespace, &ptp.Prsstart, &ptp.Prstoken, &ptp.Prsend, &ptp.Prsheadline, &ptp.Prslextype); err != nil {
		return nil, logerror(err)
	}
	return &ptp, nil
}

// PgTsParserByPrsnamePrsnamespace retrieves a row from 'pg_catalog.pg_ts_parser' as a PgTsParser.
//
// Generated from index 'pg_ts_parser_prsname_index'.
func PgTsParserByPrsnamePrsnamespace(ctx context.Context, db DB, prsname string, prsnamespace pgtypes.Oid) (*PgTsParser, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, prsname, prsnamespace, prsstart, prstoken, prsend, prsheadline, prslextype ` +
		`FROM pg_catalog.pg_ts_parser ` +
		`WHERE prsname = $1 AND prsnamespace = $2`
	// run
	logf(sqlstr, prsname, prsnamespace)
	ptp := PgTsParser{}
	if err := db.QueryRowContext(ctx, sqlstr, prsname, prsnamespace).Scan(&ptp.Tableoid, &ptp.Cmax, &ptp.Xmax, &ptp.Cmin, &ptp.Xmin, &ptp.Ctid, &ptp.Oid, &ptp.Prsname, &ptp.Prsnamespace, &ptp.Prsstart, &ptp.Prstoken, &ptp.Prsend, &ptp.Prsheadline, &ptp.Prslextype); err != nil {
		return nil, logerror(err)
	}
	return &ptp, nil
}

// PgTsTemplateByOid retrieves a row from 'pg_catalog.pg_ts_template' as a PgTsTemplate.
//
// Generated from index 'pg_ts_template_oid_index'.
func PgTsTemplateByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgTsTemplate, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, tmplname, tmplnamespace, tmplinit, tmpllexize ` +
		`FROM pg_catalog.pg_ts_template ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	ptt := PgTsTemplate{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&ptt.Tableoid, &ptt.Cmax, &ptt.Xmax, &ptt.Cmin, &ptt.Xmin, &ptt.Ctid, &ptt.Oid, &ptt.Tmplname, &ptt.Tmplnamespace, &ptt.Tmplinit, &ptt.Tmpllexize); err != nil {
		return nil, logerror(err)
	}
	return &ptt, nil
}

// PgTsTemplateByTmplnameTmplnamespace retrieves a row from 'pg_catalog.pg_ts_template' as a PgTsTemplate.
//
// Generated from index 'pg_ts_template_tmplname_index'.
func PgTsTemplateByTmplnameTmplnamespace(ctx context.Context, db DB, tmplname string, tmplnamespace pgtypes.Oid) (*PgTsTemplate, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, tmplname, tmplnamespace, tmplinit, tmpllexize ` +
		`FROM pg_catalog.pg_ts_template ` +
		`WHERE tmplname = $1 AND tmplnamespace = $2`
	// run
	logf(sqlstr, tmplname, tmplnamespace)
	ptt := PgTsTemplate{}
	if err := db.QueryRowContext(ctx, sqlstr, tmplname, tmplnamespace).Scan(&ptt.Tableoid, &ptt.Cmax, &ptt.Xmax, &ptt.Cmin, &ptt.Xmin, &ptt.Ctid, &ptt.Oid, &ptt.Tmplname, &ptt.Tmplnamespace, &ptt.Tmplinit, &ptt.Tmpllexize); err != nil {
		return nil, logerror(err)
	}
	return &ptt, nil
}

// PgTypeByOid retrieves a row from 'pg_catalog.pg_type' as a PgType.
//
// Generated from index 'pg_type_oid_index'.
func PgTypeByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgType, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, typname, typnamespace, typowner, typlen, typbyval, typtype, typcategory, typispreferred, typisdefined, typdelim, typrelid, typelem, typarray, typinput, typoutput, typreceive, typsend, typmodin, typmodout, typanalyze, typalign, typstorage, typnotnull, typbasetype, typtypmod, typndims, typcollation, typdefaultbin, typdefault, typacl ` +
		`FROM pg_catalog.pg_type ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pt := PgType{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Typname, &pt.Typnamespace, &pt.Typowner, &pt.Typlen, &pt.Typbyval, &pt.Typtype, &pt.Typcategory, &pt.Typispreferred, &pt.Typisdefined, &pt.Typdelim, &pt.Typrelid, &pt.Typelem, &pt.Typarray, &pt.Typinput, &pt.Typoutput, &pt.Typreceive, &pt.Typsend, &pt.Typmodin, &pt.Typmodout, &pt.Typanalyze, &pt.Typalign, &pt.Typstorage, &pt.Typnotnull, &pt.Typbasetype, &pt.Typtypmod, &pt.Typndims, &pt.Typcollation, &pt.Typdefaultbin, &pt.Typdefault, &pt.Typacl); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgTypeByTypnameTypnamespace retrieves a row from 'pg_catalog.pg_type' as a PgType.
//
// Generated from index 'pg_type_typname_nsp_index'.
func PgTypeByTypnameTypnamespace(ctx context.Context, db DB, typname string, typnamespace pgtypes.Oid) (*PgType, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, typname, typnamespace, typowner, typlen, typbyval, typtype, typcategory, typispreferred, typisdefined, typdelim, typrelid, typelem, typarray, typinput, typoutput, typreceive, typsend, typmodin, typmodout, typanalyze, typalign, typstorage, typnotnull, typbasetype, typtypmod, typndims, typcollation, typdefaultbin, typdefault, typacl ` +
		`FROM pg_catalog.pg_type ` +
		`WHERE typname = $1 AND typnamespace = $2`
	// run
	logf(sqlstr, typname, typnamespace)
	pt := PgType{}
	if err := db.QueryRowContext(ctx, sqlstr, typname, typnamespace).Scan(&pt.Tableoid, &pt.Cmax, &pt.Xmax, &pt.Cmin, &pt.Xmin, &pt.Ctid, &pt.Oid, &pt.Typname, &pt.Typnamespace, &pt.Typowner, &pt.Typlen, &pt.Typbyval, &pt.Typtype, &pt.Typcategory, &pt.Typispreferred, &pt.Typisdefined, &pt.Typdelim, &pt.Typrelid, &pt.Typelem, &pt.Typarray, &pt.Typinput, &pt.Typoutput, &pt.Typreceive, &pt.Typsend, &pt.Typmodin, &pt.Typmodout, &pt.Typanalyze, &pt.Typalign, &pt.Typstorage, &pt.Typnotnull, &pt.Typbasetype, &pt.Typtypmod, &pt.Typndims, &pt.Typcollation, &pt.Typdefaultbin, &pt.Typdefault, &pt.Typacl); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}

// PgUserMappingByOid retrieves a row from 'pg_catalog.pg_user_mapping' as a PgUserMapping.
//
// Generated from index 'pg_user_mapping_oid_index'.
func PgUserMappingByOid(ctx context.Context, db DB, oid pgtypes.Oid) (*PgUserMapping, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, umuser, umserver, umoptions ` +
		`FROM pg_catalog.pg_user_mapping ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	pum := PgUserMapping{}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&pum.Tableoid, &pum.Cmax, &pum.Xmax, &pum.Cmin, &pum.Xmin, &pum.Ctid, &pum.Oid, &pum.Umuser, &pum.Umserver, &pum.Umoptions); err != nil {
		return nil, logerror(err)
	}
	return &pum, nil
}

// PgUserMappingByUmuserUmserver retrieves a row from 'pg_catalog.pg_user_mapping' as a PgUserMapping.
//
// Generated from index 'pg_user_mapping_user_server_index'.
func PgUserMappingByUmuserUmserver(ctx context.Context, db DB, umuser, umserver pgtypes.Oid) (*PgUserMapping, error) {
	// query
	const sqlstr = `SELECT ` +
		`tableoid, cmax, xmax, cmin, xmin, ctid, oid, umuser, umserver, umoptions ` +
		`FROM pg_catalog.pg_user_mapping ` +
		`WHERE umuser = $1 AND umserver = $2`
	// run
	logf(sqlstr, umuser, umserver)
	pum := PgUserMapping{}
	if err := db.QueryRowContext(ctx, sqlstr, umuser, umserver).Scan(&pum.Tableoid, &pum.Cmax, &pum.Xmax, &pum.Cmin, &pum.Xmin, &pum.Ctid, &pum.Oid, &pum.Umuser, &pum.Umserver, &pum.Umoptions); err != nil {
		return nil, logerror(err)
	}
	return &pum, nil
}

// ASCII calls the stored function 'pg_catalog.ascii(text) integer' on db.
func ASCII(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.ascii
	const sqlstr = `SELECT * FROM pg_catalog.ascii($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// AbbrevByInet calls the stored function 'pg_catalog.abbrev(inet) text' on db.
func AbbrevByInet(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.abbrev
	const sqlstr = `SELECT * FROM pg_catalog.abbrev($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// AbbrevByCidr calls the stored function 'pg_catalog.abbrev(cidr) text' on db.
func AbbrevByCidr(ctx context.Context, db DB, p0 pgtypes.Cidr) (string, error) {
	// call pg_catalog.abbrev
	const sqlstr = `SELECT * FROM pg_catalog.abbrev($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// AbsByReal calls the stored function 'pg_catalog.abs(real) real' on db.
func AbsByReal(ctx context.Context, db DB, p0 float32) (float32, error) {
	// call pg_catalog.abs
	const sqlstr = `SELECT * FROM pg_catalog.abs($1)`
	// run
	var r0 float32
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// AbsByDoublePrecision calls the stored function 'pg_catalog.abs(double precision) double precision' on db.
func AbsByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.abs
	const sqlstr = `SELECT * FROM pg_catalog.abs($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// AbsByBigint calls the stored function 'pg_catalog.abs(bigint) bigint' on db.
func AbsByBigint(ctx context.Context, db DB, p0 int64) (int64, error) {
	// call pg_catalog.abs
	const sqlstr = `SELECT * FROM pg_catalog.abs($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// AbsByInteger calls the stored function 'pg_catalog.abs(integer) integer' on db.
func AbsByInteger(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.abs
	const sqlstr = `SELECT * FROM pg_catalog.abs($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// AbsBySmallint calls the stored function 'pg_catalog.abs(smallint) smallint' on db.
func AbsBySmallint(ctx context.Context, db DB, p0 int16) (int16, error) {
	// call pg_catalog.abs
	const sqlstr = `SELECT * FROM pg_catalog.abs($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// AbsByNumeric calls the stored function 'pg_catalog.abs(numeric) numeric' on db.
func AbsByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.abs
	const sqlstr = `SELECT * FROM pg_catalog.abs($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Aclcontains calls the stored function 'pg_catalog.aclcontains(aclitem, aclitem) boolean' on db.
func Aclcontains(ctx context.Context, db DB, p0 []pgtypes.Aclitem, p1 pgtypes.Aclitem) (bool, error) {
	// call pg_catalog.aclcontains
	const sqlstr = `SELECT * FROM pg_catalog.aclcontains($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Acldefault calls the stored function 'pg_catalog.acldefault("char", oid) aclitem' on db.
func Acldefault(ctx context.Context, db DB, p0 pgtypes.Char, p1 pgtypes.Oid) ([]pgtypes.Aclitem, error) {
	// call pg_catalog.acldefault
	const sqlstr = `SELECT * FROM pg_catalog.acldefault($1, $2)`
	// run
	var r0 []pgtypes.Aclitem
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Aclexplode calls the stored function 'pg_catalog.aclexplode(aclitem) (oid, oid, text, boolean)' on db.
func Aclexplode(ctx context.Context, db DB, acl []pgtypes.Aclitem) (pgtypes.Oid, pgtypes.Oid, string, bool, error) {
	// call pg_catalog.aclexplode
	const sqlstr = `SELECT * FROM pg_catalog.aclexplode($1)`
	// run
	var grantor pgtypes.Oid
	var grantee pgtypes.Oid
	var privilegeType string
	var isGrantable bool
	logf(sqlstr, acl)
	if err := db.QueryRowContext(ctx, sqlstr, acl).Scan(&grantor, &grantee, &privilegeType, &isGrantable); err != nil {
		return pgtypes.Oid{}, pgtypes.Oid{}, "", false, logerror(err)
	}
	return grantor, grantee, privilegeType, isGrantable, nil
}

// Aclinsert calls the stored function 'pg_catalog.aclinsert(aclitem, aclitem) aclitem' on db.
func Aclinsert(ctx context.Context, db DB, p0 []pgtypes.Aclitem, p1 pgtypes.Aclitem) ([]pgtypes.Aclitem, error) {
	// call pg_catalog.aclinsert
	const sqlstr = `SELECT * FROM pg_catalog.aclinsert($1, $2)`
	// run
	var r0 []pgtypes.Aclitem
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Aclitemeq calls the stored function 'pg_catalog.aclitemeq(aclitem, aclitem) boolean' on db.
func Aclitemeq(ctx context.Context, db DB, p0, p1 pgtypes.Aclitem) (bool, error) {
	// call pg_catalog.aclitemeq
	const sqlstr = `SELECT * FROM pg_catalog.aclitemeq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Aclremove calls the stored function 'pg_catalog.aclremove(aclitem, aclitem) aclitem' on db.
func Aclremove(ctx context.Context, db DB, p0 []pgtypes.Aclitem, p1 pgtypes.Aclitem) ([]pgtypes.Aclitem, error) {
	// call pg_catalog.aclremove
	const sqlstr = `SELECT * FROM pg_catalog.aclremove($1, $2)`
	// run
	var r0 []pgtypes.Aclitem
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Acos calls the stored function 'pg_catalog.acos(double precision) double precision' on db.
func Acos(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.acos
	const sqlstr = `SELECT * FROM pg_catalog.acos($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Acosd calls the stored function 'pg_catalog.acosd(double precision) double precision' on db.
func Acosd(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.acosd
	const sqlstr = `SELECT * FROM pg_catalog.acosd($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Acosh calls the stored function 'pg_catalog.acosh(double precision) double precision' on db.
func Acosh(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.acosh
	const sqlstr = `SELECT * FROM pg_catalog.acosh($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// AgeByXid calls the stored function 'pg_catalog.age(xid) integer' on db.
func AgeByXid(ctx context.Context, db DB, p0 pgtypes.Xid) (int, error) {
	// call pg_catalog.age
	const sqlstr = `SELECT * FROM pg_catalog.age($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// AgeByTimestampWithTimeZoneAndTimestampWithTimeZone calls the stored function 'pg_catalog.age(timestamp with time zone, timestamp with time zone) interval' on db.
func AgeByTimestampWithTimeZoneAndTimestampWithTimeZone(ctx context.Context, db DB, p0, p1 time.Time) ([]byte, error) {
	// call pg_catalog.age
	const sqlstr = `SELECT * FROM pg_catalog.age($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// AgeByTimestampWithTimeZone calls the stored function 'pg_catalog.age(timestamp with time zone) interval' on db.
func AgeByTimestampWithTimeZone(ctx context.Context, db DB, p0 time.Time) ([]byte, error) {
	// call pg_catalog.age
	const sqlstr = `SELECT * FROM pg_catalog.age($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// AgeByTimestampWithoutTimeZoneAndTimestampWithoutTimeZone calls the stored function 'pg_catalog.age(timestamp without time zone, timestamp without time zone) interval' on db.
func AgeByTimestampWithoutTimeZoneAndTimestampWithoutTimeZone(ctx context.Context, db DB, p0, p1 time.Time) ([]byte, error) {
	// call pg_catalog.age
	const sqlstr = `SELECT * FROM pg_catalog.age($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// AgeByTimestampWithoutTimeZone calls the stored function 'pg_catalog.age(timestamp without time zone) interval' on db.
func AgeByTimestampWithoutTimeZone(ctx context.Context, db DB, p0 time.Time) ([]byte, error) {
	// call pg_catalog.age
	const sqlstr = `SELECT * FROM pg_catalog.age($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Amvalidate calls the stored function 'pg_catalog.amvalidate(oid) boolean' on db.
func Amvalidate(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.amvalidate
	const sqlstr = `SELECT * FROM pg_catalog.amvalidate($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// AnyarrayRecv calls the stored function 'pg_catalog.anyarray_recv(internal) anyarray' on db.
func AnyarrayRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Anyarray, error) {
	// call pg_catalog.anyarray_recv
	const sqlstr = `SELECT * FROM pg_catalog.anyarray_recv($1)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// AnyarraySend calls the stored function 'pg_catalog.anyarray_send(anyarray) bytea' on db.
func AnyarraySend(ctx context.Context, db DB, p0 pgtypes.Anyarray) ([]byte, error) {
	// call pg_catalog.anyarray_send
	const sqlstr = `SELECT * FROM pg_catalog.anyarray_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// AnycompatiblearrayRecv calls the stored function 'pg_catalog.anycompatiblearray_recv(internal) anycompatiblearray' on db.
func AnycompatiblearrayRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Anycompatiblearray, error) {
	// call pg_catalog.anycompatiblearray_recv
	const sqlstr = `SELECT * FROM pg_catalog.anycompatiblearray_recv($1)`
	// run
	var r0 pgtypes.Anycompatiblearray
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Anycompatiblearray{}, logerror(err)
	}
	return r0, nil
}

// AnycompatiblearraySend calls the stored function 'pg_catalog.anycompatiblearray_send(anycompatiblearray) bytea' on db.
func AnycompatiblearraySend(ctx context.Context, db DB, p0 pgtypes.Anycompatiblearray) ([]byte, error) {
	// call pg_catalog.anycompatiblearray_send
	const sqlstr = `SELECT * FROM pg_catalog.anycompatiblearray_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Anytextcat calls the stored function 'pg_catalog.anytextcat(anynonarray, text) text' on db.
func Anytextcat(ctx context.Context, db DB, p0 pgtypes.Anynonarray, p1 string) (string, error) {
	// call pg_catalog.anytextcat
	const sqlstr = `SELECT * FROM pg_catalog.anytextcat($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// AreaByCircle calls the stored function 'pg_catalog.area(circle) double precision' on db.
func AreaByCircle(ctx context.Context, db DB, p0 pgtypes.Circle) (float64, error) {
	// call pg_catalog.area
	const sqlstr = `SELECT * FROM pg_catalog.area($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// AreaByBox calls the stored function 'pg_catalog.area(box) double precision' on db.
func AreaByBox(ctx context.Context, db DB, p0 pgtypes.Box) (float64, error) {
	// call pg_catalog.area
	const sqlstr = `SELECT * FROM pg_catalog.area($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// AreaByPath calls the stored function 'pg_catalog.area(path) double precision' on db.
func AreaByPath(ctx context.Context, db DB, p0 pgtypes.Path) (float64, error) {
	// call pg_catalog.area
	const sqlstr = `SELECT * FROM pg_catalog.area($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Areajoinsel calls the stored function 'pg_catalog.areajoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Areajoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.areajoinsel
	const sqlstr = `SELECT * FROM pg_catalog.areajoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Areasel calls the stored function 'pg_catalog.areasel(internal, oid, internal, integer) double precision' on db.
func Areasel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.areasel
	const sqlstr = `SELECT * FROM pg_catalog.areasel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// ArrayAggArrayFinalfn calls the stored function 'pg_catalog.array_agg_array_finalfn(internal, anyarray) anyarray' on db.
func ArrayAggArrayFinalfn(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Anyarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_agg_array_finalfn
	const sqlstr = `SELECT * FROM pg_catalog.array_agg_array_finalfn($1, $2)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArrayAggArrayTransfn calls the stored function 'pg_catalog.array_agg_array_transfn(internal, anyarray) internal' on db.
func ArrayAggArrayTransfn(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Anyarray) (pgtypes.Internal, error) {
	// call pg_catalog.array_agg_array_transfn
	const sqlstr = `SELECT * FROM pg_catalog.array_agg_array_transfn($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// ArrayAggFinalfn calls the stored function 'pg_catalog.array_agg_finalfn(internal, anynonarray) anyarray' on db.
func ArrayAggFinalfn(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Anynonarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_agg_finalfn
	const sqlstr = `SELECT * FROM pg_catalog.array_agg_finalfn($1, $2)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArrayAggTransfn calls the stored function 'pg_catalog.array_agg_transfn(internal, anynonarray) internal' on db.
func ArrayAggTransfn(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Anynonarray) (pgtypes.Internal, error) {
	// call pg_catalog.array_agg_transfn
	const sqlstr = `SELECT * FROM pg_catalog.array_agg_transfn($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// ArrayAppend calls the stored function 'pg_catalog.array_append(anyarray, anyelement) anyarray' on db.
func ArrayAppend(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 pgtypes.Anyelement) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_append
	const sqlstr = `SELECT * FROM pg_catalog.array_append($1, $2)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArrayCat calls the stored function 'pg_catalog.array_cat(anyarray, anyarray) anyarray' on db.
func ArrayCat(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_cat
	const sqlstr = `SELECT * FROM pg_catalog.array_cat($1, $2)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArrayDims calls the stored function 'pg_catalog.array_dims(anyarray) text' on db.
func ArrayDims(ctx context.Context, db DB, p0 pgtypes.Anyarray) (string, error) {
	// call pg_catalog.array_dims
	const sqlstr = `SELECT * FROM pg_catalog.array_dims($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ArrayEq calls the stored function 'pg_catalog.array_eq(anyarray, anyarray) boolean' on db.
func ArrayEq(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_eq
	const sqlstr = `SELECT * FROM pg_catalog.array_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// ArrayFillByAnyelementAndInteger calls the stored function 'pg_catalog.array_fill(anyelement, integer) anyarray' on db.
func ArrayFillByAnyelementAndInteger(ctx context.Context, db DB, p0 pgtypes.Anyelement, p1 []int) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_fill
	const sqlstr = `SELECT * FROM pg_catalog.array_fill($1, $2)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArrayFillByAnyelementIntegerAndInteger calls the stored function 'pg_catalog.array_fill(anyelement, integer, integer) anyarray' on db.
func ArrayFillByAnyelementIntegerAndInteger(ctx context.Context, db DB, p0 pgtypes.Anyelement, p1, p2 []int) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_fill
	const sqlstr = `SELECT * FROM pg_catalog.array_fill($1, $2, $3)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArrayGe calls the stored function 'pg_catalog.array_ge(anyarray, anyarray) boolean' on db.
func ArrayGe(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_ge
	const sqlstr = `SELECT * FROM pg_catalog.array_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// ArrayGt calls the stored function 'pg_catalog.array_gt(anyarray, anyarray) boolean' on db.
func ArrayGt(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_gt
	const sqlstr = `SELECT * FROM pg_catalog.array_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// ArrayLarger calls the stored function 'pg_catalog.array_larger(anyarray, anyarray) anyarray' on db.
func ArrayLarger(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_larger
	const sqlstr = `SELECT * FROM pg_catalog.array_larger($1, $2)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArrayLe calls the stored function 'pg_catalog.array_le(anyarray, anyarray) boolean' on db.
func ArrayLe(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_le
	const sqlstr = `SELECT * FROM pg_catalog.array_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// ArrayLength calls the stored function 'pg_catalog.array_length(anyarray, integer) integer' on db.
func ArrayLength(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 int) (int, error) {
	// call pg_catalog.array_length
	const sqlstr = `SELECT * FROM pg_catalog.array_length($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// ArrayLower calls the stored function 'pg_catalog.array_lower(anyarray, integer) integer' on db.
func ArrayLower(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 int) (int, error) {
	// call pg_catalog.array_lower
	const sqlstr = `SELECT * FROM pg_catalog.array_lower($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// ArrayLt calls the stored function 'pg_catalog.array_lt(anyarray, anyarray) boolean' on db.
func ArrayLt(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_lt
	const sqlstr = `SELECT * FROM pg_catalog.array_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// ArrayNdims calls the stored function 'pg_catalog.array_ndims(anyarray) integer' on db.
func ArrayNdims(ctx context.Context, db DB, p0 pgtypes.Anyarray) (int, error) {
	// call pg_catalog.array_ndims
	const sqlstr = `SELECT * FROM pg_catalog.array_ndims($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// ArrayNe calls the stored function 'pg_catalog.array_ne(anyarray, anyarray) boolean' on db.
func ArrayNe(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.array_ne
	const sqlstr = `SELECT * FROM pg_catalog.array_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// ArrayPositionByAnyarrayAndAnyelement calls the stored function 'pg_catalog.array_position(anyarray, anyelement) integer' on db.
func ArrayPositionByAnyarrayAndAnyelement(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 pgtypes.Anyelement) (int, error) {
	// call pg_catalog.array_position
	const sqlstr = `SELECT * FROM pg_catalog.array_position($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// ArrayPositionByAnyarrayAnyelementAndInteger calls the stored function 'pg_catalog.array_position(anyarray, anyelement, integer) integer' on db.
func ArrayPositionByAnyarrayAnyelementAndInteger(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 pgtypes.Anyelement, p2 int) (int, error) {
	// call pg_catalog.array_position
	const sqlstr = `SELECT * FROM pg_catalog.array_position($1, $2, $3)`
	// run
	var r0 int
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// ArrayPositions calls the stored function 'pg_catalog.array_positions(anyarray, anyelement) integer' on db.
func ArrayPositions(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 pgtypes.Anyelement) ([]int, error) {
	// call pg_catalog.array_positions
	const sqlstr = `SELECT * FROM pg_catalog.array_positions($1, $2)`
	// run
	var r0 []int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// ArrayPrepend calls the stored function 'pg_catalog.array_prepend(anyelement, anyarray) anyarray' on db.
func ArrayPrepend(ctx context.Context, db DB, p0 pgtypes.Anyelement, p1 pgtypes.Anyarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_prepend
	const sqlstr = `SELECT * FROM pg_catalog.array_prepend($1, $2)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArrayRecv calls the stored function 'pg_catalog.array_recv(internal, oid, integer) anyarray' on db.
func ArrayRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_recv
	const sqlstr = `SELECT * FROM pg_catalog.array_recv($1, $2, $3)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArrayRemove calls the stored function 'pg_catalog.array_remove(anyarray, anyelement) anyarray' on db.
func ArrayRemove(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 pgtypes.Anyelement) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_remove
	const sqlstr = `SELECT * FROM pg_catalog.array_remove($1, $2)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArrayReplace calls the stored function 'pg_catalog.array_replace(anyarray, anyelement, anyelement) anyarray' on db.
func ArrayReplace(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1, p2 pgtypes.Anyelement) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_replace
	const sqlstr = `SELECT * FROM pg_catalog.array_replace($1, $2, $3)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArraySend calls the stored function 'pg_catalog.array_send(anyarray) bytea' on db.
func ArraySend(ctx context.Context, db DB, p0 pgtypes.Anyarray) ([]byte, error) {
	// call pg_catalog.array_send
	const sqlstr = `SELECT * FROM pg_catalog.array_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// ArraySmaller calls the stored function 'pg_catalog.array_smaller(anyarray, anyarray) anyarray' on db.
func ArraySmaller(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (pgtypes.Anyarray, error) {
	// call pg_catalog.array_smaller
	const sqlstr = `SELECT * FROM pg_catalog.array_smaller($1, $2)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// ArrayToJSONByAnyarray calls the stored function 'pg_catalog.array_to_json(anyarray) json' on db.
func ArrayToJSONByAnyarray(ctx context.Context, db DB, p0 pgtypes.Anyarray) ([]byte, error) {
	// call pg_catalog.array_to_json
	const sqlstr = `SELECT * FROM pg_catalog.array_to_json($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// ArrayToJSONByAnyarrayAndBoolean calls the stored function 'pg_catalog.array_to_json(anyarray, boolean) json' on db.
func ArrayToJSONByAnyarrayAndBoolean(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 bool) ([]byte, error) {
	// call pg_catalog.array_to_json
	const sqlstr = `SELECT * FROM pg_catalog.array_to_json($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// ArrayToStringByAnyarrayTextAndText calls the stored function 'pg_catalog.array_to_string(anyarray, text, text) text' on db.
func ArrayToStringByAnyarrayTextAndText(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1, p2 string) (string, error) {
	// call pg_catalog.array_to_string
	const sqlstr = `SELECT * FROM pg_catalog.array_to_string($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ArrayToStringByAnyarrayAndText calls the stored function 'pg_catalog.array_to_string(anyarray, text) text' on db.
func ArrayToStringByAnyarrayAndText(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 string) (string, error) {
	// call pg_catalog.array_to_string
	const sqlstr = `SELECT * FROM pg_catalog.array_to_string($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ArrayToTsvector calls the stored function 'pg_catalog.array_to_tsvector(text) tsvector' on db.
func ArrayToTsvector(ctx context.Context, db DB, p0 StringSlice) (pgtypes.Tsvector, error) {
	// call pg_catalog.array_to_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.array_to_tsvector($1)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// ArrayTypanalyze calls the stored function 'pg_catalog.array_typanalyze(internal) boolean' on db.
func ArrayTypanalyze(ctx context.Context, db DB, p0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.array_typanalyze
	const sqlstr = `SELECT * FROM pg_catalog.array_typanalyze($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// ArrayUnnestSupport calls the stored function 'pg_catalog.array_unnest_support(internal) internal' on db.
func ArrayUnnestSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.array_unnest_support
	const sqlstr = `SELECT * FROM pg_catalog.array_unnest_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// ArrayUpper calls the stored function 'pg_catalog.array_upper(anyarray, integer) integer' on db.
func ArrayUpper(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 int) (int, error) {
	// call pg_catalog.array_upper
	const sqlstr = `SELECT * FROM pg_catalog.array_upper($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Arraycontained calls the stored function 'pg_catalog.arraycontained(anyarray, anyarray) boolean' on db.
func Arraycontained(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.arraycontained
	const sqlstr = `SELECT * FROM pg_catalog.arraycontained($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Arraycontains calls the stored function 'pg_catalog.arraycontains(anyarray, anyarray) boolean' on db.
func Arraycontains(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.arraycontains
	const sqlstr = `SELECT * FROM pg_catalog.arraycontains($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Arraycontjoinsel calls the stored function 'pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Arraycontjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.arraycontjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.arraycontjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Arraycontsel calls the stored function 'pg_catalog.arraycontsel(internal, oid, internal, integer) double precision' on db.
func Arraycontsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.arraycontsel
	const sqlstr = `SELECT * FROM pg_catalog.arraycontsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Arrayoverlap calls the stored function 'pg_catalog.arrayoverlap(anyarray, anyarray) boolean' on db.
func Arrayoverlap(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (bool, error) {
	// call pg_catalog.arrayoverlap
	const sqlstr = `SELECT * FROM pg_catalog.arrayoverlap($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Asin calls the stored function 'pg_catalog.asin(double precision) double precision' on db.
func Asin(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.asin
	const sqlstr = `SELECT * FROM pg_catalog.asin($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Asind calls the stored function 'pg_catalog.asind(double precision) double precision' on db.
func Asind(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.asind
	const sqlstr = `SELECT * FROM pg_catalog.asind($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Asinh calls the stored function 'pg_catalog.asinh(double precision) double precision' on db.
func Asinh(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.asinh
	const sqlstr = `SELECT * FROM pg_catalog.asinh($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Atan calls the stored function 'pg_catalog.atan(double precision) double precision' on db.
func Atan(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.atan
	const sqlstr = `SELECT * FROM pg_catalog.atan($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Atan2 calls the stored function 'pg_catalog.atan2(double precision, double precision) double precision' on db.
func Atan2(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.atan2
	const sqlstr = `SELECT * FROM pg_catalog.atan2($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Atan2d calls the stored function 'pg_catalog.atan2d(double precision, double precision) double precision' on db.
func Atan2d(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.atan2d
	const sqlstr = `SELECT * FROM pg_catalog.atan2d($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Atand calls the stored function 'pg_catalog.atand(double precision) double precision' on db.
func Atand(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.atand
	const sqlstr = `SELECT * FROM pg_catalog.atand($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Atanh calls the stored function 'pg_catalog.atanh(double precision) double precision' on db.
func Atanh(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.atanh
	const sqlstr = `SELECT * FROM pg_catalog.atanh($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Bernoulli calls the stored function 'pg_catalog.bernoulli(internal) tsm_handler' on db.
func Bernoulli(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.TsmHandler, error) {
	// call pg_catalog.bernoulli
	const sqlstr = `SELECT * FROM pg_catalog.bernoulli($1)`
	// run
	var r0 pgtypes.TsmHandler
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.TsmHandler{}, logerror(err)
	}
	return r0, nil
}

// Big5ToEucTw calls the stored function 'pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer)' on db.
func Big5ToEucTw(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.big5_to_euc_tw
	const sqlstr = `SELECT * FROM pg_catalog.big5_to_euc_tw($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Big5ToMic calls the stored function 'pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer)' on db.
func Big5ToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.big5_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.big5_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Big5ToUTF8 calls the stored function 'pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer)' on db.
func Big5ToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.big5_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.big5_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeCreateEmptyExtension calls the stored function 'pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid, text, text)' on db.
func BinaryUpgradeCreateEmptyExtension(ctx context.Context, db DB, p0, p1 string, p2 bool, p3 string, p4 []pgtypes.Oid, p5, p6 StringSlice) error {
	// call pg_catalog.binary_upgrade_create_empty_extension
	const sqlstr = `SELECT * FROM pg_catalog.binary_upgrade_create_empty_extension($1, $2, $3, $4, $5, $6, $7)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetMissingValue calls the stored function 'pg_catalog.binary_upgrade_set_missing_value(oid, text, text)' on db.
func BinaryUpgradeSetMissingValue(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) error {
	// call pg_catalog.binary_upgrade_set_missing_value
	const sqlstr = `SELECT * FROM pg_catalog.binary_upgrade_set_missing_value($1, $2, $3)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextArrayPgTypeOid calls the stored function 'pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid)' on db.
func BinaryUpgradeSetNextArrayPgTypeOid(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_array_pg_type_oid
	const sqlstr = `SELECT * FROM pg_catalog.binary_upgrade_set_next_array_pg_type_oid($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextHeapPgClassOid calls the stored function 'pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid)' on db.
func BinaryUpgradeSetNextHeapPgClassOid(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_heap_pg_class_oid
	const sqlstr = `SELECT * FROM pg_catalog.binary_upgrade_set_next_heap_pg_class_oid($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextIndexPgClassOid calls the stored function 'pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid)' on db.
func BinaryUpgradeSetNextIndexPgClassOid(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_index_pg_class_oid
	const sqlstr = `SELECT * FROM pg_catalog.binary_upgrade_set_next_index_pg_class_oid($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextPgAuthidOid calls the stored function 'pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid)' on db.
func BinaryUpgradeSetNextPgAuthidOid(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_pg_authid_oid
	const sqlstr = `SELECT * FROM pg_catalog.binary_upgrade_set_next_pg_authid_oid($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextPgEnumOid calls the stored function 'pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid)' on db.
func BinaryUpgradeSetNextPgEnumOid(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_pg_enum_oid
	const sqlstr = `SELECT * FROM pg_catalog.binary_upgrade_set_next_pg_enum_oid($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextPgTypeOid calls the stored function 'pg_catalog.binary_upgrade_set_next_pg_type_oid(oid)' on db.
func BinaryUpgradeSetNextPgTypeOid(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_pg_type_oid
	const sqlstr = `SELECT * FROM pg_catalog.binary_upgrade_set_next_pg_type_oid($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextToastPgClassOid calls the stored function 'pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid)' on db.
func BinaryUpgradeSetNextToastPgClassOid(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_toast_pg_class_oid
	const sqlstr = `SELECT * FROM pg_catalog.binary_upgrade_set_next_toast_pg_class_oid($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetNextToastPgTypeOid calls the stored function 'pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid)' on db.
func BinaryUpgradeSetNextToastPgTypeOid(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.binary_upgrade_set_next_toast_pg_type_oid
	const sqlstr = `SELECT * FROM pg_catalog.binary_upgrade_set_next_toast_pg_type_oid($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// BinaryUpgradeSetRecordInitPrivs calls the stored function 'pg_catalog.binary_upgrade_set_record_init_privs(boolean)' on db.
func BinaryUpgradeSetRecordInitPrivs(ctx context.Context, db DB, p0 bool) error {
	// call pg_catalog.binary_upgrade_set_record_init_privs
	const sqlstr = `SELECT * FROM pg_catalog.binary_upgrade_set_record_init_privs($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// BitByIntegerAndInteger calls the stored function 'pg_catalog.bit(integer, integer) bit' on db.
func BitByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (uint8, error) {
	// call pg_catalog.bit
	const sqlstr = `SELECT * FROM pg_catalog.bit($1, $2)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BitByBitIntegerAndBoolean calls the stored function 'pg_catalog.bit(bit, integer, boolean) bit' on db.
func BitByBitIntegerAndBoolean(ctx context.Context, db DB, p0 uint8, p1 int, p2 bool) (uint8, error) {
	// call pg_catalog.bit
	const sqlstr = `SELECT * FROM pg_catalog.bit($1, $2, $3)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BitByBigintAndInteger calls the stored function 'pg_catalog.bit(bigint, integer) bit' on db.
func BitByBigintAndInteger(ctx context.Context, db DB, p0 int64, p1 int) (uint8, error) {
	// call pg_catalog.bit
	const sqlstr = `SELECT * FROM pg_catalog.bit($1, $2)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BitLengthByBytea calls the stored function 'pg_catalog.bit_length(bytea) integer' on db.
func BitLengthByBytea(ctx context.Context, db DB, p0 []byte) (int, error) {
	// call pg_catalog.bit_length
	const sqlstr = `SELECT * FROM pg_catalog.bit_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BitLengthByText calls the stored function 'pg_catalog.bit_length(text) integer' on db.
func BitLengthByText(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.bit_length
	const sqlstr = `SELECT * FROM pg_catalog.bit_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BitLengthByBit calls the stored function 'pg_catalog.bit_length(bit) integer' on db.
func BitLengthByBit(ctx context.Context, db DB, p0 uint8) (int, error) {
	// call pg_catalog.bit_length
	const sqlstr = `SELECT * FROM pg_catalog.bit_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BitRecv calls the stored function 'pg_catalog.bit_recv(internal, oid, integer) bit' on db.
func BitRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (uint8, error) {
	// call pg_catalog.bit_recv
	const sqlstr = `SELECT * FROM pg_catalog.bit_recv($1, $2, $3)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BitSend calls the stored function 'pg_catalog.bit_send(bit) bytea' on db.
func BitSend(ctx context.Context, db DB, p0 uint8) ([]byte, error) {
	// call pg_catalog.bit_send
	const sqlstr = `SELECT * FROM pg_catalog.bit_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Bitand calls the stored function 'pg_catalog.bitand(bit, bit) bit' on db.
func Bitand(ctx context.Context, db DB, p0, p1 uint8) (uint8, error) {
	// call pg_catalog.bitand
	const sqlstr = `SELECT * FROM pg_catalog.bitand($1, $2)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Bitcat calls the stored function 'pg_catalog.bitcat(bit varying, bit varying) bit varying' on db.
func Bitcat(ctx context.Context, db DB, p0, p1 []byte) ([]byte, error) {
	// call pg_catalog.bitcat
	const sqlstr = `SELECT * FROM pg_catalog.bitcat($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Bitcmp calls the stored function 'pg_catalog.bitcmp(bit, bit) integer' on db.
func Bitcmp(ctx context.Context, db DB, p0, p1 uint8) (int, error) {
	// call pg_catalog.bitcmp
	const sqlstr = `SELECT * FROM pg_catalog.bitcmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Biteq calls the stored function 'pg_catalog.biteq(bit, bit) boolean' on db.
func Biteq(ctx context.Context, db DB, p0, p1 uint8) (bool, error) {
	// call pg_catalog.biteq
	const sqlstr = `SELECT * FROM pg_catalog.biteq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bitge calls the stored function 'pg_catalog.bitge(bit, bit) boolean' on db.
func Bitge(ctx context.Context, db DB, p0, p1 uint8) (bool, error) {
	// call pg_catalog.bitge
	const sqlstr = `SELECT * FROM pg_catalog.bitge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bitgt calls the stored function 'pg_catalog.bitgt(bit, bit) boolean' on db.
func Bitgt(ctx context.Context, db DB, p0, p1 uint8) (bool, error) {
	// call pg_catalog.bitgt
	const sqlstr = `SELECT * FROM pg_catalog.bitgt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bitle calls the stored function 'pg_catalog.bitle(bit, bit) boolean' on db.
func Bitle(ctx context.Context, db DB, p0, p1 uint8) (bool, error) {
	// call pg_catalog.bitle
	const sqlstr = `SELECT * FROM pg_catalog.bitle($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bitlt calls the stored function 'pg_catalog.bitlt(bit, bit) boolean' on db.
func Bitlt(ctx context.Context, db DB, p0, p1 uint8) (bool, error) {
	// call pg_catalog.bitlt
	const sqlstr = `SELECT * FROM pg_catalog.bitlt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bitne calls the stored function 'pg_catalog.bitne(bit, bit) boolean' on db.
func Bitne(ctx context.Context, db DB, p0, p1 uint8) (bool, error) {
	// call pg_catalog.bitne
	const sqlstr = `SELECT * FROM pg_catalog.bitne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bitnot calls the stored function 'pg_catalog.bitnot(bit) bit' on db.
func Bitnot(ctx context.Context, db DB, p0 uint8) (uint8, error) {
	// call pg_catalog.bitnot
	const sqlstr = `SELECT * FROM pg_catalog.bitnot($1)`
	// run
	var r0 uint8
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Bitor calls the stored function 'pg_catalog.bitor(bit, bit) bit' on db.
func Bitor(ctx context.Context, db DB, p0, p1 uint8) (uint8, error) {
	// call pg_catalog.bitor
	const sqlstr = `SELECT * FROM pg_catalog.bitor($1, $2)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Bitshiftleft calls the stored function 'pg_catalog.bitshiftleft(bit, integer) bit' on db.
func Bitshiftleft(ctx context.Context, db DB, p0 uint8, p1 int) (uint8, error) {
	// call pg_catalog.bitshiftleft
	const sqlstr = `SELECT * FROM pg_catalog.bitshiftleft($1, $2)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Bitshiftright calls the stored function 'pg_catalog.bitshiftright(bit, integer) bit' on db.
func Bitshiftright(ctx context.Context, db DB, p0 uint8, p1 int) (uint8, error) {
	// call pg_catalog.bitshiftright
	const sqlstr = `SELECT * FROM pg_catalog.bitshiftright($1, $2)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Bittypmodin calls the stored function 'pg_catalog.bittypmodin(cstring) integer' on db.
func Bittypmodin(ctx context.Context, db DB, p0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.bittypmodin
	const sqlstr = `SELECT * FROM pg_catalog.bittypmodin($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Bitxor calls the stored function 'pg_catalog.bitxor(bit, bit) bit' on db.
func Bitxor(ctx context.Context, db DB, p0, p1 uint8) (uint8, error) {
	// call pg_catalog.bitxor
	const sqlstr = `SELECT * FROM pg_catalog.bitxor($1, $2)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BoolByInteger calls the stored function 'pg_catalog.bool(integer) boolean' on db.
func BoolByInteger(ctx context.Context, db DB, p0 int) (bool, error) {
	// call pg_catalog.bool
	const sqlstr = `SELECT * FROM pg_catalog.bool($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoolByJsonb calls the stored function 'pg_catalog.bool(jsonb) boolean' on db.
func BoolByJsonb(ctx context.Context, db DB, p0 []byte) (bool, error) {
	// call pg_catalog.bool
	const sqlstr = `SELECT * FROM pg_catalog.bool($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoolAccum calls the stored function 'pg_catalog.bool_accum(internal, boolean) internal' on db.
func BoolAccum(ctx context.Context, db DB, p0 pgtypes.Internal, p1 bool) (pgtypes.Internal, error) {
	// call pg_catalog.bool_accum
	const sqlstr = `SELECT * FROM pg_catalog.bool_accum($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// BoolAccumInv calls the stored function 'pg_catalog.bool_accum_inv(internal, boolean) internal' on db.
func BoolAccumInv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 bool) (pgtypes.Internal, error) {
	// call pg_catalog.bool_accum_inv
	const sqlstr = `SELECT * FROM pg_catalog.bool_accum_inv($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// BoolAlltrue calls the stored function 'pg_catalog.bool_alltrue(internal) boolean' on db.
func BoolAlltrue(ctx context.Context, db DB, p0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.bool_alltrue
	const sqlstr = `SELECT * FROM pg_catalog.bool_alltrue($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoolAnytrue calls the stored function 'pg_catalog.bool_anytrue(internal) boolean' on db.
func BoolAnytrue(ctx context.Context, db DB, p0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.bool_anytrue
	const sqlstr = `SELECT * FROM pg_catalog.bool_anytrue($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoolandStatefunc calls the stored function 'pg_catalog.booland_statefunc(boolean, boolean) boolean' on db.
func BoolandStatefunc(ctx context.Context, db DB, p0, p1 bool) (bool, error) {
	// call pg_catalog.booland_statefunc
	const sqlstr = `SELECT * FROM pg_catalog.booland_statefunc($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Booleq calls the stored function 'pg_catalog.booleq(boolean, boolean) boolean' on db.
func Booleq(ctx context.Context, db DB, p0, p1 bool) (bool, error) {
	// call pg_catalog.booleq
	const sqlstr = `SELECT * FROM pg_catalog.booleq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Boolge calls the stored function 'pg_catalog.boolge(boolean, boolean) boolean' on db.
func Boolge(ctx context.Context, db DB, p0, p1 bool) (bool, error) {
	// call pg_catalog.boolge
	const sqlstr = `SELECT * FROM pg_catalog.boolge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Boolgt calls the stored function 'pg_catalog.boolgt(boolean, boolean) boolean' on db.
func Boolgt(ctx context.Context, db DB, p0, p1 bool) (bool, error) {
	// call pg_catalog.boolgt
	const sqlstr = `SELECT * FROM pg_catalog.boolgt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Boolle calls the stored function 'pg_catalog.boolle(boolean, boolean) boolean' on db.
func Boolle(ctx context.Context, db DB, p0, p1 bool) (bool, error) {
	// call pg_catalog.boolle
	const sqlstr = `SELECT * FROM pg_catalog.boolle($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Boollt calls the stored function 'pg_catalog.boollt(boolean, boolean) boolean' on db.
func Boollt(ctx context.Context, db DB, p0, p1 bool) (bool, error) {
	// call pg_catalog.boollt
	const sqlstr = `SELECT * FROM pg_catalog.boollt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Boolne calls the stored function 'pg_catalog.boolne(boolean, boolean) boolean' on db.
func Boolne(ctx context.Context, db DB, p0, p1 bool) (bool, error) {
	// call pg_catalog.boolne
	const sqlstr = `SELECT * FROM pg_catalog.boolne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoolorStatefunc calls the stored function 'pg_catalog.boolor_statefunc(boolean, boolean) boolean' on db.
func BoolorStatefunc(ctx context.Context, db DB, p0, p1 bool) (bool, error) {
	// call pg_catalog.boolor_statefunc
	const sqlstr = `SELECT * FROM pg_catalog.boolor_statefunc($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Boolrecv calls the stored function 'pg_catalog.boolrecv(internal) boolean' on db.
func Boolrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.boolrecv
	const sqlstr = `SELECT * FROM pg_catalog.boolrecv($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Boolsend calls the stored function 'pg_catalog.boolsend(boolean) bytea' on db.
func Boolsend(ctx context.Context, db DB, p0 bool) ([]byte, error) {
	// call pg_catalog.boolsend
	const sqlstr = `SELECT * FROM pg_catalog.boolsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// BoundBox calls the stored function 'pg_catalog.bound_box(box, box) box' on db.
func BoundBox(ctx context.Context, db DB, p0, p1 pgtypes.Box) (pgtypes.Box, error) {
	// call pg_catalog.bound_box
	const sqlstr = `SELECT * FROM pg_catalog.bound_box($1, $2)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// BoxByPointAndPoint calls the stored function 'pg_catalog.box(point, point) box' on db.
func BoxByPointAndPoint(ctx context.Context, db DB, p0, p1 pgtypes.Point) (pgtypes.Box, error) {
	// call pg_catalog.box
	const sqlstr = `SELECT * FROM pg_catalog.box($1, $2)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// BoxByPolygon calls the stored function 'pg_catalog.box(polygon) box' on db.
func BoxByPolygon(ctx context.Context, db DB, p0 pgtypes.Polygon) (pgtypes.Box, error) {
	// call pg_catalog.box
	const sqlstr = `SELECT * FROM pg_catalog.box($1)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// BoxByCircle calls the stored function 'pg_catalog.box(circle) box' on db.
func BoxByCircle(ctx context.Context, db DB, p0 pgtypes.Circle) (pgtypes.Box, error) {
	// call pg_catalog.box
	const sqlstr = `SELECT * FROM pg_catalog.box($1)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// BoxByPoint calls the stored function 'pg_catalog.box(point) box' on db.
func BoxByPoint(ctx context.Context, db DB, p0 pgtypes.Point) (pgtypes.Box, error) {
	// call pg_catalog.box
	const sqlstr = `SELECT * FROM pg_catalog.box($1)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// BoxAbove calls the stored function 'pg_catalog.box_above(box, box) boolean' on db.
func BoxAbove(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_above
	const sqlstr = `SELECT * FROM pg_catalog.box_above($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxAboveEq calls the stored function 'pg_catalog.box_above_eq(box, box) boolean' on db.
func BoxAboveEq(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_above_eq
	const sqlstr = `SELECT * FROM pg_catalog.box_above_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxAdd calls the stored function 'pg_catalog.box_add(box, point) box' on db.
func BoxAdd(ctx context.Context, db DB, p0 pgtypes.Box, p1 pgtypes.Point) (pgtypes.Box, error) {
	// call pg_catalog.box_add
	const sqlstr = `SELECT * FROM pg_catalog.box_add($1, $2)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// BoxBelow calls the stored function 'pg_catalog.box_below(box, box) boolean' on db.
func BoxBelow(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_below
	const sqlstr = `SELECT * FROM pg_catalog.box_below($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxBelowEq calls the stored function 'pg_catalog.box_below_eq(box, box) boolean' on db.
func BoxBelowEq(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_below_eq
	const sqlstr = `SELECT * FROM pg_catalog.box_below_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxCenter calls the stored function 'pg_catalog.box_center(box) point' on db.
func BoxCenter(ctx context.Context, db DB, p0 pgtypes.Box) (pgtypes.Point, error) {
	// call pg_catalog.box_center
	const sqlstr = `SELECT * FROM pg_catalog.box_center($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// BoxContain calls the stored function 'pg_catalog.box_contain(box, box) boolean' on db.
func BoxContain(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_contain
	const sqlstr = `SELECT * FROM pg_catalog.box_contain($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxContainPt calls the stored function 'pg_catalog.box_contain_pt(box, point) boolean' on db.
func BoxContainPt(ctx context.Context, db DB, p0 pgtypes.Box, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.box_contain_pt
	const sqlstr = `SELECT * FROM pg_catalog.box_contain_pt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxContained calls the stored function 'pg_catalog.box_contained(box, box) boolean' on db.
func BoxContained(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_contained
	const sqlstr = `SELECT * FROM pg_catalog.box_contained($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxDistance calls the stored function 'pg_catalog.box_distance(box, box) double precision' on db.
func BoxDistance(ctx context.Context, db DB, p0, p1 pgtypes.Box) (float64, error) {
	// call pg_catalog.box_distance
	const sqlstr = `SELECT * FROM pg_catalog.box_distance($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// BoxDiv calls the stored function 'pg_catalog.box_div(box, point) box' on db.
func BoxDiv(ctx context.Context, db DB, p0 pgtypes.Box, p1 pgtypes.Point) (pgtypes.Box, error) {
	// call pg_catalog.box_div
	const sqlstr = `SELECT * FROM pg_catalog.box_div($1, $2)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// BoxEq calls the stored function 'pg_catalog.box_eq(box, box) boolean' on db.
func BoxEq(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_eq
	const sqlstr = `SELECT * FROM pg_catalog.box_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxGe calls the stored function 'pg_catalog.box_ge(box, box) boolean' on db.
func BoxGe(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_ge
	const sqlstr = `SELECT * FROM pg_catalog.box_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxGt calls the stored function 'pg_catalog.box_gt(box, box) boolean' on db.
func BoxGt(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_gt
	const sqlstr = `SELECT * FROM pg_catalog.box_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxIntersect calls the stored function 'pg_catalog.box_intersect(box, box) box' on db.
func BoxIntersect(ctx context.Context, db DB, p0, p1 pgtypes.Box) (pgtypes.Box, error) {
	// call pg_catalog.box_intersect
	const sqlstr = `SELECT * FROM pg_catalog.box_intersect($1, $2)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// BoxLe calls the stored function 'pg_catalog.box_le(box, box) boolean' on db.
func BoxLe(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_le
	const sqlstr = `SELECT * FROM pg_catalog.box_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxLeft calls the stored function 'pg_catalog.box_left(box, box) boolean' on db.
func BoxLeft(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_left
	const sqlstr = `SELECT * FROM pg_catalog.box_left($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxLt calls the stored function 'pg_catalog.box_lt(box, box) boolean' on db.
func BoxLt(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_lt
	const sqlstr = `SELECT * FROM pg_catalog.box_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxMul calls the stored function 'pg_catalog.box_mul(box, point) box' on db.
func BoxMul(ctx context.Context, db DB, p0 pgtypes.Box, p1 pgtypes.Point) (pgtypes.Box, error) {
	// call pg_catalog.box_mul
	const sqlstr = `SELECT * FROM pg_catalog.box_mul($1, $2)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// BoxOverabove calls the stored function 'pg_catalog.box_overabove(box, box) boolean' on db.
func BoxOverabove(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_overabove
	const sqlstr = `SELECT * FROM pg_catalog.box_overabove($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxOverbelow calls the stored function 'pg_catalog.box_overbelow(box, box) boolean' on db.
func BoxOverbelow(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_overbelow
	const sqlstr = `SELECT * FROM pg_catalog.box_overbelow($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxOverlap calls the stored function 'pg_catalog.box_overlap(box, box) boolean' on db.
func BoxOverlap(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_overlap
	const sqlstr = `SELECT * FROM pg_catalog.box_overlap($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxOverleft calls the stored function 'pg_catalog.box_overleft(box, box) boolean' on db.
func BoxOverleft(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_overleft
	const sqlstr = `SELECT * FROM pg_catalog.box_overleft($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxOverright calls the stored function 'pg_catalog.box_overright(box, box) boolean' on db.
func BoxOverright(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_overright
	const sqlstr = `SELECT * FROM pg_catalog.box_overright($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxRecv calls the stored function 'pg_catalog.box_recv(internal) box' on db.
func BoxRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Box, error) {
	// call pg_catalog.box_recv
	const sqlstr = `SELECT * FROM pg_catalog.box_recv($1)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// BoxRight calls the stored function 'pg_catalog.box_right(box, box) boolean' on db.
func BoxRight(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_right
	const sqlstr = `SELECT * FROM pg_catalog.box_right($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxSame calls the stored function 'pg_catalog.box_same(box, box) boolean' on db.
func BoxSame(ctx context.Context, db DB, p0, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.box_same
	const sqlstr = `SELECT * FROM pg_catalog.box_same($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BoxSend calls the stored function 'pg_catalog.box_send(box) bytea' on db.
func BoxSend(ctx context.Context, db DB, p0 pgtypes.Box) ([]byte, error) {
	// call pg_catalog.box_send
	const sqlstr = `SELECT * FROM pg_catalog.box_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// BoxSub calls the stored function 'pg_catalog.box_sub(box, point) box' on db.
func BoxSub(ctx context.Context, db DB, p0 pgtypes.Box, p1 pgtypes.Point) (pgtypes.Box, error) {
	// call pg_catalog.box_sub
	const sqlstr = `SELECT * FROM pg_catalog.box_sub($1, $2)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// BpcharByName calls the stored function 'pg_catalog.bpchar(name) character' on db.
func BpcharByName(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.bpchar
	const sqlstr = `SELECT * FROM pg_catalog.bpchar($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// BpcharByCharacterIntegerAndBoolean calls the stored function 'pg_catalog.bpchar(character, integer, boolean) character' on db.
func BpcharByCharacterIntegerAndBoolean(ctx context.Context, db DB, p0 string, p1 int, p2 bool) (string, error) {
	// call pg_catalog.bpchar
	const sqlstr = `SELECT * FROM pg_catalog.bpchar($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// BpcharByChar calls the stored function 'pg_catalog.bpchar("char") character' on db.
func BpcharByChar(ctx context.Context, db DB, p0 pgtypes.Char) (string, error) {
	// call pg_catalog.bpchar
	const sqlstr = `SELECT * FROM pg_catalog.bpchar($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// BpcharLarger calls the stored function 'pg_catalog.bpchar_larger(character, character) character' on db.
func BpcharLarger(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.bpchar_larger
	const sqlstr = `SELECT * FROM pg_catalog.bpchar_larger($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// BpcharPatternGe calls the stored function 'pg_catalog.bpchar_pattern_ge(character, character) boolean' on db.
func BpcharPatternGe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpchar_pattern_ge
	const sqlstr = `SELECT * FROM pg_catalog.bpchar_pattern_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BpcharPatternGt calls the stored function 'pg_catalog.bpchar_pattern_gt(character, character) boolean' on db.
func BpcharPatternGt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpchar_pattern_gt
	const sqlstr = `SELECT * FROM pg_catalog.bpchar_pattern_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BpcharPatternLe calls the stored function 'pg_catalog.bpchar_pattern_le(character, character) boolean' on db.
func BpcharPatternLe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpchar_pattern_le
	const sqlstr = `SELECT * FROM pg_catalog.bpchar_pattern_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BpcharPatternLt calls the stored function 'pg_catalog.bpchar_pattern_lt(character, character) boolean' on db.
func BpcharPatternLt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpchar_pattern_lt
	const sqlstr = `SELECT * FROM pg_catalog.bpchar_pattern_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BpcharSmaller calls the stored function 'pg_catalog.bpchar_smaller(character, character) character' on db.
func BpcharSmaller(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.bpchar_smaller
	const sqlstr = `SELECT * FROM pg_catalog.bpchar_smaller($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// BpcharSortsupport calls the stored function 'pg_catalog.bpchar_sortsupport(internal)' on db.
func BpcharSortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.bpchar_sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.bpchar_sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Bpcharcmp calls the stored function 'pg_catalog.bpcharcmp(character, character) integer' on db.
func Bpcharcmp(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.bpcharcmp
	const sqlstr = `SELECT * FROM pg_catalog.bpcharcmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Bpchareq calls the stored function 'pg_catalog.bpchareq(character, character) boolean' on db.
func Bpchareq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpchareq
	const sqlstr = `SELECT * FROM pg_catalog.bpchareq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharge calls the stored function 'pg_catalog.bpcharge(character, character) boolean' on db.
func Bpcharge(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpcharge
	const sqlstr = `SELECT * FROM pg_catalog.bpcharge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpchargt calls the stored function 'pg_catalog.bpchargt(character, character) boolean' on db.
func Bpchargt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpchargt
	const sqlstr = `SELECT * FROM pg_catalog.bpchargt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpchariclike calls the stored function 'pg_catalog.bpchariclike(character, text) boolean' on db.
func Bpchariclike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpchariclike
	const sqlstr = `SELECT * FROM pg_catalog.bpchariclike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharicnlike calls the stored function 'pg_catalog.bpcharicnlike(character, text) boolean' on db.
func Bpcharicnlike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpcharicnlike
	const sqlstr = `SELECT * FROM pg_catalog.bpcharicnlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharicregexeq calls the stored function 'pg_catalog.bpcharicregexeq(character, text) boolean' on db.
func Bpcharicregexeq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpcharicregexeq
	const sqlstr = `SELECT * FROM pg_catalog.bpcharicregexeq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharicregexne calls the stored function 'pg_catalog.bpcharicregexne(character, text) boolean' on db.
func Bpcharicregexne(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpcharicregexne
	const sqlstr = `SELECT * FROM pg_catalog.bpcharicregexne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharle calls the stored function 'pg_catalog.bpcharle(character, character) boolean' on db.
func Bpcharle(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpcharle
	const sqlstr = `SELECT * FROM pg_catalog.bpcharle($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharlike calls the stored function 'pg_catalog.bpcharlike(character, text) boolean' on db.
func Bpcharlike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpcharlike
	const sqlstr = `SELECT * FROM pg_catalog.bpcharlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharlt calls the stored function 'pg_catalog.bpcharlt(character, character) boolean' on db.
func Bpcharlt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpcharlt
	const sqlstr = `SELECT * FROM pg_catalog.bpcharlt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharne calls the stored function 'pg_catalog.bpcharne(character, character) boolean' on db.
func Bpcharne(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpcharne
	const sqlstr = `SELECT * FROM pg_catalog.bpcharne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharnlike calls the stored function 'pg_catalog.bpcharnlike(character, text) boolean' on db.
func Bpcharnlike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpcharnlike
	const sqlstr = `SELECT * FROM pg_catalog.bpcharnlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharrecv calls the stored function 'pg_catalog.bpcharrecv(internal, oid, integer) character' on db.
func Bpcharrecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (string, error) {
	// call pg_catalog.bpcharrecv
	const sqlstr = `SELECT * FROM pg_catalog.bpcharrecv($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Bpcharregexeq calls the stored function 'pg_catalog.bpcharregexeq(character, text) boolean' on db.
func Bpcharregexeq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpcharregexeq
	const sqlstr = `SELECT * FROM pg_catalog.bpcharregexeq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharregexne calls the stored function 'pg_catalog.bpcharregexne(character, text) boolean' on db.
func Bpcharregexne(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.bpcharregexne
	const sqlstr = `SELECT * FROM pg_catalog.bpcharregexne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bpcharsend calls the stored function 'pg_catalog.bpcharsend(character) bytea' on db.
func Bpcharsend(ctx context.Context, db DB, p0 string) ([]byte, error) {
	// call pg_catalog.bpcharsend
	const sqlstr = `SELECT * FROM pg_catalog.bpcharsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Bpchartypmodin calls the stored function 'pg_catalog.bpchartypmodin(cstring) integer' on db.
func Bpchartypmodin(ctx context.Context, db DB, p0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.bpchartypmodin
	const sqlstr = `SELECT * FROM pg_catalog.bpchartypmodin($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BrinDesummarizeRange calls the stored function 'pg_catalog.brin_desummarize_range(regclass, bigint)' on db.
func BrinDesummarizeRange(ctx context.Context, db DB, p0 pgtypes.Regclass, p1 int64) error {
	// call pg_catalog.brin_desummarize_range
	const sqlstr = `SELECT * FROM pg_catalog.brin_desummarize_range($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// BrinInclusionAddValue calls the stored function 'pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal) boolean' on db.
func BrinInclusionAddValue(ctx context.Context, db DB, p0, p1, p2, p3 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_inclusion_add_value
	const sqlstr = `SELECT * FROM pg_catalog.brin_inclusion_add_value($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BrinInclusionConsistent calls the stored function 'pg_catalog.brin_inclusion_consistent(internal, internal, internal) boolean' on db.
func BrinInclusionConsistent(ctx context.Context, db DB, p0, p1, p2 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_inclusion_consistent
	const sqlstr = `SELECT * FROM pg_catalog.brin_inclusion_consistent($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BrinInclusionOpcinfo calls the stored function 'pg_catalog.brin_inclusion_opcinfo(internal) internal' on db.
func BrinInclusionOpcinfo(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.brin_inclusion_opcinfo
	const sqlstr = `SELECT * FROM pg_catalog.brin_inclusion_opcinfo($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// BrinInclusionUnion calls the stored function 'pg_catalog.brin_inclusion_union(internal, internal, internal) boolean' on db.
func BrinInclusionUnion(ctx context.Context, db DB, p0, p1, p2 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_inclusion_union
	const sqlstr = `SELECT * FROM pg_catalog.brin_inclusion_union($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BrinMinmaxAddValue calls the stored function 'pg_catalog.brin_minmax_add_value(internal, internal, internal, internal) boolean' on db.
func BrinMinmaxAddValue(ctx context.Context, db DB, p0, p1, p2, p3 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_minmax_add_value
	const sqlstr = `SELECT * FROM pg_catalog.brin_minmax_add_value($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BrinMinmaxConsistent calls the stored function 'pg_catalog.brin_minmax_consistent(internal, internal, internal) boolean' on db.
func BrinMinmaxConsistent(ctx context.Context, db DB, p0, p1, p2 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_minmax_consistent
	const sqlstr = `SELECT * FROM pg_catalog.brin_minmax_consistent($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BrinMinmaxOpcinfo calls the stored function 'pg_catalog.brin_minmax_opcinfo(internal) internal' on db.
func BrinMinmaxOpcinfo(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.brin_minmax_opcinfo
	const sqlstr = `SELECT * FROM pg_catalog.brin_minmax_opcinfo($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// BrinMinmaxUnion calls the stored function 'pg_catalog.brin_minmax_union(internal, internal, internal) boolean' on db.
func BrinMinmaxUnion(ctx context.Context, db DB, p0, p1, p2 pgtypes.Internal) (bool, error) {
	// call pg_catalog.brin_minmax_union
	const sqlstr = `SELECT * FROM pg_catalog.brin_minmax_union($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// BrinSummarizeNewValues calls the stored function 'pg_catalog.brin_summarize_new_values(regclass) integer' on db.
func BrinSummarizeNewValues(ctx context.Context, db DB, p0 pgtypes.Regclass) (int, error) {
	// call pg_catalog.brin_summarize_new_values
	const sqlstr = `SELECT * FROM pg_catalog.brin_summarize_new_values($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BrinSummarizeRange calls the stored function 'pg_catalog.brin_summarize_range(regclass, bigint) integer' on db.
func BrinSummarizeRange(ctx context.Context, db DB, p0 pgtypes.Regclass, p1 int64) (int, error) {
	// call pg_catalog.brin_summarize_range
	const sqlstr = `SELECT * FROM pg_catalog.brin_summarize_range($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Brinhandler calls the stored function 'pg_catalog.brinhandler(internal) index_am_handler' on db.
func Brinhandler(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.brinhandler
	const sqlstr = `SELECT * FROM pg_catalog.brinhandler($1)`
	// run
	var r0 pgtypes.IndexAmHandler
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return r0, nil
}

// Broadcast calls the stored function 'pg_catalog.broadcast(inet) inet' on db.
func Broadcast(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.broadcast
	const sqlstr = `SELECT * FROM pg_catalog.broadcast($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Btarraycmp calls the stored function 'pg_catalog.btarraycmp(anyarray, anyarray) integer' on db.
func Btarraycmp(ctx context.Context, db DB, p0, p1 pgtypes.Anyarray) (int, error) {
	// call pg_catalog.btarraycmp
	const sqlstr = `SELECT * FROM pg_catalog.btarraycmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btboolcmp calls the stored function 'pg_catalog.btboolcmp(boolean, boolean) integer' on db.
func Btboolcmp(ctx context.Context, db DB, p0, p1 bool) (int, error) {
	// call pg_catalog.btboolcmp
	const sqlstr = `SELECT * FROM pg_catalog.btboolcmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BtbpcharPatternCmp calls the stored function 'pg_catalog.btbpchar_pattern_cmp(character, character) integer' on db.
func BtbpcharPatternCmp(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.btbpchar_pattern_cmp
	const sqlstr = `SELECT * FROM pg_catalog.btbpchar_pattern_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BtbpcharPatternSortsupport calls the stored function 'pg_catalog.btbpchar_pattern_sortsupport(internal)' on db.
func BtbpcharPatternSortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.btbpchar_pattern_sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.btbpchar_pattern_sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Btcharcmp calls the stored function 'pg_catalog.btcharcmp("char", "char") integer' on db.
func Btcharcmp(ctx context.Context, db DB, p0, p1 pgtypes.Char) (int, error) {
	// call pg_catalog.btcharcmp
	const sqlstr = `SELECT * FROM pg_catalog.btcharcmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btequalimage calls the stored function 'pg_catalog.btequalimage(oid) boolean' on db.
func Btequalimage(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.btequalimage
	const sqlstr = `SELECT * FROM pg_catalog.btequalimage($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Btfloat48cmp calls the stored function 'pg_catalog.btfloat48cmp(real, double precision) integer' on db.
func Btfloat48cmp(ctx context.Context, db DB, p0 float32, p1 float64) (int, error) {
	// call pg_catalog.btfloat48cmp
	const sqlstr = `SELECT * FROM pg_catalog.btfloat48cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btfloat4cmp calls the stored function 'pg_catalog.btfloat4cmp(real, real) integer' on db.
func Btfloat4cmp(ctx context.Context, db DB, p0, p1 float32) (int, error) {
	// call pg_catalog.btfloat4cmp
	const sqlstr = `SELECT * FROM pg_catalog.btfloat4cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btfloat4sortsupport calls the stored function 'pg_catalog.btfloat4sortsupport(internal)' on db.
func Btfloat4sortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.btfloat4sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.btfloat4sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Btfloat84cmp calls the stored function 'pg_catalog.btfloat84cmp(double precision, real) integer' on db.
func Btfloat84cmp(ctx context.Context, db DB, p0 float64, p1 float32) (int, error) {
	// call pg_catalog.btfloat84cmp
	const sqlstr = `SELECT * FROM pg_catalog.btfloat84cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btfloat8cmp calls the stored function 'pg_catalog.btfloat8cmp(double precision, double precision) integer' on db.
func Btfloat8cmp(ctx context.Context, db DB, p0, p1 float64) (int, error) {
	// call pg_catalog.btfloat8cmp
	const sqlstr = `SELECT * FROM pg_catalog.btfloat8cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btfloat8sortsupport calls the stored function 'pg_catalog.btfloat8sortsupport(internal)' on db.
func Btfloat8sortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.btfloat8sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.btfloat8sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Bthandler calls the stored function 'pg_catalog.bthandler(internal) index_am_handler' on db.
func Bthandler(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.bthandler
	const sqlstr = `SELECT * FROM pg_catalog.bthandler($1)`
	// run
	var r0 pgtypes.IndexAmHandler
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return r0, nil
}

// Btint24cmp calls the stored function 'pg_catalog.btint24cmp(smallint, integer) integer' on db.
func Btint24cmp(ctx context.Context, db DB, p0 int16, p1 int) (int, error) {
	// call pg_catalog.btint24cmp
	const sqlstr = `SELECT * FROM pg_catalog.btint24cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btint28cmp calls the stored function 'pg_catalog.btint28cmp(smallint, bigint) integer' on db.
func Btint28cmp(ctx context.Context, db DB, p0 int16, p1 int64) (int, error) {
	// call pg_catalog.btint28cmp
	const sqlstr = `SELECT * FROM pg_catalog.btint28cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btint2cmp calls the stored function 'pg_catalog.btint2cmp(smallint, smallint) integer' on db.
func Btint2cmp(ctx context.Context, db DB, p0, p1 int16) (int, error) {
	// call pg_catalog.btint2cmp
	const sqlstr = `SELECT * FROM pg_catalog.btint2cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btint2sortsupport calls the stored function 'pg_catalog.btint2sortsupport(internal)' on db.
func Btint2sortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.btint2sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.btint2sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Btint42cmp calls the stored function 'pg_catalog.btint42cmp(integer, smallint) integer' on db.
func Btint42cmp(ctx context.Context, db DB, p0 int, p1 int16) (int, error) {
	// call pg_catalog.btint42cmp
	const sqlstr = `SELECT * FROM pg_catalog.btint42cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btint48cmp calls the stored function 'pg_catalog.btint48cmp(integer, bigint) integer' on db.
func Btint48cmp(ctx context.Context, db DB, p0 int, p1 int64) (int, error) {
	// call pg_catalog.btint48cmp
	const sqlstr = `SELECT * FROM pg_catalog.btint48cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btint4cmp calls the stored function 'pg_catalog.btint4cmp(integer, integer) integer' on db.
func Btint4cmp(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.btint4cmp
	const sqlstr = `SELECT * FROM pg_catalog.btint4cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btint4sortsupport calls the stored function 'pg_catalog.btint4sortsupport(internal)' on db.
func Btint4sortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.btint4sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.btint4sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Btint82cmp calls the stored function 'pg_catalog.btint82cmp(bigint, smallint) integer' on db.
func Btint82cmp(ctx context.Context, db DB, p0 int64, p1 int16) (int, error) {
	// call pg_catalog.btint82cmp
	const sqlstr = `SELECT * FROM pg_catalog.btint82cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btint84cmp calls the stored function 'pg_catalog.btint84cmp(bigint, integer) integer' on db.
func Btint84cmp(ctx context.Context, db DB, p0 int64, p1 int) (int, error) {
	// call pg_catalog.btint84cmp
	const sqlstr = `SELECT * FROM pg_catalog.btint84cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btint8cmp calls the stored function 'pg_catalog.btint8cmp(bigint, bigint) integer' on db.
func Btint8cmp(ctx context.Context, db DB, p0, p1 int64) (int, error) {
	// call pg_catalog.btint8cmp
	const sqlstr = `SELECT * FROM pg_catalog.btint8cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btint8sortsupport calls the stored function 'pg_catalog.btint8sortsupport(internal)' on db.
func Btint8sortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.btint8sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.btint8sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Btnamecmp calls the stored function 'pg_catalog.btnamecmp(name, name) integer' on db.
func Btnamecmp(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.btnamecmp
	const sqlstr = `SELECT * FROM pg_catalog.btnamecmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btnamesortsupport calls the stored function 'pg_catalog.btnamesortsupport(internal)' on db.
func Btnamesortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.btnamesortsupport
	const sqlstr = `SELECT * FROM pg_catalog.btnamesortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Btnametextcmp calls the stored function 'pg_catalog.btnametextcmp(name, text) integer' on db.
func Btnametextcmp(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.btnametextcmp
	const sqlstr = `SELECT * FROM pg_catalog.btnametextcmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btoidcmp calls the stored function 'pg_catalog.btoidcmp(oid, oid) integer' on db.
func Btoidcmp(ctx context.Context, db DB, p0, p1 pgtypes.Oid) (int, error) {
	// call pg_catalog.btoidcmp
	const sqlstr = `SELECT * FROM pg_catalog.btoidcmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btoidsortsupport calls the stored function 'pg_catalog.btoidsortsupport(internal)' on db.
func Btoidsortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.btoidsortsupport
	const sqlstr = `SELECT * FROM pg_catalog.btoidsortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Btoidvectorcmp calls the stored function 'pg_catalog.btoidvectorcmp(oidvector, oidvector) integer' on db.
func Btoidvectorcmp(ctx context.Context, db DB, p0, p1 pgtypes.Oidvector) (int, error) {
	// call pg_catalog.btoidvectorcmp
	const sqlstr = `SELECT * FROM pg_catalog.btoidvectorcmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btrecordcmp calls the stored function 'pg_catalog.btrecordcmp(record, record) integer' on db.
func Btrecordcmp(ctx context.Context, db DB, p0, p1 pgtypes.Record) (int, error) {
	// call pg_catalog.btrecordcmp
	const sqlstr = `SELECT * FROM pg_catalog.btrecordcmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btrecordimagecmp calls the stored function 'pg_catalog.btrecordimagecmp(record, record) integer' on db.
func Btrecordimagecmp(ctx context.Context, db DB, p0, p1 pgtypes.Record) (int, error) {
	// call pg_catalog.btrecordimagecmp
	const sqlstr = `SELECT * FROM pg_catalog.btrecordimagecmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BtrimByByteaAndBytea calls the stored function 'pg_catalog.btrim(bytea, bytea) bytea' on db.
func BtrimByByteaAndBytea(ctx context.Context, db DB, p0, p1 []byte) ([]byte, error) {
	// call pg_catalog.btrim
	const sqlstr = `SELECT * FROM pg_catalog.btrim($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// BtrimByTextAndText calls the stored function 'pg_catalog.btrim(text, text) text' on db.
func BtrimByTextAndText(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.btrim
	const sqlstr = `SELECT * FROM pg_catalog.btrim($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// BtrimByText calls the stored function 'pg_catalog.btrim(text) text' on db.
func BtrimByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.btrim
	const sqlstr = `SELECT * FROM pg_catalog.btrim($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// BttextPatternCmp calls the stored function 'pg_catalog.bttext_pattern_cmp(text, text) integer' on db.
func BttextPatternCmp(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.bttext_pattern_cmp
	const sqlstr = `SELECT * FROM pg_catalog.bttext_pattern_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// BttextPatternSortsupport calls the stored function 'pg_catalog.bttext_pattern_sortsupport(internal)' on db.
func BttextPatternSortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.bttext_pattern_sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.bttext_pattern_sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Bttextcmp calls the stored function 'pg_catalog.bttextcmp(text, text) integer' on db.
func Bttextcmp(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.bttextcmp
	const sqlstr = `SELECT * FROM pg_catalog.bttextcmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Bttextnamecmp calls the stored function 'pg_catalog.bttextnamecmp(text, name) integer' on db.
func Bttextnamecmp(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.bttextnamecmp
	const sqlstr = `SELECT * FROM pg_catalog.bttextnamecmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Bttextsortsupport calls the stored function 'pg_catalog.bttextsortsupport(internal)' on db.
func Bttextsortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.bttextsortsupport
	const sqlstr = `SELECT * FROM pg_catalog.bttextsortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Bttidcmp calls the stored function 'pg_catalog.bttidcmp(tid, tid) integer' on db.
func Bttidcmp(ctx context.Context, db DB, p0, p1 pgtypes.Tid) (int, error) {
	// call pg_catalog.bttidcmp
	const sqlstr = `SELECT * FROM pg_catalog.bttidcmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Btvarstrequalimage calls the stored function 'pg_catalog.btvarstrequalimage(oid) boolean' on db.
func Btvarstrequalimage(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.btvarstrequalimage
	const sqlstr = `SELECT * FROM pg_catalog.btvarstrequalimage($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// ByteaSortsupport calls the stored function 'pg_catalog.bytea_sortsupport(internal)' on db.
func ByteaSortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.bytea_sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.bytea_sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// ByteaStringAggFinalfn calls the stored function 'pg_catalog.bytea_string_agg_finalfn(internal) bytea' on db.
func ByteaStringAggFinalfn(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.bytea_string_agg_finalfn
	const sqlstr = `SELECT * FROM pg_catalog.bytea_string_agg_finalfn($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// ByteaStringAggTransfn calls the stored function 'pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea) internal' on db.
func ByteaStringAggTransfn(ctx context.Context, db DB, p0 pgtypes.Internal, p1, p2 []byte) (pgtypes.Internal, error) {
	// call pg_catalog.bytea_string_agg_transfn
	const sqlstr = `SELECT * FROM pg_catalog.bytea_string_agg_transfn($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Byteacat calls the stored function 'pg_catalog.byteacat(bytea, bytea) bytea' on db.
func Byteacat(ctx context.Context, db DB, p0, p1 []byte) ([]byte, error) {
	// call pg_catalog.byteacat
	const sqlstr = `SELECT * FROM pg_catalog.byteacat($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Byteacmp calls the stored function 'pg_catalog.byteacmp(bytea, bytea) integer' on db.
func Byteacmp(ctx context.Context, db DB, p0, p1 []byte) (int, error) {
	// call pg_catalog.byteacmp
	const sqlstr = `SELECT * FROM pg_catalog.byteacmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Byteaeq calls the stored function 'pg_catalog.byteaeq(bytea, bytea) boolean' on db.
func Byteaeq(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.byteaeq
	const sqlstr = `SELECT * FROM pg_catalog.byteaeq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Byteage calls the stored function 'pg_catalog.byteage(bytea, bytea) boolean' on db.
func Byteage(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.byteage
	const sqlstr = `SELECT * FROM pg_catalog.byteage($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Byteagt calls the stored function 'pg_catalog.byteagt(bytea, bytea) boolean' on db.
func Byteagt(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.byteagt
	const sqlstr = `SELECT * FROM pg_catalog.byteagt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Byteale calls the stored function 'pg_catalog.byteale(bytea, bytea) boolean' on db.
func Byteale(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.byteale
	const sqlstr = `SELECT * FROM pg_catalog.byteale($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bytealike calls the stored function 'pg_catalog.bytealike(bytea, bytea) boolean' on db.
func Bytealike(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.bytealike
	const sqlstr = `SELECT * FROM pg_catalog.bytealike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bytealt calls the stored function 'pg_catalog.bytealt(bytea, bytea) boolean' on db.
func Bytealt(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.bytealt
	const sqlstr = `SELECT * FROM pg_catalog.bytealt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Byteane calls the stored function 'pg_catalog.byteane(bytea, bytea) boolean' on db.
func Byteane(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.byteane
	const sqlstr = `SELECT * FROM pg_catalog.byteane($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Byteanlike calls the stored function 'pg_catalog.byteanlike(bytea, bytea) boolean' on db.
func Byteanlike(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.byteanlike
	const sqlstr = `SELECT * FROM pg_catalog.byteanlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Bytearecv calls the stored function 'pg_catalog.bytearecv(internal) bytea' on db.
func Bytearecv(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.bytearecv
	const sqlstr = `SELECT * FROM pg_catalog.bytearecv($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Byteasend calls the stored function 'pg_catalog.byteasend(bytea) bytea' on db.
func Byteasend(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.byteasend
	const sqlstr = `SELECT * FROM pg_catalog.byteasend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Cardinality calls the stored function 'pg_catalog.cardinality(anyarray) integer' on db.
func Cardinality(ctx context.Context, db DB, p0 pgtypes.Anyarray) (int, error) {
	// call pg_catalog.cardinality
	const sqlstr = `SELECT * FROM pg_catalog.cardinality($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// CashCmp calls the stored function 'pg_catalog.cash_cmp(money, money) integer' on db.
func CashCmp(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.cash_cmp
	const sqlstr = `SELECT * FROM pg_catalog.cash_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// CashDivCash calls the stored function 'pg_catalog.cash_div_cash(money, money) double precision' on db.
func CashDivCash(ctx context.Context, db DB, p0, p1 string) (float64, error) {
	// call pg_catalog.cash_div_cash
	const sqlstr = `SELECT * FROM pg_catalog.cash_div_cash($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// CashDivFlt4 calls the stored function 'pg_catalog.cash_div_flt4(money, real) money' on db.
func CashDivFlt4(ctx context.Context, db DB, p0 string, p1 float32) (string, error) {
	// call pg_catalog.cash_div_flt4
	const sqlstr = `SELECT * FROM pg_catalog.cash_div_flt4($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashDivFlt8 calls the stored function 'pg_catalog.cash_div_flt8(money, double precision) money' on db.
func CashDivFlt8(ctx context.Context, db DB, p0 string, p1 float64) (string, error) {
	// call pg_catalog.cash_div_flt8
	const sqlstr = `SELECT * FROM pg_catalog.cash_div_flt8($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashDivInt2 calls the stored function 'pg_catalog.cash_div_int2(money, smallint) money' on db.
func CashDivInt2(ctx context.Context, db DB, p0 string, p1 int16) (string, error) {
	// call pg_catalog.cash_div_int2
	const sqlstr = `SELECT * FROM pg_catalog.cash_div_int2($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashDivInt4 calls the stored function 'pg_catalog.cash_div_int4(money, integer) money' on db.
func CashDivInt4(ctx context.Context, db DB, p0 string, p1 int) (string, error) {
	// call pg_catalog.cash_div_int4
	const sqlstr = `SELECT * FROM pg_catalog.cash_div_int4($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashDivInt8 calls the stored function 'pg_catalog.cash_div_int8(money, bigint) money' on db.
func CashDivInt8(ctx context.Context, db DB, p0 string, p1 int64) (string, error) {
	// call pg_catalog.cash_div_int8
	const sqlstr = `SELECT * FROM pg_catalog.cash_div_int8($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashEq calls the stored function 'pg_catalog.cash_eq(money, money) boolean' on db.
func CashEq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.cash_eq
	const sqlstr = `SELECT * FROM pg_catalog.cash_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CashGe calls the stored function 'pg_catalog.cash_ge(money, money) boolean' on db.
func CashGe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.cash_ge
	const sqlstr = `SELECT * FROM pg_catalog.cash_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CashGt calls the stored function 'pg_catalog.cash_gt(money, money) boolean' on db.
func CashGt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.cash_gt
	const sqlstr = `SELECT * FROM pg_catalog.cash_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CashLe calls the stored function 'pg_catalog.cash_le(money, money) boolean' on db.
func CashLe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.cash_le
	const sqlstr = `SELECT * FROM pg_catalog.cash_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CashLt calls the stored function 'pg_catalog.cash_lt(money, money) boolean' on db.
func CashLt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.cash_lt
	const sqlstr = `SELECT * FROM pg_catalog.cash_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CashMi calls the stored function 'pg_catalog.cash_mi(money, money) money' on db.
func CashMi(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.cash_mi
	const sqlstr = `SELECT * FROM pg_catalog.cash_mi($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashMulFlt4 calls the stored function 'pg_catalog.cash_mul_flt4(money, real) money' on db.
func CashMulFlt4(ctx context.Context, db DB, p0 string, p1 float32) (string, error) {
	// call pg_catalog.cash_mul_flt4
	const sqlstr = `SELECT * FROM pg_catalog.cash_mul_flt4($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashMulFlt8 calls the stored function 'pg_catalog.cash_mul_flt8(money, double precision) money' on db.
func CashMulFlt8(ctx context.Context, db DB, p0 string, p1 float64) (string, error) {
	// call pg_catalog.cash_mul_flt8
	const sqlstr = `SELECT * FROM pg_catalog.cash_mul_flt8($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashMulInt2 calls the stored function 'pg_catalog.cash_mul_int2(money, smallint) money' on db.
func CashMulInt2(ctx context.Context, db DB, p0 string, p1 int16) (string, error) {
	// call pg_catalog.cash_mul_int2
	const sqlstr = `SELECT * FROM pg_catalog.cash_mul_int2($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashMulInt4 calls the stored function 'pg_catalog.cash_mul_int4(money, integer) money' on db.
func CashMulInt4(ctx context.Context, db DB, p0 string, p1 int) (string, error) {
	// call pg_catalog.cash_mul_int4
	const sqlstr = `SELECT * FROM pg_catalog.cash_mul_int4($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashMulInt8 calls the stored function 'pg_catalog.cash_mul_int8(money, bigint) money' on db.
func CashMulInt8(ctx context.Context, db DB, p0 string, p1 int64) (string, error) {
	// call pg_catalog.cash_mul_int8
	const sqlstr = `SELECT * FROM pg_catalog.cash_mul_int8($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashNe calls the stored function 'pg_catalog.cash_ne(money, money) boolean' on db.
func CashNe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.cash_ne
	const sqlstr = `SELECT * FROM pg_catalog.cash_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CashPl calls the stored function 'pg_catalog.cash_pl(money, money) money' on db.
func CashPl(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.cash_pl
	const sqlstr = `SELECT * FROM pg_catalog.cash_pl($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashRecv calls the stored function 'pg_catalog.cash_recv(internal) money' on db.
func CashRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (string, error) {
	// call pg_catalog.cash_recv
	const sqlstr = `SELECT * FROM pg_catalog.cash_recv($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CashSend calls the stored function 'pg_catalog.cash_send(money) bytea' on db.
func CashSend(ctx context.Context, db DB, p0 string) ([]byte, error) {
	// call pg_catalog.cash_send
	const sqlstr = `SELECT * FROM pg_catalog.cash_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// CashWords calls the stored function 'pg_catalog.cash_words(money) text' on db.
func CashWords(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.cash_words
	const sqlstr = `SELECT * FROM pg_catalog.cash_words($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Cashlarger calls the stored function 'pg_catalog.cashlarger(money, money) money' on db.
func Cashlarger(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.cashlarger
	const sqlstr = `SELECT * FROM pg_catalog.cashlarger($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Cashsmaller calls the stored function 'pg_catalog.cashsmaller(money, money) money' on db.
func Cashsmaller(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.cashsmaller
	const sqlstr = `SELECT * FROM pg_catalog.cashsmaller($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Cbrt calls the stored function 'pg_catalog.cbrt(double precision) double precision' on db.
func Cbrt(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.cbrt
	const sqlstr = `SELECT * FROM pg_catalog.cbrt($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// CeilByNumeric calls the stored function 'pg_catalog.ceil(numeric) numeric' on db.
func CeilByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.ceil
	const sqlstr = `SELECT * FROM pg_catalog.ceil($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// CeilByDoublePrecision calls the stored function 'pg_catalog.ceil(double precision) double precision' on db.
func CeilByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.ceil
	const sqlstr = `SELECT * FROM pg_catalog.ceil($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// CeilingByNumeric calls the stored function 'pg_catalog.ceiling(numeric) numeric' on db.
func CeilingByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.ceiling
	const sqlstr = `SELECT * FROM pg_catalog.ceiling($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// CeilingByDoublePrecision calls the stored function 'pg_catalog.ceiling(double precision) double precision' on db.
func CeilingByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.ceiling
	const sqlstr = `SELECT * FROM pg_catalog.ceiling($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// CenterByBox calls the stored function 'pg_catalog.center(box) point' on db.
func CenterByBox(ctx context.Context, db DB, p0 pgtypes.Box) (pgtypes.Point, error) {
	// call pg_catalog.center
	const sqlstr = `SELECT * FROM pg_catalog.center($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// CenterByCircle calls the stored function 'pg_catalog.center(circle) point' on db.
func CenterByCircle(ctx context.Context, db DB, p0 pgtypes.Circle) (pgtypes.Point, error) {
	// call pg_catalog.center
	const sqlstr = `SELECT * FROM pg_catalog.center($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// CharByInteger calls the stored function 'pg_catalog.char(integer) "char"' on db.
func CharByInteger(ctx context.Context, db DB, p0 int) (pgtypes.Char, error) {
	// call pg_catalog.char
	const sqlstr = `SELECT * FROM pg_catalog.char($1)`
	// run
	var r0 pgtypes.Char
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return r0, nil
}

// CharByText calls the stored function 'pg_catalog.char(text) "char"' on db.
func CharByText(ctx context.Context, db DB, p0 string) (pgtypes.Char, error) {
	// call pg_catalog.char
	const sqlstr = `SELECT * FROM pg_catalog.char($1)`
	// run
	var r0 pgtypes.Char
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return r0, nil
}

// CharLengthByCharacter calls the stored function 'pg_catalog.char_length(character) integer' on db.
func CharLengthByCharacter(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.char_length
	const sqlstr = `SELECT * FROM pg_catalog.char_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// CharLengthByText calls the stored function 'pg_catalog.char_length(text) integer' on db.
func CharLengthByText(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.char_length
	const sqlstr = `SELECT * FROM pg_catalog.char_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// CharacterLengthByCharacter calls the stored function 'pg_catalog.character_length(character) integer' on db.
func CharacterLengthByCharacter(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.character_length
	const sqlstr = `SELECT * FROM pg_catalog.character_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// CharacterLengthByText calls the stored function 'pg_catalog.character_length(text) integer' on db.
func CharacterLengthByText(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.character_length
	const sqlstr = `SELECT * FROM pg_catalog.character_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Chareq calls the stored function 'pg_catalog.chareq("char", "char") boolean' on db.
func Chareq(ctx context.Context, db DB, p0, p1 pgtypes.Char) (bool, error) {
	// call pg_catalog.chareq
	const sqlstr = `SELECT * FROM pg_catalog.chareq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Charge calls the stored function 'pg_catalog.charge("char", "char") boolean' on db.
func Charge(ctx context.Context, db DB, p0, p1 pgtypes.Char) (bool, error) {
	// call pg_catalog.charge
	const sqlstr = `SELECT * FROM pg_catalog.charge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Chargt calls the stored function 'pg_catalog.chargt("char", "char") boolean' on db.
func Chargt(ctx context.Context, db DB, p0, p1 pgtypes.Char) (bool, error) {
	// call pg_catalog.chargt
	const sqlstr = `SELECT * FROM pg_catalog.chargt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Charle calls the stored function 'pg_catalog.charle("char", "char") boolean' on db.
func Charle(ctx context.Context, db DB, p0, p1 pgtypes.Char) (bool, error) {
	// call pg_catalog.charle
	const sqlstr = `SELECT * FROM pg_catalog.charle($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Charlt calls the stored function 'pg_catalog.charlt("char", "char") boolean' on db.
func Charlt(ctx context.Context, db DB, p0, p1 pgtypes.Char) (bool, error) {
	// call pg_catalog.charlt
	const sqlstr = `SELECT * FROM pg_catalog.charlt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Charne calls the stored function 'pg_catalog.charne("char", "char") boolean' on db.
func Charne(ctx context.Context, db DB, p0, p1 pgtypes.Char) (bool, error) {
	// call pg_catalog.charne
	const sqlstr = `SELECT * FROM pg_catalog.charne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Charrecv calls the stored function 'pg_catalog.charrecv(internal) "char"' on db.
func Charrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Char, error) {
	// call pg_catalog.charrecv
	const sqlstr = `SELECT * FROM pg_catalog.charrecv($1)`
	// run
	var r0 pgtypes.Char
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return r0, nil
}

// Charsend calls the stored function 'pg_catalog.charsend("char") bytea' on db.
func Charsend(ctx context.Context, db DB, p0 pgtypes.Char) ([]byte, error) {
	// call pg_catalog.charsend
	const sqlstr = `SELECT * FROM pg_catalog.charsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Chr calls the stored function 'pg_catalog.chr(integer) text' on db.
func Chr(ctx context.Context, db DB, p0 int) (string, error) {
	// call pg_catalog.chr
	const sqlstr = `SELECT * FROM pg_catalog.chr($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Cideq calls the stored function 'pg_catalog.cideq(cid, cid) boolean' on db.
func Cideq(ctx context.Context, db DB, p0, p1 pgtypes.Cid) (bool, error) {
	// call pg_catalog.cideq
	const sqlstr = `SELECT * FROM pg_catalog.cideq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Cidr calls the stored function 'pg_catalog.cidr(inet) cidr' on db.
func Cidr(ctx context.Context, db DB, p0 string) (pgtypes.Cidr, error) {
	// call pg_catalog.cidr
	const sqlstr = `SELECT * FROM pg_catalog.cidr($1)`
	// run
	var r0 pgtypes.Cidr
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Cidr{}, logerror(err)
	}
	return r0, nil
}

// CidrRecv calls the stored function 'pg_catalog.cidr_recv(internal) cidr' on db.
func CidrRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Cidr, error) {
	// call pg_catalog.cidr_recv
	const sqlstr = `SELECT * FROM pg_catalog.cidr_recv($1)`
	// run
	var r0 pgtypes.Cidr
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Cidr{}, logerror(err)
	}
	return r0, nil
}

// CidrSend calls the stored function 'pg_catalog.cidr_send(cidr) bytea' on db.
func CidrSend(ctx context.Context, db DB, p0 pgtypes.Cidr) ([]byte, error) {
	// call pg_catalog.cidr_send
	const sqlstr = `SELECT * FROM pg_catalog.cidr_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Cidrecv calls the stored function 'pg_catalog.cidrecv(internal) cid' on db.
func Cidrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Cid, error) {
	// call pg_catalog.cidrecv
	const sqlstr = `SELECT * FROM pg_catalog.cidrecv($1)`
	// run
	var r0 pgtypes.Cid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Cid{}, logerror(err)
	}
	return r0, nil
}

// Cidsend calls the stored function 'pg_catalog.cidsend(cid) bytea' on db.
func Cidsend(ctx context.Context, db DB, p0 pgtypes.Cid) ([]byte, error) {
	// call pg_catalog.cidsend
	const sqlstr = `SELECT * FROM pg_catalog.cidsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// CircleByPointAndDoublePrecision calls the stored function 'pg_catalog.circle(point, double precision) circle' on db.
func CircleByPointAndDoublePrecision(ctx context.Context, db DB, p0 pgtypes.Point, p1 float64) (pgtypes.Circle, error) {
	// call pg_catalog.circle
	const sqlstr = `SELECT * FROM pg_catalog.circle($1, $2)`
	// run
	var r0 pgtypes.Circle
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return r0, nil
}

// CircleByPolygon calls the stored function 'pg_catalog.circle(polygon) circle' on db.
func CircleByPolygon(ctx context.Context, db DB, p0 pgtypes.Polygon) (pgtypes.Circle, error) {
	// call pg_catalog.circle
	const sqlstr = `SELECT * FROM pg_catalog.circle($1)`
	// run
	var r0 pgtypes.Circle
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return r0, nil
}

// CircleByBox calls the stored function 'pg_catalog.circle(box) circle' on db.
func CircleByBox(ctx context.Context, db DB, p0 pgtypes.Box) (pgtypes.Circle, error) {
	// call pg_catalog.circle
	const sqlstr = `SELECT * FROM pg_catalog.circle($1)`
	// run
	var r0 pgtypes.Circle
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return r0, nil
}

// CircleAbove calls the stored function 'pg_catalog.circle_above(circle, circle) boolean' on db.
func CircleAbove(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_above
	const sqlstr = `SELECT * FROM pg_catalog.circle_above($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleAddPt calls the stored function 'pg_catalog.circle_add_pt(circle, point) circle' on db.
func CircleAddPt(ctx context.Context, db DB, p0 pgtypes.Circle, p1 pgtypes.Point) (pgtypes.Circle, error) {
	// call pg_catalog.circle_add_pt
	const sqlstr = `SELECT * FROM pg_catalog.circle_add_pt($1, $2)`
	// run
	var r0 pgtypes.Circle
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return r0, nil
}

// CircleBelow calls the stored function 'pg_catalog.circle_below(circle, circle) boolean' on db.
func CircleBelow(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_below
	const sqlstr = `SELECT * FROM pg_catalog.circle_below($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleCenter calls the stored function 'pg_catalog.circle_center(circle) point' on db.
func CircleCenter(ctx context.Context, db DB, p0 pgtypes.Circle) (pgtypes.Point, error) {
	// call pg_catalog.circle_center
	const sqlstr = `SELECT * FROM pg_catalog.circle_center($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// CircleContain calls the stored function 'pg_catalog.circle_contain(circle, circle) boolean' on db.
func CircleContain(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_contain
	const sqlstr = `SELECT * FROM pg_catalog.circle_contain($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleContainPt calls the stored function 'pg_catalog.circle_contain_pt(circle, point) boolean' on db.
func CircleContainPt(ctx context.Context, db DB, p0 pgtypes.Circle, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.circle_contain_pt
	const sqlstr = `SELECT * FROM pg_catalog.circle_contain_pt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleContained calls the stored function 'pg_catalog.circle_contained(circle, circle) boolean' on db.
func CircleContained(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_contained
	const sqlstr = `SELECT * FROM pg_catalog.circle_contained($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleDistance calls the stored function 'pg_catalog.circle_distance(circle, circle) double precision' on db.
func CircleDistance(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (float64, error) {
	// call pg_catalog.circle_distance
	const sqlstr = `SELECT * FROM pg_catalog.circle_distance($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// CircleDivPt calls the stored function 'pg_catalog.circle_div_pt(circle, point) circle' on db.
func CircleDivPt(ctx context.Context, db DB, p0 pgtypes.Circle, p1 pgtypes.Point) (pgtypes.Circle, error) {
	// call pg_catalog.circle_div_pt
	const sqlstr = `SELECT * FROM pg_catalog.circle_div_pt($1, $2)`
	// run
	var r0 pgtypes.Circle
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return r0, nil
}

// CircleEq calls the stored function 'pg_catalog.circle_eq(circle, circle) boolean' on db.
func CircleEq(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_eq
	const sqlstr = `SELECT * FROM pg_catalog.circle_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleGe calls the stored function 'pg_catalog.circle_ge(circle, circle) boolean' on db.
func CircleGe(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_ge
	const sqlstr = `SELECT * FROM pg_catalog.circle_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleGt calls the stored function 'pg_catalog.circle_gt(circle, circle) boolean' on db.
func CircleGt(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_gt
	const sqlstr = `SELECT * FROM pg_catalog.circle_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleLe calls the stored function 'pg_catalog.circle_le(circle, circle) boolean' on db.
func CircleLe(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_le
	const sqlstr = `SELECT * FROM pg_catalog.circle_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleLeft calls the stored function 'pg_catalog.circle_left(circle, circle) boolean' on db.
func CircleLeft(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_left
	const sqlstr = `SELECT * FROM pg_catalog.circle_left($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleLt calls the stored function 'pg_catalog.circle_lt(circle, circle) boolean' on db.
func CircleLt(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_lt
	const sqlstr = `SELECT * FROM pg_catalog.circle_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleMulPt calls the stored function 'pg_catalog.circle_mul_pt(circle, point) circle' on db.
func CircleMulPt(ctx context.Context, db DB, p0 pgtypes.Circle, p1 pgtypes.Point) (pgtypes.Circle, error) {
	// call pg_catalog.circle_mul_pt
	const sqlstr = `SELECT * FROM pg_catalog.circle_mul_pt($1, $2)`
	// run
	var r0 pgtypes.Circle
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return r0, nil
}

// CircleNe calls the stored function 'pg_catalog.circle_ne(circle, circle) boolean' on db.
func CircleNe(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_ne
	const sqlstr = `SELECT * FROM pg_catalog.circle_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleOverabove calls the stored function 'pg_catalog.circle_overabove(circle, circle) boolean' on db.
func CircleOverabove(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_overabove
	const sqlstr = `SELECT * FROM pg_catalog.circle_overabove($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleOverbelow calls the stored function 'pg_catalog.circle_overbelow(circle, circle) boolean' on db.
func CircleOverbelow(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_overbelow
	const sqlstr = `SELECT * FROM pg_catalog.circle_overbelow($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleOverlap calls the stored function 'pg_catalog.circle_overlap(circle, circle) boolean' on db.
func CircleOverlap(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_overlap
	const sqlstr = `SELECT * FROM pg_catalog.circle_overlap($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleOverleft calls the stored function 'pg_catalog.circle_overleft(circle, circle) boolean' on db.
func CircleOverleft(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_overleft
	const sqlstr = `SELECT * FROM pg_catalog.circle_overleft($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleOverright calls the stored function 'pg_catalog.circle_overright(circle, circle) boolean' on db.
func CircleOverright(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_overright
	const sqlstr = `SELECT * FROM pg_catalog.circle_overright($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleRecv calls the stored function 'pg_catalog.circle_recv(internal) circle' on db.
func CircleRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Circle, error) {
	// call pg_catalog.circle_recv
	const sqlstr = `SELECT * FROM pg_catalog.circle_recv($1)`
	// run
	var r0 pgtypes.Circle
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return r0, nil
}

// CircleRight calls the stored function 'pg_catalog.circle_right(circle, circle) boolean' on db.
func CircleRight(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_right
	const sqlstr = `SELECT * FROM pg_catalog.circle_right($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleSame calls the stored function 'pg_catalog.circle_same(circle, circle) boolean' on db.
func CircleSame(ctx context.Context, db DB, p0, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.circle_same
	const sqlstr = `SELECT * FROM pg_catalog.circle_same($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// CircleSend calls the stored function 'pg_catalog.circle_send(circle) bytea' on db.
func CircleSend(ctx context.Context, db DB, p0 pgtypes.Circle) ([]byte, error) {
	// call pg_catalog.circle_send
	const sqlstr = `SELECT * FROM pg_catalog.circle_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// CircleSubPt calls the stored function 'pg_catalog.circle_sub_pt(circle, point) circle' on db.
func CircleSubPt(ctx context.Context, db DB, p0 pgtypes.Circle, p1 pgtypes.Point) (pgtypes.Circle, error) {
	// call pg_catalog.circle_sub_pt
	const sqlstr = `SELECT * FROM pg_catalog.circle_sub_pt($1, $2)`
	// run
	var r0 pgtypes.Circle
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Circle{}, logerror(err)
	}
	return r0, nil
}

// ClockTimestamp calls the stored function 'pg_catalog.clock_timestamp() timestamp with time zone' on db.
func ClockTimestamp(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.clock_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.clock_timestamp()`
	// run
	var r0 time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// CloseLb calls the stored function 'pg_catalog.close_lb(line, box) point' on db.
func CloseLb(ctx context.Context, db DB, p0 pgtypes.Line, p1 pgtypes.Box) (pgtypes.Point, error) {
	// call pg_catalog.close_lb
	const sqlstr = `SELECT * FROM pg_catalog.close_lb($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// CloseLs calls the stored function 'pg_catalog.close_ls(line, lseg) point' on db.
func CloseLs(ctx context.Context, db DB, p0 pgtypes.Line, p1 pgtypes.Lseg) (pgtypes.Point, error) {
	// call pg_catalog.close_ls
	const sqlstr = `SELECT * FROM pg_catalog.close_ls($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// CloseLseg calls the stored function 'pg_catalog.close_lseg(lseg, lseg) point' on db.
func CloseLseg(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (pgtypes.Point, error) {
	// call pg_catalog.close_lseg
	const sqlstr = `SELECT * FROM pg_catalog.close_lseg($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// ClosePb calls the stored function 'pg_catalog.close_pb(point, box) point' on db.
func ClosePb(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Box) (pgtypes.Point, error) {
	// call pg_catalog.close_pb
	const sqlstr = `SELECT * FROM pg_catalog.close_pb($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// ClosePl calls the stored function 'pg_catalog.close_pl(point, line) point' on db.
func ClosePl(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Line) (pgtypes.Point, error) {
	// call pg_catalog.close_pl
	const sqlstr = `SELECT * FROM pg_catalog.close_pl($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// ClosePs calls the stored function 'pg_catalog.close_ps(point, lseg) point' on db.
func ClosePs(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Lseg) (pgtypes.Point, error) {
	// call pg_catalog.close_ps
	const sqlstr = `SELECT * FROM pg_catalog.close_ps($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// CloseSb calls the stored function 'pg_catalog.close_sb(lseg, box) point' on db.
func CloseSb(ctx context.Context, db DB, p0 pgtypes.Lseg, p1 pgtypes.Box) (pgtypes.Point, error) {
	// call pg_catalog.close_sb
	const sqlstr = `SELECT * FROM pg_catalog.close_sb($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// CloseSl calls the stored function 'pg_catalog.close_sl(lseg, line) point' on db.
func CloseSl(ctx context.Context, db DB, p0 pgtypes.Lseg, p1 pgtypes.Line) (pgtypes.Point, error) {
	// call pg_catalog.close_sl
	const sqlstr = `SELECT * FROM pg_catalog.close_sl($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// ColDescription calls the stored function 'pg_catalog.col_description(oid, integer) text' on db.
func ColDescription(ctx context.Context, db DB, p0 pgtypes.Oid, p1 int) (string, error) {
	// call pg_catalog.col_description
	const sqlstr = `SELECT * FROM pg_catalog.col_description($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Contjoinsel calls the stored function 'pg_catalog.contjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Contjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.contjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.contjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Contsel calls the stored function 'pg_catalog.contsel(internal, oid, internal, integer) double precision' on db.
func Contsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.contsel
	const sqlstr = `SELECT * FROM pg_catalog.contsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Convert calls the stored function 'pg_catalog.convert(bytea, name, name) bytea' on db.
func Convert(ctx context.Context, db DB, p0 []byte, p1, p2 string) ([]byte, error) {
	// call pg_catalog.convert
	const sqlstr = `SELECT * FROM pg_catalog.convert($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// ConvertFrom calls the stored function 'pg_catalog.convert_from(bytea, name) text' on db.
func ConvertFrom(ctx context.Context, db DB, p0 []byte, p1 string) (string, error) {
	// call pg_catalog.convert_from
	const sqlstr = `SELECT * FROM pg_catalog.convert_from($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ConvertTo calls the stored function 'pg_catalog.convert_to(text, name) bytea' on db.
func ConvertTo(ctx context.Context, db DB, p0, p1 string) ([]byte, error) {
	// call pg_catalog.convert_to
	const sqlstr = `SELECT * FROM pg_catalog.convert_to($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Cos calls the stored function 'pg_catalog.cos(double precision) double precision' on db.
func Cos(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.cos
	const sqlstr = `SELECT * FROM pg_catalog.cos($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Cosd calls the stored function 'pg_catalog.cosd(double precision) double precision' on db.
func Cosd(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.cosd
	const sqlstr = `SELECT * FROM pg_catalog.cosd($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Cosh calls the stored function 'pg_catalog.cosh(double precision) double precision' on db.
func Cosh(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.cosh
	const sqlstr = `SELECT * FROM pg_catalog.cosh($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Cot calls the stored function 'pg_catalog.cot(double precision) double precision' on db.
func Cot(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.cot
	const sqlstr = `SELECT * FROM pg_catalog.cot($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Cotd calls the stored function 'pg_catalog.cotd(double precision) double precision' on db.
func Cotd(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.cotd
	const sqlstr = `SELECT * FROM pg_catalog.cotd($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// CurrentDatabase calls the stored function 'pg_catalog.current_database() name' on db.
func CurrentDatabase(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.current_database
	const sqlstr = `SELECT * FROM pg_catalog.current_database()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CurrentQuery calls the stored function 'pg_catalog.current_query() text' on db.
func CurrentQuery(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.current_query
	const sqlstr = `SELECT * FROM pg_catalog.current_query()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CurrentSchema calls the stored function 'pg_catalog.current_schema() name' on db.
func CurrentSchema(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.current_schema
	const sqlstr = `SELECT * FROM pg_catalog.current_schema()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CurrentSchemas calls the stored function 'pg_catalog.current_schemas(boolean) name' on db.
func CurrentSchemas(ctx context.Context, db DB, p0 bool) (StringSlice, error) {
	// call pg_catalog.current_schemas
	const sqlstr = `SELECT * FROM pg_catalog.current_schemas($1)`
	// run
	var r0 StringSlice
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// CurrentSettingByText calls the stored function 'pg_catalog.current_setting(text) text' on db.
func CurrentSettingByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.current_setting
	const sqlstr = `SELECT * FROM pg_catalog.current_setting($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CurrentSettingByTextAndBoolean calls the stored function 'pg_catalog.current_setting(text, boolean) text' on db.
func CurrentSettingByTextAndBoolean(ctx context.Context, db DB, p0 string, p1 bool) (string, error) {
	// call pg_catalog.current_setting
	const sqlstr = `SELECT * FROM pg_catalog.current_setting($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// CurrentUser calls the stored function 'pg_catalog.current_user() name' on db.
func CurrentUser(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.current_user
	const sqlstr = `SELECT * FROM pg_catalog.current_user()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Currtid calls the stored function 'pg_catalog.currtid(oid, tid) tid' on db.
func Currtid(ctx context.Context, db DB, p0 pgtypes.Oid, p1 pgtypes.Tid) (pgtypes.Tid, error) {
	// call pg_catalog.currtid
	const sqlstr = `SELECT * FROM pg_catalog.currtid($1, $2)`
	// run
	var r0 pgtypes.Tid
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tid{}, logerror(err)
	}
	return r0, nil
}

// Currtid2 calls the stored function 'pg_catalog.currtid2(text, tid) tid' on db.
func Currtid2(ctx context.Context, db DB, p0 string, p1 pgtypes.Tid) (pgtypes.Tid, error) {
	// call pg_catalog.currtid2
	const sqlstr = `SELECT * FROM pg_catalog.currtid2($1, $2)`
	// run
	var r0 pgtypes.Tid
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tid{}, logerror(err)
	}
	return r0, nil
}

// Currval calls the stored function 'pg_catalog.currval(regclass) bigint' on db.
func Currval(ctx context.Context, db DB, p0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.currval
	const sqlstr = `SELECT * FROM pg_catalog.currval($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// CursorToXML calls the stored function 'pg_catalog.cursor_to_xml(refcursor, integer, boolean, boolean, text) xml' on db.
func CursorToXML(ctx context.Context, db DB, cursor pgtypes.Refcursor, count int, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.cursor_to_xml
	const sqlstr = `SELECT * FROM pg_catalog.cursor_to_xml($1, $2, $3, $4, $5)`
	// run
	var r0 []byte
	logf(sqlstr, cursor, count, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, cursor, count, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// CursorToXmlschema calls the stored function 'pg_catalog.cursor_to_xmlschema(refcursor, boolean, boolean, text) xml' on db.
func CursorToXmlschema(ctx context.Context, db DB, cursor pgtypes.Refcursor, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.cursor_to_xmlschema
	const sqlstr = `SELECT * FROM pg_catalog.cursor_to_xmlschema($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, cursor, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, cursor, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// DatabaseToXML calls the stored function 'pg_catalog.database_to_xml(boolean, boolean, text) xml' on db.
func DatabaseToXML(ctx context.Context, db DB, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.database_to_xml
	const sqlstr = `SELECT * FROM pg_catalog.database_to_xml($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// DatabaseToXMLAndXmlschema calls the stored function 'pg_catalog.database_to_xml_and_xmlschema(boolean, boolean, text) xml' on db.
func DatabaseToXMLAndXmlschema(ctx context.Context, db DB, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.database_to_xml_and_xmlschema
	const sqlstr = `SELECT * FROM pg_catalog.database_to_xml_and_xmlschema($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// DatabaseToXmlschema calls the stored function 'pg_catalog.database_to_xmlschema(boolean, boolean, text) xml' on db.
func DatabaseToXmlschema(ctx context.Context, db DB, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.database_to_xmlschema
	const sqlstr = `SELECT * FROM pg_catalog.database_to_xmlschema($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// DateByTimestampWithTimeZone calls the stored function 'pg_catalog.date(timestamp with time zone) date' on db.
func DateByTimestampWithTimeZone(ctx context.Context, db DB, p0 time.Time) (time.Time, error) {
	// call pg_catalog.date
	const sqlstr = `SELECT * FROM pg_catalog.date($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DateByTimestampWithoutTimeZone calls the stored function 'pg_catalog.date(timestamp without time zone) date' on db.
func DateByTimestampWithoutTimeZone(ctx context.Context, db DB, p0 time.Time) (time.Time, error) {
	// call pg_catalog.date
	const sqlstr = `SELECT * FROM pg_catalog.date($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DateCmp calls the stored function 'pg_catalog.date_cmp(date, date) integer' on db.
func DateCmp(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.date_cmp
	const sqlstr = `SELECT * FROM pg_catalog.date_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// DateCmpTimestamp calls the stored function 'pg_catalog.date_cmp_timestamp(date, timestamp without time zone) integer' on db.
func DateCmpTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.date_cmp_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.date_cmp_timestamp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// DateCmpTimestamptz calls the stored function 'pg_catalog.date_cmp_timestamptz(date, timestamp with time zone) integer' on db.
func DateCmpTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.date_cmp_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.date_cmp_timestamptz($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// DateEq calls the stored function 'pg_catalog.date_eq(date, date) boolean' on db.
func DateEq(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_eq
	const sqlstr = `SELECT * FROM pg_catalog.date_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateEqTimestamp calls the stored function 'pg_catalog.date_eq_timestamp(date, timestamp without time zone) boolean' on db.
func DateEqTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_eq_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.date_eq_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateEqTimestamptz calls the stored function 'pg_catalog.date_eq_timestamptz(date, timestamp with time zone) boolean' on db.
func DateEqTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_eq_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.date_eq_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateGe calls the stored function 'pg_catalog.date_ge(date, date) boolean' on db.
func DateGe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_ge
	const sqlstr = `SELECT * FROM pg_catalog.date_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateGeTimestamp calls the stored function 'pg_catalog.date_ge_timestamp(date, timestamp without time zone) boolean' on db.
func DateGeTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_ge_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.date_ge_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateGeTimestamptz calls the stored function 'pg_catalog.date_ge_timestamptz(date, timestamp with time zone) boolean' on db.
func DateGeTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_ge_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.date_ge_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateGt calls the stored function 'pg_catalog.date_gt(date, date) boolean' on db.
func DateGt(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_gt
	const sqlstr = `SELECT * FROM pg_catalog.date_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateGtTimestamp calls the stored function 'pg_catalog.date_gt_timestamp(date, timestamp without time zone) boolean' on db.
func DateGtTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_gt_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.date_gt_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateGtTimestamptz calls the stored function 'pg_catalog.date_gt_timestamptz(date, timestamp with time zone) boolean' on db.
func DateGtTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_gt_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.date_gt_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateLarger calls the stored function 'pg_catalog.date_larger(date, date) date' on db.
func DateLarger(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.date_larger
	const sqlstr = `SELECT * FROM pg_catalog.date_larger($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DateLe calls the stored function 'pg_catalog.date_le(date, date) boolean' on db.
func DateLe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_le
	const sqlstr = `SELECT * FROM pg_catalog.date_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateLeTimestamp calls the stored function 'pg_catalog.date_le_timestamp(date, timestamp without time zone) boolean' on db.
func DateLeTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_le_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.date_le_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateLeTimestamptz calls the stored function 'pg_catalog.date_le_timestamptz(date, timestamp with time zone) boolean' on db.
func DateLeTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_le_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.date_le_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateLt calls the stored function 'pg_catalog.date_lt(date, date) boolean' on db.
func DateLt(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_lt
	const sqlstr = `SELECT * FROM pg_catalog.date_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateLtTimestamp calls the stored function 'pg_catalog.date_lt_timestamp(date, timestamp without time zone) boolean' on db.
func DateLtTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_lt_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.date_lt_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateLtTimestamptz calls the stored function 'pg_catalog.date_lt_timestamptz(date, timestamp with time zone) boolean' on db.
func DateLtTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_lt_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.date_lt_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateMi calls the stored function 'pg_catalog.date_mi(date, date) integer' on db.
func DateMi(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.date_mi
	const sqlstr = `SELECT * FROM pg_catalog.date_mi($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// DateMiInterval calls the stored function 'pg_catalog.date_mi_interval(date, interval) timestamp without time zone' on db.
func DateMiInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte) (time.Time, error) {
	// call pg_catalog.date_mi_interval
	const sqlstr = `SELECT * FROM pg_catalog.date_mi_interval($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DateMii calls the stored function 'pg_catalog.date_mii(date, integer) date' on db.
func DateMii(ctx context.Context, db DB, p0 time.Time, p1 int) (time.Time, error) {
	// call pg_catalog.date_mii
	const sqlstr = `SELECT * FROM pg_catalog.date_mii($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DateNe calls the stored function 'pg_catalog.date_ne(date, date) boolean' on db.
func DateNe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_ne
	const sqlstr = `SELECT * FROM pg_catalog.date_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateNeTimestamp calls the stored function 'pg_catalog.date_ne_timestamp(date, timestamp without time zone) boolean' on db.
func DateNeTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_ne_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.date_ne_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DateNeTimestamptz calls the stored function 'pg_catalog.date_ne_timestamptz(date, timestamp with time zone) boolean' on db.
func DateNeTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.date_ne_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.date_ne_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// DatePartByTextAndTimestampWithTimeZone calls the stored function 'pg_catalog.date_part(text, timestamp with time zone) double precision' on db.
func DatePartByTextAndTimestampWithTimeZone(ctx context.Context, db DB, p0 string, p1 time.Time) (float64, error) {
	// call pg_catalog.date_part
	const sqlstr = `SELECT * FROM pg_catalog.date_part($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DatePartByTextAndInterval calls the stored function 'pg_catalog.date_part(text, interval) double precision' on db.
func DatePartByTextAndInterval(ctx context.Context, db DB, p0 string, p1 []byte) (float64, error) {
	// call pg_catalog.date_part
	const sqlstr = `SELECT * FROM pg_catalog.date_part($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DatePartByTextAndTimeWithTimeZone calls the stored function 'pg_catalog.date_part(text, time with time zone) double precision' on db.
func DatePartByTextAndTimeWithTimeZone(ctx context.Context, db DB, p0 string, p1 time.Time) (float64, error) {
	// call pg_catalog.date_part
	const sqlstr = `SELECT * FROM pg_catalog.date_part($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DatePartByTextAndDate calls the stored function 'pg_catalog.date_part(text, date) double precision' on db.
func DatePartByTextAndDate(ctx context.Context, db DB, p0 string, p1 time.Time) (float64, error) {
	// call pg_catalog.date_part
	const sqlstr = `SELECT * FROM pg_catalog.date_part($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DatePartByTextAndTimeWithoutTimeZone calls the stored function 'pg_catalog.date_part(text, time without time zone) double precision' on db.
func DatePartByTextAndTimeWithoutTimeZone(ctx context.Context, db DB, p0 string, p1 time.Time) (float64, error) {
	// call pg_catalog.date_part
	const sqlstr = `SELECT * FROM pg_catalog.date_part($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DatePartByTextAndTimestampWithoutTimeZone calls the stored function 'pg_catalog.date_part(text, timestamp without time zone) double precision' on db.
func DatePartByTextAndTimestampWithoutTimeZone(ctx context.Context, db DB, p0 string, p1 time.Time) (float64, error) {
	// call pg_catalog.date_part
	const sqlstr = `SELECT * FROM pg_catalog.date_part($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DatePlInterval calls the stored function 'pg_catalog.date_pl_interval(date, interval) timestamp without time zone' on db.
func DatePlInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte) (time.Time, error) {
	// call pg_catalog.date_pl_interval
	const sqlstr = `SELECT * FROM pg_catalog.date_pl_interval($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DatePli calls the stored function 'pg_catalog.date_pli(date, integer) date' on db.
func DatePli(ctx context.Context, db DB, p0 time.Time, p1 int) (time.Time, error) {
	// call pg_catalog.date_pli
	const sqlstr = `SELECT * FROM pg_catalog.date_pli($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DateRecv calls the stored function 'pg_catalog.date_recv(internal) date' on db.
func DateRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (time.Time, error) {
	// call pg_catalog.date_recv
	const sqlstr = `SELECT * FROM pg_catalog.date_recv($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DateSend calls the stored function 'pg_catalog.date_send(date) bytea' on db.
func DateSend(ctx context.Context, db DB, p0 time.Time) ([]byte, error) {
	// call pg_catalog.date_send
	const sqlstr = `SELECT * FROM pg_catalog.date_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// DateSmaller calls the stored function 'pg_catalog.date_smaller(date, date) date' on db.
func DateSmaller(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.date_smaller
	const sqlstr = `SELECT * FROM pg_catalog.date_smaller($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DateSortsupport calls the stored function 'pg_catalog.date_sortsupport(internal)' on db.
func DateSortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.date_sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.date_sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// DateTruncByTextAndTimestampWithTimeZone calls the stored function 'pg_catalog.date_trunc(text, timestamp with time zone) timestamp with time zone' on db.
func DateTruncByTextAndTimestampWithTimeZone(ctx context.Context, db DB, p0 string, p1 time.Time) (time.Time, error) {
	// call pg_catalog.date_trunc
	const sqlstr = `SELECT * FROM pg_catalog.date_trunc($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DateTruncByTextAndInterval calls the stored function 'pg_catalog.date_trunc(text, interval) interval' on db.
func DateTruncByTextAndInterval(ctx context.Context, db DB, p0 string, p1 []byte) ([]byte, error) {
	// call pg_catalog.date_trunc
	const sqlstr = `SELECT * FROM pg_catalog.date_trunc($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// DateTruncByTextTimestampWithTimeZoneAndText calls the stored function 'pg_catalog.date_trunc(text, timestamp with time zone, text) timestamp with time zone' on db.
func DateTruncByTextTimestampWithTimeZoneAndText(ctx context.Context, db DB, p0 string, p1 time.Time, p2 string) (time.Time, error) {
	// call pg_catalog.date_trunc
	const sqlstr = `SELECT * FROM pg_catalog.date_trunc($1, $2, $3)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DateTruncByTextAndTimestampWithoutTimeZone calls the stored function 'pg_catalog.date_trunc(text, timestamp without time zone) timestamp without time zone' on db.
func DateTruncByTextAndTimestampWithoutTimeZone(ctx context.Context, db DB, p0 string, p1 time.Time) (time.Time, error) {
	// call pg_catalog.date_trunc
	const sqlstr = `SELECT * FROM pg_catalog.date_trunc($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DaterangeByDateAndDate calls the stored function 'pg_catalog.daterange(date, date) daterange' on db.
func DaterangeByDateAndDate(ctx context.Context, db DB, p0, p1 time.Time) (pgtypes.Daterange, error) {
	// call pg_catalog.daterange
	const sqlstr = `SELECT * FROM pg_catalog.daterange($1, $2)`
	// run
	var r0 pgtypes.Daterange
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Daterange{}, logerror(err)
	}
	return r0, nil
}

// DaterangeByDateDateAndText calls the stored function 'pg_catalog.daterange(date, date, text) daterange' on db.
func DaterangeByDateDateAndText(ctx context.Context, db DB, p0, p1 time.Time, p2 string) (pgtypes.Daterange, error) {
	// call pg_catalog.daterange
	const sqlstr = `SELECT * FROM pg_catalog.daterange($1, $2, $3)`
	// run
	var r0 pgtypes.Daterange
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Daterange{}, logerror(err)
	}
	return r0, nil
}

// DaterangeCanonical calls the stored function 'pg_catalog.daterange_canonical(daterange) daterange' on db.
func DaterangeCanonical(ctx context.Context, db DB, p0 pgtypes.Daterange) (pgtypes.Daterange, error) {
	// call pg_catalog.daterange_canonical
	const sqlstr = `SELECT * FROM pg_catalog.daterange_canonical($1)`
	// run
	var r0 pgtypes.Daterange
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Daterange{}, logerror(err)
	}
	return r0, nil
}

// DaterangeSubdiff calls the stored function 'pg_catalog.daterange_subdiff(date, date) double precision' on db.
func DaterangeSubdiff(ctx context.Context, db DB, p0, p1 time.Time) (float64, error) {
	// call pg_catalog.daterange_subdiff
	const sqlstr = `SELECT * FROM pg_catalog.daterange_subdiff($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DatetimePl calls the stored function 'pg_catalog.datetime_pl(date, time without time zone) timestamp without time zone' on db.
func DatetimePl(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.datetime_pl
	const sqlstr = `SELECT * FROM pg_catalog.datetime_pl($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// DatetimetzPl calls the stored function 'pg_catalog.datetimetz_pl(date, time with time zone) timestamp with time zone' on db.
func DatetimetzPl(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.datetimetz_pl
	const sqlstr = `SELECT * FROM pg_catalog.datetimetz_pl($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// Dcbrt calls the stored function 'pg_catalog.dcbrt(double precision) double precision' on db.
func Dcbrt(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.dcbrt
	const sqlstr = `SELECT * FROM pg_catalog.dcbrt($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Decode calls the stored function 'pg_catalog.decode(text, text) bytea' on db.
func Decode(ctx context.Context, db DB, p0, p1 string) ([]byte, error) {
	// call pg_catalog.decode
	const sqlstr = `SELECT * FROM pg_catalog.decode($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Degrees calls the stored function 'pg_catalog.degrees(double precision) double precision' on db.
func Degrees(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.degrees
	const sqlstr = `SELECT * FROM pg_catalog.degrees($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Dexp calls the stored function 'pg_catalog.dexp(double precision) double precision' on db.
func Dexp(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.dexp
	const sqlstr = `SELECT * FROM pg_catalog.dexp($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Diagonal calls the stored function 'pg_catalog.diagonal(box) lseg' on db.
func Diagonal(ctx context.Context, db DB, p0 pgtypes.Box) (pgtypes.Lseg, error) {
	// call pg_catalog.diagonal
	const sqlstr = `SELECT * FROM pg_catalog.diagonal($1)`
	// run
	var r0 pgtypes.Lseg
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Lseg{}, logerror(err)
	}
	return r0, nil
}

// Diameter calls the stored function 'pg_catalog.diameter(circle) double precision' on db.
func Diameter(ctx context.Context, db DB, p0 pgtypes.Circle) (float64, error) {
	// call pg_catalog.diameter
	const sqlstr = `SELECT * FROM pg_catalog.diameter($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DispellInit calls the stored function 'pg_catalog.dispell_init(internal) internal' on db.
func DispellInit(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dispell_init
	const sqlstr = `SELECT * FROM pg_catalog.dispell_init($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// DispellLexize calls the stored function 'pg_catalog.dispell_lexize(internal, internal, internal, internal) internal' on db.
func DispellLexize(ctx context.Context, db DB, p0, p1, p2, p3 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dispell_lexize
	const sqlstr = `SELECT * FROM pg_catalog.dispell_lexize($1, $2, $3, $4)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// DistBl calls the stored function 'pg_catalog.dist_bl(box, line) double precision' on db.
func DistBl(ctx context.Context, db DB, p0 pgtypes.Box, p1 pgtypes.Line) (float64, error) {
	// call pg_catalog.dist_bl
	const sqlstr = `SELECT * FROM pg_catalog.dist_bl($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistBp calls the stored function 'pg_catalog.dist_bp(box, point) double precision' on db.
func DistBp(ctx context.Context, db DB, p0 pgtypes.Box, p1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_bp
	const sqlstr = `SELECT * FROM pg_catalog.dist_bp($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistBs calls the stored function 'pg_catalog.dist_bs(box, lseg) double precision' on db.
func DistBs(ctx context.Context, db DB, p0 pgtypes.Box, p1 pgtypes.Lseg) (float64, error) {
	// call pg_catalog.dist_bs
	const sqlstr = `SELECT * FROM pg_catalog.dist_bs($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistCpoint calls the stored function 'pg_catalog.dist_cpoint(circle, point) double precision' on db.
func DistCpoint(ctx context.Context, db DB, p0 pgtypes.Circle, p1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_cpoint
	const sqlstr = `SELECT * FROM pg_catalog.dist_cpoint($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistCpoly calls the stored function 'pg_catalog.dist_cpoly(circle, polygon) double precision' on db.
func DistCpoly(ctx context.Context, db DB, p0 pgtypes.Circle, p1 pgtypes.Polygon) (float64, error) {
	// call pg_catalog.dist_cpoly
	const sqlstr = `SELECT * FROM pg_catalog.dist_cpoly($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistLb calls the stored function 'pg_catalog.dist_lb(line, box) double precision' on db.
func DistLb(ctx context.Context, db DB, p0 pgtypes.Line, p1 pgtypes.Box) (float64, error) {
	// call pg_catalog.dist_lb
	const sqlstr = `SELECT * FROM pg_catalog.dist_lb($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistLp calls the stored function 'pg_catalog.dist_lp(line, point) double precision' on db.
func DistLp(ctx context.Context, db DB, p0 pgtypes.Line, p1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_lp
	const sqlstr = `SELECT * FROM pg_catalog.dist_lp($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistLs calls the stored function 'pg_catalog.dist_ls(line, lseg) double precision' on db.
func DistLs(ctx context.Context, db DB, p0 pgtypes.Line, p1 pgtypes.Lseg) (float64, error) {
	// call pg_catalog.dist_ls
	const sqlstr = `SELECT * FROM pg_catalog.dist_ls($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistPathp calls the stored function 'pg_catalog.dist_pathp(path, point) double precision' on db.
func DistPathp(ctx context.Context, db DB, p0 pgtypes.Path, p1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_pathp
	const sqlstr = `SELECT * FROM pg_catalog.dist_pathp($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistPb calls the stored function 'pg_catalog.dist_pb(point, box) double precision' on db.
func DistPb(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Box) (float64, error) {
	// call pg_catalog.dist_pb
	const sqlstr = `SELECT * FROM pg_catalog.dist_pb($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistPc calls the stored function 'pg_catalog.dist_pc(point, circle) double precision' on db.
func DistPc(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Circle) (float64, error) {
	// call pg_catalog.dist_pc
	const sqlstr = `SELECT * FROM pg_catalog.dist_pc($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistPl calls the stored function 'pg_catalog.dist_pl(point, line) double precision' on db.
func DistPl(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Line) (float64, error) {
	// call pg_catalog.dist_pl
	const sqlstr = `SELECT * FROM pg_catalog.dist_pl($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistPolyc calls the stored function 'pg_catalog.dist_polyc(polygon, circle) double precision' on db.
func DistPolyc(ctx context.Context, db DB, p0 pgtypes.Polygon, p1 pgtypes.Circle) (float64, error) {
	// call pg_catalog.dist_polyc
	const sqlstr = `SELECT * FROM pg_catalog.dist_polyc($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistPolyp calls the stored function 'pg_catalog.dist_polyp(polygon, point) double precision' on db.
func DistPolyp(ctx context.Context, db DB, p0 pgtypes.Polygon, p1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_polyp
	const sqlstr = `SELECT * FROM pg_catalog.dist_polyp($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistPpath calls the stored function 'pg_catalog.dist_ppath(point, path) double precision' on db.
func DistPpath(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Path) (float64, error) {
	// call pg_catalog.dist_ppath
	const sqlstr = `SELECT * FROM pg_catalog.dist_ppath($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistPpoly calls the stored function 'pg_catalog.dist_ppoly(point, polygon) double precision' on db.
func DistPpoly(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Polygon) (float64, error) {
	// call pg_catalog.dist_ppoly
	const sqlstr = `SELECT * FROM pg_catalog.dist_ppoly($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistPs calls the stored function 'pg_catalog.dist_ps(point, lseg) double precision' on db.
func DistPs(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Lseg) (float64, error) {
	// call pg_catalog.dist_ps
	const sqlstr = `SELECT * FROM pg_catalog.dist_ps($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistSb calls the stored function 'pg_catalog.dist_sb(lseg, box) double precision' on db.
func DistSb(ctx context.Context, db DB, p0 pgtypes.Lseg, p1 pgtypes.Box) (float64, error) {
	// call pg_catalog.dist_sb
	const sqlstr = `SELECT * FROM pg_catalog.dist_sb($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistSl calls the stored function 'pg_catalog.dist_sl(lseg, line) double precision' on db.
func DistSl(ctx context.Context, db DB, p0 pgtypes.Lseg, p1 pgtypes.Line) (float64, error) {
	// call pg_catalog.dist_sl
	const sqlstr = `SELECT * FROM pg_catalog.dist_sl($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DistSp calls the stored function 'pg_catalog.dist_sp(lseg, point) double precision' on db.
func DistSp(ctx context.Context, db DB, p0 pgtypes.Lseg, p1 pgtypes.Point) (float64, error) {
	// call pg_catalog.dist_sp
	const sqlstr = `SELECT * FROM pg_catalog.dist_sp($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Div calls the stored function 'pg_catalog.div(numeric, numeric) numeric' on db.
func Div(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.div
	const sqlstr = `SELECT * FROM pg_catalog.div($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Dlog1 calls the stored function 'pg_catalog.dlog1(double precision) double precision' on db.
func Dlog1(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.dlog1
	const sqlstr = `SELECT * FROM pg_catalog.dlog1($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Dlog10 calls the stored function 'pg_catalog.dlog10(double precision) double precision' on db.
func Dlog10(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.dlog10
	const sqlstr = `SELECT * FROM pg_catalog.dlog10($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DomainRecv calls the stored function 'pg_catalog.domain_recv(internal, oid, integer) "any"' on db.
func DomainRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (pgtypes.Any, error) {
	// call pg_catalog.domain_recv
	const sqlstr = `SELECT * FROM pg_catalog.domain_recv($1, $2, $3)`
	// run
	var r0 pgtypes.Any
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Any{}, logerror(err)
	}
	return r0, nil
}

// Dpow calls the stored function 'pg_catalog.dpow(double precision, double precision) double precision' on db.
func Dpow(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.dpow
	const sqlstr = `SELECT * FROM pg_catalog.dpow($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Dround calls the stored function 'pg_catalog.dround(double precision) double precision' on db.
func Dround(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.dround
	const sqlstr = `SELECT * FROM pg_catalog.dround($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DsimpleInit calls the stored function 'pg_catalog.dsimple_init(internal) internal' on db.
func DsimpleInit(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsimple_init
	const sqlstr = `SELECT * FROM pg_catalog.dsimple_init($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// DsimpleLexize calls the stored function 'pg_catalog.dsimple_lexize(internal, internal, internal, internal) internal' on db.
func DsimpleLexize(ctx context.Context, db DB, p0, p1, p2, p3 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsimple_lexize
	const sqlstr = `SELECT * FROM pg_catalog.dsimple_lexize($1, $2, $3, $4)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// DsnowballInit calls the stored function 'pg_catalog.dsnowball_init(internal) internal' on db.
func DsnowballInit(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsnowball_init
	const sqlstr = `SELECT * FROM pg_catalog.dsnowball_init($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// DsnowballLexize calls the stored function 'pg_catalog.dsnowball_lexize(internal, internal, internal, internal) internal' on db.
func DsnowballLexize(ctx context.Context, db DB, p0, p1, p2, p3 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsnowball_lexize
	const sqlstr = `SELECT * FROM pg_catalog.dsnowball_lexize($1, $2, $3, $4)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Dsqrt calls the stored function 'pg_catalog.dsqrt(double precision) double precision' on db.
func Dsqrt(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.dsqrt
	const sqlstr = `SELECT * FROM pg_catalog.dsqrt($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// DsynonymInit calls the stored function 'pg_catalog.dsynonym_init(internal) internal' on db.
func DsynonymInit(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsynonym_init
	const sqlstr = `SELECT * FROM pg_catalog.dsynonym_init($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// DsynonymLexize calls the stored function 'pg_catalog.dsynonym_lexize(internal, internal, internal, internal) internal' on db.
func DsynonymLexize(ctx context.Context, db DB, p0, p1, p2, p3 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.dsynonym_lexize
	const sqlstr = `SELECT * FROM pg_catalog.dsynonym_lexize($1, $2, $3, $4)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Dtrunc calls the stored function 'pg_catalog.dtrunc(double precision) double precision' on db.
func Dtrunc(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.dtrunc
	const sqlstr = `SELECT * FROM pg_catalog.dtrunc($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// ElemContainedByRange calls the stored function 'pg_catalog.elem_contained_by_range(anyelement, anyrange) boolean' on db.
func ElemContainedByRange(ctx context.Context, db DB, p0 pgtypes.Anyelement, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.elem_contained_by_range
	const sqlstr = `SELECT * FROM pg_catalog.elem_contained_by_range($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Encode calls the stored function 'pg_catalog.encode(bytea, text) text' on db.
func Encode(ctx context.Context, db DB, p0 []byte, p1 string) (string, error) {
	// call pg_catalog.encode
	const sqlstr = `SELECT * FROM pg_catalog.encode($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// EnumCmp calls the stored function 'pg_catalog.enum_cmp(anyenum, anyenum) integer' on db.
func EnumCmp(ctx context.Context, db DB, p0, p1 pgtypes.Anyenum) (int, error) {
	// call pg_catalog.enum_cmp
	const sqlstr = `SELECT * FROM pg_catalog.enum_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// EnumEq calls the stored function 'pg_catalog.enum_eq(anyenum, anyenum) boolean' on db.
func EnumEq(ctx context.Context, db DB, p0, p1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_eq
	const sqlstr = `SELECT * FROM pg_catalog.enum_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// EnumFirst calls the stored function 'pg_catalog.enum_first(anyenum) anyenum' on db.
func EnumFirst(ctx context.Context, db DB, p0 pgtypes.Anyenum) (pgtypes.Anyenum, error) {
	// call pg_catalog.enum_first
	const sqlstr = `SELECT * FROM pg_catalog.enum_first($1)`
	// run
	var r0 pgtypes.Anyenum
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return r0, nil
}

// EnumGe calls the stored function 'pg_catalog.enum_ge(anyenum, anyenum) boolean' on db.
func EnumGe(ctx context.Context, db DB, p0, p1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_ge
	const sqlstr = `SELECT * FROM pg_catalog.enum_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// EnumGt calls the stored function 'pg_catalog.enum_gt(anyenum, anyenum) boolean' on db.
func EnumGt(ctx context.Context, db DB, p0, p1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_gt
	const sqlstr = `SELECT * FROM pg_catalog.enum_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// EnumLarger calls the stored function 'pg_catalog.enum_larger(anyenum, anyenum) anyenum' on db.
func EnumLarger(ctx context.Context, db DB, p0, p1 pgtypes.Anyenum) (pgtypes.Anyenum, error) {
	// call pg_catalog.enum_larger
	const sqlstr = `SELECT * FROM pg_catalog.enum_larger($1, $2)`
	// run
	var r0 pgtypes.Anyenum
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return r0, nil
}

// EnumLast calls the stored function 'pg_catalog.enum_last(anyenum) anyenum' on db.
func EnumLast(ctx context.Context, db DB, p0 pgtypes.Anyenum) (pgtypes.Anyenum, error) {
	// call pg_catalog.enum_last
	const sqlstr = `SELECT * FROM pg_catalog.enum_last($1)`
	// run
	var r0 pgtypes.Anyenum
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return r0, nil
}

// EnumLe calls the stored function 'pg_catalog.enum_le(anyenum, anyenum) boolean' on db.
func EnumLe(ctx context.Context, db DB, p0, p1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_le
	const sqlstr = `SELECT * FROM pg_catalog.enum_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// EnumLt calls the stored function 'pg_catalog.enum_lt(anyenum, anyenum) boolean' on db.
func EnumLt(ctx context.Context, db DB, p0, p1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_lt
	const sqlstr = `SELECT * FROM pg_catalog.enum_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// EnumNe calls the stored function 'pg_catalog.enum_ne(anyenum, anyenum) boolean' on db.
func EnumNe(ctx context.Context, db DB, p0, p1 pgtypes.Anyenum) (bool, error) {
	// call pg_catalog.enum_ne
	const sqlstr = `SELECT * FROM pg_catalog.enum_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// EnumRangeByAnyenumAndAnyenum calls the stored function 'pg_catalog.enum_range(anyenum, anyenum) anyarray' on db.
func EnumRangeByAnyenumAndAnyenum(ctx context.Context, db DB, p0, p1 pgtypes.Anyenum) (pgtypes.Anyarray, error) {
	// call pg_catalog.enum_range
	const sqlstr = `SELECT * FROM pg_catalog.enum_range($1, $2)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// EnumRangeByAnyenum calls the stored function 'pg_catalog.enum_range(anyenum) anyarray' on db.
func EnumRangeByAnyenum(ctx context.Context, db DB, p0 pgtypes.Anyenum) (pgtypes.Anyarray, error) {
	// call pg_catalog.enum_range
	const sqlstr = `SELECT * FROM pg_catalog.enum_range($1)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// EnumRecv calls the stored function 'pg_catalog.enum_recv(internal, oid) anyenum' on db.
func EnumRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid) (pgtypes.Anyenum, error) {
	// call pg_catalog.enum_recv
	const sqlstr = `SELECT * FROM pg_catalog.enum_recv($1, $2)`
	// run
	var r0 pgtypes.Anyenum
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return r0, nil
}

// EnumSend calls the stored function 'pg_catalog.enum_send(anyenum) bytea' on db.
func EnumSend(ctx context.Context, db DB, p0 pgtypes.Anyenum) ([]byte, error) {
	// call pg_catalog.enum_send
	const sqlstr = `SELECT * FROM pg_catalog.enum_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// EnumSmaller calls the stored function 'pg_catalog.enum_smaller(anyenum, anyenum) anyenum' on db.
func EnumSmaller(ctx context.Context, db DB, p0, p1 pgtypes.Anyenum) (pgtypes.Anyenum, error) {
	// call pg_catalog.enum_smaller
	const sqlstr = `SELECT * FROM pg_catalog.enum_smaller($1, $2)`
	// run
	var r0 pgtypes.Anyenum
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyenum{}, logerror(err)
	}
	return r0, nil
}

// Eqjoinsel calls the stored function 'pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Eqjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.eqjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.eqjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Eqsel calls the stored function 'pg_catalog.eqsel(internal, oid, internal, integer) double precision' on db.
func Eqsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.eqsel
	const sqlstr = `SELECT * FROM pg_catalog.eqsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// EucCnToMic calls the stored function 'pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer)' on db.
func EucCnToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_cn_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.euc_cn_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// EucCnToUTF8 calls the stored function 'pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer)' on db.
func EucCnToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_cn_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.euc_cn_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// EucJis2004ToShiftJis2004 calls the stored function 'pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer)' on db.
func EucJis2004ToShiftJis2004(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_jis_2004_to_shift_jis_2004
	const sqlstr = `SELECT * FROM pg_catalog.euc_jis_2004_to_shift_jis_2004($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// EucJis2004ToUTF8 calls the stored function 'pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer)' on db.
func EucJis2004ToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_jis_2004_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.euc_jis_2004_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// EucJpToMic calls the stored function 'pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer)' on db.
func EucJpToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_jp_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.euc_jp_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// EucJpToSjis calls the stored function 'pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer)' on db.
func EucJpToSjis(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_jp_to_sjis
	const sqlstr = `SELECT * FROM pg_catalog.euc_jp_to_sjis($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// EucJpToUTF8 calls the stored function 'pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer)' on db.
func EucJpToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_jp_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.euc_jp_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// EucKrToMic calls the stored function 'pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer)' on db.
func EucKrToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_kr_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.euc_kr_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// EucKrToUTF8 calls the stored function 'pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer)' on db.
func EucKrToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_kr_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.euc_kr_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// EucTwToBig5 calls the stored function 'pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer)' on db.
func EucTwToBig5(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_tw_to_big5
	const sqlstr = `SELECT * FROM pg_catalog.euc_tw_to_big5($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// EucTwToMic calls the stored function 'pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer)' on db.
func EucTwToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_tw_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.euc_tw_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// EucTwToUTF8 calls the stored function 'pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer)' on db.
func EucTwToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.euc_tw_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.euc_tw_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// ExpByDoublePrecision calls the stored function 'pg_catalog.exp(double precision) double precision' on db.
func ExpByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.exp
	const sqlstr = `SELECT * FROM pg_catalog.exp($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// ExpByNumeric calls the stored function 'pg_catalog.exp(numeric) numeric' on db.
func ExpByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.exp
	const sqlstr = `SELECT * FROM pg_catalog.exp($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Factorial calls the stored function 'pg_catalog.factorial(bigint) numeric' on db.
func Factorial(ctx context.Context, db DB, p0 int64) (float64, error) {
	// call pg_catalog.factorial
	const sqlstr = `SELECT * FROM pg_catalog.factorial($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Family calls the stored function 'pg_catalog.family(inet) integer' on db.
func Family(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.family
	const sqlstr = `SELECT * FROM pg_catalog.family($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Float4ByNumeric calls the stored function 'pg_catalog.float4(numeric) real' on db.
func Float4ByNumeric(ctx context.Context, db DB, p0 float64) (float32, error) {
	// call pg_catalog.float4
	const sqlstr = `SELECT * FROM pg_catalog.float4($1)`
	// run
	var r0 float32
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4BySmallint calls the stored function 'pg_catalog.float4(smallint) real' on db.
func Float4BySmallint(ctx context.Context, db DB, p0 int16) (float32, error) {
	// call pg_catalog.float4
	const sqlstr = `SELECT * FROM pg_catalog.float4($1)`
	// run
	var r0 float32
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4ByDoublePrecision calls the stored function 'pg_catalog.float4(double precision) real' on db.
func Float4ByDoublePrecision(ctx context.Context, db DB, p0 float64) (float32, error) {
	// call pg_catalog.float4
	const sqlstr = `SELECT * FROM pg_catalog.float4($1)`
	// run
	var r0 float32
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4ByInteger calls the stored function 'pg_catalog.float4(integer) real' on db.
func Float4ByInteger(ctx context.Context, db DB, p0 int) (float32, error) {
	// call pg_catalog.float4
	const sqlstr = `SELECT * FROM pg_catalog.float4($1)`
	// run
	var r0 float32
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4ByJsonb calls the stored function 'pg_catalog.float4(jsonb) real' on db.
func Float4ByJsonb(ctx context.Context, db DB, p0 []byte) (float32, error) {
	// call pg_catalog.float4
	const sqlstr = `SELECT * FROM pg_catalog.float4($1)`
	// run
	var r0 float32
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4ByBigint calls the stored function 'pg_catalog.float4(bigint) real' on db.
func Float4ByBigint(ctx context.Context, db DB, p0 int64) (float32, error) {
	// call pg_catalog.float4
	const sqlstr = `SELECT * FROM pg_catalog.float4($1)`
	// run
	var r0 float32
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float48div calls the stored function 'pg_catalog.float48div(real, double precision) double precision' on db.
func Float48div(ctx context.Context, db DB, p0 float32, p1 float64) (float64, error) {
	// call pg_catalog.float48div
	const sqlstr = `SELECT * FROM pg_catalog.float48div($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float48eq calls the stored function 'pg_catalog.float48eq(real, double precision) boolean' on db.
func Float48eq(ctx context.Context, db DB, p0 float32, p1 float64) (bool, error) {
	// call pg_catalog.float48eq
	const sqlstr = `SELECT * FROM pg_catalog.float48eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float48ge calls the stored function 'pg_catalog.float48ge(real, double precision) boolean' on db.
func Float48ge(ctx context.Context, db DB, p0 float32, p1 float64) (bool, error) {
	// call pg_catalog.float48ge
	const sqlstr = `SELECT * FROM pg_catalog.float48ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float48gt calls the stored function 'pg_catalog.float48gt(real, double precision) boolean' on db.
func Float48gt(ctx context.Context, db DB, p0 float32, p1 float64) (bool, error) {
	// call pg_catalog.float48gt
	const sqlstr = `SELECT * FROM pg_catalog.float48gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float48le calls the stored function 'pg_catalog.float48le(real, double precision) boolean' on db.
func Float48le(ctx context.Context, db DB, p0 float32, p1 float64) (bool, error) {
	// call pg_catalog.float48le
	const sqlstr = `SELECT * FROM pg_catalog.float48le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float48lt calls the stored function 'pg_catalog.float48lt(real, double precision) boolean' on db.
func Float48lt(ctx context.Context, db DB, p0 float32, p1 float64) (bool, error) {
	// call pg_catalog.float48lt
	const sqlstr = `SELECT * FROM pg_catalog.float48lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float48mi calls the stored function 'pg_catalog.float48mi(real, double precision) double precision' on db.
func Float48mi(ctx context.Context, db DB, p0 float32, p1 float64) (float64, error) {
	// call pg_catalog.float48mi
	const sqlstr = `SELECT * FROM pg_catalog.float48mi($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float48mul calls the stored function 'pg_catalog.float48mul(real, double precision) double precision' on db.
func Float48mul(ctx context.Context, db DB, p0 float32, p1 float64) (float64, error) {
	// call pg_catalog.float48mul
	const sqlstr = `SELECT * FROM pg_catalog.float48mul($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float48ne calls the stored function 'pg_catalog.float48ne(real, double precision) boolean' on db.
func Float48ne(ctx context.Context, db DB, p0 float32, p1 float64) (bool, error) {
	// call pg_catalog.float48ne
	const sqlstr = `SELECT * FROM pg_catalog.float48ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float48pl calls the stored function 'pg_catalog.float48pl(real, double precision) double precision' on db.
func Float48pl(ctx context.Context, db DB, p0 float32, p1 float64) (float64, error) {
	// call pg_catalog.float48pl
	const sqlstr = `SELECT * FROM pg_catalog.float48pl($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4Accum calls the stored function 'pg_catalog.float4_accum(double precision, real) double precision' on db.
func Float4Accum(ctx context.Context, db DB, p0 []float64, p1 float32) ([]float64, error) {
	// call pg_catalog.float4_accum
	const sqlstr = `SELECT * FROM pg_catalog.float4_accum($1, $2)`
	// run
	var r0 []float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Float4abs calls the stored function 'pg_catalog.float4abs(real) real' on db.
func Float4abs(ctx context.Context, db DB, p0 float32) (float32, error) {
	// call pg_catalog.float4abs
	const sqlstr = `SELECT * FROM pg_catalog.float4abs($1)`
	// run
	var r0 float32
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4div calls the stored function 'pg_catalog.float4div(real, real) real' on db.
func Float4div(ctx context.Context, db DB, p0, p1 float32) (float32, error) {
	// call pg_catalog.float4div
	const sqlstr = `SELECT * FROM pg_catalog.float4div($1, $2)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4eq calls the stored function 'pg_catalog.float4eq(real, real) boolean' on db.
func Float4eq(ctx context.Context, db DB, p0, p1 float32) (bool, error) {
	// call pg_catalog.float4eq
	const sqlstr = `SELECT * FROM pg_catalog.float4eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float4ge calls the stored function 'pg_catalog.float4ge(real, real) boolean' on db.
func Float4ge(ctx context.Context, db DB, p0, p1 float32) (bool, error) {
	// call pg_catalog.float4ge
	const sqlstr = `SELECT * FROM pg_catalog.float4ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float4gt calls the stored function 'pg_catalog.float4gt(real, real) boolean' on db.
func Float4gt(ctx context.Context, db DB, p0, p1 float32) (bool, error) {
	// call pg_catalog.float4gt
	const sqlstr = `SELECT * FROM pg_catalog.float4gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float4larger calls the stored function 'pg_catalog.float4larger(real, real) real' on db.
func Float4larger(ctx context.Context, db DB, p0, p1 float32) (float32, error) {
	// call pg_catalog.float4larger
	const sqlstr = `SELECT * FROM pg_catalog.float4larger($1, $2)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4le calls the stored function 'pg_catalog.float4le(real, real) boolean' on db.
func Float4le(ctx context.Context, db DB, p0, p1 float32) (bool, error) {
	// call pg_catalog.float4le
	const sqlstr = `SELECT * FROM pg_catalog.float4le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float4lt calls the stored function 'pg_catalog.float4lt(real, real) boolean' on db.
func Float4lt(ctx context.Context, db DB, p0, p1 float32) (bool, error) {
	// call pg_catalog.float4lt
	const sqlstr = `SELECT * FROM pg_catalog.float4lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float4mi calls the stored function 'pg_catalog.float4mi(real, real) real' on db.
func Float4mi(ctx context.Context, db DB, p0, p1 float32) (float32, error) {
	// call pg_catalog.float4mi
	const sqlstr = `SELECT * FROM pg_catalog.float4mi($1, $2)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4mul calls the stored function 'pg_catalog.float4mul(real, real) real' on db.
func Float4mul(ctx context.Context, db DB, p0, p1 float32) (float32, error) {
	// call pg_catalog.float4mul
	const sqlstr = `SELECT * FROM pg_catalog.float4mul($1, $2)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4ne calls the stored function 'pg_catalog.float4ne(real, real) boolean' on db.
func Float4ne(ctx context.Context, db DB, p0, p1 float32) (bool, error) {
	// call pg_catalog.float4ne
	const sqlstr = `SELECT * FROM pg_catalog.float4ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float4pl calls the stored function 'pg_catalog.float4pl(real, real) real' on db.
func Float4pl(ctx context.Context, db DB, p0, p1 float32) (float32, error) {
	// call pg_catalog.float4pl
	const sqlstr = `SELECT * FROM pg_catalog.float4pl($1, $2)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4recv calls the stored function 'pg_catalog.float4recv(internal) real' on db.
func Float4recv(ctx context.Context, db DB, p0 pgtypes.Internal) (float32, error) {
	// call pg_catalog.float4recv
	const sqlstr = `SELECT * FROM pg_catalog.float4recv($1)`
	// run
	var r0 float32
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4send calls the stored function 'pg_catalog.float4send(real) bytea' on db.
func Float4send(ctx context.Context, db DB, p0 float32) ([]byte, error) {
	// call pg_catalog.float4send
	const sqlstr = `SELECT * FROM pg_catalog.float4send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Float4smaller calls the stored function 'pg_catalog.float4smaller(real, real) real' on db.
func Float4smaller(ctx context.Context, db DB, p0, p1 float32) (float32, error) {
	// call pg_catalog.float4smaller
	const sqlstr = `SELECT * FROM pg_catalog.float4smaller($1, $2)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4um calls the stored function 'pg_catalog.float4um(real) real' on db.
func Float4um(ctx context.Context, db DB, p0 float32) (float32, error) {
	// call pg_catalog.float4um
	const sqlstr = `SELECT * FROM pg_catalog.float4um($1)`
	// run
	var r0 float32
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float4up calls the stored function 'pg_catalog.float4up(real) real' on db.
func Float4up(ctx context.Context, db DB, p0 float32) (float32, error) {
	// call pg_catalog.float4up
	const sqlstr = `SELECT * FROM pg_catalog.float4up($1)`
	// run
	var r0 float32
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8ByNumeric calls the stored function 'pg_catalog.float8(numeric) double precision' on db.
func Float8ByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.float8
	const sqlstr = `SELECT * FROM pg_catalog.float8($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8BySmallint calls the stored function 'pg_catalog.float8(smallint) double precision' on db.
func Float8BySmallint(ctx context.Context, db DB, p0 int16) (float64, error) {
	// call pg_catalog.float8
	const sqlstr = `SELECT * FROM pg_catalog.float8($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8ByJsonb calls the stored function 'pg_catalog.float8(jsonb) double precision' on db.
func Float8ByJsonb(ctx context.Context, db DB, p0 []byte) (float64, error) {
	// call pg_catalog.float8
	const sqlstr = `SELECT * FROM pg_catalog.float8($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8ByReal calls the stored function 'pg_catalog.float8(real) double precision' on db.
func Float8ByReal(ctx context.Context, db DB, p0 float32) (float64, error) {
	// call pg_catalog.float8
	const sqlstr = `SELECT * FROM pg_catalog.float8($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8ByInteger calls the stored function 'pg_catalog.float8(integer) double precision' on db.
func Float8ByInteger(ctx context.Context, db DB, p0 int) (float64, error) {
	// call pg_catalog.float8
	const sqlstr = `SELECT * FROM pg_catalog.float8($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8ByBigint calls the stored function 'pg_catalog.float8(bigint) double precision' on db.
func Float8ByBigint(ctx context.Context, db DB, p0 int64) (float64, error) {
	// call pg_catalog.float8
	const sqlstr = `SELECT * FROM pg_catalog.float8($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float84div calls the stored function 'pg_catalog.float84div(double precision, real) double precision' on db.
func Float84div(ctx context.Context, db DB, p0 float64, p1 float32) (float64, error) {
	// call pg_catalog.float84div
	const sqlstr = `SELECT * FROM pg_catalog.float84div($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float84eq calls the stored function 'pg_catalog.float84eq(double precision, real) boolean' on db.
func Float84eq(ctx context.Context, db DB, p0 float64, p1 float32) (bool, error) {
	// call pg_catalog.float84eq
	const sqlstr = `SELECT * FROM pg_catalog.float84eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float84ge calls the stored function 'pg_catalog.float84ge(double precision, real) boolean' on db.
func Float84ge(ctx context.Context, db DB, p0 float64, p1 float32) (bool, error) {
	// call pg_catalog.float84ge
	const sqlstr = `SELECT * FROM pg_catalog.float84ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float84gt calls the stored function 'pg_catalog.float84gt(double precision, real) boolean' on db.
func Float84gt(ctx context.Context, db DB, p0 float64, p1 float32) (bool, error) {
	// call pg_catalog.float84gt
	const sqlstr = `SELECT * FROM pg_catalog.float84gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float84le calls the stored function 'pg_catalog.float84le(double precision, real) boolean' on db.
func Float84le(ctx context.Context, db DB, p0 float64, p1 float32) (bool, error) {
	// call pg_catalog.float84le
	const sqlstr = `SELECT * FROM pg_catalog.float84le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float84lt calls the stored function 'pg_catalog.float84lt(double precision, real) boolean' on db.
func Float84lt(ctx context.Context, db DB, p0 float64, p1 float32) (bool, error) {
	// call pg_catalog.float84lt
	const sqlstr = `SELECT * FROM pg_catalog.float84lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float84mi calls the stored function 'pg_catalog.float84mi(double precision, real) double precision' on db.
func Float84mi(ctx context.Context, db DB, p0 float64, p1 float32) (float64, error) {
	// call pg_catalog.float84mi
	const sqlstr = `SELECT * FROM pg_catalog.float84mi($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float84mul calls the stored function 'pg_catalog.float84mul(double precision, real) double precision' on db.
func Float84mul(ctx context.Context, db DB, p0 float64, p1 float32) (float64, error) {
	// call pg_catalog.float84mul
	const sqlstr = `SELECT * FROM pg_catalog.float84mul($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float84ne calls the stored function 'pg_catalog.float84ne(double precision, real) boolean' on db.
func Float84ne(ctx context.Context, db DB, p0 float64, p1 float32) (bool, error) {
	// call pg_catalog.float84ne
	const sqlstr = `SELECT * FROM pg_catalog.float84ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float84pl calls the stored function 'pg_catalog.float84pl(double precision, real) double precision' on db.
func Float84pl(ctx context.Context, db DB, p0 float64, p1 float32) (float64, error) {
	// call pg_catalog.float84pl
	const sqlstr = `SELECT * FROM pg_catalog.float84pl($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8Accum calls the stored function 'pg_catalog.float8_accum(double precision, double precision) double precision' on db.
func Float8Accum(ctx context.Context, db DB, p0 []float64, p1 float64) ([]float64, error) {
	// call pg_catalog.float8_accum
	const sqlstr = `SELECT * FROM pg_catalog.float8_accum($1, $2)`
	// run
	var r0 []float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Float8Avg calls the stored function 'pg_catalog.float8_avg(double precision) double precision' on db.
func Float8Avg(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_avg
	const sqlstr = `SELECT * FROM pg_catalog.float8_avg($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8Combine calls the stored function 'pg_catalog.float8_combine(double precision, double precision) double precision' on db.
func Float8Combine(ctx context.Context, db DB, p0, p1 []float64) ([]float64, error) {
	// call pg_catalog.float8_combine
	const sqlstr = `SELECT * FROM pg_catalog.float8_combine($1, $2)`
	// run
	var r0 []float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Float8Corr calls the stored function 'pg_catalog.float8_corr(double precision) double precision' on db.
func Float8Corr(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_corr
	const sqlstr = `SELECT * FROM pg_catalog.float8_corr($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8CovarPop calls the stored function 'pg_catalog.float8_covar_pop(double precision) double precision' on db.
func Float8CovarPop(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_covar_pop
	const sqlstr = `SELECT * FROM pg_catalog.float8_covar_pop($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8CovarSamp calls the stored function 'pg_catalog.float8_covar_samp(double precision) double precision' on db.
func Float8CovarSamp(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_covar_samp
	const sqlstr = `SELECT * FROM pg_catalog.float8_covar_samp($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8RegrAccum calls the stored function 'pg_catalog.float8_regr_accum(double precision, double precision, double precision) double precision' on db.
func Float8RegrAccum(ctx context.Context, db DB, p0 []float64, p1, p2 float64) ([]float64, error) {
	// call pg_catalog.float8_regr_accum
	const sqlstr = `SELECT * FROM pg_catalog.float8_regr_accum($1, $2, $3)`
	// run
	var r0 []float64
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Float8RegrAvgx calls the stored function 'pg_catalog.float8_regr_avgx(double precision) double precision' on db.
func Float8RegrAvgx(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_avgx
	const sqlstr = `SELECT * FROM pg_catalog.float8_regr_avgx($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8RegrAvgy calls the stored function 'pg_catalog.float8_regr_avgy(double precision) double precision' on db.
func Float8RegrAvgy(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_avgy
	const sqlstr = `SELECT * FROM pg_catalog.float8_regr_avgy($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8RegrCombine calls the stored function 'pg_catalog.float8_regr_combine(double precision, double precision) double precision' on db.
func Float8RegrCombine(ctx context.Context, db DB, p0, p1 []float64) ([]float64, error) {
	// call pg_catalog.float8_regr_combine
	const sqlstr = `SELECT * FROM pg_catalog.float8_regr_combine($1, $2)`
	// run
	var r0 []float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Float8RegrIntercept calls the stored function 'pg_catalog.float8_regr_intercept(double precision) double precision' on db.
func Float8RegrIntercept(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_intercept
	const sqlstr = `SELECT * FROM pg_catalog.float8_regr_intercept($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8RegrR2 calls the stored function 'pg_catalog.float8_regr_r2(double precision) double precision' on db.
func Float8RegrR2(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_r2
	const sqlstr = `SELECT * FROM pg_catalog.float8_regr_r2($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8RegrSlope calls the stored function 'pg_catalog.float8_regr_slope(double precision) double precision' on db.
func Float8RegrSlope(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_slope
	const sqlstr = `SELECT * FROM pg_catalog.float8_regr_slope($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8RegrSxx calls the stored function 'pg_catalog.float8_regr_sxx(double precision) double precision' on db.
func Float8RegrSxx(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_sxx
	const sqlstr = `SELECT * FROM pg_catalog.float8_regr_sxx($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8RegrSxy calls the stored function 'pg_catalog.float8_regr_sxy(double precision) double precision' on db.
func Float8RegrSxy(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_sxy
	const sqlstr = `SELECT * FROM pg_catalog.float8_regr_sxy($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8RegrSyy calls the stored function 'pg_catalog.float8_regr_syy(double precision) double precision' on db.
func Float8RegrSyy(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_regr_syy
	const sqlstr = `SELECT * FROM pg_catalog.float8_regr_syy($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8StddevPop calls the stored function 'pg_catalog.float8_stddev_pop(double precision) double precision' on db.
func Float8StddevPop(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_stddev_pop
	const sqlstr = `SELECT * FROM pg_catalog.float8_stddev_pop($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8StddevSamp calls the stored function 'pg_catalog.float8_stddev_samp(double precision) double precision' on db.
func Float8StddevSamp(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_stddev_samp
	const sqlstr = `SELECT * FROM pg_catalog.float8_stddev_samp($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8VarPop calls the stored function 'pg_catalog.float8_var_pop(double precision) double precision' on db.
func Float8VarPop(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_var_pop
	const sqlstr = `SELECT * FROM pg_catalog.float8_var_pop($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8VarSamp calls the stored function 'pg_catalog.float8_var_samp(double precision) double precision' on db.
func Float8VarSamp(ctx context.Context, db DB, p0 []float64) (float64, error) {
	// call pg_catalog.float8_var_samp
	const sqlstr = `SELECT * FROM pg_catalog.float8_var_samp($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8abs calls the stored function 'pg_catalog.float8abs(double precision) double precision' on db.
func Float8abs(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.float8abs
	const sqlstr = `SELECT * FROM pg_catalog.float8abs($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8div calls the stored function 'pg_catalog.float8div(double precision, double precision) double precision' on db.
func Float8div(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.float8div
	const sqlstr = `SELECT * FROM pg_catalog.float8div($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8eq calls the stored function 'pg_catalog.float8eq(double precision, double precision) boolean' on db.
func Float8eq(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.float8eq
	const sqlstr = `SELECT * FROM pg_catalog.float8eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float8ge calls the stored function 'pg_catalog.float8ge(double precision, double precision) boolean' on db.
func Float8ge(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.float8ge
	const sqlstr = `SELECT * FROM pg_catalog.float8ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float8gt calls the stored function 'pg_catalog.float8gt(double precision, double precision) boolean' on db.
func Float8gt(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.float8gt
	const sqlstr = `SELECT * FROM pg_catalog.float8gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float8larger calls the stored function 'pg_catalog.float8larger(double precision, double precision) double precision' on db.
func Float8larger(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.float8larger
	const sqlstr = `SELECT * FROM pg_catalog.float8larger($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8le calls the stored function 'pg_catalog.float8le(double precision, double precision) boolean' on db.
func Float8le(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.float8le
	const sqlstr = `SELECT * FROM pg_catalog.float8le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float8lt calls the stored function 'pg_catalog.float8lt(double precision, double precision) boolean' on db.
func Float8lt(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.float8lt
	const sqlstr = `SELECT * FROM pg_catalog.float8lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float8mi calls the stored function 'pg_catalog.float8mi(double precision, double precision) double precision' on db.
func Float8mi(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.float8mi
	const sqlstr = `SELECT * FROM pg_catalog.float8mi($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8mul calls the stored function 'pg_catalog.float8mul(double precision, double precision) double precision' on db.
func Float8mul(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.float8mul
	const sqlstr = `SELECT * FROM pg_catalog.float8mul($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8ne calls the stored function 'pg_catalog.float8ne(double precision, double precision) boolean' on db.
func Float8ne(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.float8ne
	const sqlstr = `SELECT * FROM pg_catalog.float8ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Float8pl calls the stored function 'pg_catalog.float8pl(double precision, double precision) double precision' on db.
func Float8pl(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.float8pl
	const sqlstr = `SELECT * FROM pg_catalog.float8pl($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8recv calls the stored function 'pg_catalog.float8recv(internal) double precision' on db.
func Float8recv(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.float8recv
	const sqlstr = `SELECT * FROM pg_catalog.float8recv($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8send calls the stored function 'pg_catalog.float8send(double precision) bytea' on db.
func Float8send(ctx context.Context, db DB, p0 float64) ([]byte, error) {
	// call pg_catalog.float8send
	const sqlstr = `SELECT * FROM pg_catalog.float8send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Float8smaller calls the stored function 'pg_catalog.float8smaller(double precision, double precision) double precision' on db.
func Float8smaller(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.float8smaller
	const sqlstr = `SELECT * FROM pg_catalog.float8smaller($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8um calls the stored function 'pg_catalog.float8um(double precision) double precision' on db.
func Float8um(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.float8um
	const sqlstr = `SELECT * FROM pg_catalog.float8um($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Float8up calls the stored function 'pg_catalog.float8up(double precision) double precision' on db.
func Float8up(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.float8up
	const sqlstr = `SELECT * FROM pg_catalog.float8up($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// FloorByNumeric calls the stored function 'pg_catalog.floor(numeric) numeric' on db.
func FloorByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.floor
	const sqlstr = `SELECT * FROM pg_catalog.floor($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// FloorByDoublePrecision calls the stored function 'pg_catalog.floor(double precision) double precision' on db.
func FloorByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.floor
	const sqlstr = `SELECT * FROM pg_catalog.floor($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Flt4MulCash calls the stored function 'pg_catalog.flt4_mul_cash(real, money) money' on db.
func Flt4MulCash(ctx context.Context, db DB, p0 float32, p1 string) (string, error) {
	// call pg_catalog.flt4_mul_cash
	const sqlstr = `SELECT * FROM pg_catalog.flt4_mul_cash($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Flt8MulCash calls the stored function 'pg_catalog.flt8_mul_cash(double precision, money) money' on db.
func Flt8MulCash(ctx context.Context, db DB, p0 float64, p1 string) (string, error) {
	// call pg_catalog.flt8_mul_cash
	const sqlstr = `SELECT * FROM pg_catalog.flt8_mul_cash($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// FmgrCValidator calls the stored function 'pg_catalog.fmgr_c_validator(oid)' on db.
func FmgrCValidator(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.fmgr_c_validator
	const sqlstr = `SELECT * FROM pg_catalog.fmgr_c_validator($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// FmgrInternalValidator calls the stored function 'pg_catalog.fmgr_internal_validator(oid)' on db.
func FmgrInternalValidator(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.fmgr_internal_validator
	const sqlstr = `SELECT * FROM pg_catalog.fmgr_internal_validator($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// FmgrSQLValidator calls the stored function 'pg_catalog.fmgr_sql_validator(oid)' on db.
func FmgrSQLValidator(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.fmgr_sql_validator
	const sqlstr = `SELECT * FROM pg_catalog.fmgr_sql_validator($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// Format calls the stored function 'pg_catalog.format(text) text' on db.
func Format(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.format
	const sqlstr = `SELECT * FROM pg_catalog.format($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// FormatType calls the stored function 'pg_catalog.format_type(oid, integer) text' on db.
func FormatType(ctx context.Context, db DB, p0 pgtypes.Oid, p1 int) (string, error) {
	// call pg_catalog.format_type
	const sqlstr = `SELECT * FROM pg_catalog.format_type($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Gb18030ToUTF8 calls the stored function 'pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer)' on db.
func Gb18030ToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.gb18030_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.gb18030_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// GbkToUTF8 calls the stored function 'pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer)' on db.
func GbkToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.gbk_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.gbk_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// GcdByIntegerAndInteger calls the stored function 'pg_catalog.gcd(integer, integer) integer' on db.
func GcdByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.gcd
	const sqlstr = `SELECT * FROM pg_catalog.gcd($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GcdByBigintAndBigint calls the stored function 'pg_catalog.gcd(bigint, bigint) bigint' on db.
func GcdByBigintAndBigint(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.gcd
	const sqlstr = `SELECT * FROM pg_catalog.gcd($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GcdByNumericAndNumeric calls the stored function 'pg_catalog.gcd(numeric, numeric) numeric' on db.
func GcdByNumericAndNumeric(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.gcd
	const sqlstr = `SELECT * FROM pg_catalog.gcd($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// GenRandomUUID calls the stored function 'pg_catalog.gen_random_uuid() uuid' on db.
func GenRandomUUID(ctx context.Context, db DB) (uuid.UUID, error) {
	// call pg_catalog.gen_random_uuid
	const sqlstr = `SELECT * FROM pg_catalog.gen_random_uuid()`
	// run
	var r0 uuid.UUID
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return uuid.UUID{}, logerror(err)
	}
	return r0, nil
}

// GenerateSeriesByIntegerIntegerAndInteger calls the stored function 'pg_catalog.generate_series(integer, integer, integer) integer' on db.
func GenerateSeriesByIntegerIntegerAndInteger(ctx context.Context, db DB, p0, p1, p2 int) (int, error) {
	// call pg_catalog.generate_series
	const sqlstr = `SELECT * FROM pg_catalog.generate_series($1, $2, $3)`
	// run
	var r0 int
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GenerateSeriesByIntegerAndInteger calls the stored function 'pg_catalog.generate_series(integer, integer) integer' on db.
func GenerateSeriesByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.generate_series
	const sqlstr = `SELECT * FROM pg_catalog.generate_series($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GenerateSeriesByBigintBigintAndBigint calls the stored function 'pg_catalog.generate_series(bigint, bigint, bigint) bigint' on db.
func GenerateSeriesByBigintBigintAndBigint(ctx context.Context, db DB, p0, p1, p2 int64) (int64, error) {
	// call pg_catalog.generate_series
	const sqlstr = `SELECT * FROM pg_catalog.generate_series($1, $2, $3)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GenerateSeriesByBigintAndBigint calls the stored function 'pg_catalog.generate_series(bigint, bigint) bigint' on db.
func GenerateSeriesByBigintAndBigint(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.generate_series
	const sqlstr = `SELECT * FROM pg_catalog.generate_series($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GenerateSeriesByNumericNumericAndNumeric calls the stored function 'pg_catalog.generate_series(numeric, numeric, numeric) numeric' on db.
func GenerateSeriesByNumericNumericAndNumeric(ctx context.Context, db DB, p0, p1, p2 float64) (float64, error) {
	// call pg_catalog.generate_series
	const sqlstr = `SELECT * FROM pg_catalog.generate_series($1, $2, $3)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// GenerateSeriesByNumericAndNumeric calls the stored function 'pg_catalog.generate_series(numeric, numeric) numeric' on db.
func GenerateSeriesByNumericAndNumeric(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.generate_series
	const sqlstr = `SELECT * FROM pg_catalog.generate_series($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// GenerateSeriesByTimestampWithoutTimeZoneTimestampWithoutTimeZoneAndInterval calls the stored function 'pg_catalog.generate_series(timestamp without time zone, timestamp without time zone, interval) timestamp without time zone' on db.
func GenerateSeriesByTimestampWithoutTimeZoneTimestampWithoutTimeZoneAndInterval(ctx context.Context, db DB, p0, p1 time.Time, p2 []byte) (time.Time, error) {
	// call pg_catalog.generate_series
	const sqlstr = `SELECT * FROM pg_catalog.generate_series($1, $2, $3)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// GenerateSeriesByTimestampWithTimeZoneTimestampWithTimeZoneAndInterval calls the stored function 'pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval) timestamp with time zone' on db.
func GenerateSeriesByTimestampWithTimeZoneTimestampWithTimeZoneAndInterval(ctx context.Context, db DB, p0, p1 time.Time, p2 []byte) (time.Time, error) {
	// call pg_catalog.generate_series
	const sqlstr = `SELECT * FROM pg_catalog.generate_series($1, $2, $3)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// GenerateSeriesInt4Support calls the stored function 'pg_catalog.generate_series_int4_support(internal) internal' on db.
func GenerateSeriesInt4Support(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.generate_series_int4_support
	const sqlstr = `SELECT * FROM pg_catalog.generate_series_int4_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GenerateSeriesInt8Support calls the stored function 'pg_catalog.generate_series_int8_support(internal) internal' on db.
func GenerateSeriesInt8Support(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.generate_series_int8_support
	const sqlstr = `SELECT * FROM pg_catalog.generate_series_int8_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GenerateSubscriptsByAnyarrayIntegerAndBoolean calls the stored function 'pg_catalog.generate_subscripts(anyarray, integer, boolean) integer' on db.
func GenerateSubscriptsByAnyarrayIntegerAndBoolean(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 int, p2 bool) (int, error) {
	// call pg_catalog.generate_subscripts
	const sqlstr = `SELECT * FROM pg_catalog.generate_subscripts($1, $2, $3)`
	// run
	var r0 int
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GenerateSubscriptsByAnyarrayAndInteger calls the stored function 'pg_catalog.generate_subscripts(anyarray, integer) integer' on db.
func GenerateSubscriptsByAnyarrayAndInteger(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 int) (int, error) {
	// call pg_catalog.generate_subscripts
	const sqlstr = `SELECT * FROM pg_catalog.generate_subscripts($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GetBitByBitAndInteger calls the stored function 'pg_catalog.get_bit(bit, integer) integer' on db.
func GetBitByBitAndInteger(ctx context.Context, db DB, p0 uint8, p1 int) (int, error) {
	// call pg_catalog.get_bit
	const sqlstr = `SELECT * FROM pg_catalog.get_bit($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GetBitByByteaAndBigint calls the stored function 'pg_catalog.get_bit(bytea, bigint) integer' on db.
func GetBitByByteaAndBigint(ctx context.Context, db DB, p0 []byte, p1 int64) (int, error) {
	// call pg_catalog.get_bit
	const sqlstr = `SELECT * FROM pg_catalog.get_bit($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GetByte calls the stored function 'pg_catalog.get_byte(bytea, integer) integer' on db.
func GetByte(ctx context.Context, db DB, p0 []byte, p1 int) (int, error) {
	// call pg_catalog.get_byte
	const sqlstr = `SELECT * FROM pg_catalog.get_byte($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GetCurrentTsConfig calls the stored function 'pg_catalog.get_current_ts_config() regconfig' on db.
func GetCurrentTsConfig(ctx context.Context, db DB) (pgtypes.Regconfig, error) {
	// call pg_catalog.get_current_ts_config
	const sqlstr = `SELECT * FROM pg_catalog.get_current_ts_config()`
	// run
	var r0 pgtypes.Regconfig
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Regconfig{}, logerror(err)
	}
	return r0, nil
}

// Getdatabaseencoding calls the stored function 'pg_catalog.getdatabaseencoding() name' on db.
func Getdatabaseencoding(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.getdatabaseencoding
	const sqlstr = `SELECT * FROM pg_catalog.getdatabaseencoding()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Getpgusername calls the stored function 'pg_catalog.getpgusername() name' on db.
func Getpgusername(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.getpgusername
	const sqlstr = `SELECT * FROM pg_catalog.getpgusername()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// GinCleanPendingList calls the stored function 'pg_catalog.gin_clean_pending_list(regclass) bigint' on db.
func GinCleanPendingList(ctx context.Context, db DB, p0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.gin_clean_pending_list
	const sqlstr = `SELECT * FROM pg_catalog.gin_clean_pending_list($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GinCmpPrefix calls the stored function 'pg_catalog.gin_cmp_prefix(text, text, smallint, internal) integer' on db.
func GinCmpPrefix(ctx context.Context, db DB, p0, p1 string, p2 int16, p3 pgtypes.Internal) (int, error) {
	// call pg_catalog.gin_cmp_prefix
	const sqlstr = `SELECT * FROM pg_catalog.gin_cmp_prefix($1, $2, $3, $4)`
	// run
	var r0 int
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GinCmpTslexeme calls the stored function 'pg_catalog.gin_cmp_tslexeme(text, text) integer' on db.
func GinCmpTslexeme(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.gin_cmp_tslexeme
	const sqlstr = `SELECT * FROM pg_catalog.gin_cmp_tslexeme($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GinCompareJsonb calls the stored function 'pg_catalog.gin_compare_jsonb(text, text) integer' on db.
func GinCompareJsonb(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.gin_compare_jsonb
	const sqlstr = `SELECT * FROM pg_catalog.gin_compare_jsonb($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GinConsistentJsonb calls the stored function 'pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal, internal) boolean' on db.
func GinConsistentJsonb(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16, p2 []byte, p3 int, p4, p5, p6, p7 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gin_consistent_jsonb
	const sqlstr = `SELECT * FROM pg_catalog.gin_consistent_jsonb($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6, p7)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6, p7).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GinConsistentJsonbPath calls the stored function 'pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal, internal) boolean' on db.
func GinConsistentJsonbPath(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16, p2 []byte, p3 int, p4, p5, p6, p7 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gin_consistent_jsonb_path
	const sqlstr = `SELECT * FROM pg_catalog.gin_consistent_jsonb_path($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6, p7)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6, p7).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GinExtractJsonb calls the stored function 'pg_catalog.gin_extract_jsonb(jsonb, internal, internal) internal' on db.
func GinExtractJsonb(ctx context.Context, db DB, p0 []byte, p1, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_jsonb
	const sqlstr = `SELECT * FROM pg_catalog.gin_extract_jsonb($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GinExtractJsonbPath calls the stored function 'pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal) internal' on db.
func GinExtractJsonbPath(ctx context.Context, db DB, p0 []byte, p1, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_jsonb_path
	const sqlstr = `SELECT * FROM pg_catalog.gin_extract_jsonb_path($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GinExtractJsonbQuery calls the stored function 'pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal) internal' on db.
func GinExtractJsonbQuery(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Internal, p2 int16, p3, p4, p5, p6 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_jsonb_query
	const sqlstr = `SELECT * FROM pg_catalog.gin_extract_jsonb_query($1, $2, $3, $4, $5, $6, $7)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GinExtractJsonbQueryPath calls the stored function 'pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal) internal' on db.
func GinExtractJsonbQueryPath(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Internal, p2 int16, p3, p4, p5, p6 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_jsonb_query_path
	const sqlstr = `SELECT * FROM pg_catalog.gin_extract_jsonb_query_path($1, $2, $3, $4, $5, $6, $7)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GinExtractTsqueryByTsqueryInternalSmallintInternalAndInternal calls the stored function 'pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal) internal' on db.
func GinExtractTsqueryByTsqueryInternalSmallintInternalAndInternal(ctx context.Context, db DB, p0 pgtypes.Tsquery, p1 pgtypes.Internal, p2 int16, p3, p4 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_tsquery
	const sqlstr = `SELECT * FROM pg_catalog.gin_extract_tsquery($1, $2, $3, $4, $5)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GinExtractTsqueryByTsvectorInternalSmallintInternalInternalInternalAndInternal calls the stored function 'pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal) internal' on db.
func GinExtractTsqueryByTsvectorInternalSmallintInternalInternalInternalAndInternal(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 pgtypes.Internal, p2 int16, p3, p4, p5, p6 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_tsquery
	const sqlstr = `SELECT * FROM pg_catalog.gin_extract_tsquery($1, $2, $3, $4, $5, $6, $7)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GinExtractTsqueryByTsqueryInternalSmallintInternalInternalInternalAndInternal calls the stored function 'pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal) internal' on db.
func GinExtractTsqueryByTsqueryInternalSmallintInternalInternalInternalAndInternal(ctx context.Context, db DB, p0 pgtypes.Tsquery, p1 pgtypes.Internal, p2 int16, p3, p4, p5, p6 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_tsquery
	const sqlstr = `SELECT * FROM pg_catalog.gin_extract_tsquery($1, $2, $3, $4, $5, $6, $7)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GinExtractTsvectorByTsvectorAndInternal calls the stored function 'pg_catalog.gin_extract_tsvector(tsvector, internal) internal' on db.
func GinExtractTsvectorByTsvectorAndInternal(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.gin_extract_tsvector($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GinExtractTsvectorByTsvectorInternalAndInternal calls the stored function 'pg_catalog.gin_extract_tsvector(tsvector, internal, internal) internal' on db.
func GinExtractTsvectorByTsvectorInternalAndInternal(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gin_extract_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.gin_extract_tsvector($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GinTriconsistentJsonb calls the stored function 'pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal) "char"' on db.
func GinTriconsistentJsonb(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16, p2 []byte, p3 int, p4, p5, p6 pgtypes.Internal) (pgtypes.Char, error) {
	// call pg_catalog.gin_triconsistent_jsonb
	const sqlstr = `SELECT * FROM pg_catalog.gin_triconsistent_jsonb($1, $2, $3, $4, $5, $6, $7)`
	// run
	var r0 pgtypes.Char
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6).Scan(&r0); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return r0, nil
}

// GinTriconsistentJsonbPath calls the stored function 'pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal) "char"' on db.
func GinTriconsistentJsonbPath(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16, p2 []byte, p3 int, p4, p5, p6 pgtypes.Internal) (pgtypes.Char, error) {
	// call pg_catalog.gin_triconsistent_jsonb_path
	const sqlstr = `SELECT * FROM pg_catalog.gin_triconsistent_jsonb_path($1, $2, $3, $4, $5, $6, $7)`
	// run
	var r0 pgtypes.Char
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6).Scan(&r0); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return r0, nil
}

// GinTsqueryConsistentByInternalSmallintTsqueryIntegerInternalAndInternal calls the stored function 'pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal) boolean' on db.
func GinTsqueryConsistentByInternalSmallintTsqueryIntegerInternalAndInternal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16, p2 pgtypes.Tsquery, p3 int, p4, p5 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gin_tsquery_consistent
	const sqlstr = `SELECT * FROM pg_catalog.gin_tsquery_consistent($1, $2, $3, $4, $5, $6)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4, p5)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GinTsqueryConsistentByInternalSmallintTsvectorIntegerInternalInternalInternalAndInternal calls the stored function 'pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal, internal) boolean' on db.
func GinTsqueryConsistentByInternalSmallintTsvectorIntegerInternalInternalInternalAndInternal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16, p2 pgtypes.Tsvector, p3 int, p4, p5, p6, p7 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gin_tsquery_consistent
	const sqlstr = `SELECT * FROM pg_catalog.gin_tsquery_consistent($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6, p7)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6, p7).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GinTsqueryConsistentByInternalSmallintTsqueryIntegerInternalInternalInternalAndInternal calls the stored function 'pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal, internal) boolean' on db.
func GinTsqueryConsistentByInternalSmallintTsqueryIntegerInternalInternalInternalAndInternal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16, p2 pgtypes.Tsquery, p3 int, p4, p5, p6, p7 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gin_tsquery_consistent
	const sqlstr = `SELECT * FROM pg_catalog.gin_tsquery_consistent($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6, p7)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6, p7).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GinTsqueryTriconsistent calls the stored function 'pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal) "char"' on db.
func GinTsqueryTriconsistent(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16, p2 pgtypes.Tsvector, p3 int, p4, p5, p6 pgtypes.Internal) (pgtypes.Char, error) {
	// call pg_catalog.gin_tsquery_triconsistent
	const sqlstr = `SELECT * FROM pg_catalog.gin_tsquery_triconsistent($1, $2, $3, $4, $5, $6, $7)`
	// run
	var r0 pgtypes.Char
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6).Scan(&r0); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return r0, nil
}

// Ginarrayconsistent calls the stored function 'pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal, internal) boolean' on db.
func Ginarrayconsistent(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16, p2 pgtypes.Anyarray, p3 int, p4, p5, p6, p7 pgtypes.Internal) (bool, error) {
	// call pg_catalog.ginarrayconsistent
	const sqlstr = `SELECT * FROM pg_catalog.ginarrayconsistent($1, $2, $3, $4, $5, $6, $7, $8)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6, p7)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6, p7).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GinarrayextractByAnyarrayInternalAndInternal calls the stored function 'pg_catalog.ginarrayextract(anyarray, internal, internal) internal' on db.
func GinarrayextractByAnyarrayInternalAndInternal(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.ginarrayextract
	const sqlstr = `SELECT * FROM pg_catalog.ginarrayextract($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GinarrayextractByAnyarrayAndInternal calls the stored function 'pg_catalog.ginarrayextract(anyarray, internal) internal' on db.
func GinarrayextractByAnyarrayAndInternal(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.ginarrayextract
	const sqlstr = `SELECT * FROM pg_catalog.ginarrayextract($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Ginarraytriconsistent calls the stored function 'pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal) "char"' on db.
func Ginarraytriconsistent(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16, p2 pgtypes.Anyarray, p3 int, p4, p5, p6 pgtypes.Internal) (pgtypes.Char, error) {
	// call pg_catalog.ginarraytriconsistent
	const sqlstr = `SELECT * FROM pg_catalog.ginarraytriconsistent($1, $2, $3, $4, $5, $6, $7)`
	// run
	var r0 pgtypes.Char
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6).Scan(&r0); err != nil {
		return pgtypes.Char{}, logerror(err)
	}
	return r0, nil
}

// Ginhandler calls the stored function 'pg_catalog.ginhandler(internal) index_am_handler' on db.
func Ginhandler(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.ginhandler
	const sqlstr = `SELECT * FROM pg_catalog.ginhandler($1)`
	// run
	var r0 pgtypes.IndexAmHandler
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return r0, nil
}

// Ginqueryarrayextract calls the stored function 'pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal) internal' on db.
func Ginqueryarrayextract(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 pgtypes.Internal, p2 int16, p3, p4, p5, p6 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.ginqueryarrayextract
	const sqlstr = `SELECT * FROM pg_catalog.ginqueryarrayextract($1, $2, $3, $4, $5, $6, $7)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2, p3, p4, p5, p6)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4, p5, p6).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GistBoxConsistent calls the stored function 'pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal) boolean' on db.
func GistBoxConsistent(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Box, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gist_box_consistent
	const sqlstr = `SELECT * FROM pg_catalog.gist_box_consistent($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GistBoxDistance calls the stored function 'pg_catalog.gist_box_distance(internal, box, smallint, oid, internal) double precision' on db.
func GistBoxDistance(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Box, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.gist_box_distance
	const sqlstr = `SELECT * FROM pg_catalog.gist_box_distance($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// GistBoxPenalty calls the stored function 'pg_catalog.gist_box_penalty(internal, internal, internal) internal' on db.
func GistBoxPenalty(ctx context.Context, db DB, p0, p1, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_box_penalty
	const sqlstr = `SELECT * FROM pg_catalog.gist_box_penalty($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GistBoxPicksplit calls the stored function 'pg_catalog.gist_box_picksplit(internal, internal) internal' on db.
func GistBoxPicksplit(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_box_picksplit
	const sqlstr = `SELECT * FROM pg_catalog.gist_box_picksplit($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GistBoxSame calls the stored function 'pg_catalog.gist_box_same(box, box, internal) internal' on db.
func GistBoxSame(ctx context.Context, db DB, p0, p1 pgtypes.Box, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_box_same
	const sqlstr = `SELECT * FROM pg_catalog.gist_box_same($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GistBoxUnion calls the stored function 'pg_catalog.gist_box_union(internal, internal) box' on db.
func GistBoxUnion(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Box, error) {
	// call pg_catalog.gist_box_union
	const sqlstr = `SELECT * FROM pg_catalog.gist_box_union($1, $2)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// GistCircleCompress calls the stored function 'pg_catalog.gist_circle_compress(internal) internal' on db.
func GistCircleCompress(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_circle_compress
	const sqlstr = `SELECT * FROM pg_catalog.gist_circle_compress($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GistCircleConsistent calls the stored function 'pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal) boolean' on db.
func GistCircleConsistent(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Circle, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gist_circle_consistent
	const sqlstr = `SELECT * FROM pg_catalog.gist_circle_consistent($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GistCircleDistance calls the stored function 'pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal) double precision' on db.
func GistCircleDistance(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Circle, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.gist_circle_distance
	const sqlstr = `SELECT * FROM pg_catalog.gist_circle_distance($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// GistPointCompress calls the stored function 'pg_catalog.gist_point_compress(internal) internal' on db.
func GistPointCompress(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_point_compress
	const sqlstr = `SELECT * FROM pg_catalog.gist_point_compress($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GistPointConsistent calls the stored function 'pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal) boolean' on db.
func GistPointConsistent(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Point, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gist_point_consistent
	const sqlstr = `SELECT * FROM pg_catalog.gist_point_consistent($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GistPointDistance calls the stored function 'pg_catalog.gist_point_distance(internal, point, smallint, oid, internal) double precision' on db.
func GistPointDistance(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Point, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.gist_point_distance
	const sqlstr = `SELECT * FROM pg_catalog.gist_point_distance($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// GistPointFetch calls the stored function 'pg_catalog.gist_point_fetch(internal) internal' on db.
func GistPointFetch(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_point_fetch
	const sqlstr = `SELECT * FROM pg_catalog.gist_point_fetch($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GistPolyCompress calls the stored function 'pg_catalog.gist_poly_compress(internal) internal' on db.
func GistPolyCompress(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gist_poly_compress
	const sqlstr = `SELECT * FROM pg_catalog.gist_poly_compress($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GistPolyConsistent calls the stored function 'pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal) boolean' on db.
func GistPolyConsistent(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Polygon, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gist_poly_consistent
	const sqlstr = `SELECT * FROM pg_catalog.gist_poly_consistent($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GistPolyDistance calls the stored function 'pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal) double precision' on db.
func GistPolyDistance(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Polygon, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.gist_poly_distance
	const sqlstr = `SELECT * FROM pg_catalog.gist_poly_distance($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Gisthandler calls the stored function 'pg_catalog.gisthandler(internal) index_am_handler' on db.
func Gisthandler(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.gisthandler
	const sqlstr = `SELECT * FROM pg_catalog.gisthandler($1)`
	// run
	var r0 pgtypes.IndexAmHandler
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return r0, nil
}

// GtsqueryCompress calls the stored function 'pg_catalog.gtsquery_compress(internal) internal' on db.
func GtsqueryCompress(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsquery_compress
	const sqlstr = `SELECT * FROM pg_catalog.gtsquery_compress($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GtsqueryConsistentByInternalTsquerySmallintOidAndInternal calls the stored function 'pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal) boolean' on db.
func GtsqueryConsistentByInternalTsquerySmallintOidAndInternal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Tsquery, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gtsquery_consistent
	const sqlstr = `SELECT * FROM pg_catalog.gtsquery_consistent($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GtsqueryConsistentByInternalInternalIntegerOidAndInternal calls the stored function 'pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal) boolean' on db.
func GtsqueryConsistentByInternalInternalIntegerOidAndInternal(ctx context.Context, db DB, p0, p1 pgtypes.Internal, p2 int, p3 pgtypes.Oid, p4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gtsquery_consistent
	const sqlstr = `SELECT * FROM pg_catalog.gtsquery_consistent($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GtsqueryPenalty calls the stored function 'pg_catalog.gtsquery_penalty(internal, internal, internal) internal' on db.
func GtsqueryPenalty(ctx context.Context, db DB, p0, p1, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsquery_penalty
	const sqlstr = `SELECT * FROM pg_catalog.gtsquery_penalty($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GtsqueryPicksplit calls the stored function 'pg_catalog.gtsquery_picksplit(internal, internal) internal' on db.
func GtsqueryPicksplit(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsquery_picksplit
	const sqlstr = `SELECT * FROM pg_catalog.gtsquery_picksplit($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GtsquerySame calls the stored function 'pg_catalog.gtsquery_same(bigint, bigint, internal) internal' on db.
func GtsquerySame(ctx context.Context, db DB, p0, p1 int64, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsquery_same
	const sqlstr = `SELECT * FROM pg_catalog.gtsquery_same($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GtsqueryUnion calls the stored function 'pg_catalog.gtsquery_union(internal, internal) bigint' on db.
func GtsqueryUnion(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (int64, error) {
	// call pg_catalog.gtsquery_union
	const sqlstr = `SELECT * FROM pg_catalog.gtsquery_union($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// GtsvectorCompress calls the stored function 'pg_catalog.gtsvector_compress(internal) internal' on db.
func GtsvectorCompress(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsvector_compress
	const sqlstr = `SELECT * FROM pg_catalog.gtsvector_compress($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GtsvectorConsistentByInternalTsvectorSmallintOidAndInternal calls the stored function 'pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal) boolean' on db.
func GtsvectorConsistentByInternalTsvectorSmallintOidAndInternal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Tsvector, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gtsvector_consistent
	const sqlstr = `SELECT * FROM pg_catalog.gtsvector_consistent($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GtsvectorConsistentByInternalGtsvectorIntegerOidAndInternal calls the stored function 'pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal) boolean' on db.
func GtsvectorConsistentByInternalGtsvectorIntegerOidAndInternal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Gtsvector, p2 int, p3 pgtypes.Oid, p4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.gtsvector_consistent
	const sqlstr = `SELECT * FROM pg_catalog.gtsvector_consistent($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// GtsvectorDecompress calls the stored function 'pg_catalog.gtsvector_decompress(internal) internal' on db.
func GtsvectorDecompress(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsvector_decompress
	const sqlstr = `SELECT * FROM pg_catalog.gtsvector_decompress($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GtsvectorOptions calls the stored function 'pg_catalog.gtsvector_options(internal)' on db.
func GtsvectorOptions(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.gtsvector_options
	const sqlstr = `SELECT * FROM pg_catalog.gtsvector_options($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// GtsvectorPenalty calls the stored function 'pg_catalog.gtsvector_penalty(internal, internal, internal) internal' on db.
func GtsvectorPenalty(ctx context.Context, db DB, p0, p1, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsvector_penalty
	const sqlstr = `SELECT * FROM pg_catalog.gtsvector_penalty($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GtsvectorPicksplit calls the stored function 'pg_catalog.gtsvector_picksplit(internal, internal) internal' on db.
func GtsvectorPicksplit(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsvector_picksplit
	const sqlstr = `SELECT * FROM pg_catalog.gtsvector_picksplit($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GtsvectorSame calls the stored function 'pg_catalog.gtsvector_same(gtsvector, gtsvector, internal) internal' on db.
func GtsvectorSame(ctx context.Context, db DB, p0, p1 pgtypes.Gtsvector, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.gtsvector_same
	const sqlstr = `SELECT * FROM pg_catalog.gtsvector_same($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// GtsvectorUnion calls the stored function 'pg_catalog.gtsvector_union(internal, internal) gtsvector' on db.
func GtsvectorUnion(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Gtsvector, error) {
	// call pg_catalog.gtsvector_union
	const sqlstr = `SELECT * FROM pg_catalog.gtsvector_union($1, $2)`
	// run
	var r0 pgtypes.Gtsvector
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Gtsvector{}, logerror(err)
	}
	return r0, nil
}

// HasAnyColumnPrivilegeByNameTextAndText calls the stored function 'pg_catalog.has_any_column_privilege(name, text, text) boolean' on db.
func HasAnyColumnPrivilegeByNameTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_any_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_any_column_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasAnyColumnPrivilegeByNameOidAndText calls the stored function 'pg_catalog.has_any_column_privilege(name, oid, text) boolean' on db.
func HasAnyColumnPrivilegeByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_any_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_any_column_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasAnyColumnPrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_any_column_privilege(oid, text, text) boolean' on db.
func HasAnyColumnPrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_any_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_any_column_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasAnyColumnPrivilegeByOidOidAndText calls the stored function 'pg_catalog.has_any_column_privilege(oid, oid, text) boolean' on db.
func HasAnyColumnPrivilegeByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_any_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_any_column_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasAnyColumnPrivilegeByTextAndText calls the stored function 'pg_catalog.has_any_column_privilege(text, text) boolean' on db.
func HasAnyColumnPrivilegeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.has_any_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_any_column_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasAnyColumnPrivilegeByOidAndText calls the stored function 'pg_catalog.has_any_column_privilege(oid, text) boolean' on db.
func HasAnyColumnPrivilegeByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.has_any_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_any_column_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByNameTextTextAndText calls the stored function 'pg_catalog.has_column_privilege(name, text, text, text) boolean' on db.
func HasColumnPrivilegeByNameTextTextAndText(ctx context.Context, db DB, p0, p1, p2, p3 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByNameTextSmallintAndText calls the stored function 'pg_catalog.has_column_privilege(name, text, smallint, text) boolean' on db.
func HasColumnPrivilegeByNameTextSmallintAndText(ctx context.Context, db DB, p0, p1 string, p2 int16, p3 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByNameOidTextAndText calls the stored function 'pg_catalog.has_column_privilege(name, oid, text, text) boolean' on db.
func HasColumnPrivilegeByNameOidTextAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2, p3 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByNameOidSmallintAndText calls the stored function 'pg_catalog.has_column_privilege(name, oid, smallint, text) boolean' on db.
func HasColumnPrivilegeByNameOidSmallintAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 int16, p3 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByOidTextTextAndText calls the stored function 'pg_catalog.has_column_privilege(oid, text, text, text) boolean' on db.
func HasColumnPrivilegeByOidTextTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2, p3 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByOidTextSmallintAndText calls the stored function 'pg_catalog.has_column_privilege(oid, text, smallint, text) boolean' on db.
func HasColumnPrivilegeByOidTextSmallintAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string, p2 int16, p3 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByOidOidTextAndText calls the stored function 'pg_catalog.has_column_privilege(oid, oid, text, text) boolean' on db.
func HasColumnPrivilegeByOidOidTextAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2, p3 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByOidOidSmallintAndText calls the stored function 'pg_catalog.has_column_privilege(oid, oid, smallint, text) boolean' on db.
func HasColumnPrivilegeByOidOidSmallintAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 int16, p3 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByTextTextAndText calls the stored function 'pg_catalog.has_column_privilege(text, text, text) boolean' on db.
func HasColumnPrivilegeByTextTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByTextSmallintAndText calls the stored function 'pg_catalog.has_column_privilege(text, smallint, text) boolean' on db.
func HasColumnPrivilegeByTextSmallintAndText(ctx context.Context, db DB, p0 string, p1 int16, p2 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_column_privilege(oid, text, text) boolean' on db.
func HasColumnPrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasColumnPrivilegeByOidSmallintAndText calls the stored function 'pg_catalog.has_column_privilege(oid, smallint, text) boolean' on db.
func HasColumnPrivilegeByOidSmallintAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 int16, p2 string) (bool, error) {
	// call pg_catalog.has_column_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_column_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasDatabasePrivilegeByNameTextAndText calls the stored function 'pg_catalog.has_database_privilege(name, text, text) boolean' on db.
func HasDatabasePrivilegeByNameTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_database_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_database_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasDatabasePrivilegeByNameOidAndText calls the stored function 'pg_catalog.has_database_privilege(name, oid, text) boolean' on db.
func HasDatabasePrivilegeByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_database_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_database_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasDatabasePrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_database_privilege(oid, text, text) boolean' on db.
func HasDatabasePrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_database_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_database_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasDatabasePrivilegeByOidOidAndText calls the stored function 'pg_catalog.has_database_privilege(oid, oid, text) boolean' on db.
func HasDatabasePrivilegeByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_database_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_database_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasDatabasePrivilegeByTextAndText calls the stored function 'pg_catalog.has_database_privilege(text, text) boolean' on db.
func HasDatabasePrivilegeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.has_database_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_database_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasDatabasePrivilegeByOidAndText calls the stored function 'pg_catalog.has_database_privilege(oid, text) boolean' on db.
func HasDatabasePrivilegeByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.has_database_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_database_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasForeignDataWrapperPrivilegeByNameTextAndText calls the stored function 'pg_catalog.has_foreign_data_wrapper_privilege(name, text, text) boolean' on db.
func HasForeignDataWrapperPrivilegeByNameTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_foreign_data_wrapper_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_foreign_data_wrapper_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasForeignDataWrapperPrivilegeByNameOidAndText calls the stored function 'pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text) boolean' on db.
func HasForeignDataWrapperPrivilegeByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_foreign_data_wrapper_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_foreign_data_wrapper_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasForeignDataWrapperPrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text) boolean' on db.
func HasForeignDataWrapperPrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_foreign_data_wrapper_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_foreign_data_wrapper_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasForeignDataWrapperPrivilegeByOidOidAndText calls the stored function 'pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text) boolean' on db.
func HasForeignDataWrapperPrivilegeByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_foreign_data_wrapper_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_foreign_data_wrapper_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasForeignDataWrapperPrivilegeByTextAndText calls the stored function 'pg_catalog.has_foreign_data_wrapper_privilege(text, text) boolean' on db.
func HasForeignDataWrapperPrivilegeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.has_foreign_data_wrapper_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_foreign_data_wrapper_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasForeignDataWrapperPrivilegeByOidAndText calls the stored function 'pg_catalog.has_foreign_data_wrapper_privilege(oid, text) boolean' on db.
func HasForeignDataWrapperPrivilegeByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.has_foreign_data_wrapper_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_foreign_data_wrapper_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasFunctionPrivilegeByNameTextAndText calls the stored function 'pg_catalog.has_function_privilege(name, text, text) boolean' on db.
func HasFunctionPrivilegeByNameTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_function_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_function_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasFunctionPrivilegeByNameOidAndText calls the stored function 'pg_catalog.has_function_privilege(name, oid, text) boolean' on db.
func HasFunctionPrivilegeByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_function_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_function_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasFunctionPrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_function_privilege(oid, text, text) boolean' on db.
func HasFunctionPrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_function_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_function_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasFunctionPrivilegeByOidOidAndText calls the stored function 'pg_catalog.has_function_privilege(oid, oid, text) boolean' on db.
func HasFunctionPrivilegeByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_function_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_function_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasFunctionPrivilegeByTextAndText calls the stored function 'pg_catalog.has_function_privilege(text, text) boolean' on db.
func HasFunctionPrivilegeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.has_function_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_function_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasFunctionPrivilegeByOidAndText calls the stored function 'pg_catalog.has_function_privilege(oid, text) boolean' on db.
func HasFunctionPrivilegeByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.has_function_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_function_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasLanguagePrivilegeByNameTextAndText calls the stored function 'pg_catalog.has_language_privilege(name, text, text) boolean' on db.
func HasLanguagePrivilegeByNameTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_language_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_language_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasLanguagePrivilegeByNameOidAndText calls the stored function 'pg_catalog.has_language_privilege(name, oid, text) boolean' on db.
func HasLanguagePrivilegeByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_language_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_language_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasLanguagePrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_language_privilege(oid, text, text) boolean' on db.
func HasLanguagePrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_language_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_language_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasLanguagePrivilegeByOidOidAndText calls the stored function 'pg_catalog.has_language_privilege(oid, oid, text) boolean' on db.
func HasLanguagePrivilegeByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_language_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_language_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasLanguagePrivilegeByTextAndText calls the stored function 'pg_catalog.has_language_privilege(text, text) boolean' on db.
func HasLanguagePrivilegeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.has_language_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_language_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasLanguagePrivilegeByOidAndText calls the stored function 'pg_catalog.has_language_privilege(oid, text) boolean' on db.
func HasLanguagePrivilegeByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.has_language_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_language_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSchemaPrivilegeByNameTextAndText calls the stored function 'pg_catalog.has_schema_privilege(name, text, text) boolean' on db.
func HasSchemaPrivilegeByNameTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_schema_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_schema_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSchemaPrivilegeByNameOidAndText calls the stored function 'pg_catalog.has_schema_privilege(name, oid, text) boolean' on db.
func HasSchemaPrivilegeByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_schema_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_schema_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSchemaPrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_schema_privilege(oid, text, text) boolean' on db.
func HasSchemaPrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_schema_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_schema_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSchemaPrivilegeByOidOidAndText calls the stored function 'pg_catalog.has_schema_privilege(oid, oid, text) boolean' on db.
func HasSchemaPrivilegeByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_schema_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_schema_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSchemaPrivilegeByTextAndText calls the stored function 'pg_catalog.has_schema_privilege(text, text) boolean' on db.
func HasSchemaPrivilegeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.has_schema_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_schema_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSchemaPrivilegeByOidAndText calls the stored function 'pg_catalog.has_schema_privilege(oid, text) boolean' on db.
func HasSchemaPrivilegeByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.has_schema_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_schema_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSequencePrivilegeByNameTextAndText calls the stored function 'pg_catalog.has_sequence_privilege(name, text, text) boolean' on db.
func HasSequencePrivilegeByNameTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_sequence_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_sequence_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSequencePrivilegeByNameOidAndText calls the stored function 'pg_catalog.has_sequence_privilege(name, oid, text) boolean' on db.
func HasSequencePrivilegeByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_sequence_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_sequence_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSequencePrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_sequence_privilege(oid, text, text) boolean' on db.
func HasSequencePrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_sequence_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_sequence_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSequencePrivilegeByOidOidAndText calls the stored function 'pg_catalog.has_sequence_privilege(oid, oid, text) boolean' on db.
func HasSequencePrivilegeByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_sequence_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_sequence_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSequencePrivilegeByTextAndText calls the stored function 'pg_catalog.has_sequence_privilege(text, text) boolean' on db.
func HasSequencePrivilegeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.has_sequence_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_sequence_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasSequencePrivilegeByOidAndText calls the stored function 'pg_catalog.has_sequence_privilege(oid, text) boolean' on db.
func HasSequencePrivilegeByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.has_sequence_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_sequence_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasServerPrivilegeByNameTextAndText calls the stored function 'pg_catalog.has_server_privilege(name, text, text) boolean' on db.
func HasServerPrivilegeByNameTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_server_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_server_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasServerPrivilegeByNameOidAndText calls the stored function 'pg_catalog.has_server_privilege(name, oid, text) boolean' on db.
func HasServerPrivilegeByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_server_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_server_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasServerPrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_server_privilege(oid, text, text) boolean' on db.
func HasServerPrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_server_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_server_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasServerPrivilegeByOidOidAndText calls the stored function 'pg_catalog.has_server_privilege(oid, oid, text) boolean' on db.
func HasServerPrivilegeByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_server_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_server_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasServerPrivilegeByTextAndText calls the stored function 'pg_catalog.has_server_privilege(text, text) boolean' on db.
func HasServerPrivilegeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.has_server_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_server_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasServerPrivilegeByOidAndText calls the stored function 'pg_catalog.has_server_privilege(oid, text) boolean' on db.
func HasServerPrivilegeByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.has_server_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_server_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablePrivilegeByNameTextAndText calls the stored function 'pg_catalog.has_table_privilege(name, text, text) boolean' on db.
func HasTablePrivilegeByNameTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_table_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_table_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablePrivilegeByNameOidAndText calls the stored function 'pg_catalog.has_table_privilege(name, oid, text) boolean' on db.
func HasTablePrivilegeByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_table_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_table_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablePrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_table_privilege(oid, text, text) boolean' on db.
func HasTablePrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_table_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_table_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablePrivilegeByOidOidAndText calls the stored function 'pg_catalog.has_table_privilege(oid, oid, text) boolean' on db.
func HasTablePrivilegeByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_table_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_table_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablePrivilegeByTextAndText calls the stored function 'pg_catalog.has_table_privilege(text, text) boolean' on db.
func HasTablePrivilegeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.has_table_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_table_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablePrivilegeByOidAndText calls the stored function 'pg_catalog.has_table_privilege(oid, text) boolean' on db.
func HasTablePrivilegeByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.has_table_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_table_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablespacePrivilegeByNameTextAndText calls the stored function 'pg_catalog.has_tablespace_privilege(name, text, text) boolean' on db.
func HasTablespacePrivilegeByNameTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_tablespace_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_tablespace_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablespacePrivilegeByNameOidAndText calls the stored function 'pg_catalog.has_tablespace_privilege(name, oid, text) boolean' on db.
func HasTablespacePrivilegeByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_tablespace_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_tablespace_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablespacePrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_tablespace_privilege(oid, text, text) boolean' on db.
func HasTablespacePrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_tablespace_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_tablespace_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablespacePrivilegeByOidOidAndText calls the stored function 'pg_catalog.has_tablespace_privilege(oid, oid, text) boolean' on db.
func HasTablespacePrivilegeByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_tablespace_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_tablespace_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablespacePrivilegeByTextAndText calls the stored function 'pg_catalog.has_tablespace_privilege(text, text) boolean' on db.
func HasTablespacePrivilegeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.has_tablespace_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_tablespace_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTablespacePrivilegeByOidAndText calls the stored function 'pg_catalog.has_tablespace_privilege(oid, text) boolean' on db.
func HasTablespacePrivilegeByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.has_tablespace_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_tablespace_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTypePrivilegeByNameTextAndText calls the stored function 'pg_catalog.has_type_privilege(name, text, text) boolean' on db.
func HasTypePrivilegeByNameTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.has_type_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_type_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTypePrivilegeByNameOidAndText calls the stored function 'pg_catalog.has_type_privilege(name, oid, text) boolean' on db.
func HasTypePrivilegeByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_type_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_type_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTypePrivilegeByOidTextAndText calls the stored function 'pg_catalog.has_type_privilege(oid, text, text) boolean' on db.
func HasTypePrivilegeByOidTextAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.has_type_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_type_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTypePrivilegeByOidOidAndText calls the stored function 'pg_catalog.has_type_privilege(oid, oid, text) boolean' on db.
func HasTypePrivilegeByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.has_type_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_type_privilege($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTypePrivilegeByTextAndText calls the stored function 'pg_catalog.has_type_privilege(text, text) boolean' on db.
func HasTypePrivilegeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.has_type_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_type_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HasTypePrivilegeByOidAndText calls the stored function 'pg_catalog.has_type_privilege(oid, text) boolean' on db.
func HasTypePrivilegeByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.has_type_privilege
	const sqlstr = `SELECT * FROM pg_catalog.has_type_privilege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// HashAclitem calls the stored function 'pg_catalog.hash_aclitem(aclitem) integer' on db.
func HashAclitem(ctx context.Context, db DB, p0 pgtypes.Aclitem) (int, error) {
	// call pg_catalog.hash_aclitem
	const sqlstr = `SELECT * FROM pg_catalog.hash_aclitem($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// HashAclitemExtended calls the stored function 'pg_catalog.hash_aclitem_extended(aclitem, bigint) bigint' on db.
func HashAclitemExtended(ctx context.Context, db DB, p0 pgtypes.Aclitem, p1 int64) (int64, error) {
	// call pg_catalog.hash_aclitem_extended
	const sqlstr = `SELECT * FROM pg_catalog.hash_aclitem_extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// HashArray calls the stored function 'pg_catalog.hash_array(anyarray) integer' on db.
func HashArray(ctx context.Context, db DB, p0 pgtypes.Anyarray) (int, error) {
	// call pg_catalog.hash_array
	const sqlstr = `SELECT * FROM pg_catalog.hash_array($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// HashArrayExtended calls the stored function 'pg_catalog.hash_array_extended(anyarray, bigint) bigint' on db.
func HashArrayExtended(ctx context.Context, db DB, p0 pgtypes.Anyarray, p1 int64) (int64, error) {
	// call pg_catalog.hash_array_extended
	const sqlstr = `SELECT * FROM pg_catalog.hash_array_extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// HashNumeric calls the stored function 'pg_catalog.hash_numeric(numeric) integer' on db.
func HashNumeric(ctx context.Context, db DB, p0 float64) (int, error) {
	// call pg_catalog.hash_numeric
	const sqlstr = `SELECT * FROM pg_catalog.hash_numeric($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// HashNumericExtended calls the stored function 'pg_catalog.hash_numeric_extended(numeric, bigint) bigint' on db.
func HashNumericExtended(ctx context.Context, db DB, p0 float64, p1 int64) (int64, error) {
	// call pg_catalog.hash_numeric_extended
	const sqlstr = `SELECT * FROM pg_catalog.hash_numeric_extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// HashRange calls the stored function 'pg_catalog.hash_range(anyrange) integer' on db.
func HashRange(ctx context.Context, db DB, p0 pgtypes.Anyrange) (int, error) {
	// call pg_catalog.hash_range
	const sqlstr = `SELECT * FROM pg_catalog.hash_range($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// HashRangeExtended calls the stored function 'pg_catalog.hash_range_extended(anyrange, bigint) bigint' on db.
func HashRangeExtended(ctx context.Context, db DB, p0 pgtypes.Anyrange, p1 int64) (int64, error) {
	// call pg_catalog.hash_range_extended
	const sqlstr = `SELECT * FROM pg_catalog.hash_range_extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashbpchar calls the stored function 'pg_catalog.hashbpchar(character) integer' on db.
func Hashbpchar(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.hashbpchar
	const sqlstr = `SELECT * FROM pg_catalog.hashbpchar($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashbpcharextended calls the stored function 'pg_catalog.hashbpcharextended(character, bigint) bigint' on db.
func Hashbpcharextended(ctx context.Context, db DB, p0 string, p1 int64) (int64, error) {
	// call pg_catalog.hashbpcharextended
	const sqlstr = `SELECT * FROM pg_catalog.hashbpcharextended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashchar calls the stored function 'pg_catalog.hashchar("char") integer' on db.
func Hashchar(ctx context.Context, db DB, p0 pgtypes.Char) (int, error) {
	// call pg_catalog.hashchar
	const sqlstr = `SELECT * FROM pg_catalog.hashchar($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashcharextended calls the stored function 'pg_catalog.hashcharextended("char", bigint) bigint' on db.
func Hashcharextended(ctx context.Context, db DB, p0 pgtypes.Char, p1 int64) (int64, error) {
	// call pg_catalog.hashcharextended
	const sqlstr = `SELECT * FROM pg_catalog.hashcharextended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashenum calls the stored function 'pg_catalog.hashenum(anyenum) integer' on db.
func Hashenum(ctx context.Context, db DB, p0 pgtypes.Anyenum) (int, error) {
	// call pg_catalog.hashenum
	const sqlstr = `SELECT * FROM pg_catalog.hashenum($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashenumextended calls the stored function 'pg_catalog.hashenumextended(anyenum, bigint) bigint' on db.
func Hashenumextended(ctx context.Context, db DB, p0 pgtypes.Anyenum, p1 int64) (int64, error) {
	// call pg_catalog.hashenumextended
	const sqlstr = `SELECT * FROM pg_catalog.hashenumextended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashfloat4 calls the stored function 'pg_catalog.hashfloat4(real) integer' on db.
func Hashfloat4(ctx context.Context, db DB, p0 float32) (int, error) {
	// call pg_catalog.hashfloat4
	const sqlstr = `SELECT * FROM pg_catalog.hashfloat4($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashfloat4extended calls the stored function 'pg_catalog.hashfloat4extended(real, bigint) bigint' on db.
func Hashfloat4extended(ctx context.Context, db DB, p0 float32, p1 int64) (int64, error) {
	// call pg_catalog.hashfloat4extended
	const sqlstr = `SELECT * FROM pg_catalog.hashfloat4extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashfloat8 calls the stored function 'pg_catalog.hashfloat8(double precision) integer' on db.
func Hashfloat8(ctx context.Context, db DB, p0 float64) (int, error) {
	// call pg_catalog.hashfloat8
	const sqlstr = `SELECT * FROM pg_catalog.hashfloat8($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashfloat8extended calls the stored function 'pg_catalog.hashfloat8extended(double precision, bigint) bigint' on db.
func Hashfloat8extended(ctx context.Context, db DB, p0 float64, p1 int64) (int64, error) {
	// call pg_catalog.hashfloat8extended
	const sqlstr = `SELECT * FROM pg_catalog.hashfloat8extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashhandler calls the stored function 'pg_catalog.hashhandler(internal) index_am_handler' on db.
func Hashhandler(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.hashhandler
	const sqlstr = `SELECT * FROM pg_catalog.hashhandler($1)`
	// run
	var r0 pgtypes.IndexAmHandler
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return r0, nil
}

// Hashinet calls the stored function 'pg_catalog.hashinet(inet) integer' on db.
func Hashinet(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.hashinet
	const sqlstr = `SELECT * FROM pg_catalog.hashinet($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashinetextended calls the stored function 'pg_catalog.hashinetextended(inet, bigint) bigint' on db.
func Hashinetextended(ctx context.Context, db DB, p0 string, p1 int64) (int64, error) {
	// call pg_catalog.hashinetextended
	const sqlstr = `SELECT * FROM pg_catalog.hashinetextended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashint2 calls the stored function 'pg_catalog.hashint2(smallint) integer' on db.
func Hashint2(ctx context.Context, db DB, p0 int16) (int, error) {
	// call pg_catalog.hashint2
	const sqlstr = `SELECT * FROM pg_catalog.hashint2($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashint2extended calls the stored function 'pg_catalog.hashint2extended(smallint, bigint) bigint' on db.
func Hashint2extended(ctx context.Context, db DB, p0 int16, p1 int64) (int64, error) {
	// call pg_catalog.hashint2extended
	const sqlstr = `SELECT * FROM pg_catalog.hashint2extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashint4 calls the stored function 'pg_catalog.hashint4(integer) integer' on db.
func Hashint4(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.hashint4
	const sqlstr = `SELECT * FROM pg_catalog.hashint4($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashint4extended calls the stored function 'pg_catalog.hashint4extended(integer, bigint) bigint' on db.
func Hashint4extended(ctx context.Context, db DB, p0 int, p1 int64) (int64, error) {
	// call pg_catalog.hashint4extended
	const sqlstr = `SELECT * FROM pg_catalog.hashint4extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashint8 calls the stored function 'pg_catalog.hashint8(bigint) integer' on db.
func Hashint8(ctx context.Context, db DB, p0 int64) (int, error) {
	// call pg_catalog.hashint8
	const sqlstr = `SELECT * FROM pg_catalog.hashint8($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashint8extended calls the stored function 'pg_catalog.hashint8extended(bigint, bigint) bigint' on db.
func Hashint8extended(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.hashint8extended
	const sqlstr = `SELECT * FROM pg_catalog.hashint8extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashmacaddr calls the stored function 'pg_catalog.hashmacaddr(macaddr) integer' on db.
func Hashmacaddr(ctx context.Context, db DB, p0 pgtypes.Macaddr) (int, error) {
	// call pg_catalog.hashmacaddr
	const sqlstr = `SELECT * FROM pg_catalog.hashmacaddr($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashmacaddr8 calls the stored function 'pg_catalog.hashmacaddr8(macaddr8) integer' on db.
func Hashmacaddr8(ctx context.Context, db DB, p0 pgtypes.Macaddr8) (int, error) {
	// call pg_catalog.hashmacaddr8
	const sqlstr = `SELECT * FROM pg_catalog.hashmacaddr8($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashmacaddr8extended calls the stored function 'pg_catalog.hashmacaddr8extended(macaddr8, bigint) bigint' on db.
func Hashmacaddr8extended(ctx context.Context, db DB, p0 pgtypes.Macaddr8, p1 int64) (int64, error) {
	// call pg_catalog.hashmacaddr8extended
	const sqlstr = `SELECT * FROM pg_catalog.hashmacaddr8extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashmacaddrextended calls the stored function 'pg_catalog.hashmacaddrextended(macaddr, bigint) bigint' on db.
func Hashmacaddrextended(ctx context.Context, db DB, p0 pgtypes.Macaddr, p1 int64) (int64, error) {
	// call pg_catalog.hashmacaddrextended
	const sqlstr = `SELECT * FROM pg_catalog.hashmacaddrextended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashname calls the stored function 'pg_catalog.hashname(name) integer' on db.
func Hashname(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.hashname
	const sqlstr = `SELECT * FROM pg_catalog.hashname($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashnameextended calls the stored function 'pg_catalog.hashnameextended(name, bigint) bigint' on db.
func Hashnameextended(ctx context.Context, db DB, p0 string, p1 int64) (int64, error) {
	// call pg_catalog.hashnameextended
	const sqlstr = `SELECT * FROM pg_catalog.hashnameextended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashoid calls the stored function 'pg_catalog.hashoid(oid) integer' on db.
func Hashoid(ctx context.Context, db DB, p0 pgtypes.Oid) (int, error) {
	// call pg_catalog.hashoid
	const sqlstr = `SELECT * FROM pg_catalog.hashoid($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashoidextended calls the stored function 'pg_catalog.hashoidextended(oid, bigint) bigint' on db.
func Hashoidextended(ctx context.Context, db DB, p0 pgtypes.Oid, p1 int64) (int64, error) {
	// call pg_catalog.hashoidextended
	const sqlstr = `SELECT * FROM pg_catalog.hashoidextended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashoidvector calls the stored function 'pg_catalog.hashoidvector(oidvector) integer' on db.
func Hashoidvector(ctx context.Context, db DB, p0 pgtypes.Oidvector) (int, error) {
	// call pg_catalog.hashoidvector
	const sqlstr = `SELECT * FROM pg_catalog.hashoidvector($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashoidvectorextended calls the stored function 'pg_catalog.hashoidvectorextended(oidvector, bigint) bigint' on db.
func Hashoidvectorextended(ctx context.Context, db DB, p0 pgtypes.Oidvector, p1 int64) (int64, error) {
	// call pg_catalog.hashoidvectorextended
	const sqlstr = `SELECT * FROM pg_catalog.hashoidvectorextended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashtext calls the stored function 'pg_catalog.hashtext(text) integer' on db.
func Hashtext(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.hashtext
	const sqlstr = `SELECT * FROM pg_catalog.hashtext($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashtextextended calls the stored function 'pg_catalog.hashtextextended(text, bigint) bigint' on db.
func Hashtextextended(ctx context.Context, db DB, p0 string, p1 int64) (int64, error) {
	// call pg_catalog.hashtextextended
	const sqlstr = `SELECT * FROM pg_catalog.hashtextextended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashtid calls the stored function 'pg_catalog.hashtid(tid) integer' on db.
func Hashtid(ctx context.Context, db DB, p0 pgtypes.Tid) (int, error) {
	// call pg_catalog.hashtid
	const sqlstr = `SELECT * FROM pg_catalog.hashtid($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashtidextended calls the stored function 'pg_catalog.hashtidextended(tid, bigint) bigint' on db.
func Hashtidextended(ctx context.Context, db DB, p0 pgtypes.Tid, p1 int64) (int64, error) {
	// call pg_catalog.hashtidextended
	const sqlstr = `SELECT * FROM pg_catalog.hashtidextended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashvarlena calls the stored function 'pg_catalog.hashvarlena(internal) integer' on db.
func Hashvarlena(ctx context.Context, db DB, p0 pgtypes.Internal) (int, error) {
	// call pg_catalog.hashvarlena
	const sqlstr = `SELECT * FROM pg_catalog.hashvarlena($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Hashvarlenaextended calls the stored function 'pg_catalog.hashvarlenaextended(internal, bigint) bigint' on db.
func Hashvarlenaextended(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int64) (int64, error) {
	// call pg_catalog.hashvarlenaextended
	const sqlstr = `SELECT * FROM pg_catalog.hashvarlenaextended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// HeapTableamHandler calls the stored function 'pg_catalog.heap_tableam_handler(internal) table_am_handler' on db.
func HeapTableamHandler(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.TableAmHandler, error) {
	// call pg_catalog.heap_tableam_handler
	const sqlstr = `SELECT * FROM pg_catalog.heap_tableam_handler($1)`
	// run
	var r0 pgtypes.TableAmHandler
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.TableAmHandler{}, logerror(err)
	}
	return r0, nil
}

// Height calls the stored function 'pg_catalog.height(box) double precision' on db.
func Height(ctx context.Context, db DB, p0 pgtypes.Box) (float64, error) {
	// call pg_catalog.height
	const sqlstr = `SELECT * FROM pg_catalog.height($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Host calls the stored function 'pg_catalog.host(inet) text' on db.
func Host(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.host
	const sqlstr = `SELECT * FROM pg_catalog.host($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Hostmask calls the stored function 'pg_catalog.hostmask(inet) inet' on db.
func Hostmask(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.hostmask
	const sqlstr = `SELECT * FROM pg_catalog.hostmask($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Iclikejoinsel calls the stored function 'pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Iclikejoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.iclikejoinsel
	const sqlstr = `SELECT * FROM pg_catalog.iclikejoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Iclikesel calls the stored function 'pg_catalog.iclikesel(internal, oid, internal, integer) double precision' on db.
func Iclikesel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.iclikesel
	const sqlstr = `SELECT * FROM pg_catalog.iclikesel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Icnlikejoinsel calls the stored function 'pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Icnlikejoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.icnlikejoinsel
	const sqlstr = `SELECT * FROM pg_catalog.icnlikejoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Icnlikesel calls the stored function 'pg_catalog.icnlikesel(internal, oid, internal, integer) double precision' on db.
func Icnlikesel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.icnlikesel
	const sqlstr = `SELECT * FROM pg_catalog.icnlikesel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Icregexeqjoinsel calls the stored function 'pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Icregexeqjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.icregexeqjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.icregexeqjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Icregexeqsel calls the stored function 'pg_catalog.icregexeqsel(internal, oid, internal, integer) double precision' on db.
func Icregexeqsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.icregexeqsel
	const sqlstr = `SELECT * FROM pg_catalog.icregexeqsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Icregexnejoinsel calls the stored function 'pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Icregexnejoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.icregexnejoinsel
	const sqlstr = `SELECT * FROM pg_catalog.icregexnejoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Icregexnesel calls the stored function 'pg_catalog.icregexnesel(internal, oid, internal, integer) double precision' on db.
func Icregexnesel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.icregexnesel
	const sqlstr = `SELECT * FROM pg_catalog.icregexnesel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// InRangeByBigintBigintBigintBooleanAndBoolean calls the stored function 'pg_catalog.in_range(bigint, bigint, bigint, boolean, boolean) boolean' on db.
func InRangeByBigintBigintBigintBooleanAndBoolean(ctx context.Context, db DB, p0, p1, p2 int64, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByIntegerIntegerBigintBooleanAndBoolean calls the stored function 'pg_catalog.in_range(integer, integer, bigint, boolean, boolean) boolean' on db.
func InRangeByIntegerIntegerBigintBooleanAndBoolean(ctx context.Context, db DB, p0, p1 int, p2 int64, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByIntegerIntegerIntegerBooleanAndBoolean calls the stored function 'pg_catalog.in_range(integer, integer, integer, boolean, boolean) boolean' on db.
func InRangeByIntegerIntegerIntegerBooleanAndBoolean(ctx context.Context, db DB, p0, p1, p2 int, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByIntegerIntegerSmallintBooleanAndBoolean calls the stored function 'pg_catalog.in_range(integer, integer, smallint, boolean, boolean) boolean' on db.
func InRangeByIntegerIntegerSmallintBooleanAndBoolean(ctx context.Context, db DB, p0, p1 int, p2 int16, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeBySmallintSmallintBigintBooleanAndBoolean calls the stored function 'pg_catalog.in_range(smallint, smallint, bigint, boolean, boolean) boolean' on db.
func InRangeBySmallintSmallintBigintBooleanAndBoolean(ctx context.Context, db DB, p0, p1 int16, p2 int64, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeBySmallintSmallintIntegerBooleanAndBoolean calls the stored function 'pg_catalog.in_range(smallint, smallint, integer, boolean, boolean) boolean' on db.
func InRangeBySmallintSmallintIntegerBooleanAndBoolean(ctx context.Context, db DB, p0, p1 int16, p2 int, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeBySmallintSmallintSmallintBooleanAndBoolean calls the stored function 'pg_catalog.in_range(smallint, smallint, smallint, boolean, boolean) boolean' on db.
func InRangeBySmallintSmallintSmallintBooleanAndBoolean(ctx context.Context, db DB, p0, p1, p2 int16, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByDateDateIntervalBooleanAndBoolean calls the stored function 'pg_catalog.in_range(date, date, interval, boolean, boolean) boolean' on db.
func InRangeByDateDateIntervalBooleanAndBoolean(ctx context.Context, db DB, p0, p1 time.Time, p2 []byte, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByTimestampWithoutTimeZoneTimestampWithoutTimeZoneIntervalBooleanAndBoolean calls the stored function 'pg_catalog.in_range(timestamp without time zone, timestamp without time zone, interval, boolean, boolean) boolean' on db.
func InRangeByTimestampWithoutTimeZoneTimestampWithoutTimeZoneIntervalBooleanAndBoolean(ctx context.Context, db DB, p0, p1 time.Time, p2 []byte, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByTimestampWithTimeZoneTimestampWithTimeZoneIntervalBooleanAndBoolean calls the stored function 'pg_catalog.in_range(timestamp with time zone, timestamp with time zone, interval, boolean, boolean) boolean' on db.
func InRangeByTimestampWithTimeZoneTimestampWithTimeZoneIntervalBooleanAndBoolean(ctx context.Context, db DB, p0, p1 time.Time, p2 []byte, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByIntervalIntervalIntervalBooleanAndBoolean calls the stored function 'pg_catalog.in_range(interval, interval, interval, boolean, boolean) boolean' on db.
func InRangeByIntervalIntervalIntervalBooleanAndBoolean(ctx context.Context, db DB, p0, p1, p2 []byte, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByTimeWithoutTimeZoneTimeWithoutTimeZoneIntervalBooleanAndBoolean calls the stored function 'pg_catalog.in_range(time without time zone, time without time zone, interval, boolean, boolean) boolean' on db.
func InRangeByTimeWithoutTimeZoneTimeWithoutTimeZoneIntervalBooleanAndBoolean(ctx context.Context, db DB, p0, p1 time.Time, p2 []byte, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByTimeWithTimeZoneTimeWithTimeZoneIntervalBooleanAndBoolean calls the stored function 'pg_catalog.in_range(time with time zone, time with time zone, interval, boolean, boolean) boolean' on db.
func InRangeByTimeWithTimeZoneTimeWithTimeZoneIntervalBooleanAndBoolean(ctx context.Context, db DB, p0, p1 time.Time, p2 []byte, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByDoublePrecisionDoublePrecisionDoublePrecisionBooleanAndBoolean calls the stored function 'pg_catalog.in_range(double precision, double precision, double precision, boolean, boolean) boolean' on db.
func InRangeByDoublePrecisionDoublePrecisionDoublePrecisionBooleanAndBoolean(ctx context.Context, db DB, p0, p1, p2 float64, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByRealRealDoublePrecisionBooleanAndBoolean calls the stored function 'pg_catalog.in_range(real, real, double precision, boolean, boolean) boolean' on db.
func InRangeByRealRealDoublePrecisionBooleanAndBoolean(ctx context.Context, db DB, p0, p1 float32, p2 float64, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InRangeByNumericNumericNumericBooleanAndBoolean calls the stored function 'pg_catalog.in_range(numeric, numeric, numeric, boolean, boolean) boolean' on db.
func InRangeByNumericNumericNumericBooleanAndBoolean(ctx context.Context, db DB, p0, p1, p2 float64, p3, p4 bool) (bool, error) {
	// call pg_catalog.in_range
	const sqlstr = `SELECT * FROM pg_catalog.in_range($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InetClientAddr calls the stored function 'pg_catalog.inet_client_addr() inet' on db.
func InetClientAddr(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.inet_client_addr
	const sqlstr = `SELECT * FROM pg_catalog.inet_client_addr()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// InetClientPort calls the stored function 'pg_catalog.inet_client_port() integer' on db.
func InetClientPort(ctx context.Context, db DB) (int, error) {
	// call pg_catalog.inet_client_port
	const sqlstr = `SELECT * FROM pg_catalog.inet_client_port()`
	// run
	var r0 int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// InetGistCompress calls the stored function 'pg_catalog.inet_gist_compress(internal) internal' on db.
func InetGistCompress(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.inet_gist_compress
	const sqlstr = `SELECT * FROM pg_catalog.inet_gist_compress($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// InetGistConsistent calls the stored function 'pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal) boolean' on db.
func InetGistConsistent(ctx context.Context, db DB, p0 pgtypes.Internal, p1 string, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.inet_gist_consistent
	const sqlstr = `SELECT * FROM pg_catalog.inet_gist_consistent($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InetGistFetch calls the stored function 'pg_catalog.inet_gist_fetch(internal) internal' on db.
func InetGistFetch(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.inet_gist_fetch
	const sqlstr = `SELECT * FROM pg_catalog.inet_gist_fetch($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// InetGistPenalty calls the stored function 'pg_catalog.inet_gist_penalty(internal, internal, internal) internal' on db.
func InetGistPenalty(ctx context.Context, db DB, p0, p1, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.inet_gist_penalty
	const sqlstr = `SELECT * FROM pg_catalog.inet_gist_penalty($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// InetGistPicksplit calls the stored function 'pg_catalog.inet_gist_picksplit(internal, internal) internal' on db.
func InetGistPicksplit(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.inet_gist_picksplit
	const sqlstr = `SELECT * FROM pg_catalog.inet_gist_picksplit($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// InetGistSame calls the stored function 'pg_catalog.inet_gist_same(inet, inet, internal) internal' on db.
func InetGistSame(ctx context.Context, db DB, p0, p1 string, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.inet_gist_same
	const sqlstr = `SELECT * FROM pg_catalog.inet_gist_same($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// InetGistUnion calls the stored function 'pg_catalog.inet_gist_union(internal, internal) inet' on db.
func InetGistUnion(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (string, error) {
	// call pg_catalog.inet_gist_union
	const sqlstr = `SELECT * FROM pg_catalog.inet_gist_union($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// InetMerge calls the stored function 'pg_catalog.inet_merge(inet, inet) cidr' on db.
func InetMerge(ctx context.Context, db DB, p0, p1 string) (pgtypes.Cidr, error) {
	// call pg_catalog.inet_merge
	const sqlstr = `SELECT * FROM pg_catalog.inet_merge($1, $2)`
	// run
	var r0 pgtypes.Cidr
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Cidr{}, logerror(err)
	}
	return r0, nil
}

// InetRecv calls the stored function 'pg_catalog.inet_recv(internal) inet' on db.
func InetRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (string, error) {
	// call pg_catalog.inet_recv
	const sqlstr = `SELECT * FROM pg_catalog.inet_recv($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// InetSameFamily calls the stored function 'pg_catalog.inet_same_family(inet, inet) boolean' on db.
func InetSameFamily(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.inet_same_family
	const sqlstr = `SELECT * FROM pg_catalog.inet_same_family($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InetSend calls the stored function 'pg_catalog.inet_send(inet) bytea' on db.
func InetSend(ctx context.Context, db DB, p0 string) ([]byte, error) {
	// call pg_catalog.inet_send
	const sqlstr = `SELECT * FROM pg_catalog.inet_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// InetServerAddr calls the stored function 'pg_catalog.inet_server_addr() inet' on db.
func InetServerAddr(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.inet_server_addr
	const sqlstr = `SELECT * FROM pg_catalog.inet_server_addr()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// InetServerPort calls the stored function 'pg_catalog.inet_server_port() integer' on db.
func InetServerPort(ctx context.Context, db DB) (int, error) {
	// call pg_catalog.inet_server_port
	const sqlstr = `SELECT * FROM pg_catalog.inet_server_port()`
	// run
	var r0 int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// InetSpgChoose calls the stored function 'pg_catalog.inet_spg_choose(internal, internal)' on db.
func InetSpgChoose(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.inet_spg_choose
	const sqlstr = `SELECT * FROM pg_catalog.inet_spg_choose($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// InetSpgConfig calls the stored function 'pg_catalog.inet_spg_config(internal, internal)' on db.
func InetSpgConfig(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.inet_spg_config
	const sqlstr = `SELECT * FROM pg_catalog.inet_spg_config($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// InetSpgInnerConsistent calls the stored function 'pg_catalog.inet_spg_inner_consistent(internal, internal)' on db.
func InetSpgInnerConsistent(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.inet_spg_inner_consistent
	const sqlstr = `SELECT * FROM pg_catalog.inet_spg_inner_consistent($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// InetSpgLeafConsistent calls the stored function 'pg_catalog.inet_spg_leaf_consistent(internal, internal) boolean' on db.
func InetSpgLeafConsistent(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (bool, error) {
	// call pg_catalog.inet_spg_leaf_consistent
	const sqlstr = `SELECT * FROM pg_catalog.inet_spg_leaf_consistent($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InetSpgPicksplit calls the stored function 'pg_catalog.inet_spg_picksplit(internal, internal)' on db.
func InetSpgPicksplit(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.inet_spg_picksplit
	const sqlstr = `SELECT * FROM pg_catalog.inet_spg_picksplit($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// Inetand calls the stored function 'pg_catalog.inetand(inet, inet) inet' on db.
func Inetand(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.inetand
	const sqlstr = `SELECT * FROM pg_catalog.inetand($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Inetmi calls the stored function 'pg_catalog.inetmi(inet, inet) bigint' on db.
func Inetmi(ctx context.Context, db DB, p0, p1 string) (int64, error) {
	// call pg_catalog.inetmi
	const sqlstr = `SELECT * FROM pg_catalog.inetmi($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// InetmiInt8 calls the stored function 'pg_catalog.inetmi_int8(inet, bigint) inet' on db.
func InetmiInt8(ctx context.Context, db DB, p0 string, p1 int64) (string, error) {
	// call pg_catalog.inetmi_int8
	const sqlstr = `SELECT * FROM pg_catalog.inetmi_int8($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Inetnot calls the stored function 'pg_catalog.inetnot(inet) inet' on db.
func Inetnot(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.inetnot
	const sqlstr = `SELECT * FROM pg_catalog.inetnot($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Inetor calls the stored function 'pg_catalog.inetor(inet, inet) inet' on db.
func Inetor(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.inetor
	const sqlstr = `SELECT * FROM pg_catalog.inetor($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Inetpl calls the stored function 'pg_catalog.inetpl(inet, bigint) inet' on db.
func Inetpl(ctx context.Context, db DB, p0 string, p1 int64) (string, error) {
	// call pg_catalog.inetpl
	const sqlstr = `SELECT * FROM pg_catalog.inetpl($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Initcap calls the stored function 'pg_catalog.initcap(text) text' on db.
func Initcap(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.initcap
	const sqlstr = `SELECT * FROM pg_catalog.initcap($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Int2ByNumeric calls the stored function 'pg_catalog.int2(numeric) smallint' on db.
func Int2ByNumeric(ctx context.Context, db DB, p0 float64) (int16, error) {
	// call pg_catalog.int2
	const sqlstr = `SELECT * FROM pg_catalog.int2($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2ByDoublePrecision calls the stored function 'pg_catalog.int2(double precision) smallint' on db.
func Int2ByDoublePrecision(ctx context.Context, db DB, p0 float64) (int16, error) {
	// call pg_catalog.int2
	const sqlstr = `SELECT * FROM pg_catalog.int2($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2ByReal calls the stored function 'pg_catalog.int2(real) smallint' on db.
func Int2ByReal(ctx context.Context, db DB, p0 float32) (int16, error) {
	// call pg_catalog.int2
	const sqlstr = `SELECT * FROM pg_catalog.int2($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2ByInteger calls the stored function 'pg_catalog.int2(integer) smallint' on db.
func Int2ByInteger(ctx context.Context, db DB, p0 int) (int16, error) {
	// call pg_catalog.int2
	const sqlstr = `SELECT * FROM pg_catalog.int2($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2ByJsonb calls the stored function 'pg_catalog.int2(jsonb) smallint' on db.
func Int2ByJsonb(ctx context.Context, db DB, p0 []byte) (int16, error) {
	// call pg_catalog.int2
	const sqlstr = `SELECT * FROM pg_catalog.int2($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2ByBigint calls the stored function 'pg_catalog.int2(bigint) smallint' on db.
func Int2ByBigint(ctx context.Context, db DB, p0 int64) (int16, error) {
	// call pg_catalog.int2
	const sqlstr = `SELECT * FROM pg_catalog.int2($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int24div calls the stored function 'pg_catalog.int24div(smallint, integer) integer' on db.
func Int24div(ctx context.Context, db DB, p0 int16, p1 int) (int, error) {
	// call pg_catalog.int24div
	const sqlstr = `SELECT * FROM pg_catalog.int24div($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int24eq calls the stored function 'pg_catalog.int24eq(smallint, integer) boolean' on db.
func Int24eq(ctx context.Context, db DB, p0 int16, p1 int) (bool, error) {
	// call pg_catalog.int24eq
	const sqlstr = `SELECT * FROM pg_catalog.int24eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int24ge calls the stored function 'pg_catalog.int24ge(smallint, integer) boolean' on db.
func Int24ge(ctx context.Context, db DB, p0 int16, p1 int) (bool, error) {
	// call pg_catalog.int24ge
	const sqlstr = `SELECT * FROM pg_catalog.int24ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int24gt calls the stored function 'pg_catalog.int24gt(smallint, integer) boolean' on db.
func Int24gt(ctx context.Context, db DB, p0 int16, p1 int) (bool, error) {
	// call pg_catalog.int24gt
	const sqlstr = `SELECT * FROM pg_catalog.int24gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int24le calls the stored function 'pg_catalog.int24le(smallint, integer) boolean' on db.
func Int24le(ctx context.Context, db DB, p0 int16, p1 int) (bool, error) {
	// call pg_catalog.int24le
	const sqlstr = `SELECT * FROM pg_catalog.int24le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int24lt calls the stored function 'pg_catalog.int24lt(smallint, integer) boolean' on db.
func Int24lt(ctx context.Context, db DB, p0 int16, p1 int) (bool, error) {
	// call pg_catalog.int24lt
	const sqlstr = `SELECT * FROM pg_catalog.int24lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int24mi calls the stored function 'pg_catalog.int24mi(smallint, integer) integer' on db.
func Int24mi(ctx context.Context, db DB, p0 int16, p1 int) (int, error) {
	// call pg_catalog.int24mi
	const sqlstr = `SELECT * FROM pg_catalog.int24mi($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int24mul calls the stored function 'pg_catalog.int24mul(smallint, integer) integer' on db.
func Int24mul(ctx context.Context, db DB, p0 int16, p1 int) (int, error) {
	// call pg_catalog.int24mul
	const sqlstr = `SELECT * FROM pg_catalog.int24mul($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int24ne calls the stored function 'pg_catalog.int24ne(smallint, integer) boolean' on db.
func Int24ne(ctx context.Context, db DB, p0 int16, p1 int) (bool, error) {
	// call pg_catalog.int24ne
	const sqlstr = `SELECT * FROM pg_catalog.int24ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int24pl calls the stored function 'pg_catalog.int24pl(smallint, integer) integer' on db.
func Int24pl(ctx context.Context, db DB, p0 int16, p1 int) (int, error) {
	// call pg_catalog.int24pl
	const sqlstr = `SELECT * FROM pg_catalog.int24pl($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int28div calls the stored function 'pg_catalog.int28div(smallint, bigint) bigint' on db.
func Int28div(ctx context.Context, db DB, p0 int16, p1 int64) (int64, error) {
	// call pg_catalog.int28div
	const sqlstr = `SELECT * FROM pg_catalog.int28div($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int28eq calls the stored function 'pg_catalog.int28eq(smallint, bigint) boolean' on db.
func Int28eq(ctx context.Context, db DB, p0 int16, p1 int64) (bool, error) {
	// call pg_catalog.int28eq
	const sqlstr = `SELECT * FROM pg_catalog.int28eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int28ge calls the stored function 'pg_catalog.int28ge(smallint, bigint) boolean' on db.
func Int28ge(ctx context.Context, db DB, p0 int16, p1 int64) (bool, error) {
	// call pg_catalog.int28ge
	const sqlstr = `SELECT * FROM pg_catalog.int28ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int28gt calls the stored function 'pg_catalog.int28gt(smallint, bigint) boolean' on db.
func Int28gt(ctx context.Context, db DB, p0 int16, p1 int64) (bool, error) {
	// call pg_catalog.int28gt
	const sqlstr = `SELECT * FROM pg_catalog.int28gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int28le calls the stored function 'pg_catalog.int28le(smallint, bigint) boolean' on db.
func Int28le(ctx context.Context, db DB, p0 int16, p1 int64) (bool, error) {
	// call pg_catalog.int28le
	const sqlstr = `SELECT * FROM pg_catalog.int28le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int28lt calls the stored function 'pg_catalog.int28lt(smallint, bigint) boolean' on db.
func Int28lt(ctx context.Context, db DB, p0 int16, p1 int64) (bool, error) {
	// call pg_catalog.int28lt
	const sqlstr = `SELECT * FROM pg_catalog.int28lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int28mi calls the stored function 'pg_catalog.int28mi(smallint, bigint) bigint' on db.
func Int28mi(ctx context.Context, db DB, p0 int16, p1 int64) (int64, error) {
	// call pg_catalog.int28mi
	const sqlstr = `SELECT * FROM pg_catalog.int28mi($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int28mul calls the stored function 'pg_catalog.int28mul(smallint, bigint) bigint' on db.
func Int28mul(ctx context.Context, db DB, p0 int16, p1 int64) (int64, error) {
	// call pg_catalog.int28mul
	const sqlstr = `SELECT * FROM pg_catalog.int28mul($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int28ne calls the stored function 'pg_catalog.int28ne(smallint, bigint) boolean' on db.
func Int28ne(ctx context.Context, db DB, p0 int16, p1 int64) (bool, error) {
	// call pg_catalog.int28ne
	const sqlstr = `SELECT * FROM pg_catalog.int28ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int28pl calls the stored function 'pg_catalog.int28pl(smallint, bigint) bigint' on db.
func Int28pl(ctx context.Context, db DB, p0 int16, p1 int64) (int64, error) {
	// call pg_catalog.int28pl
	const sqlstr = `SELECT * FROM pg_catalog.int28pl($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2Accum calls the stored function 'pg_catalog.int2_accum(internal, smallint) internal' on db.
func Int2Accum(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16) (pgtypes.Internal, error) {
	// call pg_catalog.int2_accum
	const sqlstr = `SELECT * FROM pg_catalog.int2_accum($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Int2AccumInv calls the stored function 'pg_catalog.int2_accum_inv(internal, smallint) internal' on db.
func Int2AccumInv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int16) (pgtypes.Internal, error) {
	// call pg_catalog.int2_accum_inv
	const sqlstr = `SELECT * FROM pg_catalog.int2_accum_inv($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Int2AvgAccum calls the stored function 'pg_catalog.int2_avg_accum(bigint, smallint) bigint' on db.
func Int2AvgAccum(ctx context.Context, db DB, p0 []int64, p1 int16) ([]int64, error) {
	// call pg_catalog.int2_avg_accum
	const sqlstr = `SELECT * FROM pg_catalog.int2_avg_accum($1, $2)`
	// run
	var r0 []int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Int2AvgAccumInv calls the stored function 'pg_catalog.int2_avg_accum_inv(bigint, smallint) bigint' on db.
func Int2AvgAccumInv(ctx context.Context, db DB, p0 []int64, p1 int16) ([]int64, error) {
	// call pg_catalog.int2_avg_accum_inv
	const sqlstr = `SELECT * FROM pg_catalog.int2_avg_accum_inv($1, $2)`
	// run
	var r0 []int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Int2MulCash calls the stored function 'pg_catalog.int2_mul_cash(smallint, money) money' on db.
func Int2MulCash(ctx context.Context, db DB, p0 int16, p1 string) (string, error) {
	// call pg_catalog.int2_mul_cash
	const sqlstr = `SELECT * FROM pg_catalog.int2_mul_cash($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Int2Sum calls the stored function 'pg_catalog.int2_sum(bigint, smallint) bigint' on db.
func Int2Sum(ctx context.Context, db DB, p0 int64, p1 int16) (int64, error) {
	// call pg_catalog.int2_sum
	const sqlstr = `SELECT * FROM pg_catalog.int2_sum($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2abs calls the stored function 'pg_catalog.int2abs(smallint) smallint' on db.
func Int2abs(ctx context.Context, db DB, p0 int16) (int16, error) {
	// call pg_catalog.int2abs
	const sqlstr = `SELECT * FROM pg_catalog.int2abs($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2and calls the stored function 'pg_catalog.int2and(smallint, smallint) smallint' on db.
func Int2and(ctx context.Context, db DB, p0, p1 int16) (int16, error) {
	// call pg_catalog.int2and
	const sqlstr = `SELECT * FROM pg_catalog.int2and($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2div calls the stored function 'pg_catalog.int2div(smallint, smallint) smallint' on db.
func Int2div(ctx context.Context, db DB, p0, p1 int16) (int16, error) {
	// call pg_catalog.int2div
	const sqlstr = `SELECT * FROM pg_catalog.int2div($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2eq calls the stored function 'pg_catalog.int2eq(smallint, smallint) boolean' on db.
func Int2eq(ctx context.Context, db DB, p0, p1 int16) (bool, error) {
	// call pg_catalog.int2eq
	const sqlstr = `SELECT * FROM pg_catalog.int2eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int2ge calls the stored function 'pg_catalog.int2ge(smallint, smallint) boolean' on db.
func Int2ge(ctx context.Context, db DB, p0, p1 int16) (bool, error) {
	// call pg_catalog.int2ge
	const sqlstr = `SELECT * FROM pg_catalog.int2ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int2gt calls the stored function 'pg_catalog.int2gt(smallint, smallint) boolean' on db.
func Int2gt(ctx context.Context, db DB, p0, p1 int16) (bool, error) {
	// call pg_catalog.int2gt
	const sqlstr = `SELECT * FROM pg_catalog.int2gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int2int4Sum calls the stored function 'pg_catalog.int2int4_sum(bigint) bigint' on db.
func Int2int4Sum(ctx context.Context, db DB, p0 []int64) (int64, error) {
	// call pg_catalog.int2int4_sum
	const sqlstr = `SELECT * FROM pg_catalog.int2int4_sum($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2larger calls the stored function 'pg_catalog.int2larger(smallint, smallint) smallint' on db.
func Int2larger(ctx context.Context, db DB, p0, p1 int16) (int16, error) {
	// call pg_catalog.int2larger
	const sqlstr = `SELECT * FROM pg_catalog.int2larger($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2le calls the stored function 'pg_catalog.int2le(smallint, smallint) boolean' on db.
func Int2le(ctx context.Context, db DB, p0, p1 int16) (bool, error) {
	// call pg_catalog.int2le
	const sqlstr = `SELECT * FROM pg_catalog.int2le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int2lt calls the stored function 'pg_catalog.int2lt(smallint, smallint) boolean' on db.
func Int2lt(ctx context.Context, db DB, p0, p1 int16) (bool, error) {
	// call pg_catalog.int2lt
	const sqlstr = `SELECT * FROM pg_catalog.int2lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int2mi calls the stored function 'pg_catalog.int2mi(smallint, smallint) smallint' on db.
func Int2mi(ctx context.Context, db DB, p0, p1 int16) (int16, error) {
	// call pg_catalog.int2mi
	const sqlstr = `SELECT * FROM pg_catalog.int2mi($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2mod calls the stored function 'pg_catalog.int2mod(smallint, smallint) smallint' on db.
func Int2mod(ctx context.Context, db DB, p0, p1 int16) (int16, error) {
	// call pg_catalog.int2mod
	const sqlstr = `SELECT * FROM pg_catalog.int2mod($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2mul calls the stored function 'pg_catalog.int2mul(smallint, smallint) smallint' on db.
func Int2mul(ctx context.Context, db DB, p0, p1 int16) (int16, error) {
	// call pg_catalog.int2mul
	const sqlstr = `SELECT * FROM pg_catalog.int2mul($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2ne calls the stored function 'pg_catalog.int2ne(smallint, smallint) boolean' on db.
func Int2ne(ctx context.Context, db DB, p0, p1 int16) (bool, error) {
	// call pg_catalog.int2ne
	const sqlstr = `SELECT * FROM pg_catalog.int2ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int2not calls the stored function 'pg_catalog.int2not(smallint) smallint' on db.
func Int2not(ctx context.Context, db DB, p0 int16) (int16, error) {
	// call pg_catalog.int2not
	const sqlstr = `SELECT * FROM pg_catalog.int2not($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2or calls the stored function 'pg_catalog.int2or(smallint, smallint) smallint' on db.
func Int2or(ctx context.Context, db DB, p0, p1 int16) (int16, error) {
	// call pg_catalog.int2or
	const sqlstr = `SELECT * FROM pg_catalog.int2or($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2pl calls the stored function 'pg_catalog.int2pl(smallint, smallint) smallint' on db.
func Int2pl(ctx context.Context, db DB, p0, p1 int16) (int16, error) {
	// call pg_catalog.int2pl
	const sqlstr = `SELECT * FROM pg_catalog.int2pl($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2recv calls the stored function 'pg_catalog.int2recv(internal) smallint' on db.
func Int2recv(ctx context.Context, db DB, p0 pgtypes.Internal) (int16, error) {
	// call pg_catalog.int2recv
	const sqlstr = `SELECT * FROM pg_catalog.int2recv($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2send calls the stored function 'pg_catalog.int2send(smallint) bytea' on db.
func Int2send(ctx context.Context, db DB, p0 int16) ([]byte, error) {
	// call pg_catalog.int2send
	const sqlstr = `SELECT * FROM pg_catalog.int2send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Int2shl calls the stored function 'pg_catalog.int2shl(smallint, integer) smallint' on db.
func Int2shl(ctx context.Context, db DB, p0 int16, p1 int) (int16, error) {
	// call pg_catalog.int2shl
	const sqlstr = `SELECT * FROM pg_catalog.int2shl($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2shr calls the stored function 'pg_catalog.int2shr(smallint, integer) smallint' on db.
func Int2shr(ctx context.Context, db DB, p0 int16, p1 int) (int16, error) {
	// call pg_catalog.int2shr
	const sqlstr = `SELECT * FROM pg_catalog.int2shr($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2smaller calls the stored function 'pg_catalog.int2smaller(smallint, smallint) smallint' on db.
func Int2smaller(ctx context.Context, db DB, p0, p1 int16) (int16, error) {
	// call pg_catalog.int2smaller
	const sqlstr = `SELECT * FROM pg_catalog.int2smaller($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2um calls the stored function 'pg_catalog.int2um(smallint) smallint' on db.
func Int2um(ctx context.Context, db DB, p0 int16) (int16, error) {
	// call pg_catalog.int2um
	const sqlstr = `SELECT * FROM pg_catalog.int2um($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2up calls the stored function 'pg_catalog.int2up(smallint) smallint' on db.
func Int2up(ctx context.Context, db DB, p0 int16) (int16, error) {
	// call pg_catalog.int2up
	const sqlstr = `SELECT * FROM pg_catalog.int2up($1)`
	// run
	var r0 int16
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int2vectorrecv calls the stored function 'pg_catalog.int2vectorrecv(internal) int2vector' on db.
func Int2vectorrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Int2vector, error) {
	// call pg_catalog.int2vectorrecv
	const sqlstr = `SELECT * FROM pg_catalog.int2vectorrecv($1)`
	// run
	var r0 pgtypes.Int2vector
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Int2vector{}, logerror(err)
	}
	return r0, nil
}

// Int2vectorsend calls the stored function 'pg_catalog.int2vectorsend(int2vector) bytea' on db.
func Int2vectorsend(ctx context.Context, db DB, p0 pgtypes.Int2vector) ([]byte, error) {
	// call pg_catalog.int2vectorsend
	const sqlstr = `SELECT * FROM pg_catalog.int2vectorsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Int2xor calls the stored function 'pg_catalog.int2xor(smallint, smallint) smallint' on db.
func Int2xor(ctx context.Context, db DB, p0, p1 int16) (int16, error) {
	// call pg_catalog.int2xor
	const sqlstr = `SELECT * FROM pg_catalog.int2xor($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4ByBit calls the stored function 'pg_catalog.int4(bit) integer' on db.
func Int4ByBit(ctx context.Context, db DB, p0 uint8) (int, error) {
	// call pg_catalog.int4
	const sqlstr = `SELECT * FROM pg_catalog.int4($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4ByNumeric calls the stored function 'pg_catalog.int4(numeric) integer' on db.
func Int4ByNumeric(ctx context.Context, db DB, p0 float64) (int, error) {
	// call pg_catalog.int4
	const sqlstr = `SELECT * FROM pg_catalog.int4($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4ByBoolean calls the stored function 'pg_catalog.int4(boolean) integer' on db.
func Int4ByBoolean(ctx context.Context, db DB, p0 bool) (int, error) {
	// call pg_catalog.int4
	const sqlstr = `SELECT * FROM pg_catalog.int4($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4BySmallint calls the stored function 'pg_catalog.int4(smallint) integer' on db.
func Int4BySmallint(ctx context.Context, db DB, p0 int16) (int, error) {
	// call pg_catalog.int4
	const sqlstr = `SELECT * FROM pg_catalog.int4($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4ByDoublePrecision calls the stored function 'pg_catalog.int4(double precision) integer' on db.
func Int4ByDoublePrecision(ctx context.Context, db DB, p0 float64) (int, error) {
	// call pg_catalog.int4
	const sqlstr = `SELECT * FROM pg_catalog.int4($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4ByReal calls the stored function 'pg_catalog.int4(real) integer' on db.
func Int4ByReal(ctx context.Context, db DB, p0 float32) (int, error) {
	// call pg_catalog.int4
	const sqlstr = `SELECT * FROM pg_catalog.int4($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4ByJsonb calls the stored function 'pg_catalog.int4(jsonb) integer' on db.
func Int4ByJsonb(ctx context.Context, db DB, p0 []byte) (int, error) {
	// call pg_catalog.int4
	const sqlstr = `SELECT * FROM pg_catalog.int4($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4ByBigint calls the stored function 'pg_catalog.int4(bigint) integer' on db.
func Int4ByBigint(ctx context.Context, db DB, p0 int64) (int, error) {
	// call pg_catalog.int4
	const sqlstr = `SELECT * FROM pg_catalog.int4($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4ByChar calls the stored function 'pg_catalog.int4("char") integer' on db.
func Int4ByChar(ctx context.Context, db DB, p0 pgtypes.Char) (int, error) {
	// call pg_catalog.int4
	const sqlstr = `SELECT * FROM pg_catalog.int4($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int42div calls the stored function 'pg_catalog.int42div(integer, smallint) integer' on db.
func Int42div(ctx context.Context, db DB, p0 int, p1 int16) (int, error) {
	// call pg_catalog.int42div
	const sqlstr = `SELECT * FROM pg_catalog.int42div($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int42eq calls the stored function 'pg_catalog.int42eq(integer, smallint) boolean' on db.
func Int42eq(ctx context.Context, db DB, p0 int, p1 int16) (bool, error) {
	// call pg_catalog.int42eq
	const sqlstr = `SELECT * FROM pg_catalog.int42eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int42ge calls the stored function 'pg_catalog.int42ge(integer, smallint) boolean' on db.
func Int42ge(ctx context.Context, db DB, p0 int, p1 int16) (bool, error) {
	// call pg_catalog.int42ge
	const sqlstr = `SELECT * FROM pg_catalog.int42ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int42gt calls the stored function 'pg_catalog.int42gt(integer, smallint) boolean' on db.
func Int42gt(ctx context.Context, db DB, p0 int, p1 int16) (bool, error) {
	// call pg_catalog.int42gt
	const sqlstr = `SELECT * FROM pg_catalog.int42gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int42le calls the stored function 'pg_catalog.int42le(integer, smallint) boolean' on db.
func Int42le(ctx context.Context, db DB, p0 int, p1 int16) (bool, error) {
	// call pg_catalog.int42le
	const sqlstr = `SELECT * FROM pg_catalog.int42le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int42lt calls the stored function 'pg_catalog.int42lt(integer, smallint) boolean' on db.
func Int42lt(ctx context.Context, db DB, p0 int, p1 int16) (bool, error) {
	// call pg_catalog.int42lt
	const sqlstr = `SELECT * FROM pg_catalog.int42lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int42mi calls the stored function 'pg_catalog.int42mi(integer, smallint) integer' on db.
func Int42mi(ctx context.Context, db DB, p0 int, p1 int16) (int, error) {
	// call pg_catalog.int42mi
	const sqlstr = `SELECT * FROM pg_catalog.int42mi($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int42mul calls the stored function 'pg_catalog.int42mul(integer, smallint) integer' on db.
func Int42mul(ctx context.Context, db DB, p0 int, p1 int16) (int, error) {
	// call pg_catalog.int42mul
	const sqlstr = `SELECT * FROM pg_catalog.int42mul($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int42ne calls the stored function 'pg_catalog.int42ne(integer, smallint) boolean' on db.
func Int42ne(ctx context.Context, db DB, p0 int, p1 int16) (bool, error) {
	// call pg_catalog.int42ne
	const sqlstr = `SELECT * FROM pg_catalog.int42ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int42pl calls the stored function 'pg_catalog.int42pl(integer, smallint) integer' on db.
func Int42pl(ctx context.Context, db DB, p0 int, p1 int16) (int, error) {
	// call pg_catalog.int42pl
	const sqlstr = `SELECT * FROM pg_catalog.int42pl($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int48div calls the stored function 'pg_catalog.int48div(integer, bigint) bigint' on db.
func Int48div(ctx context.Context, db DB, p0 int, p1 int64) (int64, error) {
	// call pg_catalog.int48div
	const sqlstr = `SELECT * FROM pg_catalog.int48div($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int48eq calls the stored function 'pg_catalog.int48eq(integer, bigint) boolean' on db.
func Int48eq(ctx context.Context, db DB, p0 int, p1 int64) (bool, error) {
	// call pg_catalog.int48eq
	const sqlstr = `SELECT * FROM pg_catalog.int48eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int48ge calls the stored function 'pg_catalog.int48ge(integer, bigint) boolean' on db.
func Int48ge(ctx context.Context, db DB, p0 int, p1 int64) (bool, error) {
	// call pg_catalog.int48ge
	const sqlstr = `SELECT * FROM pg_catalog.int48ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int48gt calls the stored function 'pg_catalog.int48gt(integer, bigint) boolean' on db.
func Int48gt(ctx context.Context, db DB, p0 int, p1 int64) (bool, error) {
	// call pg_catalog.int48gt
	const sqlstr = `SELECT * FROM pg_catalog.int48gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int48le calls the stored function 'pg_catalog.int48le(integer, bigint) boolean' on db.
func Int48le(ctx context.Context, db DB, p0 int, p1 int64) (bool, error) {
	// call pg_catalog.int48le
	const sqlstr = `SELECT * FROM pg_catalog.int48le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int48lt calls the stored function 'pg_catalog.int48lt(integer, bigint) boolean' on db.
func Int48lt(ctx context.Context, db DB, p0 int, p1 int64) (bool, error) {
	// call pg_catalog.int48lt
	const sqlstr = `SELECT * FROM pg_catalog.int48lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int48mi calls the stored function 'pg_catalog.int48mi(integer, bigint) bigint' on db.
func Int48mi(ctx context.Context, db DB, p0 int, p1 int64) (int64, error) {
	// call pg_catalog.int48mi
	const sqlstr = `SELECT * FROM pg_catalog.int48mi($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int48mul calls the stored function 'pg_catalog.int48mul(integer, bigint) bigint' on db.
func Int48mul(ctx context.Context, db DB, p0 int, p1 int64) (int64, error) {
	// call pg_catalog.int48mul
	const sqlstr = `SELECT * FROM pg_catalog.int48mul($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int48ne calls the stored function 'pg_catalog.int48ne(integer, bigint) boolean' on db.
func Int48ne(ctx context.Context, db DB, p0 int, p1 int64) (bool, error) {
	// call pg_catalog.int48ne
	const sqlstr = `SELECT * FROM pg_catalog.int48ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int48pl calls the stored function 'pg_catalog.int48pl(integer, bigint) bigint' on db.
func Int48pl(ctx context.Context, db DB, p0 int, p1 int64) (int64, error) {
	// call pg_catalog.int48pl
	const sqlstr = `SELECT * FROM pg_catalog.int48pl($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4Accum calls the stored function 'pg_catalog.int4_accum(internal, integer) internal' on db.
func Int4Accum(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int) (pgtypes.Internal, error) {
	// call pg_catalog.int4_accum
	const sqlstr = `SELECT * FROM pg_catalog.int4_accum($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Int4AccumInv calls the stored function 'pg_catalog.int4_accum_inv(internal, integer) internal' on db.
func Int4AccumInv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int) (pgtypes.Internal, error) {
	// call pg_catalog.int4_accum_inv
	const sqlstr = `SELECT * FROM pg_catalog.int4_accum_inv($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Int4AvgAccum calls the stored function 'pg_catalog.int4_avg_accum(bigint, integer) bigint' on db.
func Int4AvgAccum(ctx context.Context, db DB, p0 []int64, p1 int) ([]int64, error) {
	// call pg_catalog.int4_avg_accum
	const sqlstr = `SELECT * FROM pg_catalog.int4_avg_accum($1, $2)`
	// run
	var r0 []int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Int4AvgAccumInv calls the stored function 'pg_catalog.int4_avg_accum_inv(bigint, integer) bigint' on db.
func Int4AvgAccumInv(ctx context.Context, db DB, p0 []int64, p1 int) ([]int64, error) {
	// call pg_catalog.int4_avg_accum_inv
	const sqlstr = `SELECT * FROM pg_catalog.int4_avg_accum_inv($1, $2)`
	// run
	var r0 []int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Int4AvgCombine calls the stored function 'pg_catalog.int4_avg_combine(bigint, bigint) bigint' on db.
func Int4AvgCombine(ctx context.Context, db DB, p0, p1 []int64) ([]int64, error) {
	// call pg_catalog.int4_avg_combine
	const sqlstr = `SELECT * FROM pg_catalog.int4_avg_combine($1, $2)`
	// run
	var r0 []int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Int4MulCash calls the stored function 'pg_catalog.int4_mul_cash(integer, money) money' on db.
func Int4MulCash(ctx context.Context, db DB, p0 int, p1 string) (string, error) {
	// call pg_catalog.int4_mul_cash
	const sqlstr = `SELECT * FROM pg_catalog.int4_mul_cash($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Int4Sum calls the stored function 'pg_catalog.int4_sum(bigint, integer) bigint' on db.
func Int4Sum(ctx context.Context, db DB, p0 int64, p1 int) (int64, error) {
	// call pg_catalog.int4_sum
	const sqlstr = `SELECT * FROM pg_catalog.int4_sum($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4abs calls the stored function 'pg_catalog.int4abs(integer) integer' on db.
func Int4abs(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.int4abs
	const sqlstr = `SELECT * FROM pg_catalog.int4abs($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4and calls the stored function 'pg_catalog.int4and(integer, integer) integer' on db.
func Int4and(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4and
	const sqlstr = `SELECT * FROM pg_catalog.int4and($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4div calls the stored function 'pg_catalog.int4div(integer, integer) integer' on db.
func Int4div(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4div
	const sqlstr = `SELECT * FROM pg_catalog.int4div($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4eq calls the stored function 'pg_catalog.int4eq(integer, integer) boolean' on db.
func Int4eq(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.int4eq
	const sqlstr = `SELECT * FROM pg_catalog.int4eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int4ge calls the stored function 'pg_catalog.int4ge(integer, integer) boolean' on db.
func Int4ge(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.int4ge
	const sqlstr = `SELECT * FROM pg_catalog.int4ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int4gt calls the stored function 'pg_catalog.int4gt(integer, integer) boolean' on db.
func Int4gt(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.int4gt
	const sqlstr = `SELECT * FROM pg_catalog.int4gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int4inc calls the stored function 'pg_catalog.int4inc(integer) integer' on db.
func Int4inc(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.int4inc
	const sqlstr = `SELECT * FROM pg_catalog.int4inc($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4larger calls the stored function 'pg_catalog.int4larger(integer, integer) integer' on db.
func Int4larger(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4larger
	const sqlstr = `SELECT * FROM pg_catalog.int4larger($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4le calls the stored function 'pg_catalog.int4le(integer, integer) boolean' on db.
func Int4le(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.int4le
	const sqlstr = `SELECT * FROM pg_catalog.int4le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int4lt calls the stored function 'pg_catalog.int4lt(integer, integer) boolean' on db.
func Int4lt(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.int4lt
	const sqlstr = `SELECT * FROM pg_catalog.int4lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int4mi calls the stored function 'pg_catalog.int4mi(integer, integer) integer' on db.
func Int4mi(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4mi
	const sqlstr = `SELECT * FROM pg_catalog.int4mi($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4mod calls the stored function 'pg_catalog.int4mod(integer, integer) integer' on db.
func Int4mod(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4mod
	const sqlstr = `SELECT * FROM pg_catalog.int4mod($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4mul calls the stored function 'pg_catalog.int4mul(integer, integer) integer' on db.
func Int4mul(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4mul
	const sqlstr = `SELECT * FROM pg_catalog.int4mul($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4ne calls the stored function 'pg_catalog.int4ne(integer, integer) boolean' on db.
func Int4ne(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.int4ne
	const sqlstr = `SELECT * FROM pg_catalog.int4ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int4not calls the stored function 'pg_catalog.int4not(integer) integer' on db.
func Int4not(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.int4not
	const sqlstr = `SELECT * FROM pg_catalog.int4not($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4or calls the stored function 'pg_catalog.int4or(integer, integer) integer' on db.
func Int4or(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4or
	const sqlstr = `SELECT * FROM pg_catalog.int4or($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4pl calls the stored function 'pg_catalog.int4pl(integer, integer) integer' on db.
func Int4pl(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4pl
	const sqlstr = `SELECT * FROM pg_catalog.int4pl($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4rangeByIntegerAndInteger calls the stored function 'pg_catalog.int4range(integer, integer) int4range' on db.
func Int4rangeByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (pgtypes.Int4range, error) {
	// call pg_catalog.int4range
	const sqlstr = `SELECT * FROM pg_catalog.int4range($1, $2)`
	// run
	var r0 pgtypes.Int4range
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Int4range{}, logerror(err)
	}
	return r0, nil
}

// Int4rangeByIntegerIntegerAndText calls the stored function 'pg_catalog.int4range(integer, integer, text) int4range' on db.
func Int4rangeByIntegerIntegerAndText(ctx context.Context, db DB, p0, p1 int, p2 string) (pgtypes.Int4range, error) {
	// call pg_catalog.int4range
	const sqlstr = `SELECT * FROM pg_catalog.int4range($1, $2, $3)`
	// run
	var r0 pgtypes.Int4range
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Int4range{}, logerror(err)
	}
	return r0, nil
}

// Int4rangeCanonical calls the stored function 'pg_catalog.int4range_canonical(int4range) int4range' on db.
func Int4rangeCanonical(ctx context.Context, db DB, p0 pgtypes.Int4range) (pgtypes.Int4range, error) {
	// call pg_catalog.int4range_canonical
	const sqlstr = `SELECT * FROM pg_catalog.int4range_canonical($1)`
	// run
	var r0 pgtypes.Int4range
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Int4range{}, logerror(err)
	}
	return r0, nil
}

// Int4rangeSubdiff calls the stored function 'pg_catalog.int4range_subdiff(integer, integer) double precision' on db.
func Int4rangeSubdiff(ctx context.Context, db DB, p0, p1 int) (float64, error) {
	// call pg_catalog.int4range_subdiff
	const sqlstr = `SELECT * FROM pg_catalog.int4range_subdiff($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Int4recv calls the stored function 'pg_catalog.int4recv(internal) integer' on db.
func Int4recv(ctx context.Context, db DB, p0 pgtypes.Internal) (int, error) {
	// call pg_catalog.int4recv
	const sqlstr = `SELECT * FROM pg_catalog.int4recv($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4send calls the stored function 'pg_catalog.int4send(integer) bytea' on db.
func Int4send(ctx context.Context, db DB, p0 int) ([]byte, error) {
	// call pg_catalog.int4send
	const sqlstr = `SELECT * FROM pg_catalog.int4send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Int4shl calls the stored function 'pg_catalog.int4shl(integer, integer) integer' on db.
func Int4shl(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4shl
	const sqlstr = `SELECT * FROM pg_catalog.int4shl($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4shr calls the stored function 'pg_catalog.int4shr(integer, integer) integer' on db.
func Int4shr(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4shr
	const sqlstr = `SELECT * FROM pg_catalog.int4shr($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4smaller calls the stored function 'pg_catalog.int4smaller(integer, integer) integer' on db.
func Int4smaller(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4smaller
	const sqlstr = `SELECT * FROM pg_catalog.int4smaller($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4um calls the stored function 'pg_catalog.int4um(integer) integer' on db.
func Int4um(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.int4um
	const sqlstr = `SELECT * FROM pg_catalog.int4um($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4up calls the stored function 'pg_catalog.int4up(integer) integer' on db.
func Int4up(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.int4up
	const sqlstr = `SELECT * FROM pg_catalog.int4up($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int4xor calls the stored function 'pg_catalog.int4xor(integer, integer) integer' on db.
func Int4xor(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.int4xor
	const sqlstr = `SELECT * FROM pg_catalog.int4xor($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8ByOid calls the stored function 'pg_catalog.int8(oid) bigint' on db.
func Int8ByOid(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.int8
	const sqlstr = `SELECT * FROM pg_catalog.int8($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8ByNumeric calls the stored function 'pg_catalog.int8(numeric) bigint' on db.
func Int8ByNumeric(ctx context.Context, db DB, p0 float64) (int64, error) {
	// call pg_catalog.int8
	const sqlstr = `SELECT * FROM pg_catalog.int8($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8ByBit calls the stored function 'pg_catalog.int8(bit) bigint' on db.
func Int8ByBit(ctx context.Context, db DB, p0 uint8) (int64, error) {
	// call pg_catalog.int8
	const sqlstr = `SELECT * FROM pg_catalog.int8($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8ByJsonb calls the stored function 'pg_catalog.int8(jsonb) bigint' on db.
func Int8ByJsonb(ctx context.Context, db DB, p0 []byte) (int64, error) {
	// call pg_catalog.int8
	const sqlstr = `SELECT * FROM pg_catalog.int8($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8ByInteger calls the stored function 'pg_catalog.int8(integer) bigint' on db.
func Int8ByInteger(ctx context.Context, db DB, p0 int) (int64, error) {
	// call pg_catalog.int8
	const sqlstr = `SELECT * FROM pg_catalog.int8($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8ByDoublePrecision calls the stored function 'pg_catalog.int8(double precision) bigint' on db.
func Int8ByDoublePrecision(ctx context.Context, db DB, p0 float64) (int64, error) {
	// call pg_catalog.int8
	const sqlstr = `SELECT * FROM pg_catalog.int8($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8ByReal calls the stored function 'pg_catalog.int8(real) bigint' on db.
func Int8ByReal(ctx context.Context, db DB, p0 float32) (int64, error) {
	// call pg_catalog.int8
	const sqlstr = `SELECT * FROM pg_catalog.int8($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8BySmallint calls the stored function 'pg_catalog.int8(smallint) bigint' on db.
func Int8BySmallint(ctx context.Context, db DB, p0 int16) (int64, error) {
	// call pg_catalog.int8
	const sqlstr = `SELECT * FROM pg_catalog.int8($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int82div calls the stored function 'pg_catalog.int82div(bigint, smallint) bigint' on db.
func Int82div(ctx context.Context, db DB, p0 int64, p1 int16) (int64, error) {
	// call pg_catalog.int82div
	const sqlstr = `SELECT * FROM pg_catalog.int82div($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int82eq calls the stored function 'pg_catalog.int82eq(bigint, smallint) boolean' on db.
func Int82eq(ctx context.Context, db DB, p0 int64, p1 int16) (bool, error) {
	// call pg_catalog.int82eq
	const sqlstr = `SELECT * FROM pg_catalog.int82eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int82ge calls the stored function 'pg_catalog.int82ge(bigint, smallint) boolean' on db.
func Int82ge(ctx context.Context, db DB, p0 int64, p1 int16) (bool, error) {
	// call pg_catalog.int82ge
	const sqlstr = `SELECT * FROM pg_catalog.int82ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int82gt calls the stored function 'pg_catalog.int82gt(bigint, smallint) boolean' on db.
func Int82gt(ctx context.Context, db DB, p0 int64, p1 int16) (bool, error) {
	// call pg_catalog.int82gt
	const sqlstr = `SELECT * FROM pg_catalog.int82gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int82le calls the stored function 'pg_catalog.int82le(bigint, smallint) boolean' on db.
func Int82le(ctx context.Context, db DB, p0 int64, p1 int16) (bool, error) {
	// call pg_catalog.int82le
	const sqlstr = `SELECT * FROM pg_catalog.int82le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int82lt calls the stored function 'pg_catalog.int82lt(bigint, smallint) boolean' on db.
func Int82lt(ctx context.Context, db DB, p0 int64, p1 int16) (bool, error) {
	// call pg_catalog.int82lt
	const sqlstr = `SELECT * FROM pg_catalog.int82lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int82mi calls the stored function 'pg_catalog.int82mi(bigint, smallint) bigint' on db.
func Int82mi(ctx context.Context, db DB, p0 int64, p1 int16) (int64, error) {
	// call pg_catalog.int82mi
	const sqlstr = `SELECT * FROM pg_catalog.int82mi($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int82mul calls the stored function 'pg_catalog.int82mul(bigint, smallint) bigint' on db.
func Int82mul(ctx context.Context, db DB, p0 int64, p1 int16) (int64, error) {
	// call pg_catalog.int82mul
	const sqlstr = `SELECT * FROM pg_catalog.int82mul($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int82ne calls the stored function 'pg_catalog.int82ne(bigint, smallint) boolean' on db.
func Int82ne(ctx context.Context, db DB, p0 int64, p1 int16) (bool, error) {
	// call pg_catalog.int82ne
	const sqlstr = `SELECT * FROM pg_catalog.int82ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int82pl calls the stored function 'pg_catalog.int82pl(bigint, smallint) bigint' on db.
func Int82pl(ctx context.Context, db DB, p0 int64, p1 int16) (int64, error) {
	// call pg_catalog.int82pl
	const sqlstr = `SELECT * FROM pg_catalog.int82pl($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int84div calls the stored function 'pg_catalog.int84div(bigint, integer) bigint' on db.
func Int84div(ctx context.Context, db DB, p0 int64, p1 int) (int64, error) {
	// call pg_catalog.int84div
	const sqlstr = `SELECT * FROM pg_catalog.int84div($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int84eq calls the stored function 'pg_catalog.int84eq(bigint, integer) boolean' on db.
func Int84eq(ctx context.Context, db DB, p0 int64, p1 int) (bool, error) {
	// call pg_catalog.int84eq
	const sqlstr = `SELECT * FROM pg_catalog.int84eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int84ge calls the stored function 'pg_catalog.int84ge(bigint, integer) boolean' on db.
func Int84ge(ctx context.Context, db DB, p0 int64, p1 int) (bool, error) {
	// call pg_catalog.int84ge
	const sqlstr = `SELECT * FROM pg_catalog.int84ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int84gt calls the stored function 'pg_catalog.int84gt(bigint, integer) boolean' on db.
func Int84gt(ctx context.Context, db DB, p0 int64, p1 int) (bool, error) {
	// call pg_catalog.int84gt
	const sqlstr = `SELECT * FROM pg_catalog.int84gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int84le calls the stored function 'pg_catalog.int84le(bigint, integer) boolean' on db.
func Int84le(ctx context.Context, db DB, p0 int64, p1 int) (bool, error) {
	// call pg_catalog.int84le
	const sqlstr = `SELECT * FROM pg_catalog.int84le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int84lt calls the stored function 'pg_catalog.int84lt(bigint, integer) boolean' on db.
func Int84lt(ctx context.Context, db DB, p0 int64, p1 int) (bool, error) {
	// call pg_catalog.int84lt
	const sqlstr = `SELECT * FROM pg_catalog.int84lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int84mi calls the stored function 'pg_catalog.int84mi(bigint, integer) bigint' on db.
func Int84mi(ctx context.Context, db DB, p0 int64, p1 int) (int64, error) {
	// call pg_catalog.int84mi
	const sqlstr = `SELECT * FROM pg_catalog.int84mi($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int84mul calls the stored function 'pg_catalog.int84mul(bigint, integer) bigint' on db.
func Int84mul(ctx context.Context, db DB, p0 int64, p1 int) (int64, error) {
	// call pg_catalog.int84mul
	const sqlstr = `SELECT * FROM pg_catalog.int84mul($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int84ne calls the stored function 'pg_catalog.int84ne(bigint, integer) boolean' on db.
func Int84ne(ctx context.Context, db DB, p0 int64, p1 int) (bool, error) {
	// call pg_catalog.int84ne
	const sqlstr = `SELECT * FROM pg_catalog.int84ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int84pl calls the stored function 'pg_catalog.int84pl(bigint, integer) bigint' on db.
func Int84pl(ctx context.Context, db DB, p0 int64, p1 int) (int64, error) {
	// call pg_catalog.int84pl
	const sqlstr = `SELECT * FROM pg_catalog.int84pl($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8Accum calls the stored function 'pg_catalog.int8_accum(internal, bigint) internal' on db.
func Int8Accum(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int64) (pgtypes.Internal, error) {
	// call pg_catalog.int8_accum
	const sqlstr = `SELECT * FROM pg_catalog.int8_accum($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Int8AccumInv calls the stored function 'pg_catalog.int8_accum_inv(internal, bigint) internal' on db.
func Int8AccumInv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int64) (pgtypes.Internal, error) {
	// call pg_catalog.int8_accum_inv
	const sqlstr = `SELECT * FROM pg_catalog.int8_accum_inv($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Int8Avg calls the stored function 'pg_catalog.int8_avg(bigint) numeric' on db.
func Int8Avg(ctx context.Context, db DB, p0 []int64) (float64, error) {
	// call pg_catalog.int8_avg
	const sqlstr = `SELECT * FROM pg_catalog.int8_avg($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Int8AvgAccum calls the stored function 'pg_catalog.int8_avg_accum(internal, bigint) internal' on db.
func Int8AvgAccum(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int64) (pgtypes.Internal, error) {
	// call pg_catalog.int8_avg_accum
	const sqlstr = `SELECT * FROM pg_catalog.int8_avg_accum($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Int8AvgAccumInv calls the stored function 'pg_catalog.int8_avg_accum_inv(internal, bigint) internal' on db.
func Int8AvgAccumInv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int64) (pgtypes.Internal, error) {
	// call pg_catalog.int8_avg_accum_inv
	const sqlstr = `SELECT * FROM pg_catalog.int8_avg_accum_inv($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Int8AvgCombine calls the stored function 'pg_catalog.int8_avg_combine(internal, internal) internal' on db.
func Int8AvgCombine(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.int8_avg_combine
	const sqlstr = `SELECT * FROM pg_catalog.int8_avg_combine($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Int8AvgDeserialize calls the stored function 'pg_catalog.int8_avg_deserialize(bytea, internal) internal' on db.
func Int8AvgDeserialize(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.int8_avg_deserialize
	const sqlstr = `SELECT * FROM pg_catalog.int8_avg_deserialize($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Int8AvgSerialize calls the stored function 'pg_catalog.int8_avg_serialize(internal) bytea' on db.
func Int8AvgSerialize(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.int8_avg_serialize
	const sqlstr = `SELECT * FROM pg_catalog.int8_avg_serialize($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Int8MulCash calls the stored function 'pg_catalog.int8_mul_cash(bigint, money) money' on db.
func Int8MulCash(ctx context.Context, db DB, p0 int64, p1 string) (string, error) {
	// call pg_catalog.int8_mul_cash
	const sqlstr = `SELECT * FROM pg_catalog.int8_mul_cash($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Int8Sum calls the stored function 'pg_catalog.int8_sum(numeric, bigint) numeric' on db.
func Int8Sum(ctx context.Context, db DB, p0 float64, p1 int64) (float64, error) {
	// call pg_catalog.int8_sum
	const sqlstr = `SELECT * FROM pg_catalog.int8_sum($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Int8abs calls the stored function 'pg_catalog.int8abs(bigint) bigint' on db.
func Int8abs(ctx context.Context, db DB, p0 int64) (int64, error) {
	// call pg_catalog.int8abs
	const sqlstr = `SELECT * FROM pg_catalog.int8abs($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8and calls the stored function 'pg_catalog.int8and(bigint, bigint) bigint' on db.
func Int8and(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.int8and
	const sqlstr = `SELECT * FROM pg_catalog.int8and($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8dec calls the stored function 'pg_catalog.int8dec(bigint) bigint' on db.
func Int8dec(ctx context.Context, db DB, p0 int64) (int64, error) {
	// call pg_catalog.int8dec
	const sqlstr = `SELECT * FROM pg_catalog.int8dec($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8decAny calls the stored function 'pg_catalog.int8dec_any(bigint, "any") bigint' on db.
func Int8decAny(ctx context.Context, db DB, p0 int64, p1 pgtypes.Any) (int64, error) {
	// call pg_catalog.int8dec_any
	const sqlstr = `SELECT * FROM pg_catalog.int8dec_any($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8div calls the stored function 'pg_catalog.int8div(bigint, bigint) bigint' on db.
func Int8div(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.int8div
	const sqlstr = `SELECT * FROM pg_catalog.int8div($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8eq calls the stored function 'pg_catalog.int8eq(bigint, bigint) boolean' on db.
func Int8eq(ctx context.Context, db DB, p0, p1 int64) (bool, error) {
	// call pg_catalog.int8eq
	const sqlstr = `SELECT * FROM pg_catalog.int8eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int8ge calls the stored function 'pg_catalog.int8ge(bigint, bigint) boolean' on db.
func Int8ge(ctx context.Context, db DB, p0, p1 int64) (bool, error) {
	// call pg_catalog.int8ge
	const sqlstr = `SELECT * FROM pg_catalog.int8ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int8gt calls the stored function 'pg_catalog.int8gt(bigint, bigint) boolean' on db.
func Int8gt(ctx context.Context, db DB, p0, p1 int64) (bool, error) {
	// call pg_catalog.int8gt
	const sqlstr = `SELECT * FROM pg_catalog.int8gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int8inc calls the stored function 'pg_catalog.int8inc(bigint) bigint' on db.
func Int8inc(ctx context.Context, db DB, p0 int64) (int64, error) {
	// call pg_catalog.int8inc
	const sqlstr = `SELECT * FROM pg_catalog.int8inc($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8incAny calls the stored function 'pg_catalog.int8inc_any(bigint, "any") bigint' on db.
func Int8incAny(ctx context.Context, db DB, p0 int64, p1 pgtypes.Any) (int64, error) {
	// call pg_catalog.int8inc_any
	const sqlstr = `SELECT * FROM pg_catalog.int8inc_any($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8incFloat8Float8 calls the stored function 'pg_catalog.int8inc_float8_float8(bigint, double precision, double precision) bigint' on db.
func Int8incFloat8Float8(ctx context.Context, db DB, p0 int64, p1, p2 float64) (int64, error) {
	// call pg_catalog.int8inc_float8_float8
	const sqlstr = `SELECT * FROM pg_catalog.int8inc_float8_float8($1, $2, $3)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8larger calls the stored function 'pg_catalog.int8larger(bigint, bigint) bigint' on db.
func Int8larger(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.int8larger
	const sqlstr = `SELECT * FROM pg_catalog.int8larger($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8le calls the stored function 'pg_catalog.int8le(bigint, bigint) boolean' on db.
func Int8le(ctx context.Context, db DB, p0, p1 int64) (bool, error) {
	// call pg_catalog.int8le
	const sqlstr = `SELECT * FROM pg_catalog.int8le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int8lt calls the stored function 'pg_catalog.int8lt(bigint, bigint) boolean' on db.
func Int8lt(ctx context.Context, db DB, p0, p1 int64) (bool, error) {
	// call pg_catalog.int8lt
	const sqlstr = `SELECT * FROM pg_catalog.int8lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int8mi calls the stored function 'pg_catalog.int8mi(bigint, bigint) bigint' on db.
func Int8mi(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.int8mi
	const sqlstr = `SELECT * FROM pg_catalog.int8mi($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8mod calls the stored function 'pg_catalog.int8mod(bigint, bigint) bigint' on db.
func Int8mod(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.int8mod
	const sqlstr = `SELECT * FROM pg_catalog.int8mod($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8mul calls the stored function 'pg_catalog.int8mul(bigint, bigint) bigint' on db.
func Int8mul(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.int8mul
	const sqlstr = `SELECT * FROM pg_catalog.int8mul($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8ne calls the stored function 'pg_catalog.int8ne(bigint, bigint) boolean' on db.
func Int8ne(ctx context.Context, db DB, p0, p1 int64) (bool, error) {
	// call pg_catalog.int8ne
	const sqlstr = `SELECT * FROM pg_catalog.int8ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Int8not calls the stored function 'pg_catalog.int8not(bigint) bigint' on db.
func Int8not(ctx context.Context, db DB, p0 int64) (int64, error) {
	// call pg_catalog.int8not
	const sqlstr = `SELECT * FROM pg_catalog.int8not($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8or calls the stored function 'pg_catalog.int8or(bigint, bigint) bigint' on db.
func Int8or(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.int8or
	const sqlstr = `SELECT * FROM pg_catalog.int8or($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8pl calls the stored function 'pg_catalog.int8pl(bigint, bigint) bigint' on db.
func Int8pl(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.int8pl
	const sqlstr = `SELECT * FROM pg_catalog.int8pl($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8plInet calls the stored function 'pg_catalog.int8pl_inet(bigint, inet) inet' on db.
func Int8plInet(ctx context.Context, db DB, p0 int64, p1 string) (string, error) {
	// call pg_catalog.int8pl_inet
	const sqlstr = `SELECT * FROM pg_catalog.int8pl_inet($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Int8rangeByBigintAndBigint calls the stored function 'pg_catalog.int8range(bigint, bigint) int8range' on db.
func Int8rangeByBigintAndBigint(ctx context.Context, db DB, p0, p1 int64) (pgtypes.Int8range, error) {
	// call pg_catalog.int8range
	const sqlstr = `SELECT * FROM pg_catalog.int8range($1, $2)`
	// run
	var r0 pgtypes.Int8range
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Int8range{}, logerror(err)
	}
	return r0, nil
}

// Int8rangeByBigintBigintAndText calls the stored function 'pg_catalog.int8range(bigint, bigint, text) int8range' on db.
func Int8rangeByBigintBigintAndText(ctx context.Context, db DB, p0, p1 int64, p2 string) (pgtypes.Int8range, error) {
	// call pg_catalog.int8range
	const sqlstr = `SELECT * FROM pg_catalog.int8range($1, $2, $3)`
	// run
	var r0 pgtypes.Int8range
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Int8range{}, logerror(err)
	}
	return r0, nil
}

// Int8rangeCanonical calls the stored function 'pg_catalog.int8range_canonical(int8range) int8range' on db.
func Int8rangeCanonical(ctx context.Context, db DB, p0 pgtypes.Int8range) (pgtypes.Int8range, error) {
	// call pg_catalog.int8range_canonical
	const sqlstr = `SELECT * FROM pg_catalog.int8range_canonical($1)`
	// run
	var r0 pgtypes.Int8range
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Int8range{}, logerror(err)
	}
	return r0, nil
}

// Int8rangeSubdiff calls the stored function 'pg_catalog.int8range_subdiff(bigint, bigint) double precision' on db.
func Int8rangeSubdiff(ctx context.Context, db DB, p0, p1 int64) (float64, error) {
	// call pg_catalog.int8range_subdiff
	const sqlstr = `SELECT * FROM pg_catalog.int8range_subdiff($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Int8recv calls the stored function 'pg_catalog.int8recv(internal) bigint' on db.
func Int8recv(ctx context.Context, db DB, p0 pgtypes.Internal) (int64, error) {
	// call pg_catalog.int8recv
	const sqlstr = `SELECT * FROM pg_catalog.int8recv($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8send calls the stored function 'pg_catalog.int8send(bigint) bytea' on db.
func Int8send(ctx context.Context, db DB, p0 int64) ([]byte, error) {
	// call pg_catalog.int8send
	const sqlstr = `SELECT * FROM pg_catalog.int8send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Int8shl calls the stored function 'pg_catalog.int8shl(bigint, integer) bigint' on db.
func Int8shl(ctx context.Context, db DB, p0 int64, p1 int) (int64, error) {
	// call pg_catalog.int8shl
	const sqlstr = `SELECT * FROM pg_catalog.int8shl($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8shr calls the stored function 'pg_catalog.int8shr(bigint, integer) bigint' on db.
func Int8shr(ctx context.Context, db DB, p0 int64, p1 int) (int64, error) {
	// call pg_catalog.int8shr
	const sqlstr = `SELECT * FROM pg_catalog.int8shr($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8smaller calls the stored function 'pg_catalog.int8smaller(bigint, bigint) bigint' on db.
func Int8smaller(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.int8smaller
	const sqlstr = `SELECT * FROM pg_catalog.int8smaller($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8um calls the stored function 'pg_catalog.int8um(bigint) bigint' on db.
func Int8um(ctx context.Context, db DB, p0 int64) (int64, error) {
	// call pg_catalog.int8um
	const sqlstr = `SELECT * FROM pg_catalog.int8um($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8up calls the stored function 'pg_catalog.int8up(bigint) bigint' on db.
func Int8up(ctx context.Context, db DB, p0 int64) (int64, error) {
	// call pg_catalog.int8up
	const sqlstr = `SELECT * FROM pg_catalog.int8up($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Int8xor calls the stored function 'pg_catalog.int8xor(bigint, bigint) bigint' on db.
func Int8xor(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.int8xor
	const sqlstr = `SELECT * FROM pg_catalog.int8xor($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// IntegerPlDate calls the stored function 'pg_catalog.integer_pl_date(integer, date) date' on db.
func IntegerPlDate(ctx context.Context, db DB, p0 int, p1 time.Time) (time.Time, error) {
	// call pg_catalog.integer_pl_date
	const sqlstr = `SELECT * FROM pg_catalog.integer_pl_date($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// InterLb calls the stored function 'pg_catalog.inter_lb(line, box) boolean' on db.
func InterLb(ctx context.Context, db DB, p0 pgtypes.Line, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.inter_lb
	const sqlstr = `SELECT * FROM pg_catalog.inter_lb($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InterSb calls the stored function 'pg_catalog.inter_sb(lseg, box) boolean' on db.
func InterSb(ctx context.Context, db DB, p0 pgtypes.Lseg, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.inter_sb
	const sqlstr = `SELECT * FROM pg_catalog.inter_sb($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// InterSl calls the stored function 'pg_catalog.inter_sl(lseg, line) boolean' on db.
func InterSl(ctx context.Context, db DB, p0 pgtypes.Lseg, p1 pgtypes.Line) (bool, error) {
	// call pg_catalog.inter_sl
	const sqlstr = `SELECT * FROM pg_catalog.inter_sl($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IntervalByIntervalAndInteger calls the stored function 'pg_catalog.interval(interval, integer) interval' on db.
func IntervalByIntervalAndInteger(ctx context.Context, db DB, p0 []byte, p1 int) ([]byte, error) {
	// call pg_catalog.interval
	const sqlstr = `SELECT * FROM pg_catalog.interval($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalByTimeWithoutTimeZone calls the stored function 'pg_catalog.interval(time without time zone) interval' on db.
func IntervalByTimeWithoutTimeZone(ctx context.Context, db DB, p0 time.Time) ([]byte, error) {
	// call pg_catalog.interval
	const sqlstr = `SELECT * FROM pg_catalog.interval($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalAccum calls the stored function 'pg_catalog.interval_accum(interval, interval) interval' on db.
func IntervalAccum(ctx context.Context, db DB, p0 [][]byte, p1 []byte) ([][]byte, error) {
	// call pg_catalog.interval_accum
	const sqlstr = `SELECT * FROM pg_catalog.interval_accum($1, $2)`
	// run
	var r0 [][]byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalAccumInv calls the stored function 'pg_catalog.interval_accum_inv(interval, interval) interval' on db.
func IntervalAccumInv(ctx context.Context, db DB, p0 [][]byte, p1 []byte) ([][]byte, error) {
	// call pg_catalog.interval_accum_inv
	const sqlstr = `SELECT * FROM pg_catalog.interval_accum_inv($1, $2)`
	// run
	var r0 [][]byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalAvg calls the stored function 'pg_catalog.interval_avg(interval) interval' on db.
func IntervalAvg(ctx context.Context, db DB, p0 [][]byte) ([]byte, error) {
	// call pg_catalog.interval_avg
	const sqlstr = `SELECT * FROM pg_catalog.interval_avg($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalCmp calls the stored function 'pg_catalog.interval_cmp(interval, interval) integer' on db.
func IntervalCmp(ctx context.Context, db DB, p0, p1 []byte) (int, error) {
	// call pg_catalog.interval_cmp
	const sqlstr = `SELECT * FROM pg_catalog.interval_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// IntervalCombine calls the stored function 'pg_catalog.interval_combine(interval, interval) interval' on db.
func IntervalCombine(ctx context.Context, db DB, p0, p1 [][]byte) ([][]byte, error) {
	// call pg_catalog.interval_combine
	const sqlstr = `SELECT * FROM pg_catalog.interval_combine($1, $2)`
	// run
	var r0 [][]byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalDiv calls the stored function 'pg_catalog.interval_div(interval, double precision) interval' on db.
func IntervalDiv(ctx context.Context, db DB, p0 []byte, p1 float64) ([]byte, error) {
	// call pg_catalog.interval_div
	const sqlstr = `SELECT * FROM pg_catalog.interval_div($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalEq calls the stored function 'pg_catalog.interval_eq(interval, interval) boolean' on db.
func IntervalEq(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.interval_eq
	const sqlstr = `SELECT * FROM pg_catalog.interval_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IntervalGe calls the stored function 'pg_catalog.interval_ge(interval, interval) boolean' on db.
func IntervalGe(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.interval_ge
	const sqlstr = `SELECT * FROM pg_catalog.interval_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IntervalGt calls the stored function 'pg_catalog.interval_gt(interval, interval) boolean' on db.
func IntervalGt(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.interval_gt
	const sqlstr = `SELECT * FROM pg_catalog.interval_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IntervalHash calls the stored function 'pg_catalog.interval_hash(interval) integer' on db.
func IntervalHash(ctx context.Context, db DB, p0 []byte) (int, error) {
	// call pg_catalog.interval_hash
	const sqlstr = `SELECT * FROM pg_catalog.interval_hash($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// IntervalHashExtended calls the stored function 'pg_catalog.interval_hash_extended(interval, bigint) bigint' on db.
func IntervalHashExtended(ctx context.Context, db DB, p0 []byte, p1 int64) (int64, error) {
	// call pg_catalog.interval_hash_extended
	const sqlstr = `SELECT * FROM pg_catalog.interval_hash_extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// IntervalLarger calls the stored function 'pg_catalog.interval_larger(interval, interval) interval' on db.
func IntervalLarger(ctx context.Context, db DB, p0, p1 []byte) ([]byte, error) {
	// call pg_catalog.interval_larger
	const sqlstr = `SELECT * FROM pg_catalog.interval_larger($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalLe calls the stored function 'pg_catalog.interval_le(interval, interval) boolean' on db.
func IntervalLe(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.interval_le
	const sqlstr = `SELECT * FROM pg_catalog.interval_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IntervalLt calls the stored function 'pg_catalog.interval_lt(interval, interval) boolean' on db.
func IntervalLt(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.interval_lt
	const sqlstr = `SELECT * FROM pg_catalog.interval_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IntervalMi calls the stored function 'pg_catalog.interval_mi(interval, interval) interval' on db.
func IntervalMi(ctx context.Context, db DB, p0, p1 []byte) ([]byte, error) {
	// call pg_catalog.interval_mi
	const sqlstr = `SELECT * FROM pg_catalog.interval_mi($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalMul calls the stored function 'pg_catalog.interval_mul(interval, double precision) interval' on db.
func IntervalMul(ctx context.Context, db DB, p0 []byte, p1 float64) ([]byte, error) {
	// call pg_catalog.interval_mul
	const sqlstr = `SELECT * FROM pg_catalog.interval_mul($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalNe calls the stored function 'pg_catalog.interval_ne(interval, interval) boolean' on db.
func IntervalNe(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.interval_ne
	const sqlstr = `SELECT * FROM pg_catalog.interval_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IntervalPl calls the stored function 'pg_catalog.interval_pl(interval, interval) interval' on db.
func IntervalPl(ctx context.Context, db DB, p0, p1 []byte) ([]byte, error) {
	// call pg_catalog.interval_pl
	const sqlstr = `SELECT * FROM pg_catalog.interval_pl($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalPlDate calls the stored function 'pg_catalog.interval_pl_date(interval, date) timestamp without time zone' on db.
func IntervalPlDate(ctx context.Context, db DB, p0 []byte, p1 time.Time) (time.Time, error) {
	// call pg_catalog.interval_pl_date
	const sqlstr = `SELECT * FROM pg_catalog.interval_pl_date($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// IntervalPlTime calls the stored function 'pg_catalog.interval_pl_time(interval, time without time zone) time without time zone' on db.
func IntervalPlTime(ctx context.Context, db DB, p0 []byte, p1 time.Time) (time.Time, error) {
	// call pg_catalog.interval_pl_time
	const sqlstr = `SELECT * FROM pg_catalog.interval_pl_time($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// IntervalPlTimestamp calls the stored function 'pg_catalog.interval_pl_timestamp(interval, timestamp without time zone) timestamp without time zone' on db.
func IntervalPlTimestamp(ctx context.Context, db DB, p0 []byte, p1 time.Time) (time.Time, error) {
	// call pg_catalog.interval_pl_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.interval_pl_timestamp($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// IntervalPlTimestamptz calls the stored function 'pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) timestamp with time zone' on db.
func IntervalPlTimestamptz(ctx context.Context, db DB, p0 []byte, p1 time.Time) (time.Time, error) {
	// call pg_catalog.interval_pl_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.interval_pl_timestamptz($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// IntervalPlTimetz calls the stored function 'pg_catalog.interval_pl_timetz(interval, time with time zone) time with time zone' on db.
func IntervalPlTimetz(ctx context.Context, db DB, p0 []byte, p1 time.Time) (time.Time, error) {
	// call pg_catalog.interval_pl_timetz
	const sqlstr = `SELECT * FROM pg_catalog.interval_pl_timetz($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// IntervalRecv calls the stored function 'pg_catalog.interval_recv(internal, oid, integer) interval' on db.
func IntervalRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) ([]byte, error) {
	// call pg_catalog.interval_recv
	const sqlstr = `SELECT * FROM pg_catalog.interval_recv($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalSend calls the stored function 'pg_catalog.interval_send(interval) bytea' on db.
func IntervalSend(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.interval_send
	const sqlstr = `SELECT * FROM pg_catalog.interval_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalSmaller calls the stored function 'pg_catalog.interval_smaller(interval, interval) interval' on db.
func IntervalSmaller(ctx context.Context, db DB, p0, p1 []byte) ([]byte, error) {
	// call pg_catalog.interval_smaller
	const sqlstr = `SELECT * FROM pg_catalog.interval_smaller($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// IntervalSupport calls the stored function 'pg_catalog.interval_support(internal) internal' on db.
func IntervalSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.interval_support
	const sqlstr = `SELECT * FROM pg_catalog.interval_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// IntervalUm calls the stored function 'pg_catalog.interval_um(interval) interval' on db.
func IntervalUm(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.interval_um
	const sqlstr = `SELECT * FROM pg_catalog.interval_um($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Intervaltypmodin calls the stored function 'pg_catalog.intervaltypmodin(cstring) integer' on db.
func Intervaltypmodin(ctx context.Context, db DB, p0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.intervaltypmodin
	const sqlstr = `SELECT * FROM pg_catalog.intervaltypmodin($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// IsNormalized calls the stored function 'pg_catalog.is_normalized(text, text) boolean' on db.
func IsNormalized(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.is_normalized
	const sqlstr = `SELECT * FROM pg_catalog.is_normalized($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Isclosed calls the stored function 'pg_catalog.isclosed(path) boolean' on db.
func Isclosed(ctx context.Context, db DB, p0 pgtypes.Path) (bool, error) {
	// call pg_catalog.isclosed
	const sqlstr = `SELECT * FROM pg_catalog.isclosed($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Isempty calls the stored function 'pg_catalog.isempty(anyrange) boolean' on db.
func Isempty(ctx context.Context, db DB, p0 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.isempty
	const sqlstr = `SELECT * FROM pg_catalog.isempty($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IsfiniteByDate calls the stored function 'pg_catalog.isfinite(date) boolean' on db.
func IsfiniteByDate(ctx context.Context, db DB, p0 time.Time) (bool, error) {
	// call pg_catalog.isfinite
	const sqlstr = `SELECT * FROM pg_catalog.isfinite($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IsfiniteByTimestampWithTimeZone calls the stored function 'pg_catalog.isfinite(timestamp with time zone) boolean' on db.
func IsfiniteByTimestampWithTimeZone(ctx context.Context, db DB, p0 time.Time) (bool, error) {
	// call pg_catalog.isfinite
	const sqlstr = `SELECT * FROM pg_catalog.isfinite($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IsfiniteByInterval calls the stored function 'pg_catalog.isfinite(interval) boolean' on db.
func IsfiniteByInterval(ctx context.Context, db DB, p0 []byte) (bool, error) {
	// call pg_catalog.isfinite
	const sqlstr = `SELECT * FROM pg_catalog.isfinite($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IsfiniteByTimestampWithoutTimeZone calls the stored function 'pg_catalog.isfinite(timestamp without time zone) boolean' on db.
func IsfiniteByTimestampWithoutTimeZone(ctx context.Context, db DB, p0 time.Time) (bool, error) {
	// call pg_catalog.isfinite
	const sqlstr = `SELECT * FROM pg_catalog.isfinite($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IshorizontalByPointAndPoint calls the stored function 'pg_catalog.ishorizontal(point, point) boolean' on db.
func IshorizontalByPointAndPoint(ctx context.Context, db DB, p0, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.ishorizontal
	const sqlstr = `SELECT * FROM pg_catalog.ishorizontal($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IshorizontalByLseg calls the stored function 'pg_catalog.ishorizontal(lseg) boolean' on db.
func IshorizontalByLseg(ctx context.Context, db DB, p0 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.ishorizontal
	const sqlstr = `SELECT * FROM pg_catalog.ishorizontal($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IshorizontalByLine calls the stored function 'pg_catalog.ishorizontal(line) boolean' on db.
func IshorizontalByLine(ctx context.Context, db DB, p0 pgtypes.Line) (bool, error) {
	// call pg_catalog.ishorizontal
	const sqlstr = `SELECT * FROM pg_catalog.ishorizontal($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Iso88591ToUTF8 calls the stored function 'pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer)' on db.
func Iso88591ToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.iso8859_1_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.iso8859_1_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Iso8859ToUTF8 calls the stored function 'pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer)' on db.
func Iso8859ToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.iso8859_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.iso8859_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// IsoToKoi8r calls the stored function 'pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer)' on db.
func IsoToKoi8r(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.iso_to_koi8r
	const sqlstr = `SELECT * FROM pg_catalog.iso_to_koi8r($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// IsoToMic calls the stored function 'pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer)' on db.
func IsoToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.iso_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.iso_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// IsoToWin1251 calls the stored function 'pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer)' on db.
func IsoToWin1251(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.iso_to_win1251
	const sqlstr = `SELECT * FROM pg_catalog.iso_to_win1251($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// IsoToWin866 calls the stored function 'pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer)' on db.
func IsoToWin866(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.iso_to_win866
	const sqlstr = `SELECT * FROM pg_catalog.iso_to_win866($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Isopen calls the stored function 'pg_catalog.isopen(path) boolean' on db.
func Isopen(ctx context.Context, db DB, p0 pgtypes.Path) (bool, error) {
	// call pg_catalog.isopen
	const sqlstr = `SELECT * FROM pg_catalog.isopen($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IsparallelByLsegAndLseg calls the stored function 'pg_catalog.isparallel(lseg, lseg) boolean' on db.
func IsparallelByLsegAndLseg(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.isparallel
	const sqlstr = `SELECT * FROM pg_catalog.isparallel($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IsparallelByLineAndLine calls the stored function 'pg_catalog.isparallel(line, line) boolean' on db.
func IsparallelByLineAndLine(ctx context.Context, db DB, p0, p1 pgtypes.Line) (bool, error) {
	// call pg_catalog.isparallel
	const sqlstr = `SELECT * FROM pg_catalog.isparallel($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IsperpByLsegAndLseg calls the stored function 'pg_catalog.isperp(lseg, lseg) boolean' on db.
func IsperpByLsegAndLseg(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.isperp
	const sqlstr = `SELECT * FROM pg_catalog.isperp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IsperpByLineAndLine calls the stored function 'pg_catalog.isperp(line, line) boolean' on db.
func IsperpByLineAndLine(ctx context.Context, db DB, p0, p1 pgtypes.Line) (bool, error) {
	// call pg_catalog.isperp
	const sqlstr = `SELECT * FROM pg_catalog.isperp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IsverticalByPointAndPoint calls the stored function 'pg_catalog.isvertical(point, point) boolean' on db.
func IsverticalByPointAndPoint(ctx context.Context, db DB, p0, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.isvertical
	const sqlstr = `SELECT * FROM pg_catalog.isvertical($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IsverticalByLseg calls the stored function 'pg_catalog.isvertical(lseg) boolean' on db.
func IsverticalByLseg(ctx context.Context, db DB, p0 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.isvertical
	const sqlstr = `SELECT * FROM pg_catalog.isvertical($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// IsverticalByLine calls the stored function 'pg_catalog.isvertical(line) boolean' on db.
func IsverticalByLine(ctx context.Context, db DB, p0 pgtypes.Line) (bool, error) {
	// call pg_catalog.isvertical
	const sqlstr = `SELECT * FROM pg_catalog.isvertical($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JSONAggFinalfn calls the stored function 'pg_catalog.json_agg_finalfn(internal) json' on db.
func JSONAggFinalfn(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.json_agg_finalfn
	const sqlstr = `SELECT * FROM pg_catalog.json_agg_finalfn($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JSONAggTransfn calls the stored function 'pg_catalog.json_agg_transfn(internal, anyelement) internal' on db.
func JSONAggTransfn(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Anyelement) (pgtypes.Internal, error) {
	// call pg_catalog.json_agg_transfn
	const sqlstr = `SELECT * FROM pg_catalog.json_agg_transfn($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// JSONArrayElement calls the stored function 'pg_catalog.json_array_element(json, integer) json' on db.
func JSONArrayElement(ctx context.Context, db DB, fromJSON []byte, elementIndex int) ([]byte, error) {
	// call pg_catalog.json_array_element
	const sqlstr = `SELECT * FROM pg_catalog.json_array_element($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, fromJSON, elementIndex)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON, elementIndex).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JSONArrayElementText calls the stored function 'pg_catalog.json_array_element_text(json, integer) text' on db.
func JSONArrayElementText(ctx context.Context, db DB, fromJSON []byte, elementIndex int) (string, error) {
	// call pg_catalog.json_array_element_text
	const sqlstr = `SELECT * FROM pg_catalog.json_array_element_text($1, $2)`
	// run
	var r0 string
	logf(sqlstr, fromJSON, elementIndex)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON, elementIndex).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// JSONArrayElements calls the stored function 'pg_catalog.json_array_elements(json) json' on db.
func JSONArrayElements(ctx context.Context, db DB, fromJSON []byte) ([]byte, error) {
	// call pg_catalog.json_array_elements
	const sqlstr = `SELECT * FROM pg_catalog.json_array_elements($1)`
	// run
	var value []byte
	logf(sqlstr, fromJSON)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON).Scan(&value); err != nil {
		return nil, logerror(err)
	}
	return value, nil
}

// JSONArrayElementsText calls the stored function 'pg_catalog.json_array_elements_text(json) text' on db.
func JSONArrayElementsText(ctx context.Context, db DB, fromJSON []byte) (string, error) {
	// call pg_catalog.json_array_elements_text
	const sqlstr = `SELECT * FROM pg_catalog.json_array_elements_text($1)`
	// run
	var value string
	logf(sqlstr, fromJSON)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON).Scan(&value); err != nil {
		return "", logerror(err)
	}
	return value, nil
}

// JSONArrayLength calls the stored function 'pg_catalog.json_array_length(json) integer' on db.
func JSONArrayLength(ctx context.Context, db DB, p0 []byte) (int, error) {
	// call pg_catalog.json_array_length
	const sqlstr = `SELECT * FROM pg_catalog.json_array_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// JSONBuildArray calls the stored function 'pg_catalog.json_build_array() json' on db.
func JSONBuildArray(ctx context.Context, db DB) ([]byte, error) {
	// call pg_catalog.json_build_array
	const sqlstr = `SELECT * FROM pg_catalog.json_build_array()`
	// run
	var r0 []byte
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JSONBuildObject calls the stored function 'pg_catalog.json_build_object() json' on db.
func JSONBuildObject(ctx context.Context, db DB) ([]byte, error) {
	// call pg_catalog.json_build_object
	const sqlstr = `SELECT * FROM pg_catalog.json_build_object()`
	// run
	var r0 []byte
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JSONEach calls the stored function 'pg_catalog.json_each(json) (text, json)' on db.
func JSONEach(ctx context.Context, db DB, fromJSON []byte) (string, []byte, error) {
	// call pg_catalog.json_each
	const sqlstr = `SELECT * FROM pg_catalog.json_each($1)`
	// run
	var key string
	var value []byte
	logf(sqlstr, fromJSON)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON).Scan(&key, &value); err != nil {
		return "", nil, logerror(err)
	}
	return key, value, nil
}

// JSONEachText calls the stored function 'pg_catalog.json_each_text(json) (text, text)' on db.
func JSONEachText(ctx context.Context, db DB, fromJSON []byte) (string, string, error) {
	// call pg_catalog.json_each_text
	const sqlstr = `SELECT * FROM pg_catalog.json_each_text($1)`
	// run
	var key string
	var value string
	logf(sqlstr, fromJSON)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON).Scan(&key, &value); err != nil {
		return "", "", logerror(err)
	}
	return key, value, nil
}

// JSONObjectByText calls the stored function 'pg_catalog.json_object(text) json' on db.
func JSONObjectByText(ctx context.Context, db DB, p0 StringSlice) ([]byte, error) {
	// call pg_catalog.json_object
	const sqlstr = `SELECT * FROM pg_catalog.json_object($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JSONObjectByTextAndText calls the stored function 'pg_catalog.json_object(text, text) json' on db.
func JSONObjectByTextAndText(ctx context.Context, db DB, p0, p1 StringSlice) ([]byte, error) {
	// call pg_catalog.json_object
	const sqlstr = `SELECT * FROM pg_catalog.json_object($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JSONObjectAggFinalfn calls the stored function 'pg_catalog.json_object_agg_finalfn(internal) json' on db.
func JSONObjectAggFinalfn(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.json_object_agg_finalfn
	const sqlstr = `SELECT * FROM pg_catalog.json_object_agg_finalfn($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JSONObjectAggTransfn calls the stored function 'pg_catalog.json_object_agg_transfn(internal, "any", "any") internal' on db.
func JSONObjectAggTransfn(ctx context.Context, db DB, p0 pgtypes.Internal, p1, p2 pgtypes.Any) (pgtypes.Internal, error) {
	// call pg_catalog.json_object_agg_transfn
	const sqlstr = `SELECT * FROM pg_catalog.json_object_agg_transfn($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// JSONObjectField calls the stored function 'pg_catalog.json_object_field(json, text) json' on db.
func JSONObjectField(ctx context.Context, db DB, fromJSON []byte, fieldName string) ([]byte, error) {
	// call pg_catalog.json_object_field
	const sqlstr = `SELECT * FROM pg_catalog.json_object_field($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, fromJSON, fieldName)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON, fieldName).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JSONObjectFieldText calls the stored function 'pg_catalog.json_object_field_text(json, text) text' on db.
func JSONObjectFieldText(ctx context.Context, db DB, fromJSON []byte, fieldName string) (string, error) {
	// call pg_catalog.json_object_field_text
	const sqlstr = `SELECT * FROM pg_catalog.json_object_field_text($1, $2)`
	// run
	var r0 string
	logf(sqlstr, fromJSON, fieldName)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON, fieldName).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// JSONObjectKeys calls the stored function 'pg_catalog.json_object_keys(json) text' on db.
func JSONObjectKeys(ctx context.Context, db DB, p0 []byte) (string, error) {
	// call pg_catalog.json_object_keys
	const sqlstr = `SELECT * FROM pg_catalog.json_object_keys($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// JSONPopulateRecord calls the stored function 'pg_catalog.json_populate_record(anyelement, json, boolean) anyelement' on db.
func JSONPopulateRecord(ctx context.Context, db DB, base pgtypes.Anyelement, fromJSON []byte, useJSONAsText bool) (pgtypes.Anyelement, error) {
	// call pg_catalog.json_populate_record
	const sqlstr = `SELECT * FROM pg_catalog.json_populate_record($1, $2, $3)`
	// run
	var r0 pgtypes.Anyelement
	logf(sqlstr, base, fromJSON, useJSONAsText)
	if err := db.QueryRowContext(ctx, sqlstr, base, fromJSON, useJSONAsText).Scan(&r0); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return r0, nil
}

// JSONPopulateRecordset calls the stored function 'pg_catalog.json_populate_recordset(anyelement, json, boolean) anyelement' on db.
func JSONPopulateRecordset(ctx context.Context, db DB, base pgtypes.Anyelement, fromJSON []byte, useJSONAsText bool) (pgtypes.Anyelement, error) {
	// call pg_catalog.json_populate_recordset
	const sqlstr = `SELECT * FROM pg_catalog.json_populate_recordset($1, $2, $3)`
	// run
	var r0 pgtypes.Anyelement
	logf(sqlstr, base, fromJSON, useJSONAsText)
	if err := db.QueryRowContext(ctx, sqlstr, base, fromJSON, useJSONAsText).Scan(&r0); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return r0, nil
}

// JSONRecv calls the stored function 'pg_catalog.json_recv(internal) json' on db.
func JSONRecv(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.json_recv
	const sqlstr = `SELECT * FROM pg_catalog.json_recv($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JSONSend calls the stored function 'pg_catalog.json_send(json) bytea' on db.
func JSONSend(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.json_send
	const sqlstr = `SELECT * FROM pg_catalog.json_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JSONStripNulls calls the stored function 'pg_catalog.json_strip_nulls(json) json' on db.
func JSONStripNulls(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.json_strip_nulls
	const sqlstr = `SELECT * FROM pg_catalog.json_strip_nulls($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JSONToRecord calls the stored function 'pg_catalog.json_to_record(json) record' on db.
func JSONToRecord(ctx context.Context, db DB, p0 []byte) (pgtypes.Record, error) {
	// call pg_catalog.json_to_record
	const sqlstr = `SELECT * FROM pg_catalog.json_to_record($1)`
	// run
	var r0 pgtypes.Record
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return r0, nil
}

// JSONToRecordset calls the stored function 'pg_catalog.json_to_recordset(json) record' on db.
func JSONToRecordset(ctx context.Context, db DB, p0 []byte) (pgtypes.Record, error) {
	// call pg_catalog.json_to_recordset
	const sqlstr = `SELECT * FROM pg_catalog.json_to_recordset($1)`
	// run
	var r0 pgtypes.Record
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return r0, nil
}

// JSONToTsvectorByJSONAndJsonb calls the stored function 'pg_catalog.json_to_tsvector(json, jsonb) tsvector' on db.
func JSONToTsvectorByJSONAndJsonb(ctx context.Context, db DB, p0, p1 []byte) (pgtypes.Tsvector, error) {
	// call pg_catalog.json_to_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.json_to_tsvector($1, $2)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// JSONToTsvectorByRegconfigJSONAndJsonb calls the stored function 'pg_catalog.json_to_tsvector(regconfig, json, jsonb) tsvector' on db.
func JSONToTsvectorByRegconfigJSONAndJsonb(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1, p2 []byte) (pgtypes.Tsvector, error) {
	// call pg_catalog.json_to_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.json_to_tsvector($1, $2, $3)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// JSONTypeof calls the stored function 'pg_catalog.json_typeof(json) text' on db.
func JSONTypeof(ctx context.Context, db DB, p0 []byte) (string, error) {
	// call pg_catalog.json_typeof
	const sqlstr = `SELECT * FROM pg_catalog.json_typeof($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// JohabToUTF8 calls the stored function 'pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer)' on db.
func JohabToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.johab_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.johab_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// JsonbAggFinalfn calls the stored function 'pg_catalog.jsonb_agg_finalfn(internal) jsonb' on db.
func JsonbAggFinalfn(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.jsonb_agg_finalfn
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_agg_finalfn($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbAggTransfn calls the stored function 'pg_catalog.jsonb_agg_transfn(internal, anyelement) internal' on db.
func JsonbAggTransfn(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Anyelement) (pgtypes.Internal, error) {
	// call pg_catalog.jsonb_agg_transfn
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_agg_transfn($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// JsonbArrayElement calls the stored function 'pg_catalog.jsonb_array_element(jsonb, integer) jsonb' on db.
func JsonbArrayElement(ctx context.Context, db DB, fromJSON []byte, elementIndex int) ([]byte, error) {
	// call pg_catalog.jsonb_array_element
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_array_element($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, fromJSON, elementIndex)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON, elementIndex).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbArrayElementText calls the stored function 'pg_catalog.jsonb_array_element_text(jsonb, integer) text' on db.
func JsonbArrayElementText(ctx context.Context, db DB, fromJSON []byte, elementIndex int) (string, error) {
	// call pg_catalog.jsonb_array_element_text
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_array_element_text($1, $2)`
	// run
	var r0 string
	logf(sqlstr, fromJSON, elementIndex)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON, elementIndex).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// JsonbArrayElements calls the stored function 'pg_catalog.jsonb_array_elements(jsonb) jsonb' on db.
func JsonbArrayElements(ctx context.Context, db DB, fromJSON []byte) ([]byte, error) {
	// call pg_catalog.jsonb_array_elements
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_array_elements($1)`
	// run
	var value []byte
	logf(sqlstr, fromJSON)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON).Scan(&value); err != nil {
		return nil, logerror(err)
	}
	return value, nil
}

// JsonbArrayElementsText calls the stored function 'pg_catalog.jsonb_array_elements_text(jsonb) text' on db.
func JsonbArrayElementsText(ctx context.Context, db DB, fromJSON []byte) (string, error) {
	// call pg_catalog.jsonb_array_elements_text
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_array_elements_text($1)`
	// run
	var value string
	logf(sqlstr, fromJSON)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON).Scan(&value); err != nil {
		return "", logerror(err)
	}
	return value, nil
}

// JsonbArrayLength calls the stored function 'pg_catalog.jsonb_array_length(jsonb) integer' on db.
func JsonbArrayLength(ctx context.Context, db DB, p0 []byte) (int, error) {
	// call pg_catalog.jsonb_array_length
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_array_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// JsonbBuildArray calls the stored function 'pg_catalog.jsonb_build_array() jsonb' on db.
func JsonbBuildArray(ctx context.Context, db DB) ([]byte, error) {
	// call pg_catalog.jsonb_build_array
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_build_array()`
	// run
	var r0 []byte
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbBuildObject calls the stored function 'pg_catalog.jsonb_build_object() jsonb' on db.
func JsonbBuildObject(ctx context.Context, db DB) ([]byte, error) {
	// call pg_catalog.jsonb_build_object
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_build_object()`
	// run
	var r0 []byte
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbCmp calls the stored function 'pg_catalog.jsonb_cmp(jsonb, jsonb) integer' on db.
func JsonbCmp(ctx context.Context, db DB, p0, p1 []byte) (int, error) {
	// call pg_catalog.jsonb_cmp
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// JsonbConcat calls the stored function 'pg_catalog.jsonb_concat(jsonb, jsonb) jsonb' on db.
func JsonbConcat(ctx context.Context, db DB, p0, p1 []byte) ([]byte, error) {
	// call pg_catalog.jsonb_concat
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_concat($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbContained calls the stored function 'pg_catalog.jsonb_contained(jsonb, jsonb) boolean' on db.
func JsonbContained(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.jsonb_contained
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_contained($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbContains calls the stored function 'pg_catalog.jsonb_contains(jsonb, jsonb) boolean' on db.
func JsonbContains(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.jsonb_contains
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_contains($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbDeleteByJsonbAndText calls the stored function 'pg_catalog.jsonb_delete(jsonb, text) jsonb' on db.
func JsonbDeleteByJsonbAndText(ctx context.Context, db DB, p0 []byte, p1 string) ([]byte, error) {
	// call pg_catalog.jsonb_delete
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_delete($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbDeleteByJsonbAndInteger calls the stored function 'pg_catalog.jsonb_delete(jsonb, integer) jsonb' on db.
func JsonbDeleteByJsonbAndInteger(ctx context.Context, db DB, p0 []byte, p1 int) ([]byte, error) {
	// call pg_catalog.jsonb_delete
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_delete($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbDeletePath calls the stored function 'pg_catalog.jsonb_delete_path(jsonb, text) jsonb' on db.
func JsonbDeletePath(ctx context.Context, db DB, p0 []byte, p1 StringSlice) ([]byte, error) {
	// call pg_catalog.jsonb_delete_path
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_delete_path($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbEach calls the stored function 'pg_catalog.jsonb_each(jsonb) (text, jsonb)' on db.
func JsonbEach(ctx context.Context, db DB, fromJSON []byte) (string, []byte, error) {
	// call pg_catalog.jsonb_each
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_each($1)`
	// run
	var key string
	var value []byte
	logf(sqlstr, fromJSON)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON).Scan(&key, &value); err != nil {
		return "", nil, logerror(err)
	}
	return key, value, nil
}

// JsonbEachText calls the stored function 'pg_catalog.jsonb_each_text(jsonb) (text, text)' on db.
func JsonbEachText(ctx context.Context, db DB, fromJSON []byte) (string, string, error) {
	// call pg_catalog.jsonb_each_text
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_each_text($1)`
	// run
	var key string
	var value string
	logf(sqlstr, fromJSON)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON).Scan(&key, &value); err != nil {
		return "", "", logerror(err)
	}
	return key, value, nil
}

// JsonbEq calls the stored function 'pg_catalog.jsonb_eq(jsonb, jsonb) boolean' on db.
func JsonbEq(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.jsonb_eq
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbExists calls the stored function 'pg_catalog.jsonb_exists(jsonb, text) boolean' on db.
func JsonbExists(ctx context.Context, db DB, p0 []byte, p1 string) (bool, error) {
	// call pg_catalog.jsonb_exists
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_exists($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbExistsAll calls the stored function 'pg_catalog.jsonb_exists_all(jsonb, text) boolean' on db.
func JsonbExistsAll(ctx context.Context, db DB, p0 []byte, p1 StringSlice) (bool, error) {
	// call pg_catalog.jsonb_exists_all
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_exists_all($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbExistsAny calls the stored function 'pg_catalog.jsonb_exists_any(jsonb, text) boolean' on db.
func JsonbExistsAny(ctx context.Context, db DB, p0 []byte, p1 StringSlice) (bool, error) {
	// call pg_catalog.jsonb_exists_any
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_exists_any($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbGe calls the stored function 'pg_catalog.jsonb_ge(jsonb, jsonb) boolean' on db.
func JsonbGe(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.jsonb_ge
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbGt calls the stored function 'pg_catalog.jsonb_gt(jsonb, jsonb) boolean' on db.
func JsonbGt(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.jsonb_gt
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbHash calls the stored function 'pg_catalog.jsonb_hash(jsonb) integer' on db.
func JsonbHash(ctx context.Context, db DB, p0 []byte) (int, error) {
	// call pg_catalog.jsonb_hash
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_hash($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// JsonbHashExtended calls the stored function 'pg_catalog.jsonb_hash_extended(jsonb, bigint) bigint' on db.
func JsonbHashExtended(ctx context.Context, db DB, p0 []byte, p1 int64) (int64, error) {
	// call pg_catalog.jsonb_hash_extended
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_hash_extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// JsonbInsert calls the stored function 'pg_catalog.jsonb_insert(jsonb, text, jsonb, boolean) jsonb' on db.
func JsonbInsert(ctx context.Context, db DB, jsonbIn []byte, path StringSlice, replacement []byte, insertAfter bool) ([]byte, error) {
	// call pg_catalog.jsonb_insert
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_insert($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, jsonbIn, path, replacement, insertAfter)
	if err := db.QueryRowContext(ctx, sqlstr, jsonbIn, path, replacement, insertAfter).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbLe calls the stored function 'pg_catalog.jsonb_le(jsonb, jsonb) boolean' on db.
func JsonbLe(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.jsonb_le
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbLt calls the stored function 'pg_catalog.jsonb_lt(jsonb, jsonb) boolean' on db.
func JsonbLt(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.jsonb_lt
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbNe calls the stored function 'pg_catalog.jsonb_ne(jsonb, jsonb) boolean' on db.
func JsonbNe(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.jsonb_ne
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbObjectByText calls the stored function 'pg_catalog.jsonb_object(text) jsonb' on db.
func JsonbObjectByText(ctx context.Context, db DB, p0 StringSlice) ([]byte, error) {
	// call pg_catalog.jsonb_object
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_object($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbObjectByTextAndText calls the stored function 'pg_catalog.jsonb_object(text, text) jsonb' on db.
func JsonbObjectByTextAndText(ctx context.Context, db DB, p0, p1 StringSlice) ([]byte, error) {
	// call pg_catalog.jsonb_object
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_object($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbObjectAggFinalfn calls the stored function 'pg_catalog.jsonb_object_agg_finalfn(internal) jsonb' on db.
func JsonbObjectAggFinalfn(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.jsonb_object_agg_finalfn
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_object_agg_finalfn($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbObjectAggTransfn calls the stored function 'pg_catalog.jsonb_object_agg_transfn(internal, "any", "any") internal' on db.
func JsonbObjectAggTransfn(ctx context.Context, db DB, p0 pgtypes.Internal, p1, p2 pgtypes.Any) (pgtypes.Internal, error) {
	// call pg_catalog.jsonb_object_agg_transfn
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_object_agg_transfn($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// JsonbObjectField calls the stored function 'pg_catalog.jsonb_object_field(jsonb, text) jsonb' on db.
func JsonbObjectField(ctx context.Context, db DB, fromJSON []byte, fieldName string) ([]byte, error) {
	// call pg_catalog.jsonb_object_field
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_object_field($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, fromJSON, fieldName)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON, fieldName).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbObjectFieldText calls the stored function 'pg_catalog.jsonb_object_field_text(jsonb, text) text' on db.
func JsonbObjectFieldText(ctx context.Context, db DB, fromJSON []byte, fieldName string) (string, error) {
	// call pg_catalog.jsonb_object_field_text
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_object_field_text($1, $2)`
	// run
	var r0 string
	logf(sqlstr, fromJSON, fieldName)
	if err := db.QueryRowContext(ctx, sqlstr, fromJSON, fieldName).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// JsonbObjectKeys calls the stored function 'pg_catalog.jsonb_object_keys(jsonb) text' on db.
func JsonbObjectKeys(ctx context.Context, db DB, p0 []byte) (string, error) {
	// call pg_catalog.jsonb_object_keys
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_object_keys($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// JsonbPathExists calls the stored function 'pg_catalog.jsonb_path_exists(jsonb, jsonpath, jsonb, boolean) boolean' on db.
func JsonbPathExists(ctx context.Context, db DB, target []byte, path pgtypes.Jsonpath, vars []byte, silent bool) (bool, error) {
	// call pg_catalog.jsonb_path_exists
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_exists($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, target, path, vars, silent)
	if err := db.QueryRowContext(ctx, sqlstr, target, path, vars, silent).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbPathExistsOpr calls the stored function 'pg_catalog.jsonb_path_exists_opr(jsonb, jsonpath) boolean' on db.
func JsonbPathExistsOpr(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Jsonpath) (bool, error) {
	// call pg_catalog.jsonb_path_exists_opr
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_exists_opr($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbPathExistsTz calls the stored function 'pg_catalog.jsonb_path_exists_tz(jsonb, jsonpath, jsonb, boolean) boolean' on db.
func JsonbPathExistsTz(ctx context.Context, db DB, target []byte, path pgtypes.Jsonpath, vars []byte, silent bool) (bool, error) {
	// call pg_catalog.jsonb_path_exists_tz
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_exists_tz($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, target, path, vars, silent)
	if err := db.QueryRowContext(ctx, sqlstr, target, path, vars, silent).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbPathMatch calls the stored function 'pg_catalog.jsonb_path_match(jsonb, jsonpath, jsonb, boolean) boolean' on db.
func JsonbPathMatch(ctx context.Context, db DB, target []byte, path pgtypes.Jsonpath, vars []byte, silent bool) (bool, error) {
	// call pg_catalog.jsonb_path_match
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_match($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, target, path, vars, silent)
	if err := db.QueryRowContext(ctx, sqlstr, target, path, vars, silent).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbPathMatchOpr calls the stored function 'pg_catalog.jsonb_path_match_opr(jsonb, jsonpath) boolean' on db.
func JsonbPathMatchOpr(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Jsonpath) (bool, error) {
	// call pg_catalog.jsonb_path_match_opr
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_match_opr($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbPathMatchTz calls the stored function 'pg_catalog.jsonb_path_match_tz(jsonb, jsonpath, jsonb, boolean) boolean' on db.
func JsonbPathMatchTz(ctx context.Context, db DB, target []byte, path pgtypes.Jsonpath, vars []byte, silent bool) (bool, error) {
	// call pg_catalog.jsonb_path_match_tz
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_match_tz($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, target, path, vars, silent)
	if err := db.QueryRowContext(ctx, sqlstr, target, path, vars, silent).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// JsonbPathQuery calls the stored function 'pg_catalog.jsonb_path_query(jsonb, jsonpath, jsonb, boolean) jsonb' on db.
func JsonbPathQuery(ctx context.Context, db DB, target []byte, path pgtypes.Jsonpath, vars []byte, silent bool) ([]byte, error) {
	// call pg_catalog.jsonb_path_query
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_query($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, target, path, vars, silent)
	if err := db.QueryRowContext(ctx, sqlstr, target, path, vars, silent).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbPathQueryArray calls the stored function 'pg_catalog.jsonb_path_query_array(jsonb, jsonpath, jsonb, boolean) jsonb' on db.
func JsonbPathQueryArray(ctx context.Context, db DB, target []byte, path pgtypes.Jsonpath, vars []byte, silent bool) ([]byte, error) {
	// call pg_catalog.jsonb_path_query_array
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_query_array($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, target, path, vars, silent)
	if err := db.QueryRowContext(ctx, sqlstr, target, path, vars, silent).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbPathQueryArrayTz calls the stored function 'pg_catalog.jsonb_path_query_array_tz(jsonb, jsonpath, jsonb, boolean) jsonb' on db.
func JsonbPathQueryArrayTz(ctx context.Context, db DB, target []byte, path pgtypes.Jsonpath, vars []byte, silent bool) ([]byte, error) {
	// call pg_catalog.jsonb_path_query_array_tz
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_query_array_tz($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, target, path, vars, silent)
	if err := db.QueryRowContext(ctx, sqlstr, target, path, vars, silent).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbPathQueryFirst calls the stored function 'pg_catalog.jsonb_path_query_first(jsonb, jsonpath, jsonb, boolean) jsonb' on db.
func JsonbPathQueryFirst(ctx context.Context, db DB, target []byte, path pgtypes.Jsonpath, vars []byte, silent bool) ([]byte, error) {
	// call pg_catalog.jsonb_path_query_first
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_query_first($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, target, path, vars, silent)
	if err := db.QueryRowContext(ctx, sqlstr, target, path, vars, silent).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbPathQueryFirstTz calls the stored function 'pg_catalog.jsonb_path_query_first_tz(jsonb, jsonpath, jsonb, boolean) jsonb' on db.
func JsonbPathQueryFirstTz(ctx context.Context, db DB, target []byte, path pgtypes.Jsonpath, vars []byte, silent bool) ([]byte, error) {
	// call pg_catalog.jsonb_path_query_first_tz
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_query_first_tz($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, target, path, vars, silent)
	if err := db.QueryRowContext(ctx, sqlstr, target, path, vars, silent).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbPathQueryTz calls the stored function 'pg_catalog.jsonb_path_query_tz(jsonb, jsonpath, jsonb, boolean) jsonb' on db.
func JsonbPathQueryTz(ctx context.Context, db DB, target []byte, path pgtypes.Jsonpath, vars []byte, silent bool) ([]byte, error) {
	// call pg_catalog.jsonb_path_query_tz
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_path_query_tz($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, target, path, vars, silent)
	if err := db.QueryRowContext(ctx, sqlstr, target, path, vars, silent).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbPopulateRecord calls the stored function 'pg_catalog.jsonb_populate_record(anyelement, jsonb) anyelement' on db.
func JsonbPopulateRecord(ctx context.Context, db DB, p0 pgtypes.Anyelement, p1 []byte) (pgtypes.Anyelement, error) {
	// call pg_catalog.jsonb_populate_record
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_populate_record($1, $2)`
	// run
	var r0 pgtypes.Anyelement
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return r0, nil
}

// JsonbPopulateRecordset calls the stored function 'pg_catalog.jsonb_populate_recordset(anyelement, jsonb) anyelement' on db.
func JsonbPopulateRecordset(ctx context.Context, db DB, p0 pgtypes.Anyelement, p1 []byte) (pgtypes.Anyelement, error) {
	// call pg_catalog.jsonb_populate_recordset
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_populate_recordset($1, $2)`
	// run
	var r0 pgtypes.Anyelement
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return r0, nil
}

// JsonbPretty calls the stored function 'pg_catalog.jsonb_pretty(jsonb) text' on db.
func JsonbPretty(ctx context.Context, db DB, p0 []byte) (string, error) {
	// call pg_catalog.jsonb_pretty
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_pretty($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// JsonbRecv calls the stored function 'pg_catalog.jsonb_recv(internal) jsonb' on db.
func JsonbRecv(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.jsonb_recv
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_recv($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbSend calls the stored function 'pg_catalog.jsonb_send(jsonb) bytea' on db.
func JsonbSend(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.jsonb_send
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbSet calls the stored function 'pg_catalog.jsonb_set(jsonb, text, jsonb, boolean) jsonb' on db.
func JsonbSet(ctx context.Context, db DB, jsonbIn []byte, path StringSlice, replacement []byte, createIfMissing bool) ([]byte, error) {
	// call pg_catalog.jsonb_set
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_set($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, jsonbIn, path, replacement, createIfMissing)
	if err := db.QueryRowContext(ctx, sqlstr, jsonbIn, path, replacement, createIfMissing).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbSetLax calls the stored function 'pg_catalog.jsonb_set_lax(jsonb, text, jsonb, boolean, text) jsonb' on db.
func JsonbSetLax(ctx context.Context, db DB, jsonbIn []byte, path StringSlice, replacement []byte, createIfMissing bool, nullValueTreatment string) ([]byte, error) {
	// call pg_catalog.jsonb_set_lax
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_set_lax($1, $2, $3, $4, $5)`
	// run
	var r0 []byte
	logf(sqlstr, jsonbIn, path, replacement, createIfMissing, nullValueTreatment)
	if err := db.QueryRowContext(ctx, sqlstr, jsonbIn, path, replacement, createIfMissing, nullValueTreatment).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbStripNulls calls the stored function 'pg_catalog.jsonb_strip_nulls(jsonb) jsonb' on db.
func JsonbStripNulls(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.jsonb_strip_nulls
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_strip_nulls($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JsonbToRecord calls the stored function 'pg_catalog.jsonb_to_record(jsonb) record' on db.
func JsonbToRecord(ctx context.Context, db DB, p0 []byte) (pgtypes.Record, error) {
	// call pg_catalog.jsonb_to_record
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_to_record($1)`
	// run
	var r0 pgtypes.Record
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return r0, nil
}

// JsonbToRecordset calls the stored function 'pg_catalog.jsonb_to_recordset(jsonb) record' on db.
func JsonbToRecordset(ctx context.Context, db DB, p0 []byte) (pgtypes.Record, error) {
	// call pg_catalog.jsonb_to_recordset
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_to_recordset($1)`
	// run
	var r0 pgtypes.Record
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return r0, nil
}

// JsonbToTsvectorByJsonbAndJsonb calls the stored function 'pg_catalog.jsonb_to_tsvector(jsonb, jsonb) tsvector' on db.
func JsonbToTsvectorByJsonbAndJsonb(ctx context.Context, db DB, p0, p1 []byte) (pgtypes.Tsvector, error) {
	// call pg_catalog.jsonb_to_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_to_tsvector($1, $2)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// JsonbToTsvectorByRegconfigJsonbAndJsonb calls the stored function 'pg_catalog.jsonb_to_tsvector(regconfig, jsonb, jsonb) tsvector' on db.
func JsonbToTsvectorByRegconfigJsonbAndJsonb(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1, p2 []byte) (pgtypes.Tsvector, error) {
	// call pg_catalog.jsonb_to_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_to_tsvector($1, $2, $3)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// JsonbTypeof calls the stored function 'pg_catalog.jsonb_typeof(jsonb) text' on db.
func JsonbTypeof(ctx context.Context, db DB, p0 []byte) (string, error) {
	// call pg_catalog.jsonb_typeof
	const sqlstr = `SELECT * FROM pg_catalog.jsonb_typeof($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// JsonpathRecv calls the stored function 'pg_catalog.jsonpath_recv(internal) jsonpath' on db.
func JsonpathRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Jsonpath, error) {
	// call pg_catalog.jsonpath_recv
	const sqlstr = `SELECT * FROM pg_catalog.jsonpath_recv($1)`
	// run
	var r0 pgtypes.Jsonpath
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Jsonpath{}, logerror(err)
	}
	return r0, nil
}

// JsonpathSend calls the stored function 'pg_catalog.jsonpath_send(jsonpath) bytea' on db.
func JsonpathSend(ctx context.Context, db DB, p0 pgtypes.Jsonpath) ([]byte, error) {
	// call pg_catalog.jsonpath_send
	const sqlstr = `SELECT * FROM pg_catalog.jsonpath_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JustifyDays calls the stored function 'pg_catalog.justify_days(interval) interval' on db.
func JustifyDays(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.justify_days
	const sqlstr = `SELECT * FROM pg_catalog.justify_days($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JustifyHours calls the stored function 'pg_catalog.justify_hours(interval) interval' on db.
func JustifyHours(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.justify_hours
	const sqlstr = `SELECT * FROM pg_catalog.justify_hours($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// JustifyInterval calls the stored function 'pg_catalog.justify_interval(interval) interval' on db.
func JustifyInterval(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.justify_interval
	const sqlstr = `SELECT * FROM pg_catalog.justify_interval($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Koi8rToIso calls the stored function 'pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer)' on db.
func Koi8rToIso(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.koi8r_to_iso
	const sqlstr = `SELECT * FROM pg_catalog.koi8r_to_iso($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Koi8rToMic calls the stored function 'pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer)' on db.
func Koi8rToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.koi8r_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.koi8r_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Koi8rToUTF8 calls the stored function 'pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer)' on db.
func Koi8rToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.koi8r_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.koi8r_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Koi8rToWin1251 calls the stored function 'pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer)' on db.
func Koi8rToWin1251(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.koi8r_to_win1251
	const sqlstr = `SELECT * FROM pg_catalog.koi8r_to_win1251($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Koi8rToWin866 calls the stored function 'pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer)' on db.
func Koi8rToWin866(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.koi8r_to_win866
	const sqlstr = `SELECT * FROM pg_catalog.koi8r_to_win866($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Koi8uToUTF8 calls the stored function 'pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer)' on db.
func Koi8uToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.koi8u_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.koi8u_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Lastval calls the stored function 'pg_catalog.lastval() bigint' on db.
func Lastval(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.lastval
	const sqlstr = `SELECT * FROM pg_catalog.lastval()`
	// run
	var r0 int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Latin1ToMic calls the stored function 'pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer)' on db.
func Latin1ToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.latin1_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.latin1_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Latin2ToMic calls the stored function 'pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer)' on db.
func Latin2ToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.latin2_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.latin2_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Latin2ToWin1250 calls the stored function 'pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer)' on db.
func Latin2ToWin1250(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.latin2_to_win1250
	const sqlstr = `SELECT * FROM pg_catalog.latin2_to_win1250($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Latin3ToMic calls the stored function 'pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer)' on db.
func Latin3ToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.latin3_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.latin3_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Latin4ToMic calls the stored function 'pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer)' on db.
func Latin4ToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.latin4_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.latin4_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// LcmByIntegerAndInteger calls the stored function 'pg_catalog.lcm(integer, integer) integer' on db.
func LcmByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.lcm
	const sqlstr = `SELECT * FROM pg_catalog.lcm($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LcmByBigintAndBigint calls the stored function 'pg_catalog.lcm(bigint, bigint) bigint' on db.
func LcmByBigintAndBigint(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.lcm
	const sqlstr = `SELECT * FROM pg_catalog.lcm($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LcmByNumericAndNumeric calls the stored function 'pg_catalog.lcm(numeric, numeric) numeric' on db.
func LcmByNumericAndNumeric(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.lcm
	const sqlstr = `SELECT * FROM pg_catalog.lcm($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Left calls the stored function 'pg_catalog.left(text, integer) text' on db.
func Left(ctx context.Context, db DB, p0 string, p1 int) (string, error) {
	// call pg_catalog.left
	const sqlstr = `SELECT * FROM pg_catalog.left($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// LengthByText calls the stored function 'pg_catalog.length(text) integer' on db.
func LengthByText(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.length
	const sqlstr = `SELECT * FROM pg_catalog.length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LengthByCharacter calls the stored function 'pg_catalog.length(character) integer' on db.
func LengthByCharacter(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.length
	const sqlstr = `SELECT * FROM pg_catalog.length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LengthByLseg calls the stored function 'pg_catalog.length(lseg) double precision' on db.
func LengthByLseg(ctx context.Context, db DB, p0 pgtypes.Lseg) (float64, error) {
	// call pg_catalog.length
	const sqlstr = `SELECT * FROM pg_catalog.length($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// LengthByPath calls the stored function 'pg_catalog.length(path) double precision' on db.
func LengthByPath(ctx context.Context, db DB, p0 pgtypes.Path) (float64, error) {
	// call pg_catalog.length
	const sqlstr = `SELECT * FROM pg_catalog.length($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// LengthByBit calls the stored function 'pg_catalog.length(bit) integer' on db.
func LengthByBit(ctx context.Context, db DB, p0 uint8) (int, error) {
	// call pg_catalog.length
	const sqlstr = `SELECT * FROM pg_catalog.length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LengthByByteaAndName calls the stored function 'pg_catalog.length(bytea, name) integer' on db.
func LengthByByteaAndName(ctx context.Context, db DB, p0 []byte, p1 string) (int, error) {
	// call pg_catalog.length
	const sqlstr = `SELECT * FROM pg_catalog.length($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LengthByBytea calls the stored function 'pg_catalog.length(bytea) integer' on db.
func LengthByBytea(ctx context.Context, db DB, p0 []byte) (int, error) {
	// call pg_catalog.length
	const sqlstr = `SELECT * FROM pg_catalog.length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LengthByTsvector calls the stored function 'pg_catalog.length(tsvector) integer' on db.
func LengthByTsvector(ctx context.Context, db DB, p0 pgtypes.Tsvector) (int, error) {
	// call pg_catalog.length
	const sqlstr = `SELECT * FROM pg_catalog.length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LikeByTextAndText calls the stored function 'pg_catalog.like(text, text) boolean' on db.
func LikeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.like
	const sqlstr = `SELECT * FROM pg_catalog.like($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LikeByNameAndText calls the stored function 'pg_catalog.like(name, text) boolean' on db.
func LikeByNameAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.like
	const sqlstr = `SELECT * FROM pg_catalog.like($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LikeByByteaAndBytea calls the stored function 'pg_catalog.like(bytea, bytea) boolean' on db.
func LikeByByteaAndBytea(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.like
	const sqlstr = `SELECT * FROM pg_catalog.like($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LikeEscapeByTextAndText calls the stored function 'pg_catalog.like_escape(text, text) text' on db.
func LikeEscapeByTextAndText(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.like_escape
	const sqlstr = `SELECT * FROM pg_catalog.like_escape($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// LikeEscapeByByteaAndBytea calls the stored function 'pg_catalog.like_escape(bytea, bytea) bytea' on db.
func LikeEscapeByByteaAndBytea(ctx context.Context, db DB, p0, p1 []byte) ([]byte, error) {
	// call pg_catalog.like_escape
	const sqlstr = `SELECT * FROM pg_catalog.like_escape($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Likejoinsel calls the stored function 'pg_catalog.likejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Likejoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.likejoinsel
	const sqlstr = `SELECT * FROM pg_catalog.likejoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Likesel calls the stored function 'pg_catalog.likesel(internal, oid, internal, integer) double precision' on db.
func Likesel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.likesel
	const sqlstr = `SELECT * FROM pg_catalog.likesel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Line calls the stored function 'pg_catalog.line(point, point) line' on db.
func Line(ctx context.Context, db DB, p0, p1 pgtypes.Point) (pgtypes.Line, error) {
	// call pg_catalog.line
	const sqlstr = `SELECT * FROM pg_catalog.line($1, $2)`
	// run
	var r0 pgtypes.Line
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Line{}, logerror(err)
	}
	return r0, nil
}

// LineDistance calls the stored function 'pg_catalog.line_distance(line, line) double precision' on db.
func LineDistance(ctx context.Context, db DB, p0, p1 pgtypes.Line) (float64, error) {
	// call pg_catalog.line_distance
	const sqlstr = `SELECT * FROM pg_catalog.line_distance($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// LineEq calls the stored function 'pg_catalog.line_eq(line, line) boolean' on db.
func LineEq(ctx context.Context, db DB, p0, p1 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_eq
	const sqlstr = `SELECT * FROM pg_catalog.line_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LineHorizontal calls the stored function 'pg_catalog.line_horizontal(line) boolean' on db.
func LineHorizontal(ctx context.Context, db DB, p0 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_horizontal
	const sqlstr = `SELECT * FROM pg_catalog.line_horizontal($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LineInterpt calls the stored function 'pg_catalog.line_interpt(line, line) point' on db.
func LineInterpt(ctx context.Context, db DB, p0, p1 pgtypes.Line) (pgtypes.Point, error) {
	// call pg_catalog.line_interpt
	const sqlstr = `SELECT * FROM pg_catalog.line_interpt($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// LineIntersect calls the stored function 'pg_catalog.line_intersect(line, line) boolean' on db.
func LineIntersect(ctx context.Context, db DB, p0, p1 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_intersect
	const sqlstr = `SELECT * FROM pg_catalog.line_intersect($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LineParallel calls the stored function 'pg_catalog.line_parallel(line, line) boolean' on db.
func LineParallel(ctx context.Context, db DB, p0, p1 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_parallel
	const sqlstr = `SELECT * FROM pg_catalog.line_parallel($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LinePerp calls the stored function 'pg_catalog.line_perp(line, line) boolean' on db.
func LinePerp(ctx context.Context, db DB, p0, p1 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_perp
	const sqlstr = `SELECT * FROM pg_catalog.line_perp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LineRecv calls the stored function 'pg_catalog.line_recv(internal) line' on db.
func LineRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Line, error) {
	// call pg_catalog.line_recv
	const sqlstr = `SELECT * FROM pg_catalog.line_recv($1)`
	// run
	var r0 pgtypes.Line
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Line{}, logerror(err)
	}
	return r0, nil
}

// LineSend calls the stored function 'pg_catalog.line_send(line) bytea' on db.
func LineSend(ctx context.Context, db DB, p0 pgtypes.Line) ([]byte, error) {
	// call pg_catalog.line_send
	const sqlstr = `SELECT * FROM pg_catalog.line_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// LineVertical calls the stored function 'pg_catalog.line_vertical(line) boolean' on db.
func LineVertical(ctx context.Context, db DB, p0 pgtypes.Line) (bool, error) {
	// call pg_catalog.line_vertical
	const sqlstr = `SELECT * FROM pg_catalog.line_vertical($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LnByDoublePrecision calls the stored function 'pg_catalog.ln(double precision) double precision' on db.
func LnByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.ln
	const sqlstr = `SELECT * FROM pg_catalog.ln($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// LnByNumeric calls the stored function 'pg_catalog.ln(numeric) numeric' on db.
func LnByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.ln
	const sqlstr = `SELECT * FROM pg_catalog.ln($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// LoClose calls the stored function 'pg_catalog.lo_close(integer) integer' on db.
func LoClose(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.lo_close
	const sqlstr = `SELECT * FROM pg_catalog.lo_close($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LoCreat calls the stored function 'pg_catalog.lo_creat(integer) oid' on db.
func LoCreat(ctx context.Context, db DB, p0 int) (pgtypes.Oid, error) {
	// call pg_catalog.lo_creat
	const sqlstr = `SELECT * FROM pg_catalog.lo_creat($1)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// LoCreate calls the stored function 'pg_catalog.lo_create(oid) oid' on db.
func LoCreate(ctx context.Context, db DB, p0 pgtypes.Oid) (pgtypes.Oid, error) {
	// call pg_catalog.lo_create
	const sqlstr = `SELECT * FROM pg_catalog.lo_create($1)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// LoExport calls the stored function 'pg_catalog.lo_export(oid, text) integer' on db.
func LoExport(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (int, error) {
	// call pg_catalog.lo_export
	const sqlstr = `SELECT * FROM pg_catalog.lo_export($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LoFromBytea calls the stored function 'pg_catalog.lo_from_bytea(oid, bytea) oid' on db.
func LoFromBytea(ctx context.Context, db DB, p0 pgtypes.Oid, p1 []byte) (pgtypes.Oid, error) {
	// call pg_catalog.lo_from_bytea
	const sqlstr = `SELECT * FROM pg_catalog.lo_from_bytea($1, $2)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// LoGetByOid calls the stored function 'pg_catalog.lo_get(oid) bytea' on db.
func LoGetByOid(ctx context.Context, db DB, p0 pgtypes.Oid) ([]byte, error) {
	// call pg_catalog.lo_get
	const sqlstr = `SELECT * FROM pg_catalog.lo_get($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// LoGetByOidBigintAndInteger calls the stored function 'pg_catalog.lo_get(oid, bigint, integer) bytea' on db.
func LoGetByOidBigintAndInteger(ctx context.Context, db DB, p0 pgtypes.Oid, p1 int64, p2 int) ([]byte, error) {
	// call pg_catalog.lo_get
	const sqlstr = `SELECT * FROM pg_catalog.lo_get($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// LoImportByText calls the stored function 'pg_catalog.lo_import(text) oid' on db.
func LoImportByText(ctx context.Context, db DB, p0 string) (pgtypes.Oid, error) {
	// call pg_catalog.lo_import
	const sqlstr = `SELECT * FROM pg_catalog.lo_import($1)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// LoImportByTextAndOid calls the stored function 'pg_catalog.lo_import(text, oid) oid' on db.
func LoImportByTextAndOid(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid) (pgtypes.Oid, error) {
	// call pg_catalog.lo_import
	const sqlstr = `SELECT * FROM pg_catalog.lo_import($1, $2)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// LoLseek calls the stored function 'pg_catalog.lo_lseek(integer, integer, integer) integer' on db.
func LoLseek(ctx context.Context, db DB, p0, p1, p2 int) (int, error) {
	// call pg_catalog.lo_lseek
	const sqlstr = `SELECT * FROM pg_catalog.lo_lseek($1, $2, $3)`
	// run
	var r0 int
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LoLseek64 calls the stored function 'pg_catalog.lo_lseek64(integer, bigint, integer) bigint' on db.
func LoLseek64(ctx context.Context, db DB, p0 int, p1 int64, p2 int) (int64, error) {
	// call pg_catalog.lo_lseek64
	const sqlstr = `SELECT * FROM pg_catalog.lo_lseek64($1, $2, $3)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LoOpen calls the stored function 'pg_catalog.lo_open(oid, integer) integer' on db.
func LoOpen(ctx context.Context, db DB, p0 pgtypes.Oid, p1 int) (int, error) {
	// call pg_catalog.lo_open
	const sqlstr = `SELECT * FROM pg_catalog.lo_open($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LoPut calls the stored function 'pg_catalog.lo_put(oid, bigint, bytea)' on db.
func LoPut(ctx context.Context, db DB, p0 pgtypes.Oid, p1 int64, p2 []byte) error {
	// call pg_catalog.lo_put
	const sqlstr = `SELECT * FROM pg_catalog.lo_put($1, $2, $3)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2); err != nil {
		return logerror(err)
	}
	return nil
}

// LoTell calls the stored function 'pg_catalog.lo_tell(integer) integer' on db.
func LoTell(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.lo_tell
	const sqlstr = `SELECT * FROM pg_catalog.lo_tell($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LoTell64 calls the stored function 'pg_catalog.lo_tell64(integer) bigint' on db.
func LoTell64(ctx context.Context, db DB, p0 int) (int64, error) {
	// call pg_catalog.lo_tell64
	const sqlstr = `SELECT * FROM pg_catalog.lo_tell64($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LoTruncate calls the stored function 'pg_catalog.lo_truncate(integer, integer) integer' on db.
func LoTruncate(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.lo_truncate
	const sqlstr = `SELECT * FROM pg_catalog.lo_truncate($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LoTruncate64 calls the stored function 'pg_catalog.lo_truncate64(integer, bigint) integer' on db.
func LoTruncate64(ctx context.Context, db DB, p0 int, p1 int64) (int, error) {
	// call pg_catalog.lo_truncate64
	const sqlstr = `SELECT * FROM pg_catalog.lo_truncate64($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LoUnlink calls the stored function 'pg_catalog.lo_unlink(oid) integer' on db.
func LoUnlink(ctx context.Context, db DB, p0 pgtypes.Oid) (int, error) {
	// call pg_catalog.lo_unlink
	const sqlstr = `SELECT * FROM pg_catalog.lo_unlink($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LogByDoublePrecision calls the stored function 'pg_catalog.log(double precision) double precision' on db.
func LogByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.log
	const sqlstr = `SELECT * FROM pg_catalog.log($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// LogByNumericAndNumeric calls the stored function 'pg_catalog.log(numeric, numeric) numeric' on db.
func LogByNumericAndNumeric(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.log
	const sqlstr = `SELECT * FROM pg_catalog.log($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// LogByNumeric calls the stored function 'pg_catalog.log(numeric) numeric' on db.
func LogByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.log
	const sqlstr = `SELECT * FROM pg_catalog.log($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Log10ByDoublePrecision calls the stored function 'pg_catalog.log10(double precision) double precision' on db.
func Log10ByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.log10
	const sqlstr = `SELECT * FROM pg_catalog.log10($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Log10ByNumeric calls the stored function 'pg_catalog.log10(numeric) numeric' on db.
func Log10ByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.log10
	const sqlstr = `SELECT * FROM pg_catalog.log10($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Loread calls the stored function 'pg_catalog.loread(integer, integer) bytea' on db.
func Loread(ctx context.Context, db DB, p0, p1 int) ([]byte, error) {
	// call pg_catalog.loread
	const sqlstr = `SELECT * FROM pg_catalog.loread($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// LowerByAnyrange calls the stored function 'pg_catalog.lower(anyrange) anyelement' on db.
func LowerByAnyrange(ctx context.Context, db DB, p0 pgtypes.Anyrange) (pgtypes.Anyelement, error) {
	// call pg_catalog.lower
	const sqlstr = `SELECT * FROM pg_catalog.lower($1)`
	// run
	var r0 pgtypes.Anyelement
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return r0, nil
}

// LowerByText calls the stored function 'pg_catalog.lower(text) text' on db.
func LowerByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.lower
	const sqlstr = `SELECT * FROM pg_catalog.lower($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// LowerInc calls the stored function 'pg_catalog.lower_inc(anyrange) boolean' on db.
func LowerInc(ctx context.Context, db DB, p0 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.lower_inc
	const sqlstr = `SELECT * FROM pg_catalog.lower_inc($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LowerInf calls the stored function 'pg_catalog.lower_inf(anyrange) boolean' on db.
func LowerInf(ctx context.Context, db DB, p0 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.lower_inf
	const sqlstr = `SELECT * FROM pg_catalog.lower_inf($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Lowrite calls the stored function 'pg_catalog.lowrite(integer, bytea) integer' on db.
func Lowrite(ctx context.Context, db DB, p0 int, p1 []byte) (int, error) {
	// call pg_catalog.lowrite
	const sqlstr = `SELECT * FROM pg_catalog.lowrite($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// LpadByTextIntegerAndText calls the stored function 'pg_catalog.lpad(text, integer, text) text' on db.
func LpadByTextIntegerAndText(ctx context.Context, db DB, p0 string, p1 int, p2 string) (string, error) {
	// call pg_catalog.lpad
	const sqlstr = `SELECT * FROM pg_catalog.lpad($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// LpadByTextAndInteger calls the stored function 'pg_catalog.lpad(text, integer) text' on db.
func LpadByTextAndInteger(ctx context.Context, db DB, p0 string, p1 int) (string, error) {
	// call pg_catalog.lpad
	const sqlstr = `SELECT * FROM pg_catalog.lpad($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// LsegByBox calls the stored function 'pg_catalog.lseg(box) lseg' on db.
func LsegByBox(ctx context.Context, db DB, p0 pgtypes.Box) (pgtypes.Lseg, error) {
	// call pg_catalog.lseg
	const sqlstr = `SELECT * FROM pg_catalog.lseg($1)`
	// run
	var r0 pgtypes.Lseg
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Lseg{}, logerror(err)
	}
	return r0, nil
}

// LsegByPointAndPoint calls the stored function 'pg_catalog.lseg(point, point) lseg' on db.
func LsegByPointAndPoint(ctx context.Context, db DB, p0, p1 pgtypes.Point) (pgtypes.Lseg, error) {
	// call pg_catalog.lseg
	const sqlstr = `SELECT * FROM pg_catalog.lseg($1, $2)`
	// run
	var r0 pgtypes.Lseg
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Lseg{}, logerror(err)
	}
	return r0, nil
}

// LsegCenter calls the stored function 'pg_catalog.lseg_center(lseg) point' on db.
func LsegCenter(ctx context.Context, db DB, p0 pgtypes.Lseg) (pgtypes.Point, error) {
	// call pg_catalog.lseg_center
	const sqlstr = `SELECT * FROM pg_catalog.lseg_center($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// LsegDistance calls the stored function 'pg_catalog.lseg_distance(lseg, lseg) double precision' on db.
func LsegDistance(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (float64, error) {
	// call pg_catalog.lseg_distance
	const sqlstr = `SELECT * FROM pg_catalog.lseg_distance($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// LsegEq calls the stored function 'pg_catalog.lseg_eq(lseg, lseg) boolean' on db.
func LsegEq(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_eq
	const sqlstr = `SELECT * FROM pg_catalog.lseg_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LsegGe calls the stored function 'pg_catalog.lseg_ge(lseg, lseg) boolean' on db.
func LsegGe(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_ge
	const sqlstr = `SELECT * FROM pg_catalog.lseg_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LsegGt calls the stored function 'pg_catalog.lseg_gt(lseg, lseg) boolean' on db.
func LsegGt(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_gt
	const sqlstr = `SELECT * FROM pg_catalog.lseg_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LsegHorizontal calls the stored function 'pg_catalog.lseg_horizontal(lseg) boolean' on db.
func LsegHorizontal(ctx context.Context, db DB, p0 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_horizontal
	const sqlstr = `SELECT * FROM pg_catalog.lseg_horizontal($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LsegInterpt calls the stored function 'pg_catalog.lseg_interpt(lseg, lseg) point' on db.
func LsegInterpt(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (pgtypes.Point, error) {
	// call pg_catalog.lseg_interpt
	const sqlstr = `SELECT * FROM pg_catalog.lseg_interpt($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// LsegIntersect calls the stored function 'pg_catalog.lseg_intersect(lseg, lseg) boolean' on db.
func LsegIntersect(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_intersect
	const sqlstr = `SELECT * FROM pg_catalog.lseg_intersect($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LsegLe calls the stored function 'pg_catalog.lseg_le(lseg, lseg) boolean' on db.
func LsegLe(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_le
	const sqlstr = `SELECT * FROM pg_catalog.lseg_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LsegLength calls the stored function 'pg_catalog.lseg_length(lseg) double precision' on db.
func LsegLength(ctx context.Context, db DB, p0 pgtypes.Lseg) (float64, error) {
	// call pg_catalog.lseg_length
	const sqlstr = `SELECT * FROM pg_catalog.lseg_length($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// LsegLt calls the stored function 'pg_catalog.lseg_lt(lseg, lseg) boolean' on db.
func LsegLt(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_lt
	const sqlstr = `SELECT * FROM pg_catalog.lseg_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LsegNe calls the stored function 'pg_catalog.lseg_ne(lseg, lseg) boolean' on db.
func LsegNe(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_ne
	const sqlstr = `SELECT * FROM pg_catalog.lseg_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LsegParallel calls the stored function 'pg_catalog.lseg_parallel(lseg, lseg) boolean' on db.
func LsegParallel(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_parallel
	const sqlstr = `SELECT * FROM pg_catalog.lseg_parallel($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LsegPerp calls the stored function 'pg_catalog.lseg_perp(lseg, lseg) boolean' on db.
func LsegPerp(ctx context.Context, db DB, p0, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_perp
	const sqlstr = `SELECT * FROM pg_catalog.lseg_perp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LsegRecv calls the stored function 'pg_catalog.lseg_recv(internal) lseg' on db.
func LsegRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Lseg, error) {
	// call pg_catalog.lseg_recv
	const sqlstr = `SELECT * FROM pg_catalog.lseg_recv($1)`
	// run
	var r0 pgtypes.Lseg
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Lseg{}, logerror(err)
	}
	return r0, nil
}

// LsegSend calls the stored function 'pg_catalog.lseg_send(lseg) bytea' on db.
func LsegSend(ctx context.Context, db DB, p0 pgtypes.Lseg) ([]byte, error) {
	// call pg_catalog.lseg_send
	const sqlstr = `SELECT * FROM pg_catalog.lseg_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// LsegVertical calls the stored function 'pg_catalog.lseg_vertical(lseg) boolean' on db.
func LsegVertical(ctx context.Context, db DB, p0 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.lseg_vertical
	const sqlstr = `SELECT * FROM pg_catalog.lseg_vertical($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// LtrimByTextAndText calls the stored function 'pg_catalog.ltrim(text, text) text' on db.
func LtrimByTextAndText(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.ltrim
	const sqlstr = `SELECT * FROM pg_catalog.ltrim($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// LtrimByText calls the stored function 'pg_catalog.ltrim(text) text' on db.
func LtrimByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.ltrim
	const sqlstr = `SELECT * FROM pg_catalog.ltrim($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Macaddr calls the stored function 'pg_catalog.macaddr(macaddr8) macaddr' on db.
func Macaddr(ctx context.Context, db DB, p0 pgtypes.Macaddr8) (pgtypes.Macaddr, error) {
	// call pg_catalog.macaddr
	const sqlstr = `SELECT * FROM pg_catalog.macaddr($1)`
	// run
	var r0 pgtypes.Macaddr
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return r0, nil
}

// Macaddr8 calls the stored function 'pg_catalog.macaddr8(macaddr) macaddr8' on db.
func Macaddr8(ctx context.Context, db DB, p0 pgtypes.Macaddr) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8($1)`
	// run
	var r0 pgtypes.Macaddr8
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return r0, nil
}

// Macaddr8And calls the stored function 'pg_catalog.macaddr8_and(macaddr8, macaddr8) macaddr8' on db.
func Macaddr8And(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr8) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8_and
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_and($1, $2)`
	// run
	var r0 pgtypes.Macaddr8
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return r0, nil
}

// Macaddr8Cmp calls the stored function 'pg_catalog.macaddr8_cmp(macaddr8, macaddr8) integer' on db.
func Macaddr8Cmp(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr8) (int, error) {
	// call pg_catalog.macaddr8_cmp
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Macaddr8Eq calls the stored function 'pg_catalog.macaddr8_eq(macaddr8, macaddr8) boolean' on db.
func Macaddr8Eq(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_eq
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Macaddr8Ge calls the stored function 'pg_catalog.macaddr8_ge(macaddr8, macaddr8) boolean' on db.
func Macaddr8Ge(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_ge
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Macaddr8Gt calls the stored function 'pg_catalog.macaddr8_gt(macaddr8, macaddr8) boolean' on db.
func Macaddr8Gt(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_gt
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Macaddr8Le calls the stored function 'pg_catalog.macaddr8_le(macaddr8, macaddr8) boolean' on db.
func Macaddr8Le(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_le
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Macaddr8Lt calls the stored function 'pg_catalog.macaddr8_lt(macaddr8, macaddr8) boolean' on db.
func Macaddr8Lt(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_lt
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Macaddr8Ne calls the stored function 'pg_catalog.macaddr8_ne(macaddr8, macaddr8) boolean' on db.
func Macaddr8Ne(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr8) (bool, error) {
	// call pg_catalog.macaddr8_ne
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Macaddr8Not calls the stored function 'pg_catalog.macaddr8_not(macaddr8) macaddr8' on db.
func Macaddr8Not(ctx context.Context, db DB, p0 pgtypes.Macaddr8) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8_not
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_not($1)`
	// run
	var r0 pgtypes.Macaddr8
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return r0, nil
}

// Macaddr8Or calls the stored function 'pg_catalog.macaddr8_or(macaddr8, macaddr8) macaddr8' on db.
func Macaddr8Or(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr8) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8_or
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_or($1, $2)`
	// run
	var r0 pgtypes.Macaddr8
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return r0, nil
}

// Macaddr8Recv calls the stored function 'pg_catalog.macaddr8_recv(internal) macaddr8' on db.
func Macaddr8Recv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8_recv
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_recv($1)`
	// run
	var r0 pgtypes.Macaddr8
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return r0, nil
}

// Macaddr8Send calls the stored function 'pg_catalog.macaddr8_send(macaddr8) bytea' on db.
func Macaddr8Send(ctx context.Context, db DB, p0 pgtypes.Macaddr8) ([]byte, error) {
	// call pg_catalog.macaddr8_send
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Macaddr8Set7bit calls the stored function 'pg_catalog.macaddr8_set7bit(macaddr8) macaddr8' on db.
func Macaddr8Set7bit(ctx context.Context, db DB, p0 pgtypes.Macaddr8) (pgtypes.Macaddr8, error) {
	// call pg_catalog.macaddr8_set7bit
	const sqlstr = `SELECT * FROM pg_catalog.macaddr8_set7bit($1)`
	// run
	var r0 pgtypes.Macaddr8
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return r0, nil
}

// MacaddrAnd calls the stored function 'pg_catalog.macaddr_and(macaddr, macaddr) macaddr' on db.
func MacaddrAnd(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr) (pgtypes.Macaddr, error) {
	// call pg_catalog.macaddr_and
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_and($1, $2)`
	// run
	var r0 pgtypes.Macaddr
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return r0, nil
}

// MacaddrCmp calls the stored function 'pg_catalog.macaddr_cmp(macaddr, macaddr) integer' on db.
func MacaddrCmp(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr) (int, error) {
	// call pg_catalog.macaddr_cmp
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// MacaddrEq calls the stored function 'pg_catalog.macaddr_eq(macaddr, macaddr) boolean' on db.
func MacaddrEq(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_eq
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// MacaddrGe calls the stored function 'pg_catalog.macaddr_ge(macaddr, macaddr) boolean' on db.
func MacaddrGe(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_ge
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// MacaddrGt calls the stored function 'pg_catalog.macaddr_gt(macaddr, macaddr) boolean' on db.
func MacaddrGt(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_gt
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// MacaddrLe calls the stored function 'pg_catalog.macaddr_le(macaddr, macaddr) boolean' on db.
func MacaddrLe(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_le
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// MacaddrLt calls the stored function 'pg_catalog.macaddr_lt(macaddr, macaddr) boolean' on db.
func MacaddrLt(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_lt
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// MacaddrNe calls the stored function 'pg_catalog.macaddr_ne(macaddr, macaddr) boolean' on db.
func MacaddrNe(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr) (bool, error) {
	// call pg_catalog.macaddr_ne
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// MacaddrNot calls the stored function 'pg_catalog.macaddr_not(macaddr) macaddr' on db.
func MacaddrNot(ctx context.Context, db DB, p0 pgtypes.Macaddr) (pgtypes.Macaddr, error) {
	// call pg_catalog.macaddr_not
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_not($1)`
	// run
	var r0 pgtypes.Macaddr
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return r0, nil
}

// MacaddrOr calls the stored function 'pg_catalog.macaddr_or(macaddr, macaddr) macaddr' on db.
func MacaddrOr(ctx context.Context, db DB, p0, p1 pgtypes.Macaddr) (pgtypes.Macaddr, error) {
	// call pg_catalog.macaddr_or
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_or($1, $2)`
	// run
	var r0 pgtypes.Macaddr
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return r0, nil
}

// MacaddrRecv calls the stored function 'pg_catalog.macaddr_recv(internal) macaddr' on db.
func MacaddrRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Macaddr, error) {
	// call pg_catalog.macaddr_recv
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_recv($1)`
	// run
	var r0 pgtypes.Macaddr
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return r0, nil
}

// MacaddrSend calls the stored function 'pg_catalog.macaddr_send(macaddr) bytea' on db.
func MacaddrSend(ctx context.Context, db DB, p0 pgtypes.Macaddr) ([]byte, error) {
	// call pg_catalog.macaddr_send
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// MacaddrSortsupport calls the stored function 'pg_catalog.macaddr_sortsupport(internal)' on db.
func MacaddrSortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.macaddr_sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.macaddr_sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// MakeDate calls the stored function 'pg_catalog.make_date(integer, integer, integer) date' on db.
func MakeDate(ctx context.Context, db DB, year, month, day int) (time.Time, error) {
	// call pg_catalog.make_date
	const sqlstr = `SELECT * FROM pg_catalog.make_date($1, $2, $3)`
	// run
	var r0 time.Time
	logf(sqlstr, year, month, day)
	if err := db.QueryRowContext(ctx, sqlstr, year, month, day).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// MakeInterval calls the stored function 'pg_catalog.make_interval(integer, integer, integer, integer, integer, integer, double precision) interval' on db.
func MakeInterval(ctx context.Context, db DB, years, months, weeks, days, hours, mins int, secs float64) ([]byte, error) {
	// call pg_catalog.make_interval
	const sqlstr = `SELECT * FROM pg_catalog.make_interval($1, $2, $3, $4, $5, $6, $7)`
	// run
	var r0 []byte
	logf(sqlstr, years, months, weeks, days, hours, mins, secs)
	if err := db.QueryRowContext(ctx, sqlstr, years, months, weeks, days, hours, mins, secs).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// MakeTime calls the stored function 'pg_catalog.make_time(integer, integer, double precision) time without time zone' on db.
func MakeTime(ctx context.Context, db DB, hour, min int, sec float64) (time.Time, error) {
	// call pg_catalog.make_time
	const sqlstr = `SELECT * FROM pg_catalog.make_time($1, $2, $3)`
	// run
	var r0 time.Time
	logf(sqlstr, hour, min, sec)
	if err := db.QueryRowContext(ctx, sqlstr, hour, min, sec).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// MakeTimestamp calls the stored function 'pg_catalog.make_timestamp(integer, integer, integer, integer, integer, double precision) timestamp without time zone' on db.
func MakeTimestamp(ctx context.Context, db DB, year, month, mday, hour, min int, sec float64) (time.Time, error) {
	// call pg_catalog.make_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.make_timestamp($1, $2, $3, $4, $5, $6)`
	// run
	var r0 time.Time
	logf(sqlstr, year, month, mday, hour, min, sec)
	if err := db.QueryRowContext(ctx, sqlstr, year, month, mday, hour, min, sec).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// MakeTimestamptzByYearMonthMdayHourMinAndSec calls the stored function 'pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision) timestamp with time zone' on db.
func MakeTimestamptzByYearMonthMdayHourMinAndSec(ctx context.Context, db DB, year, month, mday, hour, min int, sec float64) (time.Time, error) {
	// call pg_catalog.make_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.make_timestamptz($1, $2, $3, $4, $5, $6)`
	// run
	var r0 time.Time
	logf(sqlstr, year, month, mday, hour, min, sec)
	if err := db.QueryRowContext(ctx, sqlstr, year, month, mday, hour, min, sec).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// MakeTimestamptzByYearMonthMdayHourMinSecAndTimezone calls the stored function 'pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision, text) timestamp with time zone' on db.
func MakeTimestamptzByYearMonthMdayHourMinSecAndTimezone(ctx context.Context, db DB, year, month, mday, hour, min int, sec float64, timezone string) (time.Time, error) {
	// call pg_catalog.make_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.make_timestamptz($1, $2, $3, $4, $5, $6, $7)`
	// run
	var r0 time.Time
	logf(sqlstr, year, month, mday, hour, min, sec, timezone)
	if err := db.QueryRowContext(ctx, sqlstr, year, month, mday, hour, min, sec, timezone).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// Makeaclitem calls the stored function 'pg_catalog.makeaclitem(oid, oid, text, boolean) aclitem' on db.
func Makeaclitem(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string, p3 bool) (pgtypes.Aclitem, error) {
	// call pg_catalog.makeaclitem
	const sqlstr = `SELECT * FROM pg_catalog.makeaclitem($1, $2, $3, $4)`
	// run
	var r0 pgtypes.Aclitem
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return pgtypes.Aclitem{}, logerror(err)
	}
	return r0, nil
}

// Masklen calls the stored function 'pg_catalog.masklen(inet) integer' on db.
func Masklen(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.masklen
	const sqlstr = `SELECT * FROM pg_catalog.masklen($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Matchingjoinsel calls the stored function 'pg_catalog.matchingjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Matchingjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.matchingjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.matchingjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Matchingsel calls the stored function 'pg_catalog.matchingsel(internal, oid, internal, integer) double precision' on db.
func Matchingsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.matchingsel
	const sqlstr = `SELECT * FROM pg_catalog.matchingsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Md5ByText calls the stored function 'pg_catalog.md5(text) text' on db.
func Md5ByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.md5
	const sqlstr = `SELECT * FROM pg_catalog.md5($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Md5ByBytea calls the stored function 'pg_catalog.md5(bytea) text' on db.
func Md5ByBytea(ctx context.Context, db DB, p0 []byte) (string, error) {
	// call pg_catalog.md5
	const sqlstr = `SELECT * FROM pg_catalog.md5($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// MicToBig5 calls the stored function 'pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer)' on db.
func MicToBig5(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_big5
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_big5($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToEucCn calls the stored function 'pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer)' on db.
func MicToEucCn(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_euc_cn
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_euc_cn($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToEucJp calls the stored function 'pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer)' on db.
func MicToEucJp(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_euc_jp
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_euc_jp($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToEucKr calls the stored function 'pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer)' on db.
func MicToEucKr(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_euc_kr
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_euc_kr($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToEucTw calls the stored function 'pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer)' on db.
func MicToEucTw(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_euc_tw
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_euc_tw($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToIso calls the stored function 'pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer)' on db.
func MicToIso(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_iso
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_iso($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToKoi8r calls the stored function 'pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer)' on db.
func MicToKoi8r(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_koi8r
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_koi8r($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToLatin1 calls the stored function 'pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer)' on db.
func MicToLatin1(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_latin1
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_latin1($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToLatin2 calls the stored function 'pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer)' on db.
func MicToLatin2(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_latin2
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_latin2($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToLatin3 calls the stored function 'pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer)' on db.
func MicToLatin3(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_latin3
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_latin3($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToLatin4 calls the stored function 'pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer)' on db.
func MicToLatin4(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_latin4
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_latin4($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToSjis calls the stored function 'pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer)' on db.
func MicToSjis(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_sjis
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_sjis($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToWin1250 calls the stored function 'pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer)' on db.
func MicToWin1250(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_win1250
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_win1250($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToWin1251 calls the stored function 'pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer)' on db.
func MicToWin1251(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_win1251
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_win1251($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MicToWin866 calls the stored function 'pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer)' on db.
func MicToWin866(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.mic_to_win866
	const sqlstr = `SELECT * FROM pg_catalog.mic_to_win866($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// MinScale calls the stored function 'pg_catalog.min_scale(numeric) integer' on db.
func MinScale(ctx context.Context, db DB, p0 float64) (int, error) {
	// call pg_catalog.min_scale
	const sqlstr = `SELECT * FROM pg_catalog.min_scale($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// ModByNumericAndNumeric calls the stored function 'pg_catalog.mod(numeric, numeric) numeric' on db.
func ModByNumericAndNumeric(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.mod
	const sqlstr = `SELECT * FROM pg_catalog.mod($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// ModBySmallintAndSmallint calls the stored function 'pg_catalog.mod(smallint, smallint) smallint' on db.
func ModBySmallintAndSmallint(ctx context.Context, db DB, p0, p1 int16) (int16, error) {
	// call pg_catalog.mod
	const sqlstr = `SELECT * FROM pg_catalog.mod($1, $2)`
	// run
	var r0 int16
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// ModByIntegerAndInteger calls the stored function 'pg_catalog.mod(integer, integer) integer' on db.
func ModByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (int, error) {
	// call pg_catalog.mod
	const sqlstr = `SELECT * FROM pg_catalog.mod($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// ModByBigintAndBigint calls the stored function 'pg_catalog.mod(bigint, bigint) bigint' on db.
func ModByBigintAndBigint(ctx context.Context, db DB, p0, p1 int64) (int64, error) {
	// call pg_catalog.mod
	const sqlstr = `SELECT * FROM pg_catalog.mod($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// ModeFinal calls the stored function 'pg_catalog.mode_final(internal, anyelement) anyelement' on db.
func ModeFinal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Anyelement) (pgtypes.Anyelement, error) {
	// call pg_catalog.mode_final
	const sqlstr = `SELECT * FROM pg_catalog.mode_final($1, $2)`
	// run
	var r0 pgtypes.Anyelement
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return r0, nil
}

// MoneyByInteger calls the stored function 'pg_catalog.money(integer) money' on db.
func MoneyByInteger(ctx context.Context, db DB, p0 int) (string, error) {
	// call pg_catalog.money
	const sqlstr = `SELECT * FROM pg_catalog.money($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// MoneyByBigint calls the stored function 'pg_catalog.money(bigint) money' on db.
func MoneyByBigint(ctx context.Context, db DB, p0 int64) (string, error) {
	// call pg_catalog.money
	const sqlstr = `SELECT * FROM pg_catalog.money($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// MoneyByNumeric calls the stored function 'pg_catalog.money(numeric) money' on db.
func MoneyByNumeric(ctx context.Context, db DB, p0 float64) (string, error) {
	// call pg_catalog.money
	const sqlstr = `SELECT * FROM pg_catalog.money($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// MulDInterval calls the stored function 'pg_catalog.mul_d_interval(double precision, interval) interval' on db.
func MulDInterval(ctx context.Context, db DB, p0 float64, p1 []byte) ([]byte, error) {
	// call pg_catalog.mul_d_interval
	const sqlstr = `SELECT * FROM pg_catalog.mul_d_interval($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// MxidAge calls the stored function 'pg_catalog.mxid_age(xid) integer' on db.
func MxidAge(ctx context.Context, db DB, p0 pgtypes.Xid) (int, error) {
	// call pg_catalog.mxid_age
	const sqlstr = `SELECT * FROM pg_catalog.mxid_age($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// NameByCharacterVarying calls the stored function 'pg_catalog.name(character varying) name' on db.
func NameByCharacterVarying(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.name
	const sqlstr = `SELECT * FROM pg_catalog.name($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// NameByText calls the stored function 'pg_catalog.name(text) name' on db.
func NameByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.name
	const sqlstr = `SELECT * FROM pg_catalog.name($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// NameByCharacter calls the stored function 'pg_catalog.name(character) name' on db.
func NameByCharacter(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.name
	const sqlstr = `SELECT * FROM pg_catalog.name($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Nameconcatoid calls the stored function 'pg_catalog.nameconcatoid(name, oid) name' on db.
func Nameconcatoid(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid) (string, error) {
	// call pg_catalog.nameconcatoid
	const sqlstr = `SELECT * FROM pg_catalog.nameconcatoid($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Nameeq calls the stored function 'pg_catalog.nameeq(name, name) boolean' on db.
func Nameeq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.nameeq
	const sqlstr = `SELECT * FROM pg_catalog.nameeq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Nameeqtext calls the stored function 'pg_catalog.nameeqtext(name, text) boolean' on db.
func Nameeqtext(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.nameeqtext
	const sqlstr = `SELECT * FROM pg_catalog.nameeqtext($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namege calls the stored function 'pg_catalog.namege(name, name) boolean' on db.
func Namege(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.namege
	const sqlstr = `SELECT * FROM pg_catalog.namege($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namegetext calls the stored function 'pg_catalog.namegetext(name, text) boolean' on db.
func Namegetext(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.namegetext
	const sqlstr = `SELECT * FROM pg_catalog.namegetext($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namegt calls the stored function 'pg_catalog.namegt(name, name) boolean' on db.
func Namegt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.namegt
	const sqlstr = `SELECT * FROM pg_catalog.namegt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namegttext calls the stored function 'pg_catalog.namegttext(name, text) boolean' on db.
func Namegttext(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.namegttext
	const sqlstr = `SELECT * FROM pg_catalog.namegttext($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Nameiclike calls the stored function 'pg_catalog.nameiclike(name, text) boolean' on db.
func Nameiclike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.nameiclike
	const sqlstr = `SELECT * FROM pg_catalog.nameiclike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Nameicnlike calls the stored function 'pg_catalog.nameicnlike(name, text) boolean' on db.
func Nameicnlike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.nameicnlike
	const sqlstr = `SELECT * FROM pg_catalog.nameicnlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Nameicregexeq calls the stored function 'pg_catalog.nameicregexeq(name, text) boolean' on db.
func Nameicregexeq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.nameicregexeq
	const sqlstr = `SELECT * FROM pg_catalog.nameicregexeq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Nameicregexne calls the stored function 'pg_catalog.nameicregexne(name, text) boolean' on db.
func Nameicregexne(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.nameicregexne
	const sqlstr = `SELECT * FROM pg_catalog.nameicregexne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namele calls the stored function 'pg_catalog.namele(name, name) boolean' on db.
func Namele(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.namele
	const sqlstr = `SELECT * FROM pg_catalog.namele($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Nameletext calls the stored function 'pg_catalog.nameletext(name, text) boolean' on db.
func Nameletext(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.nameletext
	const sqlstr = `SELECT * FROM pg_catalog.nameletext($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namelike calls the stored function 'pg_catalog.namelike(name, text) boolean' on db.
func Namelike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.namelike
	const sqlstr = `SELECT * FROM pg_catalog.namelike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namelt calls the stored function 'pg_catalog.namelt(name, name) boolean' on db.
func Namelt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.namelt
	const sqlstr = `SELECT * FROM pg_catalog.namelt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namelttext calls the stored function 'pg_catalog.namelttext(name, text) boolean' on db.
func Namelttext(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.namelttext
	const sqlstr = `SELECT * FROM pg_catalog.namelttext($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namene calls the stored function 'pg_catalog.namene(name, name) boolean' on db.
func Namene(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.namene
	const sqlstr = `SELECT * FROM pg_catalog.namene($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namenetext calls the stored function 'pg_catalog.namenetext(name, text) boolean' on db.
func Namenetext(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.namenetext
	const sqlstr = `SELECT * FROM pg_catalog.namenetext($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namenlike calls the stored function 'pg_catalog.namenlike(name, text) boolean' on db.
func Namenlike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.namenlike
	const sqlstr = `SELECT * FROM pg_catalog.namenlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namerecv calls the stored function 'pg_catalog.namerecv(internal) name' on db.
func Namerecv(ctx context.Context, db DB, p0 pgtypes.Internal) (string, error) {
	// call pg_catalog.namerecv
	const sqlstr = `SELECT * FROM pg_catalog.namerecv($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Nameregexeq calls the stored function 'pg_catalog.nameregexeq(name, text) boolean' on db.
func Nameregexeq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.nameregexeq
	const sqlstr = `SELECT * FROM pg_catalog.nameregexeq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Nameregexne calls the stored function 'pg_catalog.nameregexne(name, text) boolean' on db.
func Nameregexne(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.nameregexne
	const sqlstr = `SELECT * FROM pg_catalog.nameregexne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Namesend calls the stored function 'pg_catalog.namesend(name) bytea' on db.
func Namesend(ctx context.Context, db DB, p0 string) ([]byte, error) {
	// call pg_catalog.namesend
	const sqlstr = `SELECT * FROM pg_catalog.namesend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Neqjoinsel calls the stored function 'pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Neqjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.neqjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.neqjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Neqsel calls the stored function 'pg_catalog.neqsel(internal, oid, internal, integer) double precision' on db.
func Neqsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.neqsel
	const sqlstr = `SELECT * FROM pg_catalog.neqsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Netmask calls the stored function 'pg_catalog.netmask(inet) inet' on db.
func Netmask(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.netmask
	const sqlstr = `SELECT * FROM pg_catalog.netmask($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Network calls the stored function 'pg_catalog.network(inet) cidr' on db.
func Network(ctx context.Context, db DB, p0 string) (pgtypes.Cidr, error) {
	// call pg_catalog.network
	const sqlstr = `SELECT * FROM pg_catalog.network($1)`
	// run
	var r0 pgtypes.Cidr
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Cidr{}, logerror(err)
	}
	return r0, nil
}

// NetworkCmp calls the stored function 'pg_catalog.network_cmp(inet, inet) integer' on db.
func NetworkCmp(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.network_cmp
	const sqlstr = `SELECT * FROM pg_catalog.network_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// NetworkEq calls the stored function 'pg_catalog.network_eq(inet, inet) boolean' on db.
func NetworkEq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.network_eq
	const sqlstr = `SELECT * FROM pg_catalog.network_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NetworkGe calls the stored function 'pg_catalog.network_ge(inet, inet) boolean' on db.
func NetworkGe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.network_ge
	const sqlstr = `SELECT * FROM pg_catalog.network_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NetworkGt calls the stored function 'pg_catalog.network_gt(inet, inet) boolean' on db.
func NetworkGt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.network_gt
	const sqlstr = `SELECT * FROM pg_catalog.network_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NetworkLarger calls the stored function 'pg_catalog.network_larger(inet, inet) inet' on db.
func NetworkLarger(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.network_larger
	const sqlstr = `SELECT * FROM pg_catalog.network_larger($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// NetworkLe calls the stored function 'pg_catalog.network_le(inet, inet) boolean' on db.
func NetworkLe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.network_le
	const sqlstr = `SELECT * FROM pg_catalog.network_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NetworkLt calls the stored function 'pg_catalog.network_lt(inet, inet) boolean' on db.
func NetworkLt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.network_lt
	const sqlstr = `SELECT * FROM pg_catalog.network_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NetworkNe calls the stored function 'pg_catalog.network_ne(inet, inet) boolean' on db.
func NetworkNe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.network_ne
	const sqlstr = `SELECT * FROM pg_catalog.network_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NetworkOverlap calls the stored function 'pg_catalog.network_overlap(inet, inet) boolean' on db.
func NetworkOverlap(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.network_overlap
	const sqlstr = `SELECT * FROM pg_catalog.network_overlap($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NetworkSmaller calls the stored function 'pg_catalog.network_smaller(inet, inet) inet' on db.
func NetworkSmaller(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.network_smaller
	const sqlstr = `SELECT * FROM pg_catalog.network_smaller($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// NetworkSortsupport calls the stored function 'pg_catalog.network_sortsupport(internal)' on db.
func NetworkSortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.network_sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.network_sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// NetworkSub calls the stored function 'pg_catalog.network_sub(inet, inet) boolean' on db.
func NetworkSub(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.network_sub
	const sqlstr = `SELECT * FROM pg_catalog.network_sub($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NetworkSubeq calls the stored function 'pg_catalog.network_subeq(inet, inet) boolean' on db.
func NetworkSubeq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.network_subeq
	const sqlstr = `SELECT * FROM pg_catalog.network_subeq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NetworkSubsetSupport calls the stored function 'pg_catalog.network_subset_support(internal) internal' on db.
func NetworkSubsetSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.network_subset_support
	const sqlstr = `SELECT * FROM pg_catalog.network_subset_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// NetworkSup calls the stored function 'pg_catalog.network_sup(inet, inet) boolean' on db.
func NetworkSup(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.network_sup
	const sqlstr = `SELECT * FROM pg_catalog.network_sup($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NetworkSupeq calls the stored function 'pg_catalog.network_supeq(inet, inet) boolean' on db.
func NetworkSupeq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.network_supeq
	const sqlstr = `SELECT * FROM pg_catalog.network_supeq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Networkjoinsel calls the stored function 'pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Networkjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.networkjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.networkjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Networksel calls the stored function 'pg_catalog.networksel(internal, oid, internal, integer) double precision' on db.
func Networksel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.networksel
	const sqlstr = `SELECT * FROM pg_catalog.networksel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Nextval calls the stored function 'pg_catalog.nextval(regclass) bigint' on db.
func Nextval(ctx context.Context, db DB, p0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.nextval
	const sqlstr = `SELECT * FROM pg_catalog.nextval($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Nlikejoinsel calls the stored function 'pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Nlikejoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.nlikejoinsel
	const sqlstr = `SELECT * FROM pg_catalog.nlikejoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Nlikesel calls the stored function 'pg_catalog.nlikesel(internal, oid, internal, integer) double precision' on db.
func Nlikesel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.nlikesel
	const sqlstr = `SELECT * FROM pg_catalog.nlikesel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Normalize calls the stored function 'pg_catalog.normalize(text, text) text' on db.
func Normalize(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.normalize
	const sqlstr = `SELECT * FROM pg_catalog.normalize($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// NotlikeByTextAndText calls the stored function 'pg_catalog.notlike(text, text) boolean' on db.
func NotlikeByTextAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.notlike
	const sqlstr = `SELECT * FROM pg_catalog.notlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NotlikeByNameAndText calls the stored function 'pg_catalog.notlike(name, text) boolean' on db.
func NotlikeByNameAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.notlike
	const sqlstr = `SELECT * FROM pg_catalog.notlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NotlikeByByteaAndBytea calls the stored function 'pg_catalog.notlike(bytea, bytea) boolean' on db.
func NotlikeByByteaAndBytea(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.notlike
	const sqlstr = `SELECT * FROM pg_catalog.notlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Now calls the stored function 'pg_catalog.now() timestamp with time zone' on db.
func Now(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.now
	const sqlstr = `SELECT * FROM pg_catalog.now()`
	// run
	var r0 time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// NpointsByPath calls the stored function 'pg_catalog.npoints(path) integer' on db.
func NpointsByPath(ctx context.Context, db DB, p0 pgtypes.Path) (int, error) {
	// call pg_catalog.npoints
	const sqlstr = `SELECT * FROM pg_catalog.npoints($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// NpointsByPolygon calls the stored function 'pg_catalog.npoints(polygon) integer' on db.
func NpointsByPolygon(ctx context.Context, db DB, p0 pgtypes.Polygon) (int, error) {
	// call pg_catalog.npoints
	const sqlstr = `SELECT * FROM pg_catalog.npoints($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// NumericByNumericAndInteger calls the stored function 'pg_catalog.numeric(numeric, integer) numeric' on db.
func NumericByNumericAndInteger(ctx context.Context, db DB, p0 float64, p1 int) (float64, error) {
	// call pg_catalog.numeric
	const sqlstr = `SELECT * FROM pg_catalog.numeric($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericByInteger calls the stored function 'pg_catalog.numeric(integer) numeric' on db.
func NumericByInteger(ctx context.Context, db DB, p0 int) (float64, error) {
	// call pg_catalog.numeric
	const sqlstr = `SELECT * FROM pg_catalog.numeric($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericByReal calls the stored function 'pg_catalog.numeric(real) numeric' on db.
func NumericByReal(ctx context.Context, db DB, p0 float32) (float64, error) {
	// call pg_catalog.numeric
	const sqlstr = `SELECT * FROM pg_catalog.numeric($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericByDoublePrecision calls the stored function 'pg_catalog.numeric(double precision) numeric' on db.
func NumericByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.numeric
	const sqlstr = `SELECT * FROM pg_catalog.numeric($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericByBigint calls the stored function 'pg_catalog.numeric(bigint) numeric' on db.
func NumericByBigint(ctx context.Context, db DB, p0 int64) (float64, error) {
	// call pg_catalog.numeric
	const sqlstr = `SELECT * FROM pg_catalog.numeric($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericBySmallint calls the stored function 'pg_catalog.numeric(smallint) numeric' on db.
func NumericBySmallint(ctx context.Context, db DB, p0 int16) (float64, error) {
	// call pg_catalog.numeric
	const sqlstr = `SELECT * FROM pg_catalog.numeric($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericByJsonb calls the stored function 'pg_catalog.numeric(jsonb) numeric' on db.
func NumericByJsonb(ctx context.Context, db DB, p0 []byte) (float64, error) {
	// call pg_catalog.numeric
	const sqlstr = `SELECT * FROM pg_catalog.numeric($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericByMoney calls the stored function 'pg_catalog.numeric(money) numeric' on db.
func NumericByMoney(ctx context.Context, db DB, p0 string) (float64, error) {
	// call pg_catalog.numeric
	const sqlstr = `SELECT * FROM pg_catalog.numeric($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericAbs calls the stored function 'pg_catalog.numeric_abs(numeric) numeric' on db.
func NumericAbs(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.numeric_abs
	const sqlstr = `SELECT * FROM pg_catalog.numeric_abs($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericAccum calls the stored function 'pg_catalog.numeric_accum(internal, numeric) internal' on db.
func NumericAccum(ctx context.Context, db DB, p0 pgtypes.Internal, p1 float64) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_accum
	const sqlstr = `SELECT * FROM pg_catalog.numeric_accum($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// NumericAccumInv calls the stored function 'pg_catalog.numeric_accum_inv(internal, numeric) internal' on db.
func NumericAccumInv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 float64) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_accum_inv
	const sqlstr = `SELECT * FROM pg_catalog.numeric_accum_inv($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// NumericAdd calls the stored function 'pg_catalog.numeric_add(numeric, numeric) numeric' on db.
func NumericAdd(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.numeric_add
	const sqlstr = `SELECT * FROM pg_catalog.numeric_add($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericAvg calls the stored function 'pg_catalog.numeric_avg(internal) numeric' on db.
func NumericAvg(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_avg
	const sqlstr = `SELECT * FROM pg_catalog.numeric_avg($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericAvgAccum calls the stored function 'pg_catalog.numeric_avg_accum(internal, numeric) internal' on db.
func NumericAvgAccum(ctx context.Context, db DB, p0 pgtypes.Internal, p1 float64) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_avg_accum
	const sqlstr = `SELECT * FROM pg_catalog.numeric_avg_accum($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// NumericAvgCombine calls the stored function 'pg_catalog.numeric_avg_combine(internal, internal) internal' on db.
func NumericAvgCombine(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_avg_combine
	const sqlstr = `SELECT * FROM pg_catalog.numeric_avg_combine($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// NumericAvgDeserialize calls the stored function 'pg_catalog.numeric_avg_deserialize(bytea, internal) internal' on db.
func NumericAvgDeserialize(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_avg_deserialize
	const sqlstr = `SELECT * FROM pg_catalog.numeric_avg_deserialize($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// NumericAvgSerialize calls the stored function 'pg_catalog.numeric_avg_serialize(internal) bytea' on db.
func NumericAvgSerialize(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.numeric_avg_serialize
	const sqlstr = `SELECT * FROM pg_catalog.numeric_avg_serialize($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// NumericCmp calls the stored function 'pg_catalog.numeric_cmp(numeric, numeric) integer' on db.
func NumericCmp(ctx context.Context, db DB, p0, p1 float64) (int, error) {
	// call pg_catalog.numeric_cmp
	const sqlstr = `SELECT * FROM pg_catalog.numeric_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// NumericCombine calls the stored function 'pg_catalog.numeric_combine(internal, internal) internal' on db.
func NumericCombine(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_combine
	const sqlstr = `SELECT * FROM pg_catalog.numeric_combine($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// NumericDeserialize calls the stored function 'pg_catalog.numeric_deserialize(bytea, internal) internal' on db.
func NumericDeserialize(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_deserialize
	const sqlstr = `SELECT * FROM pg_catalog.numeric_deserialize($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// NumericDiv calls the stored function 'pg_catalog.numeric_div(numeric, numeric) numeric' on db.
func NumericDiv(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.numeric_div
	const sqlstr = `SELECT * FROM pg_catalog.numeric_div($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericDivTrunc calls the stored function 'pg_catalog.numeric_div_trunc(numeric, numeric) numeric' on db.
func NumericDivTrunc(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.numeric_div_trunc
	const sqlstr = `SELECT * FROM pg_catalog.numeric_div_trunc($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericEq calls the stored function 'pg_catalog.numeric_eq(numeric, numeric) boolean' on db.
func NumericEq(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.numeric_eq
	const sqlstr = `SELECT * FROM pg_catalog.numeric_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NumericExp calls the stored function 'pg_catalog.numeric_exp(numeric) numeric' on db.
func NumericExp(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.numeric_exp
	const sqlstr = `SELECT * FROM pg_catalog.numeric_exp($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericFac calls the stored function 'pg_catalog.numeric_fac(bigint) numeric' on db.
func NumericFac(ctx context.Context, db DB, p0 int64) (float64, error) {
	// call pg_catalog.numeric_fac
	const sqlstr = `SELECT * FROM pg_catalog.numeric_fac($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericGe calls the stored function 'pg_catalog.numeric_ge(numeric, numeric) boolean' on db.
func NumericGe(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.numeric_ge
	const sqlstr = `SELECT * FROM pg_catalog.numeric_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NumericGt calls the stored function 'pg_catalog.numeric_gt(numeric, numeric) boolean' on db.
func NumericGt(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.numeric_gt
	const sqlstr = `SELECT * FROM pg_catalog.numeric_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NumericInc calls the stored function 'pg_catalog.numeric_inc(numeric) numeric' on db.
func NumericInc(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.numeric_inc
	const sqlstr = `SELECT * FROM pg_catalog.numeric_inc($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericLarger calls the stored function 'pg_catalog.numeric_larger(numeric, numeric) numeric' on db.
func NumericLarger(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.numeric_larger
	const sqlstr = `SELECT * FROM pg_catalog.numeric_larger($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericLe calls the stored function 'pg_catalog.numeric_le(numeric, numeric) boolean' on db.
func NumericLe(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.numeric_le
	const sqlstr = `SELECT * FROM pg_catalog.numeric_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NumericLn calls the stored function 'pg_catalog.numeric_ln(numeric) numeric' on db.
func NumericLn(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.numeric_ln
	const sqlstr = `SELECT * FROM pg_catalog.numeric_ln($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericLog calls the stored function 'pg_catalog.numeric_log(numeric, numeric) numeric' on db.
func NumericLog(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.numeric_log
	const sqlstr = `SELECT * FROM pg_catalog.numeric_log($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericLt calls the stored function 'pg_catalog.numeric_lt(numeric, numeric) boolean' on db.
func NumericLt(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.numeric_lt
	const sqlstr = `SELECT * FROM pg_catalog.numeric_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NumericMod calls the stored function 'pg_catalog.numeric_mod(numeric, numeric) numeric' on db.
func NumericMod(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.numeric_mod
	const sqlstr = `SELECT * FROM pg_catalog.numeric_mod($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericMul calls the stored function 'pg_catalog.numeric_mul(numeric, numeric) numeric' on db.
func NumericMul(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.numeric_mul
	const sqlstr = `SELECT * FROM pg_catalog.numeric_mul($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericNe calls the stored function 'pg_catalog.numeric_ne(numeric, numeric) boolean' on db.
func NumericNe(ctx context.Context, db DB, p0, p1 float64) (bool, error) {
	// call pg_catalog.numeric_ne
	const sqlstr = `SELECT * FROM pg_catalog.numeric_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// NumericPolyAvg calls the stored function 'pg_catalog.numeric_poly_avg(internal) numeric' on db.
func NumericPolyAvg(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_avg
	const sqlstr = `SELECT * FROM pg_catalog.numeric_poly_avg($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericPolyCombine calls the stored function 'pg_catalog.numeric_poly_combine(internal, internal) internal' on db.
func NumericPolyCombine(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_poly_combine
	const sqlstr = `SELECT * FROM pg_catalog.numeric_poly_combine($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// NumericPolyDeserialize calls the stored function 'pg_catalog.numeric_poly_deserialize(bytea, internal) internal' on db.
func NumericPolyDeserialize(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_poly_deserialize
	const sqlstr = `SELECT * FROM pg_catalog.numeric_poly_deserialize($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// NumericPolySerialize calls the stored function 'pg_catalog.numeric_poly_serialize(internal) bytea' on db.
func NumericPolySerialize(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.numeric_poly_serialize
	const sqlstr = `SELECT * FROM pg_catalog.numeric_poly_serialize($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// NumericPolyStddevPop calls the stored function 'pg_catalog.numeric_poly_stddev_pop(internal) numeric' on db.
func NumericPolyStddevPop(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_stddev_pop
	const sqlstr = `SELECT * FROM pg_catalog.numeric_poly_stddev_pop($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericPolyStddevSamp calls the stored function 'pg_catalog.numeric_poly_stddev_samp(internal) numeric' on db.
func NumericPolyStddevSamp(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_stddev_samp
	const sqlstr = `SELECT * FROM pg_catalog.numeric_poly_stddev_samp($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericPolySum calls the stored function 'pg_catalog.numeric_poly_sum(internal) numeric' on db.
func NumericPolySum(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_sum
	const sqlstr = `SELECT * FROM pg_catalog.numeric_poly_sum($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericPolyVarPop calls the stored function 'pg_catalog.numeric_poly_var_pop(internal) numeric' on db.
func NumericPolyVarPop(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_var_pop
	const sqlstr = `SELECT * FROM pg_catalog.numeric_poly_var_pop($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericPolyVarSamp calls the stored function 'pg_catalog.numeric_poly_var_samp(internal) numeric' on db.
func NumericPolyVarSamp(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_poly_var_samp
	const sqlstr = `SELECT * FROM pg_catalog.numeric_poly_var_samp($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericPower calls the stored function 'pg_catalog.numeric_power(numeric, numeric) numeric' on db.
func NumericPower(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.numeric_power
	const sqlstr = `SELECT * FROM pg_catalog.numeric_power($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericRecv calls the stored function 'pg_catalog.numeric_recv(internal, oid, integer) numeric' on db.
func NumericRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (float64, error) {
	// call pg_catalog.numeric_recv
	const sqlstr = `SELECT * FROM pg_catalog.numeric_recv($1, $2, $3)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericSend calls the stored function 'pg_catalog.numeric_send(numeric) bytea' on db.
func NumericSend(ctx context.Context, db DB, p0 float64) ([]byte, error) {
	// call pg_catalog.numeric_send
	const sqlstr = `SELECT * FROM pg_catalog.numeric_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// NumericSerialize calls the stored function 'pg_catalog.numeric_serialize(internal) bytea' on db.
func NumericSerialize(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.numeric_serialize
	const sqlstr = `SELECT * FROM pg_catalog.numeric_serialize($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// NumericSmaller calls the stored function 'pg_catalog.numeric_smaller(numeric, numeric) numeric' on db.
func NumericSmaller(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.numeric_smaller
	const sqlstr = `SELECT * FROM pg_catalog.numeric_smaller($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericSortsupport calls the stored function 'pg_catalog.numeric_sortsupport(internal)' on db.
func NumericSortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.numeric_sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.numeric_sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// NumericSqrt calls the stored function 'pg_catalog.numeric_sqrt(numeric) numeric' on db.
func NumericSqrt(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.numeric_sqrt
	const sqlstr = `SELECT * FROM pg_catalog.numeric_sqrt($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericStddevPop calls the stored function 'pg_catalog.numeric_stddev_pop(internal) numeric' on db.
func NumericStddevPop(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_stddev_pop
	const sqlstr = `SELECT * FROM pg_catalog.numeric_stddev_pop($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericStddevSamp calls the stored function 'pg_catalog.numeric_stddev_samp(internal) numeric' on db.
func NumericStddevSamp(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_stddev_samp
	const sqlstr = `SELECT * FROM pg_catalog.numeric_stddev_samp($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericSub calls the stored function 'pg_catalog.numeric_sub(numeric, numeric) numeric' on db.
func NumericSub(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.numeric_sub
	const sqlstr = `SELECT * FROM pg_catalog.numeric_sub($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericSum calls the stored function 'pg_catalog.numeric_sum(internal) numeric' on db.
func NumericSum(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_sum
	const sqlstr = `SELECT * FROM pg_catalog.numeric_sum($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericSupport calls the stored function 'pg_catalog.numeric_support(internal) internal' on db.
func NumericSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.numeric_support
	const sqlstr = `SELECT * FROM pg_catalog.numeric_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// NumericUminus calls the stored function 'pg_catalog.numeric_uminus(numeric) numeric' on db.
func NumericUminus(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.numeric_uminus
	const sqlstr = `SELECT * FROM pg_catalog.numeric_uminus($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericUplus calls the stored function 'pg_catalog.numeric_uplus(numeric) numeric' on db.
func NumericUplus(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.numeric_uplus
	const sqlstr = `SELECT * FROM pg_catalog.numeric_uplus($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericVarPop calls the stored function 'pg_catalog.numeric_var_pop(internal) numeric' on db.
func NumericVarPop(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_var_pop
	const sqlstr = `SELECT * FROM pg_catalog.numeric_var_pop($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// NumericVarSamp calls the stored function 'pg_catalog.numeric_var_samp(internal) numeric' on db.
func NumericVarSamp(ctx context.Context, db DB, p0 pgtypes.Internal) (float64, error) {
	// call pg_catalog.numeric_var_samp
	const sqlstr = `SELECT * FROM pg_catalog.numeric_var_samp($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Numerictypmodin calls the stored function 'pg_catalog.numerictypmodin(cstring) integer' on db.
func Numerictypmodin(ctx context.Context, db DB, p0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.numerictypmodin
	const sqlstr = `SELECT * FROM pg_catalog.numerictypmodin($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Numnode calls the stored function 'pg_catalog.numnode(tsquery) integer' on db.
func Numnode(ctx context.Context, db DB, p0 pgtypes.Tsquery) (int, error) {
	// call pg_catalog.numnode
	const sqlstr = `SELECT * FROM pg_catalog.numnode($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// NumrangeByNumericAndNumeric calls the stored function 'pg_catalog.numrange(numeric, numeric) numrange' on db.
func NumrangeByNumericAndNumeric(ctx context.Context, db DB, p0, p1 float64) (pgtypes.Numrange, error) {
	// call pg_catalog.numrange
	const sqlstr = `SELECT * FROM pg_catalog.numrange($1, $2)`
	// run
	var r0 pgtypes.Numrange
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Numrange{}, logerror(err)
	}
	return r0, nil
}

// NumrangeByNumericNumericAndText calls the stored function 'pg_catalog.numrange(numeric, numeric, text) numrange' on db.
func NumrangeByNumericNumericAndText(ctx context.Context, db DB, p0, p1 float64, p2 string) (pgtypes.Numrange, error) {
	// call pg_catalog.numrange
	const sqlstr = `SELECT * FROM pg_catalog.numrange($1, $2, $3)`
	// run
	var r0 pgtypes.Numrange
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Numrange{}, logerror(err)
	}
	return r0, nil
}

// NumrangeSubdiff calls the stored function 'pg_catalog.numrange_subdiff(numeric, numeric) double precision' on db.
func NumrangeSubdiff(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.numrange_subdiff
	const sqlstr = `SELECT * FROM pg_catalog.numrange_subdiff($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// ObjDescriptionByOidAndName calls the stored function 'pg_catalog.obj_description(oid, name) text' on db.
func ObjDescriptionByOidAndName(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (string, error) {
	// call pg_catalog.obj_description
	const sqlstr = `SELECT * FROM pg_catalog.obj_description($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ObjDescriptionByOid calls the stored function 'pg_catalog.obj_description(oid) text' on db.
func ObjDescriptionByOid(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.obj_description
	const sqlstr = `SELECT * FROM pg_catalog.obj_description($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// OctetLengthByText calls the stored function 'pg_catalog.octet_length(text) integer' on db.
func OctetLengthByText(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.octet_length
	const sqlstr = `SELECT * FROM pg_catalog.octet_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// OctetLengthByCharacter calls the stored function 'pg_catalog.octet_length(character) integer' on db.
func OctetLengthByCharacter(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.octet_length
	const sqlstr = `SELECT * FROM pg_catalog.octet_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// OctetLengthByBit calls the stored function 'pg_catalog.octet_length(bit) integer' on db.
func OctetLengthByBit(ctx context.Context, db DB, p0 uint8) (int, error) {
	// call pg_catalog.octet_length
	const sqlstr = `SELECT * FROM pg_catalog.octet_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// OctetLengthByBytea calls the stored function 'pg_catalog.octet_length(bytea) integer' on db.
func OctetLengthByBytea(ctx context.Context, db DB, p0 []byte) (int, error) {
	// call pg_catalog.octet_length
	const sqlstr = `SELECT * FROM pg_catalog.octet_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Oid calls the stored function 'pg_catalog.oid(bigint) oid' on db.
func Oid(ctx context.Context, db DB, p0 int64) (pgtypes.Oid, error) {
	// call pg_catalog.oid
	const sqlstr = `SELECT * FROM pg_catalog.oid($1)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// Oideq calls the stored function 'pg_catalog.oideq(oid, oid) boolean' on db.
func Oideq(ctx context.Context, db DB, p0, p1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oideq
	const sqlstr = `SELECT * FROM pg_catalog.oideq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidge calls the stored function 'pg_catalog.oidge(oid, oid) boolean' on db.
func Oidge(ctx context.Context, db DB, p0, p1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oidge
	const sqlstr = `SELECT * FROM pg_catalog.oidge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidgt calls the stored function 'pg_catalog.oidgt(oid, oid) boolean' on db.
func Oidgt(ctx context.Context, db DB, p0, p1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oidgt
	const sqlstr = `SELECT * FROM pg_catalog.oidgt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidlarger calls the stored function 'pg_catalog.oidlarger(oid, oid) oid' on db.
func Oidlarger(ctx context.Context, db DB, p0, p1 pgtypes.Oid) (pgtypes.Oid, error) {
	// call pg_catalog.oidlarger
	const sqlstr = `SELECT * FROM pg_catalog.oidlarger($1, $2)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// Oidle calls the stored function 'pg_catalog.oidle(oid, oid) boolean' on db.
func Oidle(ctx context.Context, db DB, p0, p1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oidle
	const sqlstr = `SELECT * FROM pg_catalog.oidle($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidlt calls the stored function 'pg_catalog.oidlt(oid, oid) boolean' on db.
func Oidlt(ctx context.Context, db DB, p0, p1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oidlt
	const sqlstr = `SELECT * FROM pg_catalog.oidlt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidne calls the stored function 'pg_catalog.oidne(oid, oid) boolean' on db.
func Oidne(ctx context.Context, db DB, p0, p1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.oidne
	const sqlstr = `SELECT * FROM pg_catalog.oidne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidrecv calls the stored function 'pg_catalog.oidrecv(internal) oid' on db.
func Oidrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Oid, error) {
	// call pg_catalog.oidrecv
	const sqlstr = `SELECT * FROM pg_catalog.oidrecv($1)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// Oidsend calls the stored function 'pg_catalog.oidsend(oid) bytea' on db.
func Oidsend(ctx context.Context, db DB, p0 pgtypes.Oid) ([]byte, error) {
	// call pg_catalog.oidsend
	const sqlstr = `SELECT * FROM pg_catalog.oidsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Oidsmaller calls the stored function 'pg_catalog.oidsmaller(oid, oid) oid' on db.
func Oidsmaller(ctx context.Context, db DB, p0, p1 pgtypes.Oid) (pgtypes.Oid, error) {
	// call pg_catalog.oidsmaller
	const sqlstr = `SELECT * FROM pg_catalog.oidsmaller($1, $2)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// Oidvectoreq calls the stored function 'pg_catalog.oidvectoreq(oidvector, oidvector) boolean' on db.
func Oidvectoreq(ctx context.Context, db DB, p0, p1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectoreq
	const sqlstr = `SELECT * FROM pg_catalog.oidvectoreq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidvectorge calls the stored function 'pg_catalog.oidvectorge(oidvector, oidvector) boolean' on db.
func Oidvectorge(ctx context.Context, db DB, p0, p1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectorge
	const sqlstr = `SELECT * FROM pg_catalog.oidvectorge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidvectorgt calls the stored function 'pg_catalog.oidvectorgt(oidvector, oidvector) boolean' on db.
func Oidvectorgt(ctx context.Context, db DB, p0, p1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectorgt
	const sqlstr = `SELECT * FROM pg_catalog.oidvectorgt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidvectorle calls the stored function 'pg_catalog.oidvectorle(oidvector, oidvector) boolean' on db.
func Oidvectorle(ctx context.Context, db DB, p0, p1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectorle
	const sqlstr = `SELECT * FROM pg_catalog.oidvectorle($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidvectorlt calls the stored function 'pg_catalog.oidvectorlt(oidvector, oidvector) boolean' on db.
func Oidvectorlt(ctx context.Context, db DB, p0, p1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectorlt
	const sqlstr = `SELECT * FROM pg_catalog.oidvectorlt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidvectorne calls the stored function 'pg_catalog.oidvectorne(oidvector, oidvector) boolean' on db.
func Oidvectorne(ctx context.Context, db DB, p0, p1 pgtypes.Oidvector) (bool, error) {
	// call pg_catalog.oidvectorne
	const sqlstr = `SELECT * FROM pg_catalog.oidvectorne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Oidvectorrecv calls the stored function 'pg_catalog.oidvectorrecv(internal) oidvector' on db.
func Oidvectorrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Oidvector, error) {
	// call pg_catalog.oidvectorrecv
	const sqlstr = `SELECT * FROM pg_catalog.oidvectorrecv($1)`
	// run
	var r0 pgtypes.Oidvector
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oidvector{}, logerror(err)
	}
	return r0, nil
}

// Oidvectorsend calls the stored function 'pg_catalog.oidvectorsend(oidvector) bytea' on db.
func Oidvectorsend(ctx context.Context, db DB, p0 pgtypes.Oidvector) ([]byte, error) {
	// call pg_catalog.oidvectorsend
	const sqlstr = `SELECT * FROM pg_catalog.oidvectorsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Oidvectortypes calls the stored function 'pg_catalog.oidvectortypes(oidvector) text' on db.
func Oidvectortypes(ctx context.Context, db DB, p0 pgtypes.Oidvector) (string, error) {
	// call pg_catalog.oidvectortypes
	const sqlstr = `SELECT * FROM pg_catalog.oidvectortypes($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// OnPb calls the stored function 'pg_catalog.on_pb(point, box) boolean' on db.
func OnPb(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.on_pb
	const sqlstr = `SELECT * FROM pg_catalog.on_pb($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OnPl calls the stored function 'pg_catalog.on_pl(point, line) boolean' on db.
func OnPl(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Line) (bool, error) {
	// call pg_catalog.on_pl
	const sqlstr = `SELECT * FROM pg_catalog.on_pl($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OnPpath calls the stored function 'pg_catalog.on_ppath(point, path) boolean' on db.
func OnPpath(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Path) (bool, error) {
	// call pg_catalog.on_ppath
	const sqlstr = `SELECT * FROM pg_catalog.on_ppath($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OnPs calls the stored function 'pg_catalog.on_ps(point, lseg) boolean' on db.
func OnPs(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Lseg) (bool, error) {
	// call pg_catalog.on_ps
	const sqlstr = `SELECT * FROM pg_catalog.on_ps($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OnSb calls the stored function 'pg_catalog.on_sb(lseg, box) boolean' on db.
func OnSb(ctx context.Context, db DB, p0 pgtypes.Lseg, p1 pgtypes.Box) (bool, error) {
	// call pg_catalog.on_sb
	const sqlstr = `SELECT * FROM pg_catalog.on_sb($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OnSl calls the stored function 'pg_catalog.on_sl(lseg, line) boolean' on db.
func OnSl(ctx context.Context, db DB, p0 pgtypes.Lseg, p1 pgtypes.Line) (bool, error) {
	// call pg_catalog.on_sl
	const sqlstr = `SELECT * FROM pg_catalog.on_sl($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OrderedSetTransition calls the stored function 'pg_catalog.ordered_set_transition(internal, "any") internal' on db.
func OrderedSetTransition(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Any) (pgtypes.Internal, error) {
	// call pg_catalog.ordered_set_transition
	const sqlstr = `SELECT * FROM pg_catalog.ordered_set_transition($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimeWithTimeZoneTimeWithTimeZoneTimeWithTimeZoneAndTimeWithTimeZone calls the stored function 'pg_catalog.overlaps(time with time zone, time with time zone, time with time zone, time with time zone) boolean' on db.
func OverlapsByTimeWithTimeZoneTimeWithTimeZoneTimeWithTimeZoneAndTimeWithTimeZone(ctx context.Context, db DB, p0, p1, p2, p3 time.Time) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimestampWithTimeZoneTimestampWithTimeZoneTimestampWithTimeZoneAndTimestampWithTimeZone calls the stored function 'pg_catalog.overlaps(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone) boolean' on db.
func OverlapsByTimestampWithTimeZoneTimestampWithTimeZoneTimestampWithTimeZoneAndTimestampWithTimeZone(ctx context.Context, db DB, p0, p1, p2, p3 time.Time) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimestampWithTimeZoneIntervalTimestampWithTimeZoneAndInterval calls the stored function 'pg_catalog.overlaps(timestamp with time zone, interval, timestamp with time zone, interval) boolean' on db.
func OverlapsByTimestampWithTimeZoneIntervalTimestampWithTimeZoneAndInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte, p2 time.Time, p3 []byte) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimestampWithTimeZoneTimestampWithTimeZoneTimestampWithTimeZoneAndInterval calls the stored function 'pg_catalog.overlaps(timestamp with time zone, timestamp with time zone, timestamp with time zone, interval) boolean' on db.
func OverlapsByTimestampWithTimeZoneTimestampWithTimeZoneTimestampWithTimeZoneAndInterval(ctx context.Context, db DB, p0, p1, p2 time.Time, p3 []byte) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimestampWithTimeZoneIntervalTimestampWithTimeZoneAndTimestampWithTimeZone calls the stored function 'pg_catalog.overlaps(timestamp with time zone, interval, timestamp with time zone, timestamp with time zone) boolean' on db.
func OverlapsByTimestampWithTimeZoneIntervalTimestampWithTimeZoneAndTimestampWithTimeZone(ctx context.Context, db DB, p0 time.Time, p1 []byte, p2, p3 time.Time) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimeWithoutTimeZoneTimeWithoutTimeZoneTimeWithoutTimeZoneAndTimeWithoutTimeZone calls the stored function 'pg_catalog.overlaps(time without time zone, time without time zone, time without time zone, time without time zone) boolean' on db.
func OverlapsByTimeWithoutTimeZoneTimeWithoutTimeZoneTimeWithoutTimeZoneAndTimeWithoutTimeZone(ctx context.Context, db DB, p0, p1, p2, p3 time.Time) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimeWithoutTimeZoneIntervalTimeWithoutTimeZoneAndInterval calls the stored function 'pg_catalog.overlaps(time without time zone, interval, time without time zone, interval) boolean' on db.
func OverlapsByTimeWithoutTimeZoneIntervalTimeWithoutTimeZoneAndInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte, p2 time.Time, p3 []byte) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimeWithoutTimeZoneTimeWithoutTimeZoneTimeWithoutTimeZoneAndInterval calls the stored function 'pg_catalog.overlaps(time without time zone, time without time zone, time without time zone, interval) boolean' on db.
func OverlapsByTimeWithoutTimeZoneTimeWithoutTimeZoneTimeWithoutTimeZoneAndInterval(ctx context.Context, db DB, p0, p1, p2 time.Time, p3 []byte) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimeWithoutTimeZoneIntervalTimeWithoutTimeZoneAndTimeWithoutTimeZone calls the stored function 'pg_catalog.overlaps(time without time zone, interval, time without time zone, time without time zone) boolean' on db.
func OverlapsByTimeWithoutTimeZoneIntervalTimeWithoutTimeZoneAndTimeWithoutTimeZone(ctx context.Context, db DB, p0 time.Time, p1 []byte, p2, p3 time.Time) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimestampWithoutTimeZoneTimestampWithoutTimeZoneTimestampWithoutTimeZoneAndTimestampWithoutTimeZone calls the stored function 'pg_catalog.overlaps(timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone) boolean' on db.
func OverlapsByTimestampWithoutTimeZoneTimestampWithoutTimeZoneTimestampWithoutTimeZoneAndTimestampWithoutTimeZone(ctx context.Context, db DB, p0, p1, p2, p3 time.Time) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimestampWithoutTimeZoneIntervalTimestampWithoutTimeZoneAndInterval calls the stored function 'pg_catalog.overlaps(timestamp without time zone, interval, timestamp without time zone, interval) boolean' on db.
func OverlapsByTimestampWithoutTimeZoneIntervalTimestampWithoutTimeZoneAndInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte, p2 time.Time, p3 []byte) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimestampWithoutTimeZoneTimestampWithoutTimeZoneTimestampWithoutTimeZoneAndInterval calls the stored function 'pg_catalog.overlaps(timestamp without time zone, timestamp without time zone, timestamp without time zone, interval) boolean' on db.
func OverlapsByTimestampWithoutTimeZoneTimestampWithoutTimeZoneTimestampWithoutTimeZoneAndInterval(ctx context.Context, db DB, p0, p1, p2 time.Time, p3 []byte) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlapsByTimestampWithoutTimeZoneIntervalTimestampWithoutTimeZoneAndTimestampWithoutTimeZone calls the stored function 'pg_catalog.overlaps(timestamp without time zone, interval, timestamp without time zone, timestamp without time zone) boolean' on db.
func OverlapsByTimestampWithoutTimeZoneIntervalTimestampWithoutTimeZoneAndTimestampWithoutTimeZone(ctx context.Context, db DB, p0 time.Time, p1 []byte, p2, p3 time.Time) (bool, error) {
	// call pg_catalog.overlaps
	const sqlstr = `SELECT * FROM pg_catalog.overlaps($1, $2, $3, $4)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// OverlayByTextTextIntegerAndInteger calls the stored function 'pg_catalog.overlay(text, text, integer, integer) text' on db.
func OverlayByTextTextIntegerAndInteger(ctx context.Context, db DB, p0, p1 string, p2, p3 int) (string, error) {
	// call pg_catalog.overlay
	const sqlstr = `SELECT * FROM pg_catalog.overlay($1, $2, $3, $4)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// OverlayByTextTextAndInteger calls the stored function 'pg_catalog.overlay(text, text, integer) text' on db.
func OverlayByTextTextAndInteger(ctx context.Context, db DB, p0, p1 string, p2 int) (string, error) {
	// call pg_catalog.overlay
	const sqlstr = `SELECT * FROM pg_catalog.overlay($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// OverlayByBitBitIntegerAndInteger calls the stored function 'pg_catalog.overlay(bit, bit, integer, integer) bit' on db.
func OverlayByBitBitIntegerAndInteger(ctx context.Context, db DB, p0, p1 uint8, p2, p3 int) (uint8, error) {
	// call pg_catalog.overlay
	const sqlstr = `SELECT * FROM pg_catalog.overlay($1, $2, $3, $4)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// OverlayByBitBitAndInteger calls the stored function 'pg_catalog.overlay(bit, bit, integer) bit' on db.
func OverlayByBitBitAndInteger(ctx context.Context, db DB, p0, p1 uint8, p2 int) (uint8, error) {
	// call pg_catalog.overlay
	const sqlstr = `SELECT * FROM pg_catalog.overlay($1, $2, $3)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// OverlayByByteaByteaIntegerAndInteger calls the stored function 'pg_catalog.overlay(bytea, bytea, integer, integer) bytea' on db.
func OverlayByByteaByteaIntegerAndInteger(ctx context.Context, db DB, p0, p1 []byte, p2, p3 int) ([]byte, error) {
	// call pg_catalog.overlay
	const sqlstr = `SELECT * FROM pg_catalog.overlay($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// OverlayByByteaByteaAndInteger calls the stored function 'pg_catalog.overlay(bytea, bytea, integer) bytea' on db.
func OverlayByByteaByteaAndInteger(ctx context.Context, db DB, p0, p1 []byte, p2 int) ([]byte, error) {
	// call pg_catalog.overlay
	const sqlstr = `SELECT * FROM pg_catalog.overlay($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// ParseIdent calls the stored function 'pg_catalog.parse_ident(text, boolean) text' on db.
func ParseIdent(ctx context.Context, db DB, str string, strict bool) (StringSlice, error) {
	// call pg_catalog.parse_ident
	const sqlstr = `SELECT * FROM pg_catalog.parse_ident($1, $2)`
	// run
	var r0 StringSlice
	logf(sqlstr, str, strict)
	if err := db.QueryRowContext(ctx, sqlstr, str, strict).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// Path calls the stored function 'pg_catalog.path(polygon) path' on db.
func Path(ctx context.Context, db DB, p0 pgtypes.Polygon) (pgtypes.Path, error) {
	// call pg_catalog.path
	const sqlstr = `SELECT * FROM pg_catalog.path($1)`
	// run
	var r0 pgtypes.Path
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return r0, nil
}

// PathAdd calls the stored function 'pg_catalog.path_add(path, path) path' on db.
func PathAdd(ctx context.Context, db DB, p0, p1 pgtypes.Path) (pgtypes.Path, error) {
	// call pg_catalog.path_add
	const sqlstr = `SELECT * FROM pg_catalog.path_add($1, $2)`
	// run
	var r0 pgtypes.Path
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return r0, nil
}

// PathAddPt calls the stored function 'pg_catalog.path_add_pt(path, point) path' on db.
func PathAddPt(ctx context.Context, db DB, p0 pgtypes.Path, p1 pgtypes.Point) (pgtypes.Path, error) {
	// call pg_catalog.path_add_pt
	const sqlstr = `SELECT * FROM pg_catalog.path_add_pt($1, $2)`
	// run
	var r0 pgtypes.Path
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return r0, nil
}

// PathCenter calls the stored function 'pg_catalog.path_center(path) point' on db.
func PathCenter(ctx context.Context, db DB, p0 pgtypes.Path) (pgtypes.Point, error) {
	// call pg_catalog.path_center
	const sqlstr = `SELECT * FROM pg_catalog.path_center($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PathContainPt calls the stored function 'pg_catalog.path_contain_pt(path, point) boolean' on db.
func PathContainPt(ctx context.Context, db DB, p0 pgtypes.Path, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.path_contain_pt
	const sqlstr = `SELECT * FROM pg_catalog.path_contain_pt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PathDistance calls the stored function 'pg_catalog.path_distance(path, path) double precision' on db.
func PathDistance(ctx context.Context, db DB, p0, p1 pgtypes.Path) (float64, error) {
	// call pg_catalog.path_distance
	const sqlstr = `SELECT * FROM pg_catalog.path_distance($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PathDivPt calls the stored function 'pg_catalog.path_div_pt(path, point) path' on db.
func PathDivPt(ctx context.Context, db DB, p0 pgtypes.Path, p1 pgtypes.Point) (pgtypes.Path, error) {
	// call pg_catalog.path_div_pt
	const sqlstr = `SELECT * FROM pg_catalog.path_div_pt($1, $2)`
	// run
	var r0 pgtypes.Path
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return r0, nil
}

// PathInter calls the stored function 'pg_catalog.path_inter(path, path) boolean' on db.
func PathInter(ctx context.Context, db DB, p0, p1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_inter
	const sqlstr = `SELECT * FROM pg_catalog.path_inter($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PathLength calls the stored function 'pg_catalog.path_length(path) double precision' on db.
func PathLength(ctx context.Context, db DB, p0 pgtypes.Path) (float64, error) {
	// call pg_catalog.path_length
	const sqlstr = `SELECT * FROM pg_catalog.path_length($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PathMulPt calls the stored function 'pg_catalog.path_mul_pt(path, point) path' on db.
func PathMulPt(ctx context.Context, db DB, p0 pgtypes.Path, p1 pgtypes.Point) (pgtypes.Path, error) {
	// call pg_catalog.path_mul_pt
	const sqlstr = `SELECT * FROM pg_catalog.path_mul_pt($1, $2)`
	// run
	var r0 pgtypes.Path
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return r0, nil
}

// PathNEq calls the stored function 'pg_catalog.path_n_eq(path, path) boolean' on db.
func PathNEq(ctx context.Context, db DB, p0, p1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_n_eq
	const sqlstr = `SELECT * FROM pg_catalog.path_n_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PathNGe calls the stored function 'pg_catalog.path_n_ge(path, path) boolean' on db.
func PathNGe(ctx context.Context, db DB, p0, p1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_n_ge
	const sqlstr = `SELECT * FROM pg_catalog.path_n_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PathNGt calls the stored function 'pg_catalog.path_n_gt(path, path) boolean' on db.
func PathNGt(ctx context.Context, db DB, p0, p1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_n_gt
	const sqlstr = `SELECT * FROM pg_catalog.path_n_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PathNLe calls the stored function 'pg_catalog.path_n_le(path, path) boolean' on db.
func PathNLe(ctx context.Context, db DB, p0, p1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_n_le
	const sqlstr = `SELECT * FROM pg_catalog.path_n_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PathNLt calls the stored function 'pg_catalog.path_n_lt(path, path) boolean' on db.
func PathNLt(ctx context.Context, db DB, p0, p1 pgtypes.Path) (bool, error) {
	// call pg_catalog.path_n_lt
	const sqlstr = `SELECT * FROM pg_catalog.path_n_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PathNpoints calls the stored function 'pg_catalog.path_npoints(path) integer' on db.
func PathNpoints(ctx context.Context, db DB, p0 pgtypes.Path) (int, error) {
	// call pg_catalog.path_npoints
	const sqlstr = `SELECT * FROM pg_catalog.path_npoints($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PathRecv calls the stored function 'pg_catalog.path_recv(internal) path' on db.
func PathRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Path, error) {
	// call pg_catalog.path_recv
	const sqlstr = `SELECT * FROM pg_catalog.path_recv($1)`
	// run
	var r0 pgtypes.Path
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return r0, nil
}

// PathSend calls the stored function 'pg_catalog.path_send(path) bytea' on db.
func PathSend(ctx context.Context, db DB, p0 pgtypes.Path) ([]byte, error) {
	// call pg_catalog.path_send
	const sqlstr = `SELECT * FROM pg_catalog.path_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PathSubPt calls the stored function 'pg_catalog.path_sub_pt(path, point) path' on db.
func PathSubPt(ctx context.Context, db DB, p0 pgtypes.Path, p1 pgtypes.Point) (pgtypes.Path, error) {
	// call pg_catalog.path_sub_pt
	const sqlstr = `SELECT * FROM pg_catalog.path_sub_pt($1, $2)`
	// run
	var r0 pgtypes.Path
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return r0, nil
}

// Pclose calls the stored function 'pg_catalog.pclose(path) path' on db.
func Pclose(ctx context.Context, db DB, p0 pgtypes.Path) (pgtypes.Path, error) {
	// call pg_catalog.pclose
	const sqlstr = `SELECT * FROM pg_catalog.pclose($1)`
	// run
	var r0 pgtypes.Path
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return r0, nil
}

// PercentileContFloat8Final calls the stored function 'pg_catalog.percentile_cont_float8_final(internal, double precision) double precision' on db.
func PercentileContFloat8Final(ctx context.Context, db DB, p0 pgtypes.Internal, p1 float64) (float64, error) {
	// call pg_catalog.percentile_cont_float8_final
	const sqlstr = `SELECT * FROM pg_catalog.percentile_cont_float8_final($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PercentileContFloat8MultiFinal calls the stored function 'pg_catalog.percentile_cont_float8_multi_final(internal, double precision) double precision' on db.
func PercentileContFloat8MultiFinal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 []float64) ([]float64, error) {
	// call pg_catalog.percentile_cont_float8_multi_final
	const sqlstr = `SELECT * FROM pg_catalog.percentile_cont_float8_multi_final($1, $2)`
	// run
	var r0 []float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PercentileContIntervalFinal calls the stored function 'pg_catalog.percentile_cont_interval_final(internal, double precision) interval' on db.
func PercentileContIntervalFinal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 float64) ([]byte, error) {
	// call pg_catalog.percentile_cont_interval_final
	const sqlstr = `SELECT * FROM pg_catalog.percentile_cont_interval_final($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PercentileContIntervalMultiFinal calls the stored function 'pg_catalog.percentile_cont_interval_multi_final(internal, double precision) interval' on db.
func PercentileContIntervalMultiFinal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 []float64) ([][]byte, error) {
	// call pg_catalog.percentile_cont_interval_multi_final
	const sqlstr = `SELECT * FROM pg_catalog.percentile_cont_interval_multi_final($1, $2)`
	// run
	var r0 [][]byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PercentileDiscFinal calls the stored function 'pg_catalog.percentile_disc_final(internal, double precision, anyelement) anyelement' on db.
func PercentileDiscFinal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 float64, p2 pgtypes.Anyelement) (pgtypes.Anyelement, error) {
	// call pg_catalog.percentile_disc_final
	const sqlstr = `SELECT * FROM pg_catalog.percentile_disc_final($1, $2, $3)`
	// run
	var r0 pgtypes.Anyelement
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return r0, nil
}

// PercentileDiscMultiFinal calls the stored function 'pg_catalog.percentile_disc_multi_final(internal, double precision, anyelement) anyarray' on db.
func PercentileDiscMultiFinal(ctx context.Context, db DB, p0 pgtypes.Internal, p1 []float64, p2 pgtypes.Anyelement) (pgtypes.Anyarray, error) {
	// call pg_catalog.percentile_disc_multi_final
	const sqlstr = `SELECT * FROM pg_catalog.percentile_disc_multi_final($1, $2, $3)`
	// run
	var r0 pgtypes.Anyarray
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Anyarray{}, logerror(err)
	}
	return r0, nil
}

// PgAdvisoryLockByBigint calls the stored function 'pg_catalog.pg_advisory_lock(bigint)' on db.
func PgAdvisoryLockByBigint(ctx context.Context, db DB, p0 int64) error {
	// call pg_catalog.pg_advisory_lock
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_lock($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryLockByIntegerAndInteger calls the stored function 'pg_catalog.pg_advisory_lock(integer, integer)' on db.
func PgAdvisoryLockByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) error {
	// call pg_catalog.pg_advisory_lock
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_lock($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryLockSharedByBigint calls the stored function 'pg_catalog.pg_advisory_lock_shared(bigint)' on db.
func PgAdvisoryLockSharedByBigint(ctx context.Context, db DB, p0 int64) error {
	// call pg_catalog.pg_advisory_lock_shared
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_lock_shared($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryLockSharedByIntegerAndInteger calls the stored function 'pg_catalog.pg_advisory_lock_shared(integer, integer)' on db.
func PgAdvisoryLockSharedByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) error {
	// call pg_catalog.pg_advisory_lock_shared
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_lock_shared($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryUnlockByBigint calls the stored function 'pg_catalog.pg_advisory_unlock(bigint) boolean' on db.
func PgAdvisoryUnlockByBigint(ctx context.Context, db DB, p0 int64) (bool, error) {
	// call pg_catalog.pg_advisory_unlock
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_unlock($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgAdvisoryUnlockByIntegerAndInteger calls the stored function 'pg_catalog.pg_advisory_unlock(integer, integer) boolean' on db.
func PgAdvisoryUnlockByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.pg_advisory_unlock
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_unlock($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgAdvisoryUnlockAll calls the stored function 'pg_catalog.pg_advisory_unlock_all()' on db.
func PgAdvisoryUnlockAll(ctx context.Context, db DB) error {
	// call pg_catalog.pg_advisory_unlock_all
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_unlock_all()`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryUnlockSharedByBigint calls the stored function 'pg_catalog.pg_advisory_unlock_shared(bigint) boolean' on db.
func PgAdvisoryUnlockSharedByBigint(ctx context.Context, db DB, p0 int64) (bool, error) {
	// call pg_catalog.pg_advisory_unlock_shared
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_unlock_shared($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgAdvisoryUnlockSharedByIntegerAndInteger calls the stored function 'pg_catalog.pg_advisory_unlock_shared(integer, integer) boolean' on db.
func PgAdvisoryUnlockSharedByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.pg_advisory_unlock_shared
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_unlock_shared($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgAdvisoryXactLockByBigint calls the stored function 'pg_catalog.pg_advisory_xact_lock(bigint)' on db.
func PgAdvisoryXactLockByBigint(ctx context.Context, db DB, p0 int64) error {
	// call pg_catalog.pg_advisory_xact_lock
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_xact_lock($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryXactLockByIntegerAndInteger calls the stored function 'pg_catalog.pg_advisory_xact_lock(integer, integer)' on db.
func PgAdvisoryXactLockByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) error {
	// call pg_catalog.pg_advisory_xact_lock
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_xact_lock($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryXactLockSharedByBigint calls the stored function 'pg_catalog.pg_advisory_xact_lock_shared(bigint)' on db.
func PgAdvisoryXactLockSharedByBigint(ctx context.Context, db DB, p0 int64) error {
	// call pg_catalog.pg_advisory_xact_lock_shared
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_xact_lock_shared($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAdvisoryXactLockSharedByIntegerAndInteger calls the stored function 'pg_catalog.pg_advisory_xact_lock_shared(integer, integer)' on db.
func PgAdvisoryXactLockSharedByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) error {
	// call pg_catalog.pg_advisory_xact_lock_shared
	const sqlstr = `SELECT * FROM pg_catalog.pg_advisory_xact_lock_shared($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// PgAvailableExtensionVersions calls the stored function 'pg_catalog.pg_available_extension_versions() (name, text, boolean, boolean, boolean, name, name, text)' on db.
func PgAvailableExtensionVersions(ctx context.Context, db DB) (string, string, bool, bool, bool, string, StringSlice, string, error) {
	// call pg_catalog.pg_available_extension_versions
	const sqlstr = `SELECT * FROM pg_catalog.pg_available_extension_versions()`
	// run
	var name string
	var version string
	var superuser bool
	var trusted bool
	var relocatable bool
	var schema string
	var requires StringSlice
	var comment string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &version, &superuser, &trusted, &relocatable, &schema, &requires, &comment); err != nil {
		return "", "", false, false, false, "", StringSlice{}, "", logerror(err)
	}
	return name, version, superuser, trusted, relocatable, schema, requires, comment, nil
}

// PgAvailableExtensions calls the stored function 'pg_catalog.pg_available_extensions() (name, text, text)' on db.
func PgAvailableExtensions(ctx context.Context, db DB) (string, string, string, error) {
	// call pg_catalog.pg_available_extensions
	const sqlstr = `SELECT * FROM pg_catalog.pg_available_extensions()`
	// run
	var name string
	var defaultVersion string
	var comment string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &defaultVersion, &comment); err != nil {
		return "", "", "", logerror(err)
	}
	return name, defaultVersion, comment, nil
}

// PgBackendPid calls the stored function 'pg_catalog.pg_backend_pid() integer' on db.
func PgBackendPid(ctx context.Context, db DB) (int, error) {
	// call pg_catalog.pg_backend_pid
	const sqlstr = `SELECT * FROM pg_catalog.pg_backend_pid()`
	// run
	var r0 int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgBackupStartTime calls the stored function 'pg_catalog.pg_backup_start_time() timestamp with time zone' on db.
func PgBackupStartTime(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_backup_start_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_backup_start_time()`
	// run
	var r0 time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgBlockingPids calls the stored function 'pg_catalog.pg_blocking_pids(integer) integer' on db.
func PgBlockingPids(ctx context.Context, db DB, p0 int) ([]int, error) {
	// call pg_catalog.pg_blocking_pids
	const sqlstr = `SELECT * FROM pg_catalog.pg_blocking_pids($1)`
	// run
	var r0 []int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgCancelBackend calls the stored function 'pg_catalog.pg_cancel_backend(integer) boolean' on db.
func PgCancelBackend(ctx context.Context, db DB, p0 int) (bool, error) {
	// call pg_catalog.pg_cancel_backend
	const sqlstr = `SELECT * FROM pg_catalog.pg_cancel_backend($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgCharToEncoding calls the stored function 'pg_catalog.pg_char_to_encoding(name) integer' on db.
func PgCharToEncoding(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.pg_char_to_encoding
	const sqlstr = `SELECT * FROM pg_catalog.pg_char_to_encoding($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgClientEncoding calls the stored function 'pg_catalog.pg_client_encoding() name' on db.
func PgClientEncoding(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.pg_client_encoding
	const sqlstr = `SELECT * FROM pg_catalog.pg_client_encoding()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgCollationActualVersion calls the stored function 'pg_catalog.pg_collation_actual_version(oid) text' on db.
func PgCollationActualVersion(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_collation_actual_version
	const sqlstr = `SELECT * FROM pg_catalog.pg_collation_actual_version($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgCollationFor calls the stored function 'pg_catalog.pg_collation_for("any") text' on db.
func PgCollationFor(ctx context.Context, db DB, p0 pgtypes.Any) (string, error) {
	// call pg_catalog.pg_collation_for
	const sqlstr = `SELECT * FROM pg_catalog.pg_collation_for($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgCollationIsVisible calls the stored function 'pg_catalog.pg_collation_is_visible(oid) boolean' on db.
func PgCollationIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_collation_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_collation_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgColumnIsUpdatable calls the stored function 'pg_catalog.pg_column_is_updatable(regclass, smallint, boolean) boolean' on db.
func PgColumnIsUpdatable(ctx context.Context, db DB, p0 pgtypes.Regclass, p1 int16, p2 bool) (bool, error) {
	// call pg_catalog.pg_column_is_updatable
	const sqlstr = `SELECT * FROM pg_catalog.pg_column_is_updatable($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgColumnSize calls the stored function 'pg_catalog.pg_column_size("any") integer' on db.
func PgColumnSize(ctx context.Context, db DB, p0 pgtypes.Any) (int, error) {
	// call pg_catalog.pg_column_size
	const sqlstr = `SELECT * FROM pg_catalog.pg_column_size($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgConfLoadTime calls the stored function 'pg_catalog.pg_conf_load_time() timestamp with time zone' on db.
func PgConfLoadTime(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_conf_load_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_conf_load_time()`
	// run
	var r0 time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgConfig calls the stored function 'pg_catalog.pg_config() (text, text)' on db.
func PgConfig(ctx context.Context, db DB) (string, string, error) {
	// call pg_catalog.pg_config
	const sqlstr = `SELECT * FROM pg_catalog.pg_config()`
	// run
	var name string
	var setting string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &setting); err != nil {
		return "", "", logerror(err)
	}
	return name, setting, nil
}

// PgControlCheckpoint calls the stored function 'pg_catalog.pg_control_checkpoint() (pg_lsn, pg_lsn, text, integer, integer, boolean, text, oid, xid, xid, xid, oid, xid, xid, oid, xid, xid, timestamp with time zone)' on db.
func PgControlCheckpoint(ctx context.Context, db DB) (pgtypes.PgLsn, pgtypes.PgLsn, string, int, int, bool, string, pgtypes.Oid, pgtypes.Xid, pgtypes.Xid, pgtypes.Xid, pgtypes.Oid, pgtypes.Xid, pgtypes.Xid, pgtypes.Oid, pgtypes.Xid, pgtypes.Xid, time.Time, error) {
	// call pg_catalog.pg_control_checkpoint
	const sqlstr = `SELECT * FROM pg_catalog.pg_control_checkpoint()`
	// run
	var checkpointLsn pgtypes.PgLsn
	var redoLsn pgtypes.PgLsn
	var redoWalFile string
	var timelineID int
	var prevTimelineID int
	var fullPageWrites bool
	var nextXid string
	var nextOid pgtypes.Oid
	var nextMultixactID pgtypes.Xid
	var nextMultiOffset pgtypes.Xid
	var oldestXid pgtypes.Xid
	var oldestXidDbid pgtypes.Oid
	var oldestActiveXid pgtypes.Xid
	var oldestMultiXid pgtypes.Xid
	var oldestMultiDbid pgtypes.Oid
	var oldestCommitTsXid pgtypes.Xid
	var newestCommitTsXid pgtypes.Xid
	var checkpointTime time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&checkpointLsn, &redoLsn, &redoWalFile, &timelineID, &prevTimelineID, &fullPageWrites, &nextXid, &nextOid, &nextMultixactID, &nextMultiOffset, &oldestXid, &oldestXidDbid, &oldestActiveXid, &oldestMultiXid, &oldestMultiDbid, &oldestCommitTsXid, &newestCommitTsXid, &checkpointTime); err != nil {
		return pgtypes.PgLsn{}, pgtypes.PgLsn{}, "", 0, 0, false, "", pgtypes.Oid{}, pgtypes.Xid{}, pgtypes.Xid{}, pgtypes.Xid{}, pgtypes.Oid{}, pgtypes.Xid{}, pgtypes.Xid{}, pgtypes.Oid{}, pgtypes.Xid{}, pgtypes.Xid{}, time.Time{}, logerror(err)
	}
	return checkpointLsn, redoLsn, redoWalFile, timelineID, prevTimelineID, fullPageWrites, nextXid, nextOid, nextMultixactID, nextMultiOffset, oldestXid, oldestXidDbid, oldestActiveXid, oldestMultiXid, oldestMultiDbid, oldestCommitTsXid, newestCommitTsXid, checkpointTime, nil
}

// PgControlInit calls the stored function 'pg_catalog.pg_control_init() (integer, integer, integer, integer, integer, integer, integer, integer, integer, boolean, integer)' on db.
func PgControlInit(ctx context.Context, db DB) (int, int, int, int, int, int, int, int, int, bool, int, error) {
	// call pg_catalog.pg_control_init
	const sqlstr = `SELECT * FROM pg_catalog.pg_control_init()`
	// run
	var maxDataAlignment int
	var databaseBlockSize int
	var blocksPerSegment int
	var walBlockSize int
	var bytesPerWalSegment int
	var maxIdentifierLength int
	var maxIndexColumns int
	var maxToastChunkSize int
	var largeObjectChunkSize int
	var float8PassByValue bool
	var dataPageChecksumVersion int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&maxDataAlignment, &databaseBlockSize, &blocksPerSegment, &walBlockSize, &bytesPerWalSegment, &maxIdentifierLength, &maxIndexColumns, &maxToastChunkSize, &largeObjectChunkSize, &float8PassByValue, &dataPageChecksumVersion); err != nil {
		return 0, 0, 0, 0, 0, 0, 0, 0, 0, false, 0, logerror(err)
	}
	return maxDataAlignment, databaseBlockSize, blocksPerSegment, walBlockSize, bytesPerWalSegment, maxIdentifierLength, maxIndexColumns, maxToastChunkSize, largeObjectChunkSize, float8PassByValue, dataPageChecksumVersion, nil
}

// PgControlRecovery calls the stored function 'pg_catalog.pg_control_recovery() (pg_lsn, integer, pg_lsn, pg_lsn, boolean)' on db.
func PgControlRecovery(ctx context.Context, db DB) (pgtypes.PgLsn, int, pgtypes.PgLsn, pgtypes.PgLsn, bool, error) {
	// call pg_catalog.pg_control_recovery
	const sqlstr = `SELECT * FROM pg_catalog.pg_control_recovery()`
	// run
	var minRecoveryEndLsn pgtypes.PgLsn
	var minRecoveryEndTimeline int
	var backupStartLsn pgtypes.PgLsn
	var backupEndLsn pgtypes.PgLsn
	var endOfBackupRecordRequired bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&minRecoveryEndLsn, &minRecoveryEndTimeline, &backupStartLsn, &backupEndLsn, &endOfBackupRecordRequired); err != nil {
		return pgtypes.PgLsn{}, 0, pgtypes.PgLsn{}, pgtypes.PgLsn{}, false, logerror(err)
	}
	return minRecoveryEndLsn, minRecoveryEndTimeline, backupStartLsn, backupEndLsn, endOfBackupRecordRequired, nil
}

// PgControlSystem calls the stored function 'pg_catalog.pg_control_system() (integer, integer, bigint, timestamp with time zone)' on db.
func PgControlSystem(ctx context.Context, db DB) (int, int, int64, time.Time, error) {
	// call pg_catalog.pg_control_system
	const sqlstr = `SELECT * FROM pg_catalog.pg_control_system()`
	// run
	var pgControlVersion int
	var catalogVersionNo int
	var systemIdentifier int64
	var pgControlLastModified time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&pgControlVersion, &catalogVersionNo, &systemIdentifier, &pgControlLastModified); err != nil {
		return 0, 0, 0, time.Time{}, logerror(err)
	}
	return pgControlVersion, catalogVersionNo, systemIdentifier, pgControlLastModified, nil
}

// PgConversionIsVisible calls the stored function 'pg_catalog.pg_conversion_is_visible(oid) boolean' on db.
func PgConversionIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_conversion_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_conversion_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgCopyLogicalReplicationSlotBySrcSlotNameDstSlotNameTemporaryAndPlugin calls the stored function 'pg_catalog.pg_copy_logical_replication_slot(name, name, boolean, name) (name, pg_lsn)' on db.
func PgCopyLogicalReplicationSlotBySrcSlotNameDstSlotNameTemporaryAndPlugin(ctx context.Context, db DB, srcSlotName, dstSlotName string, temporary bool, plugin string) (string, pgtypes.PgLsn, error) {
	// call pg_catalog.pg_copy_logical_replication_slot
	const sqlstr = `SELECT * FROM pg_catalog.pg_copy_logical_replication_slot($1, $2, $3, $4)`
	// run
	var slotName string
	var lsn pgtypes.PgLsn
	logf(sqlstr, srcSlotName, dstSlotName, temporary, plugin)
	if err := db.QueryRowContext(ctx, sqlstr, srcSlotName, dstSlotName, temporary, plugin).Scan(&slotName, &lsn); err != nil {
		return "", pgtypes.PgLsn{}, logerror(err)
	}
	return slotName, lsn, nil
}

// PgCopyLogicalReplicationSlotBySrcSlotNameDstSlotNameAndTemporary calls the stored function 'pg_catalog.pg_copy_logical_replication_slot(name, name, boolean) (name, pg_lsn)' on db.
func PgCopyLogicalReplicationSlotBySrcSlotNameDstSlotNameAndTemporary(ctx context.Context, db DB, srcSlotName, dstSlotName string, temporary bool) (string, pgtypes.PgLsn, error) {
	// call pg_catalog.pg_copy_logical_replication_slot
	const sqlstr = `SELECT * FROM pg_catalog.pg_copy_logical_replication_slot($1, $2, $3)`
	// run
	var slotName string
	var lsn pgtypes.PgLsn
	logf(sqlstr, srcSlotName, dstSlotName, temporary)
	if err := db.QueryRowContext(ctx, sqlstr, srcSlotName, dstSlotName, temporary).Scan(&slotName, &lsn); err != nil {
		return "", pgtypes.PgLsn{}, logerror(err)
	}
	return slotName, lsn, nil
}

// PgCopyLogicalReplicationSlotBySrcSlotNameAndDstSlotName calls the stored function 'pg_catalog.pg_copy_logical_replication_slot(name, name) (name, pg_lsn)' on db.
func PgCopyLogicalReplicationSlotBySrcSlotNameAndDstSlotName(ctx context.Context, db DB, srcSlotName, dstSlotName string) (string, pgtypes.PgLsn, error) {
	// call pg_catalog.pg_copy_logical_replication_slot
	const sqlstr = `SELECT * FROM pg_catalog.pg_copy_logical_replication_slot($1, $2)`
	// run
	var slotName string
	var lsn pgtypes.PgLsn
	logf(sqlstr, srcSlotName, dstSlotName)
	if err := db.QueryRowContext(ctx, sqlstr, srcSlotName, dstSlotName).Scan(&slotName, &lsn); err != nil {
		return "", pgtypes.PgLsn{}, logerror(err)
	}
	return slotName, lsn, nil
}

// PgCopyPhysicalReplicationSlotBySrcSlotNameDstSlotNameAndTemporary calls the stored function 'pg_catalog.pg_copy_physical_replication_slot(name, name, boolean) (name, pg_lsn)' on db.
func PgCopyPhysicalReplicationSlotBySrcSlotNameDstSlotNameAndTemporary(ctx context.Context, db DB, srcSlotName, dstSlotName string, temporary bool) (string, pgtypes.PgLsn, error) {
	// call pg_catalog.pg_copy_physical_replication_slot
	const sqlstr = `SELECT * FROM pg_catalog.pg_copy_physical_replication_slot($1, $2, $3)`
	// run
	var slotName string
	var lsn pgtypes.PgLsn
	logf(sqlstr, srcSlotName, dstSlotName, temporary)
	if err := db.QueryRowContext(ctx, sqlstr, srcSlotName, dstSlotName, temporary).Scan(&slotName, &lsn); err != nil {
		return "", pgtypes.PgLsn{}, logerror(err)
	}
	return slotName, lsn, nil
}

// PgCopyPhysicalReplicationSlotBySrcSlotNameAndDstSlotName calls the stored function 'pg_catalog.pg_copy_physical_replication_slot(name, name) (name, pg_lsn)' on db.
func PgCopyPhysicalReplicationSlotBySrcSlotNameAndDstSlotName(ctx context.Context, db DB, srcSlotName, dstSlotName string) (string, pgtypes.PgLsn, error) {
	// call pg_catalog.pg_copy_physical_replication_slot
	const sqlstr = `SELECT * FROM pg_catalog.pg_copy_physical_replication_slot($1, $2)`
	// run
	var slotName string
	var lsn pgtypes.PgLsn
	logf(sqlstr, srcSlotName, dstSlotName)
	if err := db.QueryRowContext(ctx, sqlstr, srcSlotName, dstSlotName).Scan(&slotName, &lsn); err != nil {
		return "", pgtypes.PgLsn{}, logerror(err)
	}
	return slotName, lsn, nil
}

// PgCreateLogicalReplicationSlot calls the stored function 'pg_catalog.pg_create_logical_replication_slot(name, name, boolean) (name, pg_lsn)' on db.
func PgCreateLogicalReplicationSlot(ctx context.Context, db DB, slotName, plugin string, temporary bool) (string, pgtypes.PgLsn, error) {
	// call pg_catalog.pg_create_logical_replication_slot
	const sqlstr = `SELECT * FROM pg_catalog.pg_create_logical_replication_slot($1, $2, $3)`
	// run
	var slotName string
	var lsn pgtypes.PgLsn
	logf(sqlstr, slotName, plugin, temporary)
	if err := db.QueryRowContext(ctx, sqlstr, slotName, plugin, temporary).Scan(&slotName, &lsn); err != nil {
		return "", pgtypes.PgLsn{}, logerror(err)
	}
	return slotName, lsn, nil
}

// PgCreatePhysicalReplicationSlot calls the stored function 'pg_catalog.pg_create_physical_replication_slot(name, boolean, boolean) (name, pg_lsn)' on db.
func PgCreatePhysicalReplicationSlot(ctx context.Context, db DB, slotName string, immediatelyReserve, temporary bool) (string, pgtypes.PgLsn, error) {
	// call pg_catalog.pg_create_physical_replication_slot
	const sqlstr = `SELECT * FROM pg_catalog.pg_create_physical_replication_slot($1, $2, $3)`
	// run
	var slotName string
	var lsn pgtypes.PgLsn
	logf(sqlstr, slotName, immediatelyReserve, temporary)
	if err := db.QueryRowContext(ctx, sqlstr, slotName, immediatelyReserve, temporary).Scan(&slotName, &lsn); err != nil {
		return "", pgtypes.PgLsn{}, logerror(err)
	}
	return slotName, lsn, nil
}

// PgCreateRestorePoint calls the stored function 'pg_catalog.pg_create_restore_point(text) pg_lsn' on db.
func PgCreateRestorePoint(ctx context.Context, db DB, p0 string) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_create_restore_point
	const sqlstr = `SELECT * FROM pg_catalog.pg_create_restore_point($1)`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgCurrentLogfile calls the stored function 'pg_catalog.pg_current_logfile() text' on db.
func PgCurrentLogfile(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.pg_current_logfile
	const sqlstr = `SELECT * FROM pg_catalog.pg_current_logfile()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgCurrentLogfileByText calls the stored function 'pg_catalog.pg_current_logfile(text) text' on db.
func PgCurrentLogfileByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.pg_current_logfile
	const sqlstr = `SELECT * FROM pg_catalog.pg_current_logfile($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgCurrentSnapshot calls the stored function 'pg_catalog.pg_current_snapshot() pg_snapshot' on db.
func PgCurrentSnapshot(ctx context.Context, db DB) (pgtypes.PgSnapshot, error) {
	// call pg_catalog.pg_current_snapshot
	const sqlstr = `SELECT * FROM pg_catalog.pg_current_snapshot()`
	// run
	var r0 pgtypes.PgSnapshot
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.PgSnapshot{}, logerror(err)
	}
	return r0, nil
}

// PgCurrentWalFlushLsn calls the stored function 'pg_catalog.pg_current_wal_flush_lsn() pg_lsn' on db.
func PgCurrentWalFlushLsn(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_current_wal_flush_lsn
	const sqlstr = `SELECT * FROM pg_catalog.pg_current_wal_flush_lsn()`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgCurrentWalInsertLsn calls the stored function 'pg_catalog.pg_current_wal_insert_lsn() pg_lsn' on db.
func PgCurrentWalInsertLsn(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_current_wal_insert_lsn
	const sqlstr = `SELECT * FROM pg_catalog.pg_current_wal_insert_lsn()`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgCurrentWalLsn calls the stored function 'pg_catalog.pg_current_wal_lsn() pg_lsn' on db.
func PgCurrentWalLsn(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_current_wal_lsn
	const sqlstr = `SELECT * FROM pg_catalog.pg_current_wal_lsn()`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgCurrentXactID calls the stored function 'pg_catalog.pg_current_xact_id() xid8' on db.
func PgCurrentXactID(ctx context.Context, db DB) (pgtypes.Xid8, error) {
	// call pg_catalog.pg_current_xact_id
	const sqlstr = `SELECT * FROM pg_catalog.pg_current_xact_id()`
	// run
	var r0 pgtypes.Xid8
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return r0, nil
}

// PgCurrentXactIDIfAssigned calls the stored function 'pg_catalog.pg_current_xact_id_if_assigned() xid8' on db.
func PgCurrentXactIDIfAssigned(ctx context.Context, db DB) (pgtypes.Xid8, error) {
	// call pg_catalog.pg_current_xact_id_if_assigned
	const sqlstr = `SELECT * FROM pg_catalog.pg_current_xact_id_if_assigned()`
	// run
	var r0 pgtypes.Xid8
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return r0, nil
}

// PgCursor calls the stored function 'pg_catalog.pg_cursor() (text, text, boolean, boolean, boolean, timestamp with time zone)' on db.
func PgCursor(ctx context.Context, db DB) (string, string, bool, bool, bool, time.Time, error) {
	// call pg_catalog.pg_cursor
	const sqlstr = `SELECT * FROM pg_catalog.pg_cursor()`
	// run
	var name string
	var statement string
	var isHoldable bool
	var isBinary bool
	var isScrollable bool
	var creationTime time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &statement, &isHoldable, &isBinary, &isScrollable, &creationTime); err != nil {
		return "", "", false, false, false, time.Time{}, logerror(err)
	}
	return name, statement, isHoldable, isBinary, isScrollable, creationTime, nil
}

// PgDatabaseSizeByName calls the stored function 'pg_catalog.pg_database_size(name) bigint' on db.
func PgDatabaseSizeByName(ctx context.Context, db DB, p0 string) (int64, error) {
	// call pg_catalog.pg_database_size
	const sqlstr = `SELECT * FROM pg_catalog.pg_database_size($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgDatabaseSizeByOid calls the stored function 'pg_catalog.pg_database_size(oid) bigint' on db.
func PgDatabaseSizeByOid(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_database_size
	const sqlstr = `SELECT * FROM pg_catalog.pg_database_size($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgDdlCommandRecv calls the stored function 'pg_catalog.pg_ddl_command_recv(internal) pg_ddl_command' on db.
func PgDdlCommandRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.PgDdlCommand, error) {
	// call pg_catalog.pg_ddl_command_recv
	const sqlstr = `SELECT * FROM pg_catalog.pg_ddl_command_recv($1)`
	// run
	var r0 pgtypes.PgDdlCommand
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.PgDdlCommand{}, logerror(err)
	}
	return r0, nil
}

// PgDdlCommandSend calls the stored function 'pg_catalog.pg_ddl_command_send(pg_ddl_command) bytea' on db.
func PgDdlCommandSend(ctx context.Context, db DB, p0 pgtypes.PgDdlCommand) ([]byte, error) {
	// call pg_catalog.pg_ddl_command_send
	const sqlstr = `SELECT * FROM pg_catalog.pg_ddl_command_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgDependenciesRecv calls the stored function 'pg_catalog.pg_dependencies_recv(internal) pg_dependencies' on db.
func PgDependenciesRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.PgDependencies, error) {
	// call pg_catalog.pg_dependencies_recv
	const sqlstr = `SELECT * FROM pg_catalog.pg_dependencies_recv($1)`
	// run
	var r0 pgtypes.PgDependencies
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.PgDependencies{}, logerror(err)
	}
	return r0, nil
}

// PgDependenciesSend calls the stored function 'pg_catalog.pg_dependencies_send(pg_dependencies) bytea' on db.
func PgDependenciesSend(ctx context.Context, db DB, p0 pgtypes.PgDependencies) ([]byte, error) {
	// call pg_catalog.pg_dependencies_send
	const sqlstr = `SELECT * FROM pg_catalog.pg_dependencies_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgDescribeObject calls the stored function 'pg_catalog.pg_describe_object(oid, oid, integer) text' on db.
func PgDescribeObject(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 int) (string, error) {
	// call pg_catalog.pg_describe_object
	const sqlstr = `SELECT * FROM pg_catalog.pg_describe_object($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgDropReplicationSlot calls the stored function 'pg_catalog.pg_drop_replication_slot(name)' on db.
func PgDropReplicationSlot(ctx context.Context, db DB, p0 string) error {
	// call pg_catalog.pg_drop_replication_slot
	const sqlstr = `SELECT * FROM pg_catalog.pg_drop_replication_slot($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgEncodingMaxLength calls the stored function 'pg_catalog.pg_encoding_max_length(integer) integer' on db.
func PgEncodingMaxLength(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.pg_encoding_max_length
	const sqlstr = `SELECT * FROM pg_catalog.pg_encoding_max_length($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgEncodingToChar calls the stored function 'pg_catalog.pg_encoding_to_char(integer) name' on db.
func PgEncodingToChar(ctx context.Context, db DB, p0 int) (string, error) {
	// call pg_catalog.pg_encoding_to_char
	const sqlstr = `SELECT * FROM pg_catalog.pg_encoding_to_char($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgEventTriggerDdlCommands calls the stored function 'pg_catalog.pg_event_trigger_ddl_commands() (oid, oid, integer, text, text, text, text, boolean, pg_ddl_command)' on db.
func PgEventTriggerDdlCommands(ctx context.Context, db DB) (pgtypes.Oid, pgtypes.Oid, int, string, string, string, string, bool, pgtypes.PgDdlCommand, error) {
	// call pg_catalog.pg_event_trigger_ddl_commands
	const sqlstr = `SELECT * FROM pg_catalog.pg_event_trigger_ddl_commands()`
	// run
	var classid pgtypes.Oid
	var objid pgtypes.Oid
	var objsubid int
	var commandTag string
	var objectType string
	var schemaName string
	var objectIdentity string
	var inExtension bool
	var command pgtypes.PgDdlCommand
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&classid, &objid, &objsubid, &commandTag, &objectType, &schemaName, &objectIdentity, &inExtension, &command); err != nil {
		return pgtypes.Oid{}, pgtypes.Oid{}, 0, "", "", "", "", false, pgtypes.PgDdlCommand{}, logerror(err)
	}
	return classid, objid, objsubid, commandTag, objectType, schemaName, objectIdentity, inExtension, command, nil
}

// PgEventTriggerDroppedObjects calls the stored function 'pg_catalog.pg_event_trigger_dropped_objects() (oid, oid, integer, boolean, boolean, boolean, text, text, text, text, text, text)' on db.
func PgEventTriggerDroppedObjects(ctx context.Context, db DB) (pgtypes.Oid, pgtypes.Oid, int, bool, bool, bool, string, string, string, string, StringSlice, StringSlice, error) {
	// call pg_catalog.pg_event_trigger_dropped_objects
	const sqlstr = `SELECT * FROM pg_catalog.pg_event_trigger_dropped_objects()`
	// run
	var classid pgtypes.Oid
	var objid pgtypes.Oid
	var objsubid int
	var original bool
	var normal bool
	var isTemporary bool
	var objectType string
	var schemaName string
	var objectName string
	var objectIdentity string
	var addressNames StringSlice
	var addressArgs StringSlice
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&classid, &objid, &objsubid, &original, &normal, &isTemporary, &objectType, &schemaName, &objectName, &objectIdentity, &addressNames, &addressArgs); err != nil {
		return pgtypes.Oid{}, pgtypes.Oid{}, 0, false, false, false, "", "", "", "", StringSlice{}, StringSlice{}, logerror(err)
	}
	return classid, objid, objsubid, original, normal, isTemporary, objectType, schemaName, objectName, objectIdentity, addressNames, addressArgs, nil
}

// PgEventTriggerTableRewriteOid calls the stored function 'pg_catalog.pg_event_trigger_table_rewrite_oid() oid' on db.
func PgEventTriggerTableRewriteOid(ctx context.Context, db DB) (pgtypes.Oid, error) {
	// call pg_catalog.pg_event_trigger_table_rewrite_oid
	const sqlstr = `SELECT * FROM pg_catalog.pg_event_trigger_table_rewrite_oid()`
	// run
	var oid pgtypes.Oid
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&oid); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return oid, nil
}

// PgEventTriggerTableRewriteReason calls the stored function 'pg_catalog.pg_event_trigger_table_rewrite_reason() integer' on db.
func PgEventTriggerTableRewriteReason(ctx context.Context, db DB) (int, error) {
	// call pg_catalog.pg_event_trigger_table_rewrite_reason
	const sqlstr = `SELECT * FROM pg_catalog.pg_event_trigger_table_rewrite_reason()`
	// run
	var r0 int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgExportSnapshot calls the stored function 'pg_catalog.pg_export_snapshot() text' on db.
func PgExportSnapshot(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.pg_export_snapshot
	const sqlstr = `SELECT * FROM pg_catalog.pg_export_snapshot()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgExtensionConfigDump calls the stored function 'pg_catalog.pg_extension_config_dump(regclass, text)' on db.
func PgExtensionConfigDump(ctx context.Context, db DB, p0 pgtypes.Regclass, p1 string) error {
	// call pg_catalog.pg_extension_config_dump
	const sqlstr = `SELECT * FROM pg_catalog.pg_extension_config_dump($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// PgExtensionUpdatePaths calls the stored function 'pg_catalog.pg_extension_update_paths(name) (text, text, text)' on db.
func PgExtensionUpdatePaths(ctx context.Context, db DB, name string) (string, string, string, error) {
	// call pg_catalog.pg_extension_update_paths
	const sqlstr = `SELECT * FROM pg_catalog.pg_extension_update_paths($1)`
	// run
	var source string
	var target string
	var path string
	logf(sqlstr, name)
	if err := db.QueryRowContext(ctx, sqlstr, name).Scan(&source, &target, &path); err != nil {
		return "", "", "", logerror(err)
	}
	return source, target, path, nil
}

// PgFilenodeRelation calls the stored function 'pg_catalog.pg_filenode_relation(oid, oid) regclass' on db.
func PgFilenodeRelation(ctx context.Context, db DB, p0, p1 pgtypes.Oid) (pgtypes.Regclass, error) {
	// call pg_catalog.pg_filenode_relation
	const sqlstr = `SELECT * FROM pg_catalog.pg_filenode_relation($1, $2)`
	// run
	var r0 pgtypes.Regclass
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return r0, nil
}

// PgFunctionIsVisible calls the stored function 'pg_catalog.pg_function_is_visible(oid) boolean' on db.
func PgFunctionIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_function_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_function_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgGetConstraintdefByOid calls the stored function 'pg_catalog.pg_get_constraintdef(oid) text' on db.
func PgGetConstraintdefByOid(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_constraintdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_constraintdef($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetConstraintdefByOidAndBoolean calls the stored function 'pg_catalog.pg_get_constraintdef(oid, boolean) text' on db.
func PgGetConstraintdefByOidAndBoolean(ctx context.Context, db DB, p0 pgtypes.Oid, p1 bool) (string, error) {
	// call pg_catalog.pg_get_constraintdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_constraintdef($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetExprByPgNodeTreeAndOid calls the stored function 'pg_catalog.pg_get_expr(pg_node_tree, oid) text' on db.
func PgGetExprByPgNodeTreeAndOid(ctx context.Context, db DB, p0 pgtypes.PgNodeTree, p1 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_expr
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_expr($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetExprByPgNodeTreeOidAndBoolean calls the stored function 'pg_catalog.pg_get_expr(pg_node_tree, oid, boolean) text' on db.
func PgGetExprByPgNodeTreeOidAndBoolean(ctx context.Context, db DB, p0 pgtypes.PgNodeTree, p1 pgtypes.Oid, p2 bool) (string, error) {
	// call pg_catalog.pg_get_expr
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_expr($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetFunctionArgDefault calls the stored function 'pg_catalog.pg_get_function_arg_default(oid, integer) text' on db.
func PgGetFunctionArgDefault(ctx context.Context, db DB, p0 pgtypes.Oid, p1 int) (string, error) {
	// call pg_catalog.pg_get_function_arg_default
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_function_arg_default($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetFunctionArguments calls the stored function 'pg_catalog.pg_get_function_arguments(oid) text' on db.
func PgGetFunctionArguments(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_function_arguments
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_function_arguments($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetFunctionIdentityArguments calls the stored function 'pg_catalog.pg_get_function_identity_arguments(oid) text' on db.
func PgGetFunctionIdentityArguments(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_function_identity_arguments
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_function_identity_arguments($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetFunctionResult calls the stored function 'pg_catalog.pg_get_function_result(oid) text' on db.
func PgGetFunctionResult(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_function_result
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_function_result($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetFunctiondef calls the stored function 'pg_catalog.pg_get_functiondef(oid) text' on db.
func PgGetFunctiondef(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_functiondef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_functiondef($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetIndexdefByOid calls the stored function 'pg_catalog.pg_get_indexdef(oid) text' on db.
func PgGetIndexdefByOid(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_indexdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_indexdef($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetIndexdefByOidIntegerAndBoolean calls the stored function 'pg_catalog.pg_get_indexdef(oid, integer, boolean) text' on db.
func PgGetIndexdefByOidIntegerAndBoolean(ctx context.Context, db DB, p0 pgtypes.Oid, p1 int, p2 bool) (string, error) {
	// call pg_catalog.pg_get_indexdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_indexdef($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetKeywords calls the stored function 'pg_catalog.pg_get_keywords() (text, "char", text)' on db.
func PgGetKeywords(ctx context.Context, db DB) (string, pgtypes.Char, string, error) {
	// call pg_catalog.pg_get_keywords
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_keywords()`
	// run
	var word string
	var catcode pgtypes.Char
	var catdesc string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&word, &catcode, &catdesc); err != nil {
		return "", pgtypes.Char{}, "", logerror(err)
	}
	return word, catcode, catdesc, nil
}

// PgGetMultixactMembers calls the stored function 'pg_catalog.pg_get_multixact_members(xid) (xid, text)' on db.
func PgGetMultixactMembers(ctx context.Context, db DB, multixid pgtypes.Xid) (pgtypes.Xid, string, error) {
	// call pg_catalog.pg_get_multixact_members
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_multixact_members($1)`
	// run
	var xid pgtypes.Xid
	var mode string
	logf(sqlstr, multixid)
	if err := db.QueryRowContext(ctx, sqlstr, multixid).Scan(&xid, &mode); err != nil {
		return pgtypes.Xid{}, "", logerror(err)
	}
	return xid, mode, nil
}

// PgGetObjectAddress calls the stored function 'pg_catalog.pg_get_object_address(text, text, text) (oid, oid, integer)' on db.
func PgGetObjectAddress(ctx context.Context, db DB, typ string, objectNames, objectArgs StringSlice) (pgtypes.Oid, pgtypes.Oid, int, error) {
	// call pg_catalog.pg_get_object_address
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_object_address($1, $2, $3)`
	// run
	var classid pgtypes.Oid
	var objid pgtypes.Oid
	var objsubid int
	logf(sqlstr, typ, objectNames, objectArgs)
	if err := db.QueryRowContext(ctx, sqlstr, typ, objectNames, objectArgs).Scan(&classid, &objid, &objsubid); err != nil {
		return pgtypes.Oid{}, pgtypes.Oid{}, 0, logerror(err)
	}
	return classid, objid, objsubid, nil
}

// PgGetPartitionConstraintdef calls the stored function 'pg_catalog.pg_get_partition_constraintdef(oid) text' on db.
func PgGetPartitionConstraintdef(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_partition_constraintdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_partition_constraintdef($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetPartkeydef calls the stored function 'pg_catalog.pg_get_partkeydef(oid) text' on db.
func PgGetPartkeydef(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_partkeydef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_partkeydef($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetPublicationTables calls the stored function 'pg_catalog.pg_get_publication_tables(text) oid' on db.
func PgGetPublicationTables(ctx context.Context, db DB, pubname string) (pgtypes.Oid, error) {
	// call pg_catalog.pg_get_publication_tables
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_publication_tables($1)`
	// run
	var relid pgtypes.Oid
	logf(sqlstr, pubname)
	if err := db.QueryRowContext(ctx, sqlstr, pubname).Scan(&relid); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return relid, nil
}

// PgGetReplicaIdentityIndex calls the stored function 'pg_catalog.pg_get_replica_identity_index(regclass) regclass' on db.
func PgGetReplicaIdentityIndex(ctx context.Context, db DB, p0 pgtypes.Regclass) (pgtypes.Regclass, error) {
	// call pg_catalog.pg_get_replica_identity_index
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_replica_identity_index($1)`
	// run
	var r0 pgtypes.Regclass
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return r0, nil
}

// PgGetReplicationSlots calls the stored function 'pg_catalog.pg_get_replication_slots() (name, name, text, oid, boolean, boolean, integer, xid, xid, pg_lsn, pg_lsn, text, bigint)' on db.
func PgGetReplicationSlots(ctx context.Context, db DB) (string, string, string, pgtypes.Oid, bool, bool, int, pgtypes.Xid, pgtypes.Xid, pgtypes.PgLsn, pgtypes.PgLsn, string, int64, error) {
	// call pg_catalog.pg_get_replication_slots
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_replication_slots()`
	// run
	var slotName string
	var plugin string
	var slotType string
	var datoid pgtypes.Oid
	var temporary bool
	var active bool
	var activePid int
	var xmin pgtypes.Xid
	var catalogXmin pgtypes.Xid
	var restartLsn pgtypes.PgLsn
	var confirmedFlushLsn pgtypes.PgLsn
	var walStatus string
	var safeWalSize int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&slotName, &plugin, &slotType, &datoid, &temporary, &active, &activePid, &xmin, &catalogXmin, &restartLsn, &confirmedFlushLsn, &walStatus, &safeWalSize); err != nil {
		return "", "", "", pgtypes.Oid{}, false, false, 0, pgtypes.Xid{}, pgtypes.Xid{}, pgtypes.PgLsn{}, pgtypes.PgLsn{}, "", 0, logerror(err)
	}
	return slotName, plugin, slotType, datoid, temporary, active, activePid, xmin, catalogXmin, restartLsn, confirmedFlushLsn, walStatus, safeWalSize, nil
}

// PgGetRuledefByOid calls the stored function 'pg_catalog.pg_get_ruledef(oid) text' on db.
func PgGetRuledefByOid(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_ruledef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_ruledef($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetRuledefByOidAndBoolean calls the stored function 'pg_catalog.pg_get_ruledef(oid, boolean) text' on db.
func PgGetRuledefByOidAndBoolean(ctx context.Context, db DB, p0 pgtypes.Oid, p1 bool) (string, error) {
	// call pg_catalog.pg_get_ruledef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_ruledef($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetSerialSequence calls the stored function 'pg_catalog.pg_get_serial_sequence(text, text) text' on db.
func PgGetSerialSequence(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.pg_get_serial_sequence
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_serial_sequence($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetShmemAllocations calls the stored function 'pg_catalog.pg_get_shmem_allocations() (text, bigint, bigint, bigint)' on db.
func PgGetShmemAllocations(ctx context.Context, db DB) (string, int64, int64, int64, error) {
	// call pg_catalog.pg_get_shmem_allocations
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_shmem_allocations()`
	// run
	var name string
	var off int64
	var size int64
	var allocatedSize int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &off, &size, &allocatedSize); err != nil {
		return "", 0, 0, 0, logerror(err)
	}
	return name, off, size, allocatedSize, nil
}

// PgGetStatisticsobjdef calls the stored function 'pg_catalog.pg_get_statisticsobjdef(oid) text' on db.
func PgGetStatisticsobjdef(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_statisticsobjdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_statisticsobjdef($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetTriggerdefByOid calls the stored function 'pg_catalog.pg_get_triggerdef(oid) text' on db.
func PgGetTriggerdefByOid(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_triggerdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_triggerdef($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetTriggerdefByOidAndBoolean calls the stored function 'pg_catalog.pg_get_triggerdef(oid, boolean) text' on db.
func PgGetTriggerdefByOidAndBoolean(ctx context.Context, db DB, p0 pgtypes.Oid, p1 bool) (string, error) {
	// call pg_catalog.pg_get_triggerdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_triggerdef($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetUserbyid calls the stored function 'pg_catalog.pg_get_userbyid(oid) name' on db.
func PgGetUserbyid(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_userbyid
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_userbyid($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetViewdefByText calls the stored function 'pg_catalog.pg_get_viewdef(text) text' on db.
func PgGetViewdefByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.pg_get_viewdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_viewdef($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetViewdefByOid calls the stored function 'pg_catalog.pg_get_viewdef(oid) text' on db.
func PgGetViewdefByOid(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_get_viewdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_viewdef($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetViewdefByTextAndBoolean calls the stored function 'pg_catalog.pg_get_viewdef(text, boolean) text' on db.
func PgGetViewdefByTextAndBoolean(ctx context.Context, db DB, p0 string, p1 bool) (string, error) {
	// call pg_catalog.pg_get_viewdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_viewdef($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetViewdefByOidAndBoolean calls the stored function 'pg_catalog.pg_get_viewdef(oid, boolean) text' on db.
func PgGetViewdefByOidAndBoolean(ctx context.Context, db DB, p0 pgtypes.Oid, p1 bool) (string, error) {
	// call pg_catalog.pg_get_viewdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_viewdef($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgGetViewdefByOidAndInteger calls the stored function 'pg_catalog.pg_get_viewdef(oid, integer) text' on db.
func PgGetViewdefByOidAndInteger(ctx context.Context, db DB, p0 pgtypes.Oid, p1 int) (string, error) {
	// call pg_catalog.pg_get_viewdef
	const sqlstr = `SELECT * FROM pg_catalog.pg_get_viewdef($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgHasRoleByNameNameAndText calls the stored function 'pg_catalog.pg_has_role(name, name, text) boolean' on db.
func PgHasRoleByNameNameAndText(ctx context.Context, db DB, p0, p1, p2 string) (bool, error) {
	// call pg_catalog.pg_has_role
	const sqlstr = `SELECT * FROM pg_catalog.pg_has_role($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgHasRoleByNameOidAndText calls the stored function 'pg_catalog.pg_has_role(name, oid, text) boolean' on db.
func PgHasRoleByNameOidAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.pg_has_role
	const sqlstr = `SELECT * FROM pg_catalog.pg_has_role($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgHasRoleByOidNameAndText calls the stored function 'pg_catalog.pg_has_role(oid, name, text) boolean' on db.
func PgHasRoleByOidNameAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1, p2 string) (bool, error) {
	// call pg_catalog.pg_has_role
	const sqlstr = `SELECT * FROM pg_catalog.pg_has_role($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgHasRoleByOidOidAndText calls the stored function 'pg_catalog.pg_has_role(oid, oid, text) boolean' on db.
func PgHasRoleByOidOidAndText(ctx context.Context, db DB, p0, p1 pgtypes.Oid, p2 string) (bool, error) {
	// call pg_catalog.pg_has_role
	const sqlstr = `SELECT * FROM pg_catalog.pg_has_role($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgHasRoleByNameAndText calls the stored function 'pg_catalog.pg_has_role(name, text) boolean' on db.
func PgHasRoleByNameAndText(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.pg_has_role
	const sqlstr = `SELECT * FROM pg_catalog.pg_has_role($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgHasRoleByOidAndText calls the stored function 'pg_catalog.pg_has_role(oid, text) boolean' on db.
func PgHasRoleByOidAndText(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.pg_has_role
	const sqlstr = `SELECT * FROM pg_catalog.pg_has_role($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgHbaFileRules calls the stored function 'pg_catalog.pg_hba_file_rules() (integer, text, text, text, text, text, text, text, text)' on db.
func PgHbaFileRules(ctx context.Context, db DB) (int, string, StringSlice, StringSlice, string, string, string, StringSlice, string, error) {
	// call pg_catalog.pg_hba_file_rules
	const sqlstr = `SELECT * FROM pg_catalog.pg_hba_file_rules()`
	// run
	var lineNumber int
	var typ string
	var database StringSlice
	var userName StringSlice
	var address string
	var netmask string
	var authMethod string
	var options StringSlice
	var e string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&lineNumber, &typ, &database, &userName, &address, &netmask, &authMethod, &options, &e); err != nil {
		return 0, "", StringSlice{}, StringSlice{}, "", "", "", StringSlice{}, "", logerror(err)
	}
	return lineNumber, typ, database, userName, address, netmask, authMethod, options, e, nil
}

// PgIdentifyObject calls the stored function 'pg_catalog.pg_identify_object(oid, oid, integer) (text, text, text, text)' on db.
func PgIdentifyObject(ctx context.Context, db DB, classid, objid pgtypes.Oid, objsubid int) (string, string, string, string, error) {
	// call pg_catalog.pg_identify_object
	const sqlstr = `SELECT * FROM pg_catalog.pg_identify_object($1, $2, $3)`
	// run
	var typ string
	var schema string
	var name string
	var identity string
	logf(sqlstr, classid, objid, objsubid)
	if err := db.QueryRowContext(ctx, sqlstr, classid, objid, objsubid).Scan(&typ, &schema, &name, &identity); err != nil {
		return "", "", "", "", logerror(err)
	}
	return typ, schema, name, identity, nil
}

// PgIdentifyObjectAsAddress calls the stored function 'pg_catalog.pg_identify_object_as_address(oid, oid, integer) (text, text, text)' on db.
func PgIdentifyObjectAsAddress(ctx context.Context, db DB, classid, objid pgtypes.Oid, objsubid int) (string, StringSlice, StringSlice, error) {
	// call pg_catalog.pg_identify_object_as_address
	const sqlstr = `SELECT * FROM pg_catalog.pg_identify_object_as_address($1, $2, $3)`
	// run
	var typ string
	var objectNames StringSlice
	var objectArgs StringSlice
	logf(sqlstr, classid, objid, objsubid)
	if err := db.QueryRowContext(ctx, sqlstr, classid, objid, objsubid).Scan(&typ, &objectNames, &objectArgs); err != nil {
		return "", StringSlice{}, StringSlice{}, logerror(err)
	}
	return typ, objectNames, objectArgs, nil
}

// PgImportSystemCollations calls the stored function 'pg_catalog.pg_import_system_collations(regnamespace) integer' on db.
func PgImportSystemCollations(ctx context.Context, db DB, p0 pgtypes.Regnamespace) (int, error) {
	// call pg_catalog.pg_import_system_collations
	const sqlstr = `SELECT * FROM pg_catalog.pg_import_system_collations($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgIndexColumnHasProperty calls the stored function 'pg_catalog.pg_index_column_has_property(regclass, integer, text) boolean' on db.
func PgIndexColumnHasProperty(ctx context.Context, db DB, p0 pgtypes.Regclass, p1 int, p2 string) (bool, error) {
	// call pg_catalog.pg_index_column_has_property
	const sqlstr = `SELECT * FROM pg_catalog.pg_index_column_has_property($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgIndexHasProperty calls the stored function 'pg_catalog.pg_index_has_property(regclass, text) boolean' on db.
func PgIndexHasProperty(ctx context.Context, db DB, p0 pgtypes.Regclass, p1 string) (bool, error) {
	// call pg_catalog.pg_index_has_property
	const sqlstr = `SELECT * FROM pg_catalog.pg_index_has_property($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgIndexamHasProperty calls the stored function 'pg_catalog.pg_indexam_has_property(oid, text) boolean' on db.
func PgIndexamHasProperty(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (bool, error) {
	// call pg_catalog.pg_indexam_has_property
	const sqlstr = `SELECT * FROM pg_catalog.pg_indexam_has_property($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgIndexamProgressPhasename calls the stored function 'pg_catalog.pg_indexam_progress_phasename(oid, bigint) text' on db.
func PgIndexamProgressPhasename(ctx context.Context, db DB, p0 pgtypes.Oid, p1 int64) (string, error) {
	// call pg_catalog.pg_indexam_progress_phasename
	const sqlstr = `SELECT * FROM pg_catalog.pg_indexam_progress_phasename($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgIndexesSize calls the stored function 'pg_catalog.pg_indexes_size(regclass) bigint' on db.
func PgIndexesSize(ctx context.Context, db DB, p0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.pg_indexes_size
	const sqlstr = `SELECT * FROM pg_catalog.pg_indexes_size($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgIsInBackup calls the stored function 'pg_catalog.pg_is_in_backup() boolean' on db.
func PgIsInBackup(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_is_in_backup
	const sqlstr = `SELECT * FROM pg_catalog.pg_is_in_backup()`
	// run
	var r0 bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgIsInRecovery calls the stored function 'pg_catalog.pg_is_in_recovery() boolean' on db.
func PgIsInRecovery(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_is_in_recovery
	const sqlstr = `SELECT * FROM pg_catalog.pg_is_in_recovery()`
	// run
	var r0 bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgIsOtherTempSchema calls the stored function 'pg_catalog.pg_is_other_temp_schema(oid) boolean' on db.
func PgIsOtherTempSchema(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_is_other_temp_schema
	const sqlstr = `SELECT * FROM pg_catalog.pg_is_other_temp_schema($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgIsWalReplayPaused calls the stored function 'pg_catalog.pg_is_wal_replay_paused() boolean' on db.
func PgIsWalReplayPaused(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_is_wal_replay_paused
	const sqlstr = `SELECT * FROM pg_catalog.pg_is_wal_replay_paused()`
	// run
	var r0 bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgIsolationTestSessionIsBlocked calls the stored function 'pg_catalog.pg_isolation_test_session_is_blocked(integer, integer) boolean' on db.
func PgIsolationTestSessionIsBlocked(ctx context.Context, db DB, p0 int, p1 []int) (bool, error) {
	// call pg_catalog.pg_isolation_test_session_is_blocked
	const sqlstr = `SELECT * FROM pg_catalog.pg_isolation_test_session_is_blocked($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgJitAvailable calls the stored function 'pg_catalog.pg_jit_available() boolean' on db.
func PgJitAvailable(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_jit_available
	const sqlstr = `SELECT * FROM pg_catalog.pg_jit_available()`
	// run
	var r0 bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgLastCommittedXact calls the stored function 'pg_catalog.pg_last_committed_xact() (xid, timestamp with time zone)' on db.
func PgLastCommittedXact(ctx context.Context, db DB) (pgtypes.Xid, time.Time, error) {
	// call pg_catalog.pg_last_committed_xact
	const sqlstr = `SELECT * FROM pg_catalog.pg_last_committed_xact()`
	// run
	var xid pgtypes.Xid
	var timestamp time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&xid, &timestamp); err != nil {
		return pgtypes.Xid{}, time.Time{}, logerror(err)
	}
	return xid, timestamp, nil
}

// PgLastWalReceiveLsn calls the stored function 'pg_catalog.pg_last_wal_receive_lsn() pg_lsn' on db.
func PgLastWalReceiveLsn(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_last_wal_receive_lsn
	const sqlstr = `SELECT * FROM pg_catalog.pg_last_wal_receive_lsn()`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgLastWalReplayLsn calls the stored function 'pg_catalog.pg_last_wal_replay_lsn() pg_lsn' on db.
func PgLastWalReplayLsn(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_last_wal_replay_lsn
	const sqlstr = `SELECT * FROM pg_catalog.pg_last_wal_replay_lsn()`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgLastXactReplayTimestamp calls the stored function 'pg_catalog.pg_last_xact_replay_timestamp() timestamp with time zone' on db.
func PgLastXactReplayTimestamp(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_last_xact_replay_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.pg_last_xact_replay_timestamp()`
	// run
	var r0 time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgListeningChannels calls the stored function 'pg_catalog.pg_listening_channels() text' on db.
func PgListeningChannels(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.pg_listening_channels
	const sqlstr = `SELECT * FROM pg_catalog.pg_listening_channels()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgLockStatus calls the stored function 'pg_catalog.pg_lock_status() (text, oid, oid, integer, smallint, text, xid, oid, oid, smallint, text, integer, text, boolean, boolean)' on db.
func PgLockStatus(ctx context.Context, db DB) (string, pgtypes.Oid, pgtypes.Oid, int, int16, string, pgtypes.Xid, pgtypes.Oid, pgtypes.Oid, int16, string, int, string, bool, bool, error) {
	// call pg_catalog.pg_lock_status
	const sqlstr = `SELECT * FROM pg_catalog.pg_lock_status()`
	// run
	var locktype string
	var database pgtypes.Oid
	var relation pgtypes.Oid
	var page int
	var tuple int16
	var virtualxid string
	var transactionid pgtypes.Xid
	var classid pgtypes.Oid
	var objid pgtypes.Oid
	var objsubid int16
	var virtualtransaction string
	var pid int
	var mode string
	var granted bool
	var fastpath bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&locktype, &database, &relation, &page, &tuple, &virtualxid, &transactionid, &classid, &objid, &objsubid, &virtualtransaction, &pid, &mode, &granted, &fastpath); err != nil {
		return "", pgtypes.Oid{}, pgtypes.Oid{}, 0, 0, "", pgtypes.Xid{}, pgtypes.Oid{}, pgtypes.Oid{}, 0, "", 0, "", false, false, logerror(err)
	}
	return locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid, virtualtransaction, pid, mode, granted, fastpath, nil
}

// PgLogicalEmitMessageByBooleanTextAndText calls the stored function 'pg_catalog.pg_logical_emit_message(boolean, text, text) pg_lsn' on db.
func PgLogicalEmitMessageByBooleanTextAndText(ctx context.Context, db DB, p0 bool, p1, p2 string) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_logical_emit_message
	const sqlstr = `SELECT * FROM pg_catalog.pg_logical_emit_message($1, $2, $3)`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgLogicalEmitMessageByBooleanTextAndBytea calls the stored function 'pg_catalog.pg_logical_emit_message(boolean, text, bytea) pg_lsn' on db.
func PgLogicalEmitMessageByBooleanTextAndBytea(ctx context.Context, db DB, p0 bool, p1 string, p2 []byte) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_logical_emit_message
	const sqlstr = `SELECT * FROM pg_catalog.pg_logical_emit_message($1, $2, $3)`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgLogicalSlotGetBinaryChanges calls the stored function 'pg_catalog.pg_logical_slot_get_binary_changes(name, pg_lsn, integer, text) (pg_lsn, xid, bytea)' on db.
func PgLogicalSlotGetBinaryChanges(ctx context.Context, db DB, slotName string, uptoLsn pgtypes.PgLsn, uptoNchanges int, options StringSlice) (pgtypes.PgLsn, pgtypes.Xid, []byte, error) {
	// call pg_catalog.pg_logical_slot_get_binary_changes
	const sqlstr = `SELECT * FROM pg_catalog.pg_logical_slot_get_binary_changes($1, $2, $3, $4)`
	// run
	var lsn pgtypes.PgLsn
	var xid pgtypes.Xid
	var data []byte
	logf(sqlstr, slotName, uptoLsn, uptoNchanges, options)
	if err := db.QueryRowContext(ctx, sqlstr, slotName, uptoLsn, uptoNchanges, options).Scan(&lsn, &xid, &data); err != nil {
		return pgtypes.PgLsn{}, pgtypes.Xid{}, nil, logerror(err)
	}
	return lsn, xid, data, nil
}

// PgLogicalSlotGetChanges calls the stored function 'pg_catalog.pg_logical_slot_get_changes(name, pg_lsn, integer, text) (pg_lsn, xid, text)' on db.
func PgLogicalSlotGetChanges(ctx context.Context, db DB, slotName string, uptoLsn pgtypes.PgLsn, uptoNchanges int, options StringSlice) (pgtypes.PgLsn, pgtypes.Xid, string, error) {
	// call pg_catalog.pg_logical_slot_get_changes
	const sqlstr = `SELECT * FROM pg_catalog.pg_logical_slot_get_changes($1, $2, $3, $4)`
	// run
	var lsn pgtypes.PgLsn
	var xid pgtypes.Xid
	var data string
	logf(sqlstr, slotName, uptoLsn, uptoNchanges, options)
	if err := db.QueryRowContext(ctx, sqlstr, slotName, uptoLsn, uptoNchanges, options).Scan(&lsn, &xid, &data); err != nil {
		return pgtypes.PgLsn{}, pgtypes.Xid{}, "", logerror(err)
	}
	return lsn, xid, data, nil
}

// PgLogicalSlotPeekBinaryChanges calls the stored function 'pg_catalog.pg_logical_slot_peek_binary_changes(name, pg_lsn, integer, text) (pg_lsn, xid, bytea)' on db.
func PgLogicalSlotPeekBinaryChanges(ctx context.Context, db DB, slotName string, uptoLsn pgtypes.PgLsn, uptoNchanges int, options StringSlice) (pgtypes.PgLsn, pgtypes.Xid, []byte, error) {
	// call pg_catalog.pg_logical_slot_peek_binary_changes
	const sqlstr = `SELECT * FROM pg_catalog.pg_logical_slot_peek_binary_changes($1, $2, $3, $4)`
	// run
	var lsn pgtypes.PgLsn
	var xid pgtypes.Xid
	var data []byte
	logf(sqlstr, slotName, uptoLsn, uptoNchanges, options)
	if err := db.QueryRowContext(ctx, sqlstr, slotName, uptoLsn, uptoNchanges, options).Scan(&lsn, &xid, &data); err != nil {
		return pgtypes.PgLsn{}, pgtypes.Xid{}, nil, logerror(err)
	}
	return lsn, xid, data, nil
}

// PgLogicalSlotPeekChanges calls the stored function 'pg_catalog.pg_logical_slot_peek_changes(name, pg_lsn, integer, text) (pg_lsn, xid, text)' on db.
func PgLogicalSlotPeekChanges(ctx context.Context, db DB, slotName string, uptoLsn pgtypes.PgLsn, uptoNchanges int, options StringSlice) (pgtypes.PgLsn, pgtypes.Xid, string, error) {
	// call pg_catalog.pg_logical_slot_peek_changes
	const sqlstr = `SELECT * FROM pg_catalog.pg_logical_slot_peek_changes($1, $2, $3, $4)`
	// run
	var lsn pgtypes.PgLsn
	var xid pgtypes.Xid
	var data string
	logf(sqlstr, slotName, uptoLsn, uptoNchanges, options)
	if err := db.QueryRowContext(ctx, sqlstr, slotName, uptoLsn, uptoNchanges, options).Scan(&lsn, &xid, &data); err != nil {
		return pgtypes.PgLsn{}, pgtypes.Xid{}, "", logerror(err)
	}
	return lsn, xid, data, nil
}

// PgLsArchiveStatusdir calls the stored function 'pg_catalog.pg_ls_archive_statusdir() (text, bigint, timestamp with time zone)' on db.
func PgLsArchiveStatusdir(ctx context.Context, db DB) (string, int64, time.Time, error) {
	// call pg_catalog.pg_ls_archive_statusdir
	const sqlstr = `SELECT * FROM pg_catalog.pg_ls_archive_statusdir()`
	// run
	var name string
	var size int64
	var modification time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &size, &modification); err != nil {
		return "", 0, time.Time{}, logerror(err)
	}
	return name, size, modification, nil
}

// PgLsDirByText calls the stored function 'pg_catalog.pg_ls_dir(text) text' on db.
func PgLsDirByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.pg_ls_dir
	const sqlstr = `SELECT * FROM pg_catalog.pg_ls_dir($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgLsDirByTextBooleanAndBoolean calls the stored function 'pg_catalog.pg_ls_dir(text, boolean, boolean) text' on db.
func PgLsDirByTextBooleanAndBoolean(ctx context.Context, db DB, p0 string, p1, p2 bool) (string, error) {
	// call pg_catalog.pg_ls_dir
	const sqlstr = `SELECT * FROM pg_catalog.pg_ls_dir($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgLsLogdir calls the stored function 'pg_catalog.pg_ls_logdir() (text, bigint, timestamp with time zone)' on db.
func PgLsLogdir(ctx context.Context, db DB) (string, int64, time.Time, error) {
	// call pg_catalog.pg_ls_logdir
	const sqlstr = `SELECT * FROM pg_catalog.pg_ls_logdir()`
	// run
	var name string
	var size int64
	var modification time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &size, &modification); err != nil {
		return "", 0, time.Time{}, logerror(err)
	}
	return name, size, modification, nil
}

// PgLsTmpdir calls the stored function 'pg_catalog.pg_ls_tmpdir() (text, bigint, timestamp with time zone)' on db.
func PgLsTmpdir(ctx context.Context, db DB) (string, int64, time.Time, error) {
	// call pg_catalog.pg_ls_tmpdir
	const sqlstr = `SELECT * FROM pg_catalog.pg_ls_tmpdir()`
	// run
	var name string
	var size int64
	var modification time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &size, &modification); err != nil {
		return "", 0, time.Time{}, logerror(err)
	}
	return name, size, modification, nil
}

// PgLsTmpdirByTablespace calls the stored function 'pg_catalog.pg_ls_tmpdir(oid) (text, bigint, timestamp with time zone)' on db.
func PgLsTmpdirByTablespace(ctx context.Context, db DB, tablespace pgtypes.Oid) (string, int64, time.Time, error) {
	// call pg_catalog.pg_ls_tmpdir
	const sqlstr = `SELECT * FROM pg_catalog.pg_ls_tmpdir($1)`
	// run
	var name string
	var size int64
	var modification time.Time
	logf(sqlstr, tablespace)
	if err := db.QueryRowContext(ctx, sqlstr, tablespace).Scan(&name, &size, &modification); err != nil {
		return "", 0, time.Time{}, logerror(err)
	}
	return name, size, modification, nil
}

// PgLsWaldir calls the stored function 'pg_catalog.pg_ls_waldir() (text, bigint, timestamp with time zone)' on db.
func PgLsWaldir(ctx context.Context, db DB) (string, int64, time.Time, error) {
	// call pg_catalog.pg_ls_waldir
	const sqlstr = `SELECT * FROM pg_catalog.pg_ls_waldir()`
	// run
	var name string
	var size int64
	var modification time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &size, &modification); err != nil {
		return "", 0, time.Time{}, logerror(err)
	}
	return name, size, modification, nil
}

// PgLsnCmp calls the stored function 'pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn) integer' on db.
func PgLsnCmp(ctx context.Context, db DB, p0, p1 pgtypes.PgLsn) (int, error) {
	// call pg_catalog.pg_lsn_cmp
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgLsnEq calls the stored function 'pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn) boolean' on db.
func PgLsnEq(ctx context.Context, db DB, p0, p1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_eq
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgLsnGe calls the stored function 'pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn) boolean' on db.
func PgLsnGe(ctx context.Context, db DB, p0, p1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_ge
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgLsnGt calls the stored function 'pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn) boolean' on db.
func PgLsnGt(ctx context.Context, db DB, p0, p1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_gt
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgLsnHash calls the stored function 'pg_catalog.pg_lsn_hash(pg_lsn) integer' on db.
func PgLsnHash(ctx context.Context, db DB, p0 pgtypes.PgLsn) (int, error) {
	// call pg_catalog.pg_lsn_hash
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_hash($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgLsnHashExtended calls the stored function 'pg_catalog.pg_lsn_hash_extended(pg_lsn, bigint) bigint' on db.
func PgLsnHashExtended(ctx context.Context, db DB, p0 pgtypes.PgLsn, p1 int64) (int64, error) {
	// call pg_catalog.pg_lsn_hash_extended
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_hash_extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgLsnLarger calls the stored function 'pg_catalog.pg_lsn_larger(pg_lsn, pg_lsn) pg_lsn' on db.
func PgLsnLarger(ctx context.Context, db DB, p0, p1 pgtypes.PgLsn) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_lsn_larger
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_larger($1, $2)`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgLsnLe calls the stored function 'pg_catalog.pg_lsn_le(pg_lsn, pg_lsn) boolean' on db.
func PgLsnLe(ctx context.Context, db DB, p0, p1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_le
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgLsnLt calls the stored function 'pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn) boolean' on db.
func PgLsnLt(ctx context.Context, db DB, p0, p1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_lt
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgLsnMi calls the stored function 'pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn) numeric' on db.
func PgLsnMi(ctx context.Context, db DB, p0, p1 pgtypes.PgLsn) (float64, error) {
	// call pg_catalog.pg_lsn_mi
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_mi($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PgLsnNe calls the stored function 'pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn) boolean' on db.
func PgLsnNe(ctx context.Context, db DB, p0, p1 pgtypes.PgLsn) (bool, error) {
	// call pg_catalog.pg_lsn_ne
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgLsnRecv calls the stored function 'pg_catalog.pg_lsn_recv(internal) pg_lsn' on db.
func PgLsnRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_lsn_recv
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_recv($1)`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgLsnSend calls the stored function 'pg_catalog.pg_lsn_send(pg_lsn) bytea' on db.
func PgLsnSend(ctx context.Context, db DB, p0 pgtypes.PgLsn) ([]byte, error) {
	// call pg_catalog.pg_lsn_send
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgLsnSmaller calls the stored function 'pg_catalog.pg_lsn_smaller(pg_lsn, pg_lsn) pg_lsn' on db.
func PgLsnSmaller(ctx context.Context, db DB, p0, p1 pgtypes.PgLsn) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_lsn_smaller
	const sqlstr = `SELECT * FROM pg_catalog.pg_lsn_smaller($1, $2)`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgMcvListItems calls the stored function 'pg_catalog.pg_mcv_list_items(pg_mcv_list) (integer, text, boolean, double precision, double precision)' on db.
func PgMcvListItems(ctx context.Context, db DB, mcvList pgtypes.PgMcvList) (int, StringSlice, []bool, float64, float64, error) {
	// call pg_catalog.pg_mcv_list_items
	const sqlstr = `SELECT * FROM pg_catalog.pg_mcv_list_items($1)`
	// run
	var index int
	var values StringSlice
	var nulls []bool
	var frequency float64
	var baseFrequency float64
	logf(sqlstr, mcvList)
	if err := db.QueryRowContext(ctx, sqlstr, mcvList).Scan(&index, &values, &nulls, &frequency, &baseFrequency); err != nil {
		return 0, StringSlice{}, nil, 0.0, 0.0, logerror(err)
	}
	return index, values, nulls, frequency, baseFrequency, nil
}

// PgMcvListRecv calls the stored function 'pg_catalog.pg_mcv_list_recv(internal) pg_mcv_list' on db.
func PgMcvListRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.PgMcvList, error) {
	// call pg_catalog.pg_mcv_list_recv
	const sqlstr = `SELECT * FROM pg_catalog.pg_mcv_list_recv($1)`
	// run
	var r0 pgtypes.PgMcvList
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.PgMcvList{}, logerror(err)
	}
	return r0, nil
}

// PgMcvListSend calls the stored function 'pg_catalog.pg_mcv_list_send(pg_mcv_list) bytea' on db.
func PgMcvListSend(ctx context.Context, db DB, p0 pgtypes.PgMcvList) ([]byte, error) {
	// call pg_catalog.pg_mcv_list_send
	const sqlstr = `SELECT * FROM pg_catalog.pg_mcv_list_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgMyTempSchema calls the stored function 'pg_catalog.pg_my_temp_schema() oid' on db.
func PgMyTempSchema(ctx context.Context, db DB) (pgtypes.Oid, error) {
	// call pg_catalog.pg_my_temp_schema
	const sqlstr = `SELECT * FROM pg_catalog.pg_my_temp_schema()`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// PgNdistinctRecv calls the stored function 'pg_catalog.pg_ndistinct_recv(internal) pg_ndistinct' on db.
func PgNdistinctRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.PgNdistinct, error) {
	// call pg_catalog.pg_ndistinct_recv
	const sqlstr = `SELECT * FROM pg_catalog.pg_ndistinct_recv($1)`
	// run
	var r0 pgtypes.PgNdistinct
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.PgNdistinct{}, logerror(err)
	}
	return r0, nil
}

// PgNdistinctSend calls the stored function 'pg_catalog.pg_ndistinct_send(pg_ndistinct) bytea' on db.
func PgNdistinctSend(ctx context.Context, db DB, p0 pgtypes.PgNdistinct) ([]byte, error) {
	// call pg_catalog.pg_ndistinct_send
	const sqlstr = `SELECT * FROM pg_catalog.pg_ndistinct_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgNextoid calls the stored function 'pg_catalog.pg_nextoid(regclass, name, regclass) oid' on db.
func PgNextoid(ctx context.Context, db DB, p0 pgtypes.Regclass, p1 string, p2 pgtypes.Regclass) (pgtypes.Oid, error) {
	// call pg_catalog.pg_nextoid
	const sqlstr = `SELECT * FROM pg_catalog.pg_nextoid($1, $2, $3)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// PgNodeTreeRecv calls the stored function 'pg_catalog.pg_node_tree_recv(internal) pg_node_tree' on db.
func PgNodeTreeRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.PgNodeTree, error) {
	// call pg_catalog.pg_node_tree_recv
	const sqlstr = `SELECT * FROM pg_catalog.pg_node_tree_recv($1)`
	// run
	var r0 pgtypes.PgNodeTree
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.PgNodeTree{}, logerror(err)
	}
	return r0, nil
}

// PgNodeTreeSend calls the stored function 'pg_catalog.pg_node_tree_send(pg_node_tree) bytea' on db.
func PgNodeTreeSend(ctx context.Context, db DB, p0 pgtypes.PgNodeTree) ([]byte, error) {
	// call pg_catalog.pg_node_tree_send
	const sqlstr = `SELECT * FROM pg_catalog.pg_node_tree_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgNotificationQueueUsage calls the stored function 'pg_catalog.pg_notification_queue_usage() double precision' on db.
func PgNotificationQueueUsage(ctx context.Context, db DB) (float64, error) {
	// call pg_catalog.pg_notification_queue_usage
	const sqlstr = `SELECT * FROM pg_catalog.pg_notification_queue_usage()`
	// run
	var r0 float64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PgNotify calls the stored function 'pg_catalog.pg_notify(text, text)' on db.
func PgNotify(ctx context.Context, db DB, p0, p1 string) error {
	// call pg_catalog.pg_notify
	const sqlstr = `SELECT * FROM pg_catalog.pg_notify($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// PgOpclassIsVisible calls the stored function 'pg_catalog.pg_opclass_is_visible(oid) boolean' on db.
func PgOpclassIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_opclass_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_opclass_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgOperatorIsVisible calls the stored function 'pg_catalog.pg_operator_is_visible(oid) boolean' on db.
func PgOperatorIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_operator_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_operator_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgOpfamilyIsVisible calls the stored function 'pg_catalog.pg_opfamily_is_visible(oid) boolean' on db.
func PgOpfamilyIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_opfamily_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_opfamily_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgOptionsToTable calls the stored function 'pg_catalog.pg_options_to_table(text) (text, text)' on db.
func PgOptionsToTable(ctx context.Context, db DB, optionsArray StringSlice) (string, string, error) {
	// call pg_catalog.pg_options_to_table
	const sqlstr = `SELECT * FROM pg_catalog.pg_options_to_table($1)`
	// run
	var optionName string
	var optionValue string
	logf(sqlstr, optionsArray)
	if err := db.QueryRowContext(ctx, sqlstr, optionsArray).Scan(&optionName, &optionValue); err != nil {
		return "", "", logerror(err)
	}
	return optionName, optionValue, nil
}

// PgPartitionAncestors calls the stored function 'pg_catalog.pg_partition_ancestors(regclass) regclass' on db.
func PgPartitionAncestors(ctx context.Context, db DB, partitionid pgtypes.Regclass) (pgtypes.Regclass, error) {
	// call pg_catalog.pg_partition_ancestors
	const sqlstr = `SELECT * FROM pg_catalog.pg_partition_ancestors($1)`
	// run
	var relid pgtypes.Regclass
	logf(sqlstr, partitionid)
	if err := db.QueryRowContext(ctx, sqlstr, partitionid).Scan(&relid); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return relid, nil
}

// PgPartitionRoot calls the stored function 'pg_catalog.pg_partition_root(regclass) regclass' on db.
func PgPartitionRoot(ctx context.Context, db DB, p0 pgtypes.Regclass) (pgtypes.Regclass, error) {
	// call pg_catalog.pg_partition_root
	const sqlstr = `SELECT * FROM pg_catalog.pg_partition_root($1)`
	// run
	var r0 pgtypes.Regclass
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return r0, nil
}

// PgPartitionTree calls the stored function 'pg_catalog.pg_partition_tree(regclass) (regclass, regclass, boolean, integer)' on db.
func PgPartitionTree(ctx context.Context, db DB, rootrelid pgtypes.Regclass) (pgtypes.Regclass, pgtypes.Regclass, bool, int, error) {
	// call pg_catalog.pg_partition_tree
	const sqlstr = `SELECT * FROM pg_catalog.pg_partition_tree($1)`
	// run
	var relid pgtypes.Regclass
	var parentrelid pgtypes.Regclass
	var isleaf bool
	var level int
	logf(sqlstr, rootrelid)
	if err := db.QueryRowContext(ctx, sqlstr, rootrelid).Scan(&relid, &parentrelid, &isleaf, &level); err != nil {
		return pgtypes.Regclass{}, pgtypes.Regclass{}, false, 0, logerror(err)
	}
	return relid, parentrelid, isleaf, level, nil
}

// PgPostmasterStartTime calls the stored function 'pg_catalog.pg_postmaster_start_time() timestamp with time zone' on db.
func PgPostmasterStartTime(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_postmaster_start_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_postmaster_start_time()`
	// run
	var r0 time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgPreparedStatement calls the stored function 'pg_catalog.pg_prepared_statement() (text, text, timestamp with time zone, regtype, boolean)' on db.
func PgPreparedStatement(ctx context.Context, db DB) (string, string, time.Time, []pgtypes.Regtype, bool, error) {
	// call pg_catalog.pg_prepared_statement
	const sqlstr = `SELECT * FROM pg_catalog.pg_prepared_statement()`
	// run
	var name string
	var statement string
	var prepareTime time.Time
	var parameterTypes []pgtypes.Regtype
	var fromSQL bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &statement, &prepareTime, &parameterTypes, &fromSQL); err != nil {
		return "", "", time.Time{}, nil, false, logerror(err)
	}
	return name, statement, prepareTime, parameterTypes, fromSQL, nil
}

// PgPreparedXact calls the stored function 'pg_catalog.pg_prepared_xact() (xid, text, timestamp with time zone, oid, oid)' on db.
func PgPreparedXact(ctx context.Context, db DB) (pgtypes.Xid, string, time.Time, pgtypes.Oid, pgtypes.Oid, error) {
	// call pg_catalog.pg_prepared_xact
	const sqlstr = `SELECT * FROM pg_catalog.pg_prepared_xact()`
	// run
	var transaction pgtypes.Xid
	var gid string
	var prepared time.Time
	var ownerid pgtypes.Oid
	var dbid pgtypes.Oid
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&transaction, &gid, &prepared, &ownerid, &dbid); err != nil {
		return pgtypes.Xid{}, "", time.Time{}, pgtypes.Oid{}, pgtypes.Oid{}, logerror(err)
	}
	return transaction, gid, prepared, ownerid, dbid, nil
}

// PgPromote calls the stored function 'pg_catalog.pg_promote(boolean, integer) boolean' on db.
func PgPromote(ctx context.Context, db DB, wait bool, waitSeconds int) (bool, error) {
	// call pg_catalog.pg_promote
	const sqlstr = `SELECT * FROM pg_catalog.pg_promote($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, wait, waitSeconds)
	if err := db.QueryRowContext(ctx, sqlstr, wait, waitSeconds).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgReadBinaryFileByTextBigintBigintAndBoolean calls the stored function 'pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean) bytea' on db.
func PgReadBinaryFileByTextBigintBigintAndBoolean(ctx context.Context, db DB, p0 string, p1, p2 int64, p3 bool) ([]byte, error) {
	// call pg_catalog.pg_read_binary_file
	const sqlstr = `SELECT * FROM pg_catalog.pg_read_binary_file($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgReadBinaryFileByTextBigintAndBigint calls the stored function 'pg_catalog.pg_read_binary_file(text, bigint, bigint) bytea' on db.
func PgReadBinaryFileByTextBigintAndBigint(ctx context.Context, db DB, p0 string, p1, p2 int64) ([]byte, error) {
	// call pg_catalog.pg_read_binary_file
	const sqlstr = `SELECT * FROM pg_catalog.pg_read_binary_file($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgReadBinaryFileByText calls the stored function 'pg_catalog.pg_read_binary_file(text) bytea' on db.
func PgReadBinaryFileByText(ctx context.Context, db DB, p0 string) ([]byte, error) {
	// call pg_catalog.pg_read_binary_file
	const sqlstr = `SELECT * FROM pg_catalog.pg_read_binary_file($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgReadFileByTextBigintAndBigint calls the stored function 'pg_catalog.pg_read_file(text, bigint, bigint) text' on db.
func PgReadFileByTextBigintAndBigint(ctx context.Context, db DB, p0 string, p1, p2 int64) (string, error) {
	// call pg_catalog.pg_read_file
	const sqlstr = `SELECT * FROM pg_catalog.pg_read_file($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgReadFileByTextBigintBigintAndBoolean calls the stored function 'pg_catalog.pg_read_file(text, bigint, bigint, boolean) text' on db.
func PgReadFileByTextBigintBigintAndBoolean(ctx context.Context, db DB, p0 string, p1, p2 int64, p3 bool) (string, error) {
	// call pg_catalog.pg_read_file
	const sqlstr = `SELECT * FROM pg_catalog.pg_read_file($1, $2, $3, $4)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgReadFileByText calls the stored function 'pg_catalog.pg_read_file(text) text' on db.
func PgReadFileByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.pg_read_file
	const sqlstr = `SELECT * FROM pg_catalog.pg_read_file($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgReadFileOld calls the stored function 'pg_catalog.pg_read_file_old(text, bigint, bigint) text' on db.
func PgReadFileOld(ctx context.Context, db DB, p0 string, p1, p2 int64) (string, error) {
	// call pg_catalog.pg_read_file_old
	const sqlstr = `SELECT * FROM pg_catalog.pg_read_file_old($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgRelationFilenode calls the stored function 'pg_catalog.pg_relation_filenode(regclass) oid' on db.
func PgRelationFilenode(ctx context.Context, db DB, p0 pgtypes.Regclass) (pgtypes.Oid, error) {
	// call pg_catalog.pg_relation_filenode
	const sqlstr = `SELECT * FROM pg_catalog.pg_relation_filenode($1)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// PgRelationFilepath calls the stored function 'pg_catalog.pg_relation_filepath(regclass) text' on db.
func PgRelationFilepath(ctx context.Context, db DB, p0 pgtypes.Regclass) (string, error) {
	// call pg_catalog.pg_relation_filepath
	const sqlstr = `SELECT * FROM pg_catalog.pg_relation_filepath($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgRelationIsPublishable calls the stored function 'pg_catalog.pg_relation_is_publishable(regclass) boolean' on db.
func PgRelationIsPublishable(ctx context.Context, db DB, p0 pgtypes.Regclass) (bool, error) {
	// call pg_catalog.pg_relation_is_publishable
	const sqlstr = `SELECT * FROM pg_catalog.pg_relation_is_publishable($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgRelationIsUpdatable calls the stored function 'pg_catalog.pg_relation_is_updatable(regclass, boolean) integer' on db.
func PgRelationIsUpdatable(ctx context.Context, db DB, p0 pgtypes.Regclass, p1 bool) (int, error) {
	// call pg_catalog.pg_relation_is_updatable
	const sqlstr = `SELECT * FROM pg_catalog.pg_relation_is_updatable($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgRelationSizeByRegclass calls the stored function 'pg_catalog.pg_relation_size(regclass) bigint' on db.
func PgRelationSizeByRegclass(ctx context.Context, db DB, p0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.pg_relation_size
	const sqlstr = `SELECT * FROM pg_catalog.pg_relation_size($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgRelationSizeByRegclassAndText calls the stored function 'pg_catalog.pg_relation_size(regclass, text) bigint' on db.
func PgRelationSizeByRegclassAndText(ctx context.Context, db DB, p0 pgtypes.Regclass, p1 string) (int64, error) {
	// call pg_catalog.pg_relation_size
	const sqlstr = `SELECT * FROM pg_catalog.pg_relation_size($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgReloadConf calls the stored function 'pg_catalog.pg_reload_conf() boolean' on db.
func PgReloadConf(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_reload_conf
	const sqlstr = `SELECT * FROM pg_catalog.pg_reload_conf()`
	// run
	var r0 bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgReplicationOriginAdvance calls the stored function 'pg_catalog.pg_replication_origin_advance(text, pg_lsn)' on db.
func PgReplicationOriginAdvance(ctx context.Context, db DB, p0 string, p1 pgtypes.PgLsn) error {
	// call pg_catalog.pg_replication_origin_advance
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_origin_advance($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationOriginCreate calls the stored function 'pg_catalog.pg_replication_origin_create(text) oid' on db.
func PgReplicationOriginCreate(ctx context.Context, db DB, p0 string) (pgtypes.Oid, error) {
	// call pg_catalog.pg_replication_origin_create
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_origin_create($1)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// PgReplicationOriginDrop calls the stored function 'pg_catalog.pg_replication_origin_drop(text)' on db.
func PgReplicationOriginDrop(ctx context.Context, db DB, p0 string) error {
	// call pg_catalog.pg_replication_origin_drop
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_origin_drop($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationOriginOid calls the stored function 'pg_catalog.pg_replication_origin_oid(text) oid' on db.
func PgReplicationOriginOid(ctx context.Context, db DB, p0 string) (pgtypes.Oid, error) {
	// call pg_catalog.pg_replication_origin_oid
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_origin_oid($1)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// PgReplicationOriginProgress calls the stored function 'pg_catalog.pg_replication_origin_progress(text, boolean) pg_lsn' on db.
func PgReplicationOriginProgress(ctx context.Context, db DB, p0 string, p1 bool) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_replication_origin_progress
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_origin_progress($1, $2)`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgReplicationOriginSessionIsSetup calls the stored function 'pg_catalog.pg_replication_origin_session_is_setup() boolean' on db.
func PgReplicationOriginSessionIsSetup(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_replication_origin_session_is_setup
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_origin_session_is_setup()`
	// run
	var r0 bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgReplicationOriginSessionProgress calls the stored function 'pg_catalog.pg_replication_origin_session_progress(boolean) pg_lsn' on db.
func PgReplicationOriginSessionProgress(ctx context.Context, db DB, p0 bool) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_replication_origin_session_progress
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_origin_session_progress($1)`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgReplicationOriginSessionReset calls the stored function 'pg_catalog.pg_replication_origin_session_reset()' on db.
func PgReplicationOriginSessionReset(ctx context.Context, db DB) error {
	// call pg_catalog.pg_replication_origin_session_reset
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_origin_session_reset()`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationOriginSessionSetup calls the stored function 'pg_catalog.pg_replication_origin_session_setup(text)' on db.
func PgReplicationOriginSessionSetup(ctx context.Context, db DB, p0 string) error {
	// call pg_catalog.pg_replication_origin_session_setup
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_origin_session_setup($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationOriginXactReset calls the stored function 'pg_catalog.pg_replication_origin_xact_reset()' on db.
func PgReplicationOriginXactReset(ctx context.Context, db DB) error {
	// call pg_catalog.pg_replication_origin_xact_reset
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_origin_xact_reset()`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationOriginXactSetup calls the stored function 'pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone)' on db.
func PgReplicationOriginXactSetup(ctx context.Context, db DB, p0 pgtypes.PgLsn, p1 time.Time) error {
	// call pg_catalog.pg_replication_origin_xact_setup
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_origin_xact_setup($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// PgReplicationSlotAdvance calls the stored function 'pg_catalog.pg_replication_slot_advance(name, pg_lsn) (name, pg_lsn)' on db.
func PgReplicationSlotAdvance(ctx context.Context, db DB, slotName string, uptoLsn pgtypes.PgLsn) (string, pgtypes.PgLsn, error) {
	// call pg_catalog.pg_replication_slot_advance
	const sqlstr = `SELECT * FROM pg_catalog.pg_replication_slot_advance($1, $2)`
	// run
	var slotName string
	var endLsn pgtypes.PgLsn
	logf(sqlstr, slotName, uptoLsn)
	if err := db.QueryRowContext(ctx, sqlstr, slotName, uptoLsn).Scan(&slotName, &endLsn); err != nil {
		return "", pgtypes.PgLsn{}, logerror(err)
	}
	return slotName, endLsn, nil
}

// PgRotateLogfile calls the stored function 'pg_catalog.pg_rotate_logfile() boolean' on db.
func PgRotateLogfile(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_rotate_logfile
	const sqlstr = `SELECT * FROM pg_catalog.pg_rotate_logfile()`
	// run
	var r0 bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgRotateLogfileOld calls the stored function 'pg_catalog.pg_rotate_logfile_old() boolean' on db.
func PgRotateLogfileOld(ctx context.Context, db DB) (bool, error) {
	// call pg_catalog.pg_rotate_logfile_old
	const sqlstr = `SELECT * FROM pg_catalog.pg_rotate_logfile_old()`
	// run
	var r0 bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgSafeSnapshotBlockingPids calls the stored function 'pg_catalog.pg_safe_snapshot_blocking_pids(integer) integer' on db.
func PgSafeSnapshotBlockingPids(ctx context.Context, db DB, p0 int) ([]int, error) {
	// call pg_catalog.pg_safe_snapshot_blocking_pids
	const sqlstr = `SELECT * FROM pg_catalog.pg_safe_snapshot_blocking_pids($1)`
	// run
	var r0 []int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgSequenceLastValue calls the stored function 'pg_catalog.pg_sequence_last_value(regclass) bigint' on db.
func PgSequenceLastValue(ctx context.Context, db DB, p0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.pg_sequence_last_value
	const sqlstr = `SELECT * FROM pg_catalog.pg_sequence_last_value($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgSequenceParameters calls the stored function 'pg_catalog.pg_sequence_parameters(oid) (bigint, bigint, bigint, bigint, boolean, bigint, oid)' on db.
func PgSequenceParameters(ctx context.Context, db DB, sequenceOid pgtypes.Oid) (int64, int64, int64, int64, bool, int64, pgtypes.Oid, error) {
	// call pg_catalog.pg_sequence_parameters
	const sqlstr = `SELECT * FROM pg_catalog.pg_sequence_parameters($1)`
	// run
	var startValue int64
	var minimumValue int64
	var maximumValue int64
	var increment int64
	var cycleOption bool
	var cacheSize int64
	var dataType pgtypes.Oid
	logf(sqlstr, sequenceOid)
	if err := db.QueryRowContext(ctx, sqlstr, sequenceOid).Scan(&startValue, &minimumValue, &maximumValue, &increment, &cycleOption, &cacheSize, &dataType); err != nil {
		return 0, 0, 0, 0, false, 0, pgtypes.Oid{}, logerror(err)
	}
	return startValue, minimumValue, maximumValue, increment, cycleOption, cacheSize, dataType, nil
}

// PgShowAllFileSettings calls the stored function 'pg_catalog.pg_show_all_file_settings() (text, integer, integer, text, text, boolean, text)' on db.
func PgShowAllFileSettings(ctx context.Context, db DB) (string, int, int, string, string, bool, string, error) {
	// call pg_catalog.pg_show_all_file_settings
	const sqlstr = `SELECT * FROM pg_catalog.pg_show_all_file_settings()`
	// run
	var sourcefile string
	var sourceline int
	var seqno int
	var name string
	var setting string
	var applied bool
	var e string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&sourcefile, &sourceline, &seqno, &name, &setting, &applied, &e); err != nil {
		return "", 0, 0, "", "", false, "", logerror(err)
	}
	return sourcefile, sourceline, seqno, name, setting, applied, e, nil
}

// PgShowAllSettings calls the stored function 'pg_catalog.pg_show_all_settings() (text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, integer, boolean)' on db.
func PgShowAllSettings(ctx context.Context, db DB) (string, string, string, string, string, string, string, string, string, string, string, StringSlice, string, string, string, int, bool, error) {
	// call pg_catalog.pg_show_all_settings
	const sqlstr = `SELECT * FROM pg_catalog.pg_show_all_settings()`
	// run
	var name string
	var setting string
	var unit string
	var category string
	var shortDesc string
	var extraDesc string
	var context string
	var vartype string
	var source string
	var minVal string
	var maxVal string
	var enumvals StringSlice
	var bootVal string
	var resetVal string
	var sourcefile string
	var sourceline int
	var pendingRestart bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &setting, &unit, &category, &shortDesc, &extraDesc, &context, &vartype, &source, &minVal, &maxVal, &enumvals, &bootVal, &resetVal, &sourcefile, &sourceline, &pendingRestart); err != nil {
		return "", "", "", "", "", "", "", "", "", "", "", StringSlice{}, "", "", "", 0, false, logerror(err)
	}
	return name, setting, unit, category, shortDesc, extraDesc, context, vartype, source, minVal, maxVal, enumvals, bootVal, resetVal, sourcefile, sourceline, pendingRestart, nil
}

// PgShowReplicationOriginStatus calls the stored function 'pg_catalog.pg_show_replication_origin_status() (oid, text, pg_lsn, pg_lsn)' on db.
func PgShowReplicationOriginStatus(ctx context.Context, db DB) (pgtypes.Oid, string, pgtypes.PgLsn, pgtypes.PgLsn, error) {
	// call pg_catalog.pg_show_replication_origin_status
	const sqlstr = `SELECT * FROM pg_catalog.pg_show_replication_origin_status()`
	// run
	var localID pgtypes.Oid
	var externalID string
	var remoteLsn pgtypes.PgLsn
	var localLsn pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&localID, &externalID, &remoteLsn, &localLsn); err != nil {
		return pgtypes.Oid{}, "", pgtypes.PgLsn{}, pgtypes.PgLsn{}, logerror(err)
	}
	return localID, externalID, remoteLsn, localLsn, nil
}

// PgSizeBytes calls the stored function 'pg_catalog.pg_size_bytes(text) bigint' on db.
func PgSizeBytes(ctx context.Context, db DB, p0 string) (int64, error) {
	// call pg_catalog.pg_size_bytes
	const sqlstr = `SELECT * FROM pg_catalog.pg_size_bytes($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgSizePrettyByBigint calls the stored function 'pg_catalog.pg_size_pretty(bigint) text' on db.
func PgSizePrettyByBigint(ctx context.Context, db DB, p0 int64) (string, error) {
	// call pg_catalog.pg_size_pretty
	const sqlstr = `SELECT * FROM pg_catalog.pg_size_pretty($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgSizePrettyByNumeric calls the stored function 'pg_catalog.pg_size_pretty(numeric) text' on db.
func PgSizePrettyByNumeric(ctx context.Context, db DB, p0 float64) (string, error) {
	// call pg_catalog.pg_size_pretty
	const sqlstr = `SELECT * FROM pg_catalog.pg_size_pretty($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgSleep calls the stored function 'pg_catalog.pg_sleep(double precision)' on db.
func PgSleep(ctx context.Context, db DB, p0 float64) error {
	// call pg_catalog.pg_sleep
	const sqlstr = `SELECT * FROM pg_catalog.pg_sleep($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgSleepFor calls the stored function 'pg_catalog.pg_sleep_for(interval)' on db.
func PgSleepFor(ctx context.Context, db DB, p0 []byte) error {
	// call pg_catalog.pg_sleep_for
	const sqlstr = `SELECT * FROM pg_catalog.pg_sleep_for($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgSleepUntil calls the stored function 'pg_catalog.pg_sleep_until(timestamp with time zone)' on db.
func PgSleepUntil(ctx context.Context, db DB, p0 time.Time) error {
	// call pg_catalog.pg_sleep_until
	const sqlstr = `SELECT * FROM pg_catalog.pg_sleep_until($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgSnapshotRecv calls the stored function 'pg_catalog.pg_snapshot_recv(internal) pg_snapshot' on db.
func PgSnapshotRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.PgSnapshot, error) {
	// call pg_catalog.pg_snapshot_recv
	const sqlstr = `SELECT * FROM pg_catalog.pg_snapshot_recv($1)`
	// run
	var r0 pgtypes.PgSnapshot
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.PgSnapshot{}, logerror(err)
	}
	return r0, nil
}

// PgSnapshotSend calls the stored function 'pg_catalog.pg_snapshot_send(pg_snapshot) bytea' on db.
func PgSnapshotSend(ctx context.Context, db DB, p0 pgtypes.PgSnapshot) ([]byte, error) {
	// call pg_catalog.pg_snapshot_send
	const sqlstr = `SELECT * FROM pg_catalog.pg_snapshot_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PgSnapshotXip calls the stored function 'pg_catalog.pg_snapshot_xip(pg_snapshot) xid8' on db.
func PgSnapshotXip(ctx context.Context, db DB, p0 pgtypes.PgSnapshot) (pgtypes.Xid8, error) {
	// call pg_catalog.pg_snapshot_xip
	const sqlstr = `SELECT * FROM pg_catalog.pg_snapshot_xip($1)`
	// run
	var r0 pgtypes.Xid8
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return r0, nil
}

// PgSnapshotXmax calls the stored function 'pg_catalog.pg_snapshot_xmax(pg_snapshot) xid8' on db.
func PgSnapshotXmax(ctx context.Context, db DB, p0 pgtypes.PgSnapshot) (pgtypes.Xid8, error) {
	// call pg_catalog.pg_snapshot_xmax
	const sqlstr = `SELECT * FROM pg_catalog.pg_snapshot_xmax($1)`
	// run
	var r0 pgtypes.Xid8
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return r0, nil
}

// PgSnapshotXmin calls the stored function 'pg_catalog.pg_snapshot_xmin(pg_snapshot) xid8' on db.
func PgSnapshotXmin(ctx context.Context, db DB, p0 pgtypes.PgSnapshot) (pgtypes.Xid8, error) {
	// call pg_catalog.pg_snapshot_xmin
	const sqlstr = `SELECT * FROM pg_catalog.pg_snapshot_xmin($1)`
	// run
	var r0 pgtypes.Xid8
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return r0, nil
}

// PgStartBackup calls the stored function 'pg_catalog.pg_start_backup(text, boolean, boolean) pg_lsn' on db.
func PgStartBackup(ctx context.Context, db DB, label string, fast, exclusive bool) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_start_backup
	const sqlstr = `SELECT * FROM pg_catalog.pg_start_backup($1, $2, $3)`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr, label, fast, exclusive)
	if err := db.QueryRowContext(ctx, sqlstr, label, fast, exclusive).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgStatClearSnapshot calls the stored function 'pg_catalog.pg_stat_clear_snapshot()' on db.
func PgStatClearSnapshot(ctx context.Context, db DB) error {
	// call pg_catalog.pg_stat_clear_snapshot
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_clear_snapshot()`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatFileByFilename calls the stored function 'pg_catalog.pg_stat_file(text) (bigint, timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone, boolean)' on db.
func PgStatFileByFilename(ctx context.Context, db DB, filename string) (int64, time.Time, time.Time, time.Time, time.Time, bool, error) {
	// call pg_catalog.pg_stat_file
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_file($1)`
	// run
	var size int64
	var access time.Time
	var modification time.Time
	var change time.Time
	var creation time.Time
	var isdir bool
	logf(sqlstr, filename)
	if err := db.QueryRowContext(ctx, sqlstr, filename).Scan(&size, &access, &modification, &change, &creation, &isdir); err != nil {
		return 0, time.Time{}, time.Time{}, time.Time{}, time.Time{}, false, logerror(err)
	}
	return size, access, modification, change, creation, isdir, nil
}

// PgStatFileByFilenameAndMissingOk calls the stored function 'pg_catalog.pg_stat_file(text, boolean) (bigint, timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone, boolean)' on db.
func PgStatFileByFilenameAndMissingOk(ctx context.Context, db DB, filename string, missingOk bool) (int64, time.Time, time.Time, time.Time, time.Time, bool, error) {
	// call pg_catalog.pg_stat_file
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_file($1, $2)`
	// run
	var size int64
	var access time.Time
	var modification time.Time
	var change time.Time
	var creation time.Time
	var isdir bool
	logf(sqlstr, filename, missingOk)
	if err := db.QueryRowContext(ctx, sqlstr, filename, missingOk).Scan(&size, &access, &modification, &change, &creation, &isdir); err != nil {
		return 0, time.Time{}, time.Time{}, time.Time{}, time.Time{}, false, logerror(err)
	}
	return size, access, modification, change, creation, isdir, nil
}

// PgStatGetActivity calls the stored function 'pg_catalog.pg_stat_get_activity(integer) (oid, integer, oid, text, text, text, text, text, timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone, inet, text, integer, xid, xid, text, boolean, text, text, integer, boolean, text, numeric, text, boolean, text, boolean, integer)' on db.
func PgStatGetActivity(ctx context.Context, db DB, pid int) (pgtypes.Oid, int, pgtypes.Oid, string, string, string, string, string, time.Time, time.Time, time.Time, time.Time, string, string, int, pgtypes.Xid, pgtypes.Xid, string, bool, string, string, int, bool, string, float64, string, bool, string, bool, int, error) {
	// call pg_catalog.pg_stat_get_activity
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_activity($1)`
	// run
	var datid pgtypes.Oid
	var pid int
	var usesysid pgtypes.Oid
	var applicationName string
	var state string
	var query string
	var waitEventType string
	var waitEvent string
	var xactStart time.Time
	var queryStart time.Time
	var backendStart time.Time
	var stateChange time.Time
	var clientAddr string
	var clientHostname string
	var clientPort int
	var backendXid pgtypes.Xid
	var backendXmin pgtypes.Xid
	var backendType string
	var ssl bool
	var sslversion string
	var sslcipher string
	var sslbits int
	var sslcompression bool
	var sslClientDn string
	var sslClientSerial float64
	var sslIssuerDn string
	var gssAuth bool
	var gssPrinc string
	var gssEnc bool
	var leaderPid int
	logf(sqlstr, pid)
	if err := db.QueryRowContext(ctx, sqlstr, pid).Scan(&datid, &pid, &usesysid, &applicationName, &state, &query, &waitEventType, &waitEvent, &xactStart, &queryStart, &backendStart, &stateChange, &clientAddr, &clientHostname, &clientPort, &backendXid, &backendXmin, &backendType, &ssl, &sslversion, &sslcipher, &sslbits, &sslcompression, &sslClientDn, &sslClientSerial, &sslIssuerDn, &gssAuth, &gssPrinc, &gssEnc, &leaderPid); err != nil {
		return pgtypes.Oid{}, 0, pgtypes.Oid{}, "", "", "", "", "", time.Time{}, time.Time{}, time.Time{}, time.Time{}, "", "", 0, pgtypes.Xid{}, pgtypes.Xid{}, "", false, "", "", 0, false, "", 0.0, "", false, "", false, 0, logerror(err)
	}
	return datid, pid, usesysid, applicationName, state, query, waitEventType, waitEvent, xactStart, queryStart, backendStart, stateChange, clientAddr, clientHostname, clientPort, backendXid, backendXmin, backendType, ssl, sslversion, sslcipher, sslbits, sslcompression, sslClientDn, sslClientSerial, sslIssuerDn, gssAuth, gssPrinc, gssEnc, leaderPid, nil
}

// PgStatGetAnalyzeCount calls the stored function 'pg_catalog.pg_stat_get_analyze_count(oid) bigint' on db.
func PgStatGetAnalyzeCount(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_analyze_count
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_analyze_count($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetArchiver calls the stored function 'pg_catalog.pg_stat_get_archiver() (bigint, text, timestamp with time zone, bigint, text, timestamp with time zone, timestamp with time zone)' on db.
func PgStatGetArchiver(ctx context.Context, db DB) (int64, string, time.Time, int64, string, time.Time, time.Time, error) {
	// call pg_catalog.pg_stat_get_archiver
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_archiver()`
	// run
	var archivedCount int64
	var lastArchivedWal string
	var lastArchivedTime time.Time
	var failedCount int64
	var lastFailedWal string
	var lastFailedTime time.Time
	var statsReset time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&archivedCount, &lastArchivedWal, &lastArchivedTime, &failedCount, &lastFailedWal, &lastFailedTime, &statsReset); err != nil {
		return 0, "", time.Time{}, 0, "", time.Time{}, time.Time{}, logerror(err)
	}
	return archivedCount, lastArchivedWal, lastArchivedTime, failedCount, lastFailedWal, lastFailedTime, statsReset, nil
}

// PgStatGetAutoanalyzeCount calls the stored function 'pg_catalog.pg_stat_get_autoanalyze_count(oid) bigint' on db.
func PgStatGetAutoanalyzeCount(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_autoanalyze_count
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_autoanalyze_count($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetAutovacuumCount calls the stored function 'pg_catalog.pg_stat_get_autovacuum_count(oid) bigint' on db.
func PgStatGetAutovacuumCount(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_autovacuum_count
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_autovacuum_count($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendActivity calls the stored function 'pg_catalog.pg_stat_get_backend_activity(integer) text' on db.
func PgStatGetBackendActivity(ctx context.Context, db DB, p0 int) (string, error) {
	// call pg_catalog.pg_stat_get_backend_activity
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_activity($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendActivityStart calls the stored function 'pg_catalog.pg_stat_get_backend_activity_start(integer) timestamp with time zone' on db.
func PgStatGetBackendActivityStart(ctx context.Context, db DB, p0 int) (time.Time, error) {
	// call pg_catalog.pg_stat_get_backend_activity_start
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_activity_start($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendClientAddr calls the stored function 'pg_catalog.pg_stat_get_backend_client_addr(integer) inet' on db.
func PgStatGetBackendClientAddr(ctx context.Context, db DB, p0 int) (string, error) {
	// call pg_catalog.pg_stat_get_backend_client_addr
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_client_addr($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendClientPort calls the stored function 'pg_catalog.pg_stat_get_backend_client_port(integer) integer' on db.
func PgStatGetBackendClientPort(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.pg_stat_get_backend_client_port
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_client_port($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendDbid calls the stored function 'pg_catalog.pg_stat_get_backend_dbid(integer) oid' on db.
func PgStatGetBackendDbid(ctx context.Context, db DB, p0 int) (pgtypes.Oid, error) {
	// call pg_catalog.pg_stat_get_backend_dbid
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_dbid($1)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendIdset calls the stored function 'pg_catalog.pg_stat_get_backend_idset() integer' on db.
func PgStatGetBackendIdset(ctx context.Context, db DB) (int, error) {
	// call pg_catalog.pg_stat_get_backend_idset
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_idset()`
	// run
	var r0 int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendPid calls the stored function 'pg_catalog.pg_stat_get_backend_pid(integer) integer' on db.
func PgStatGetBackendPid(ctx context.Context, db DB, p0 int) (int, error) {
	// call pg_catalog.pg_stat_get_backend_pid
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_pid($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendStart calls the stored function 'pg_catalog.pg_stat_get_backend_start(integer) timestamp with time zone' on db.
func PgStatGetBackendStart(ctx context.Context, db DB, p0 int) (time.Time, error) {
	// call pg_catalog.pg_stat_get_backend_start
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_start($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendUserid calls the stored function 'pg_catalog.pg_stat_get_backend_userid(integer) oid' on db.
func PgStatGetBackendUserid(ctx context.Context, db DB, p0 int) (pgtypes.Oid, error) {
	// call pg_catalog.pg_stat_get_backend_userid
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_userid($1)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendWaitEvent calls the stored function 'pg_catalog.pg_stat_get_backend_wait_event(integer) text' on db.
func PgStatGetBackendWaitEvent(ctx context.Context, db DB, p0 int) (string, error) {
	// call pg_catalog.pg_stat_get_backend_wait_event
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_wait_event($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendWaitEventType calls the stored function 'pg_catalog.pg_stat_get_backend_wait_event_type(integer) text' on db.
func PgStatGetBackendWaitEventType(ctx context.Context, db DB, p0 int) (string, error) {
	// call pg_catalog.pg_stat_get_backend_wait_event_type
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_wait_event_type($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgStatGetBackendXactStart calls the stored function 'pg_catalog.pg_stat_get_backend_xact_start(integer) timestamp with time zone' on db.
func PgStatGetBackendXactStart(ctx context.Context, db DB, p0 int) (time.Time, error) {
	// call pg_catalog.pg_stat_get_backend_xact_start
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_backend_xact_start($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetBgwriterBufWrittenCheckpoints calls the stored function 'pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() bigint' on db.
func PgStatGetBgwriterBufWrittenCheckpoints(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints()`
	// run
	var r0 int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBgwriterBufWrittenClean calls the stored function 'pg_catalog.pg_stat_get_bgwriter_buf_written_clean() bigint' on db.
func PgStatGetBgwriterBufWrittenClean(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_bgwriter_buf_written_clean
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_bgwriter_buf_written_clean()`
	// run
	var r0 int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBgwriterMaxwrittenClean calls the stored function 'pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() bigint' on db.
func PgStatGetBgwriterMaxwrittenClean(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_bgwriter_maxwritten_clean
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_bgwriter_maxwritten_clean()`
	// run
	var r0 int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBgwriterRequestedCheckpoints calls the stored function 'pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() bigint' on db.
func PgStatGetBgwriterRequestedCheckpoints(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_bgwriter_requested_checkpoints
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_bgwriter_requested_checkpoints()`
	// run
	var r0 int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBgwriterStatResetTime calls the stored function 'pg_catalog.pg_stat_get_bgwriter_stat_reset_time() timestamp with time zone' on db.
func PgStatGetBgwriterStatResetTime(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_stat_get_bgwriter_stat_reset_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_bgwriter_stat_reset_time()`
	// run
	var r0 time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetBgwriterTimedCheckpoints calls the stored function 'pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() bigint' on db.
func PgStatGetBgwriterTimedCheckpoints(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_bgwriter_timed_checkpoints
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_bgwriter_timed_checkpoints()`
	// run
	var r0 int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBlocksFetched calls the stored function 'pg_catalog.pg_stat_get_blocks_fetched(oid) bigint' on db.
func PgStatGetBlocksFetched(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_blocks_fetched
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_blocks_fetched($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBlocksHit calls the stored function 'pg_catalog.pg_stat_get_blocks_hit(oid) bigint' on db.
func PgStatGetBlocksHit(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_blocks_hit
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_blocks_hit($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBufAlloc calls the stored function 'pg_catalog.pg_stat_get_buf_alloc() bigint' on db.
func PgStatGetBufAlloc(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_buf_alloc
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_buf_alloc()`
	// run
	var r0 int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBufFsyncBackend calls the stored function 'pg_catalog.pg_stat_get_buf_fsync_backend() bigint' on db.
func PgStatGetBufFsyncBackend(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_buf_fsync_backend
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_buf_fsync_backend()`
	// run
	var r0 int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetBufWrittenBackend calls the stored function 'pg_catalog.pg_stat_get_buf_written_backend() bigint' on db.
func PgStatGetBufWrittenBackend(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.pg_stat_get_buf_written_backend
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_buf_written_backend()`
	// run
	var r0 int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetCheckpointSyncTime calls the stored function 'pg_catalog.pg_stat_get_checkpoint_sync_time() double precision' on db.
func PgStatGetCheckpointSyncTime(ctx context.Context, db DB) (float64, error) {
	// call pg_catalog.pg_stat_get_checkpoint_sync_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_checkpoint_sync_time()`
	// run
	var r0 float64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PgStatGetCheckpointWriteTime calls the stored function 'pg_catalog.pg_stat_get_checkpoint_write_time() double precision' on db.
func PgStatGetCheckpointWriteTime(ctx context.Context, db DB) (float64, error) {
	// call pg_catalog.pg_stat_get_checkpoint_write_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_checkpoint_write_time()`
	// run
	var r0 float64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbBlkReadTime calls the stored function 'pg_catalog.pg_stat_get_db_blk_read_time(oid) double precision' on db.
func PgStatGetDbBlkReadTime(ctx context.Context, db DB, p0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_db_blk_read_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_blk_read_time($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbBlkWriteTime calls the stored function 'pg_catalog.pg_stat_get_db_blk_write_time(oid) double precision' on db.
func PgStatGetDbBlkWriteTime(ctx context.Context, db DB, p0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_db_blk_write_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_blk_write_time($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbBlocksFetched calls the stored function 'pg_catalog.pg_stat_get_db_blocks_fetched(oid) bigint' on db.
func PgStatGetDbBlocksFetched(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_blocks_fetched
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_blocks_fetched($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbBlocksHit calls the stored function 'pg_catalog.pg_stat_get_db_blocks_hit(oid) bigint' on db.
func PgStatGetDbBlocksHit(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_blocks_hit
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_blocks_hit($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbChecksumFailures calls the stored function 'pg_catalog.pg_stat_get_db_checksum_failures(oid) bigint' on db.
func PgStatGetDbChecksumFailures(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_checksum_failures
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_checksum_failures($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbChecksumLastFailure calls the stored function 'pg_catalog.pg_stat_get_db_checksum_last_failure(oid) timestamp with time zone' on db.
func PgStatGetDbChecksumLastFailure(ctx context.Context, db DB, p0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_db_checksum_last_failure
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_checksum_last_failure($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbConflictAll calls the stored function 'pg_catalog.pg_stat_get_db_conflict_all(oid) bigint' on db.
func PgStatGetDbConflictAll(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_all
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_conflict_all($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbConflictBufferpin calls the stored function 'pg_catalog.pg_stat_get_db_conflict_bufferpin(oid) bigint' on db.
func PgStatGetDbConflictBufferpin(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_bufferpin
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_conflict_bufferpin($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbConflictLock calls the stored function 'pg_catalog.pg_stat_get_db_conflict_lock(oid) bigint' on db.
func PgStatGetDbConflictLock(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_lock
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_conflict_lock($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbConflictSnapshot calls the stored function 'pg_catalog.pg_stat_get_db_conflict_snapshot(oid) bigint' on db.
func PgStatGetDbConflictSnapshot(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_snapshot
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_conflict_snapshot($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbConflictStartupDeadlock calls the stored function 'pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid) bigint' on db.
func PgStatGetDbConflictStartupDeadlock(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_startup_deadlock
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_conflict_startup_deadlock($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbConflictTablespace calls the stored function 'pg_catalog.pg_stat_get_db_conflict_tablespace(oid) bigint' on db.
func PgStatGetDbConflictTablespace(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_conflict_tablespace
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_conflict_tablespace($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbDeadlocks calls the stored function 'pg_catalog.pg_stat_get_db_deadlocks(oid) bigint' on db.
func PgStatGetDbDeadlocks(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_deadlocks
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_deadlocks($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbNumbackends calls the stored function 'pg_catalog.pg_stat_get_db_numbackends(oid) integer' on db.
func PgStatGetDbNumbackends(ctx context.Context, db DB, p0 pgtypes.Oid) (int, error) {
	// call pg_catalog.pg_stat_get_db_numbackends
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_numbackends($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbStatResetTime calls the stored function 'pg_catalog.pg_stat_get_db_stat_reset_time(oid) timestamp with time zone' on db.
func PgStatGetDbStatResetTime(ctx context.Context, db DB, p0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_db_stat_reset_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_stat_reset_time($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbTempBytes calls the stored function 'pg_catalog.pg_stat_get_db_temp_bytes(oid) bigint' on db.
func PgStatGetDbTempBytes(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_temp_bytes
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_temp_bytes($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbTempFiles calls the stored function 'pg_catalog.pg_stat_get_db_temp_files(oid) bigint' on db.
func PgStatGetDbTempFiles(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_temp_files
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_temp_files($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbTuplesDeleted calls the stored function 'pg_catalog.pg_stat_get_db_tuples_deleted(oid) bigint' on db.
func PgStatGetDbTuplesDeleted(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_tuples_deleted
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_tuples_deleted($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbTuplesFetched calls the stored function 'pg_catalog.pg_stat_get_db_tuples_fetched(oid) bigint' on db.
func PgStatGetDbTuplesFetched(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_tuples_fetched
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_tuples_fetched($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbTuplesInserted calls the stored function 'pg_catalog.pg_stat_get_db_tuples_inserted(oid) bigint' on db.
func PgStatGetDbTuplesInserted(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_tuples_inserted
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_tuples_inserted($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbTuplesReturned calls the stored function 'pg_catalog.pg_stat_get_db_tuples_returned(oid) bigint' on db.
func PgStatGetDbTuplesReturned(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_tuples_returned
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_tuples_returned($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbTuplesUpdated calls the stored function 'pg_catalog.pg_stat_get_db_tuples_updated(oid) bigint' on db.
func PgStatGetDbTuplesUpdated(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_tuples_updated
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_tuples_updated($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbXactCommit calls the stored function 'pg_catalog.pg_stat_get_db_xact_commit(oid) bigint' on db.
func PgStatGetDbXactCommit(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_xact_commit
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_xact_commit($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDbXactRollback calls the stored function 'pg_catalog.pg_stat_get_db_xact_rollback(oid) bigint' on db.
func PgStatGetDbXactRollback(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_db_xact_rollback
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_db_xact_rollback($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetDeadTuples calls the stored function 'pg_catalog.pg_stat_get_dead_tuples(oid) bigint' on db.
func PgStatGetDeadTuples(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_dead_tuples
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_dead_tuples($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetFunctionCalls calls the stored function 'pg_catalog.pg_stat_get_function_calls(oid) bigint' on db.
func PgStatGetFunctionCalls(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_function_calls
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_function_calls($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetFunctionSelfTime calls the stored function 'pg_catalog.pg_stat_get_function_self_time(oid) double precision' on db.
func PgStatGetFunctionSelfTime(ctx context.Context, db DB, p0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_function_self_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_function_self_time($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PgStatGetFunctionTotalTime calls the stored function 'pg_catalog.pg_stat_get_function_total_time(oid) double precision' on db.
func PgStatGetFunctionTotalTime(ctx context.Context, db DB, p0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_function_total_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_function_total_time($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PgStatGetInsSinceVacuum calls the stored function 'pg_catalog.pg_stat_get_ins_since_vacuum(oid) bigint' on db.
func PgStatGetInsSinceVacuum(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_ins_since_vacuum
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_ins_since_vacuum($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetLastAnalyzeTime calls the stored function 'pg_catalog.pg_stat_get_last_analyze_time(oid) timestamp with time zone' on db.
func PgStatGetLastAnalyzeTime(ctx context.Context, db DB, p0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_last_analyze_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_last_analyze_time($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetLastAutoanalyzeTime calls the stored function 'pg_catalog.pg_stat_get_last_autoanalyze_time(oid) timestamp with time zone' on db.
func PgStatGetLastAutoanalyzeTime(ctx context.Context, db DB, p0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_last_autoanalyze_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_last_autoanalyze_time($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetLastAutovacuumTime calls the stored function 'pg_catalog.pg_stat_get_last_autovacuum_time(oid) timestamp with time zone' on db.
func PgStatGetLastAutovacuumTime(ctx context.Context, db DB, p0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_last_autovacuum_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_last_autovacuum_time($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetLastVacuumTime calls the stored function 'pg_catalog.pg_stat_get_last_vacuum_time(oid) timestamp with time zone' on db.
func PgStatGetLastVacuumTime(ctx context.Context, db DB, p0 pgtypes.Oid) (time.Time, error) {
	// call pg_catalog.pg_stat_get_last_vacuum_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_last_vacuum_time($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetLiveTuples calls the stored function 'pg_catalog.pg_stat_get_live_tuples(oid) bigint' on db.
func PgStatGetLiveTuples(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_live_tuples
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_live_tuples($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetModSinceAnalyze calls the stored function 'pg_catalog.pg_stat_get_mod_since_analyze(oid) bigint' on db.
func PgStatGetModSinceAnalyze(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_mod_since_analyze
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_mod_since_analyze($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetNumscans calls the stored function 'pg_catalog.pg_stat_get_numscans(oid) bigint' on db.
func PgStatGetNumscans(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_numscans
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_numscans($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetProgressInfo calls the stored function 'pg_catalog.pg_stat_get_progress_info(text) (integer, oid, oid, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint)' on db.
func PgStatGetProgressInfo(ctx context.Context, db DB, cmdtype string) (int, pgtypes.Oid, pgtypes.Oid, int64, int64, int64, int64, int64, int64, int64, int64, int64, int64, int64, int64, int64, int64, int64, int64, int64, int64, int64, int64, error) {
	// call pg_catalog.pg_stat_get_progress_info
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_progress_info($1)`
	// run
	var pid int
	var datid pgtypes.Oid
	var relid pgtypes.Oid
	var param1 int64
	var param2 int64
	var param3 int64
	var param4 int64
	var param5 int64
	var param6 int64
	var param7 int64
	var param8 int64
	var param9 int64
	var param10 int64
	var param11 int64
	var param12 int64
	var param13 int64
	var param14 int64
	var param15 int64
	var param16 int64
	var param17 int64
	var param18 int64
	var param19 int64
	var param20 int64
	logf(sqlstr, cmdtype)
	if err := db.QueryRowContext(ctx, sqlstr, cmdtype).Scan(&pid, &datid, &relid, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, &param19, &param20); err != nil {
		return 0, pgtypes.Oid{}, pgtypes.Oid{}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, logerror(err)
	}
	return pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20, nil
}

// PgStatGetSlru calls the stored function 'pg_catalog.pg_stat_get_slru() (text, bigint, bigint, bigint, bigint, bigint, bigint, bigint, timestamp with time zone)' on db.
func PgStatGetSlru(ctx context.Context, db DB) (string, int64, int64, int64, int64, int64, int64, int64, time.Time, error) {
	// call pg_catalog.pg_stat_get_slru
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_slru()`
	// run
	var name string
	var blksZeroed int64
	var blksHit int64
	var blksRead int64
	var blksWritten int64
	var blksExists int64
	var flushes int64
	var truncates int64
	var statsReset time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &blksZeroed, &blksHit, &blksRead, &blksWritten, &blksExists, &flushes, &truncates, &statsReset); err != nil {
		return "", 0, 0, 0, 0, 0, 0, 0, time.Time{}, logerror(err)
	}
	return name, blksZeroed, blksHit, blksRead, blksWritten, blksExists, flushes, truncates, statsReset, nil
}

// PgStatGetSnapshotTimestamp calls the stored function 'pg_catalog.pg_stat_get_snapshot_timestamp() timestamp with time zone' on db.
func PgStatGetSnapshotTimestamp(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.pg_stat_get_snapshot_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_snapshot_timestamp()`
	// run
	var r0 time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgStatGetSubscription calls the stored function 'pg_catalog.pg_stat_get_subscription(oid) (oid, oid, integer, pg_lsn, timestamp with time zone, timestamp with time zone, pg_lsn, timestamp with time zone)' on db.
func PgStatGetSubscription(ctx context.Context, db DB, subid pgtypes.Oid) (pgtypes.Oid, pgtypes.Oid, int, pgtypes.PgLsn, time.Time, time.Time, pgtypes.PgLsn, time.Time, error) {
	// call pg_catalog.pg_stat_get_subscription
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_subscription($1)`
	// run
	var subid pgtypes.Oid
	var relid pgtypes.Oid
	var pid int
	var receivedLsn pgtypes.PgLsn
	var lastMsgSendTime time.Time
	var lastMsgReceiptTime time.Time
	var latestEndLsn pgtypes.PgLsn
	var latestEndTime time.Time
	logf(sqlstr, subid)
	if err := db.QueryRowContext(ctx, sqlstr, subid).Scan(&subid, &relid, &pid, &receivedLsn, &lastMsgSendTime, &lastMsgReceiptTime, &latestEndLsn, &latestEndTime); err != nil {
		return pgtypes.Oid{}, pgtypes.Oid{}, 0, pgtypes.PgLsn{}, time.Time{}, time.Time{}, pgtypes.PgLsn{}, time.Time{}, logerror(err)
	}
	return subid, relid, pid, receivedLsn, lastMsgSendTime, lastMsgReceiptTime, latestEndLsn, latestEndTime, nil
}

// PgStatGetTuplesDeleted calls the stored function 'pg_catalog.pg_stat_get_tuples_deleted(oid) bigint' on db.
func PgStatGetTuplesDeleted(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_deleted
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_tuples_deleted($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetTuplesFetched calls the stored function 'pg_catalog.pg_stat_get_tuples_fetched(oid) bigint' on db.
func PgStatGetTuplesFetched(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_fetched
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_tuples_fetched($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetTuplesHotUpdated calls the stored function 'pg_catalog.pg_stat_get_tuples_hot_updated(oid) bigint' on db.
func PgStatGetTuplesHotUpdated(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_hot_updated
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_tuples_hot_updated($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetTuplesInserted calls the stored function 'pg_catalog.pg_stat_get_tuples_inserted(oid) bigint' on db.
func PgStatGetTuplesInserted(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_inserted
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_tuples_inserted($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetTuplesReturned calls the stored function 'pg_catalog.pg_stat_get_tuples_returned(oid) bigint' on db.
func PgStatGetTuplesReturned(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_returned
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_tuples_returned($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetTuplesUpdated calls the stored function 'pg_catalog.pg_stat_get_tuples_updated(oid) bigint' on db.
func PgStatGetTuplesUpdated(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_tuples_updated
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_tuples_updated($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetVacuumCount calls the stored function 'pg_catalog.pg_stat_get_vacuum_count(oid) bigint' on db.
func PgStatGetVacuumCount(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_vacuum_count
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_vacuum_count($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetWalReceiver calls the stored function 'pg_catalog.pg_stat_get_wal_receiver() (integer, text, pg_lsn, integer, pg_lsn, pg_lsn, integer, timestamp with time zone, timestamp with time zone, pg_lsn, timestamp with time zone, text, text, integer, text)' on db.
func PgStatGetWalReceiver(ctx context.Context, db DB) (int, string, pgtypes.PgLsn, int, pgtypes.PgLsn, pgtypes.PgLsn, int, time.Time, time.Time, pgtypes.PgLsn, time.Time, string, string, int, string, error) {
	// call pg_catalog.pg_stat_get_wal_receiver
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_wal_receiver()`
	// run
	var pid int
	var status string
	var receiveStartLsn pgtypes.PgLsn
	var receiveStartTli int
	var writtenLsn pgtypes.PgLsn
	var flushedLsn pgtypes.PgLsn
	var receivedTli int
	var lastMsgSendTime time.Time
	var lastMsgReceiptTime time.Time
	var latestEndLsn pgtypes.PgLsn
	var latestEndTime time.Time
	var slotName string
	var senderHost string
	var senderPort int
	var conninfo string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&pid, &status, &receiveStartLsn, &receiveStartTli, &writtenLsn, &flushedLsn, &receivedTli, &lastMsgSendTime, &lastMsgReceiptTime, &latestEndLsn, &latestEndTime, &slotName, &senderHost, &senderPort, &conninfo); err != nil {
		return 0, "", pgtypes.PgLsn{}, 0, pgtypes.PgLsn{}, pgtypes.PgLsn{}, 0, time.Time{}, time.Time{}, pgtypes.PgLsn{}, time.Time{}, "", "", 0, "", logerror(err)
	}
	return pid, status, receiveStartLsn, receiveStartTli, writtenLsn, flushedLsn, receivedTli, lastMsgSendTime, lastMsgReceiptTime, latestEndLsn, latestEndTime, slotName, senderHost, senderPort, conninfo, nil
}

// PgStatGetWalSenders calls the stored function 'pg_catalog.pg_stat_get_wal_senders() (integer, text, pg_lsn, pg_lsn, pg_lsn, pg_lsn, interval, interval, interval, integer, text, timestamp with time zone)' on db.
func PgStatGetWalSenders(ctx context.Context, db DB) (int, string, pgtypes.PgLsn, pgtypes.PgLsn, pgtypes.PgLsn, pgtypes.PgLsn, []byte, []byte, []byte, int, string, time.Time, error) {
	// call pg_catalog.pg_stat_get_wal_senders
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_wal_senders()`
	// run
	var pid int
	var state string
	var sentLsn pgtypes.PgLsn
	var writeLsn pgtypes.PgLsn
	var flushLsn pgtypes.PgLsn
	var replayLsn pgtypes.PgLsn
	var writeLag []byte
	var flushLag []byte
	var replayLag []byte
	var syncPriority int
	var syncState string
	var replyTime time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&pid, &state, &sentLsn, &writeLsn, &flushLsn, &replayLsn, &writeLag, &flushLag, &replayLag, &syncPriority, &syncState, &replyTime); err != nil {
		return 0, "", pgtypes.PgLsn{}, pgtypes.PgLsn{}, pgtypes.PgLsn{}, pgtypes.PgLsn{}, nil, nil, nil, 0, "", time.Time{}, logerror(err)
	}
	return pid, state, sentLsn, writeLsn, flushLsn, replayLsn, writeLag, flushLag, replayLag, syncPriority, syncState, replyTime, nil
}

// PgStatGetXactBlocksFetched calls the stored function 'pg_catalog.pg_stat_get_xact_blocks_fetched(oid) bigint' on db.
func PgStatGetXactBlocksFetched(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_blocks_fetched
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_blocks_fetched($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetXactBlocksHit calls the stored function 'pg_catalog.pg_stat_get_xact_blocks_hit(oid) bigint' on db.
func PgStatGetXactBlocksHit(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_blocks_hit
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_blocks_hit($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetXactFunctionCalls calls the stored function 'pg_catalog.pg_stat_get_xact_function_calls(oid) bigint' on db.
func PgStatGetXactFunctionCalls(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_function_calls
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_function_calls($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetXactFunctionSelfTime calls the stored function 'pg_catalog.pg_stat_get_xact_function_self_time(oid) double precision' on db.
func PgStatGetXactFunctionSelfTime(ctx context.Context, db DB, p0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_xact_function_self_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_function_self_time($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PgStatGetXactFunctionTotalTime calls the stored function 'pg_catalog.pg_stat_get_xact_function_total_time(oid) double precision' on db.
func PgStatGetXactFunctionTotalTime(ctx context.Context, db DB, p0 pgtypes.Oid) (float64, error) {
	// call pg_catalog.pg_stat_get_xact_function_total_time
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_function_total_time($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PgStatGetXactNumscans calls the stored function 'pg_catalog.pg_stat_get_xact_numscans(oid) bigint' on db.
func PgStatGetXactNumscans(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_numscans
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_numscans($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetXactTuplesDeleted calls the stored function 'pg_catalog.pg_stat_get_xact_tuples_deleted(oid) bigint' on db.
func PgStatGetXactTuplesDeleted(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_deleted
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_tuples_deleted($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetXactTuplesFetched calls the stored function 'pg_catalog.pg_stat_get_xact_tuples_fetched(oid) bigint' on db.
func PgStatGetXactTuplesFetched(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_fetched
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_tuples_fetched($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetXactTuplesHotUpdated calls the stored function 'pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid) bigint' on db.
func PgStatGetXactTuplesHotUpdated(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_hot_updated
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_tuples_hot_updated($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetXactTuplesInserted calls the stored function 'pg_catalog.pg_stat_get_xact_tuples_inserted(oid) bigint' on db.
func PgStatGetXactTuplesInserted(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_inserted
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_tuples_inserted($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetXactTuplesReturned calls the stored function 'pg_catalog.pg_stat_get_xact_tuples_returned(oid) bigint' on db.
func PgStatGetXactTuplesReturned(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_returned
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_tuples_returned($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatGetXactTuplesUpdated calls the stored function 'pg_catalog.pg_stat_get_xact_tuples_updated(oid) bigint' on db.
func PgStatGetXactTuplesUpdated(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_stat_get_xact_tuples_updated
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_get_xact_tuples_updated($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgStatReset calls the stored function 'pg_catalog.pg_stat_reset()' on db.
func PgStatReset(ctx context.Context, db DB) error {
	// call pg_catalog.pg_stat_reset
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_reset()`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatResetShared calls the stored function 'pg_catalog.pg_stat_reset_shared(text)' on db.
func PgStatResetShared(ctx context.Context, db DB, p0 string) error {
	// call pg_catalog.pg_stat_reset_shared
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_reset_shared($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatResetSingleFunctionCounters calls the stored function 'pg_catalog.pg_stat_reset_single_function_counters(oid)' on db.
func PgStatResetSingleFunctionCounters(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.pg_stat_reset_single_function_counters
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_reset_single_function_counters($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatResetSingleTableCounters calls the stored function 'pg_catalog.pg_stat_reset_single_table_counters(oid)' on db.
func PgStatResetSingleTableCounters(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.pg_stat_reset_single_table_counters
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_reset_single_table_counters($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatResetSlru calls the stored function 'pg_catalog.pg_stat_reset_slru(text)' on db.
func PgStatResetSlru(ctx context.Context, db DB, p0 string) error {
	// call pg_catalog.pg_stat_reset_slru
	const sqlstr = `SELECT * FROM pg_catalog.pg_stat_reset_slru($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PgStatisticsObjIsVisible calls the stored function 'pg_catalog.pg_statistics_obj_is_visible(oid) boolean' on db.
func PgStatisticsObjIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_statistics_obj_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_statistics_obj_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgStopBackup calls the stored function 'pg_catalog.pg_stop_backup() pg_lsn' on db.
func PgStopBackup(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_stop_backup
	const sqlstr = `SELECT * FROM pg_catalog.pg_stop_backup()`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgStopBackupByExclusiveAndWaitForArchive calls the stored function 'pg_catalog.pg_stop_backup(boolean, boolean) (pg_lsn, text, text)' on db.
func PgStopBackupByExclusiveAndWaitForArchive(ctx context.Context, db DB, exclusive, waitForArchive bool) (pgtypes.PgLsn, string, string, error) {
	// call pg_catalog.pg_stop_backup
	const sqlstr = `SELECT * FROM pg_catalog.pg_stop_backup($1, $2)`
	// run
	var lsn pgtypes.PgLsn
	var labelfile string
	var spcmapfile string
	logf(sqlstr, exclusive, waitForArchive)
	if err := db.QueryRowContext(ctx, sqlstr, exclusive, waitForArchive).Scan(&lsn, &labelfile, &spcmapfile); err != nil {
		return pgtypes.PgLsn{}, "", "", logerror(err)
	}
	return lsn, labelfile, spcmapfile, nil
}

// PgSwitchWal calls the stored function 'pg_catalog.pg_switch_wal() pg_lsn' on db.
func PgSwitchWal(ctx context.Context, db DB) (pgtypes.PgLsn, error) {
	// call pg_catalog.pg_switch_wal
	const sqlstr = `SELECT * FROM pg_catalog.pg_switch_wal()`
	// run
	var r0 pgtypes.PgLsn
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.PgLsn{}, logerror(err)
	}
	return r0, nil
}

// PgTableIsVisible calls the stored function 'pg_catalog.pg_table_is_visible(oid) boolean' on db.
func PgTableIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_table_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_table_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTableSize calls the stored function 'pg_catalog.pg_table_size(regclass) bigint' on db.
func PgTableSize(ctx context.Context, db DB, p0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.pg_table_size
	const sqlstr = `SELECT * FROM pg_catalog.pg_table_size($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgTablespaceDatabases calls the stored function 'pg_catalog.pg_tablespace_databases(oid) oid' on db.
func PgTablespaceDatabases(ctx context.Context, db DB, p0 pgtypes.Oid) (pgtypes.Oid, error) {
	// call pg_catalog.pg_tablespace_databases
	const sqlstr = `SELECT * FROM pg_catalog.pg_tablespace_databases($1)`
	// run
	var r0 pgtypes.Oid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Oid{}, logerror(err)
	}
	return r0, nil
}

// PgTablespaceLocation calls the stored function 'pg_catalog.pg_tablespace_location(oid) text' on db.
func PgTablespaceLocation(ctx context.Context, db DB, p0 pgtypes.Oid) (string, error) {
	// call pg_catalog.pg_tablespace_location
	const sqlstr = `SELECT * FROM pg_catalog.pg_tablespace_location($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgTablespaceSizeByOid calls the stored function 'pg_catalog.pg_tablespace_size(oid) bigint' on db.
func PgTablespaceSizeByOid(ctx context.Context, db DB, p0 pgtypes.Oid) (int64, error) {
	// call pg_catalog.pg_tablespace_size
	const sqlstr = `SELECT * FROM pg_catalog.pg_tablespace_size($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgTablespaceSizeByName calls the stored function 'pg_catalog.pg_tablespace_size(name) bigint' on db.
func PgTablespaceSizeByName(ctx context.Context, db DB, p0 string) (int64, error) {
	// call pg_catalog.pg_tablespace_size
	const sqlstr = `SELECT * FROM pg_catalog.pg_tablespace_size($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgTerminateBackend calls the stored function 'pg_catalog.pg_terminate_backend(integer) boolean' on db.
func PgTerminateBackend(ctx context.Context, db DB, p0 int) (bool, error) {
	// call pg_catalog.pg_terminate_backend
	const sqlstr = `SELECT * FROM pg_catalog.pg_terminate_backend($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTimezoneAbbrevs calls the stored function 'pg_catalog.pg_timezone_abbrevs() (text, interval, boolean)' on db.
func PgTimezoneAbbrevs(ctx context.Context, db DB) (string, []byte, bool, error) {
	// call pg_catalog.pg_timezone_abbrevs
	const sqlstr = `SELECT * FROM pg_catalog.pg_timezone_abbrevs()`
	// run
	var abbrev string
	var utcOffset []byte
	var isDst bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&abbrev, &utcOffset, &isDst); err != nil {
		return "", nil, false, logerror(err)
	}
	return abbrev, utcOffset, isDst, nil
}

// PgTimezoneNames calls the stored function 'pg_catalog.pg_timezone_names() (text, text, interval, boolean)' on db.
func PgTimezoneNames(ctx context.Context, db DB) (string, string, []byte, bool, error) {
	// call pg_catalog.pg_timezone_names
	const sqlstr = `SELECT * FROM pg_catalog.pg_timezone_names()`
	// run
	var name string
	var abbrev string
	var utcOffset []byte
	var isDst bool
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&name, &abbrev, &utcOffset, &isDst); err != nil {
		return "", "", nil, false, logerror(err)
	}
	return name, abbrev, utcOffset, isDst, nil
}

// PgTotalRelationSize calls the stored function 'pg_catalog.pg_total_relation_size(regclass) bigint' on db.
func PgTotalRelationSize(ctx context.Context, db DB, p0 pgtypes.Regclass) (int64, error) {
	// call pg_catalog.pg_total_relation_size
	const sqlstr = `SELECT * FROM pg_catalog.pg_total_relation_size($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgTriggerDepth calls the stored function 'pg_catalog.pg_trigger_depth() integer' on db.
func PgTriggerDepth(ctx context.Context, db DB) (int, error) {
	// call pg_catalog.pg_trigger_depth
	const sqlstr = `SELECT * FROM pg_catalog.pg_trigger_depth()`
	// run
	var r0 int
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PgTryAdvisoryLockByBigint calls the stored function 'pg_catalog.pg_try_advisory_lock(bigint) boolean' on db.
func PgTryAdvisoryLockByBigint(ctx context.Context, db DB, p0 int64) (bool, error) {
	// call pg_catalog.pg_try_advisory_lock
	const sqlstr = `SELECT * FROM pg_catalog.pg_try_advisory_lock($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTryAdvisoryLockByIntegerAndInteger calls the stored function 'pg_catalog.pg_try_advisory_lock(integer, integer) boolean' on db.
func PgTryAdvisoryLockByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.pg_try_advisory_lock
	const sqlstr = `SELECT * FROM pg_catalog.pg_try_advisory_lock($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTryAdvisoryLockSharedByBigint calls the stored function 'pg_catalog.pg_try_advisory_lock_shared(bigint) boolean' on db.
func PgTryAdvisoryLockSharedByBigint(ctx context.Context, db DB, p0 int64) (bool, error) {
	// call pg_catalog.pg_try_advisory_lock_shared
	const sqlstr = `SELECT * FROM pg_catalog.pg_try_advisory_lock_shared($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTryAdvisoryLockSharedByIntegerAndInteger calls the stored function 'pg_catalog.pg_try_advisory_lock_shared(integer, integer) boolean' on db.
func PgTryAdvisoryLockSharedByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.pg_try_advisory_lock_shared
	const sqlstr = `SELECT * FROM pg_catalog.pg_try_advisory_lock_shared($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTryAdvisoryXactLockByBigint calls the stored function 'pg_catalog.pg_try_advisory_xact_lock(bigint) boolean' on db.
func PgTryAdvisoryXactLockByBigint(ctx context.Context, db DB, p0 int64) (bool, error) {
	// call pg_catalog.pg_try_advisory_xact_lock
	const sqlstr = `SELECT * FROM pg_catalog.pg_try_advisory_xact_lock($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTryAdvisoryXactLockByIntegerAndInteger calls the stored function 'pg_catalog.pg_try_advisory_xact_lock(integer, integer) boolean' on db.
func PgTryAdvisoryXactLockByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.pg_try_advisory_xact_lock
	const sqlstr = `SELECT * FROM pg_catalog.pg_try_advisory_xact_lock($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTryAdvisoryXactLockSharedByBigint calls the stored function 'pg_catalog.pg_try_advisory_xact_lock_shared(bigint) boolean' on db.
func PgTryAdvisoryXactLockSharedByBigint(ctx context.Context, db DB, p0 int64) (bool, error) {
	// call pg_catalog.pg_try_advisory_xact_lock_shared
	const sqlstr = `SELECT * FROM pg_catalog.pg_try_advisory_xact_lock_shared($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTryAdvisoryXactLockSharedByIntegerAndInteger calls the stored function 'pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer) boolean' on db.
func PgTryAdvisoryXactLockSharedByIntegerAndInteger(ctx context.Context, db DB, p0, p1 int) (bool, error) {
	// call pg_catalog.pg_try_advisory_xact_lock_shared
	const sqlstr = `SELECT * FROM pg_catalog.pg_try_advisory_xact_lock_shared($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTsConfigIsVisible calls the stored function 'pg_catalog.pg_ts_config_is_visible(oid) boolean' on db.
func PgTsConfigIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_ts_config_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_ts_config_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTsDictIsVisible calls the stored function 'pg_catalog.pg_ts_dict_is_visible(oid) boolean' on db.
func PgTsDictIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_ts_dict_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_ts_dict_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTsParserIsVisible calls the stored function 'pg_catalog.pg_ts_parser_is_visible(oid) boolean' on db.
func PgTsParserIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_ts_parser_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_ts_parser_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTsTemplateIsVisible calls the stored function 'pg_catalog.pg_ts_template_is_visible(oid) boolean' on db.
func PgTsTemplateIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_ts_template_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_ts_template_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTypeIsVisible calls the stored function 'pg_catalog.pg_type_is_visible(oid) boolean' on db.
func PgTypeIsVisible(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.pg_type_is_visible
	const sqlstr = `SELECT * FROM pg_catalog.pg_type_is_visible($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgTypeof calls the stored function 'pg_catalog.pg_typeof("any") regtype' on db.
func PgTypeof(ctx context.Context, db DB, p0 pgtypes.Any) (pgtypes.Regtype, error) {
	// call pg_catalog.pg_typeof
	const sqlstr = `SELECT * FROM pg_catalog.pg_typeof($1)`
	// run
	var r0 pgtypes.Regtype
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regtype{}, logerror(err)
	}
	return r0, nil
}

// PgVisibleInSnapshot calls the stored function 'pg_catalog.pg_visible_in_snapshot(xid8, pg_snapshot) boolean' on db.
func PgVisibleInSnapshot(ctx context.Context, db DB, p0 pgtypes.Xid8, p1 pgtypes.PgSnapshot) (bool, error) {
	// call pg_catalog.pg_visible_in_snapshot
	const sqlstr = `SELECT * FROM pg_catalog.pg_visible_in_snapshot($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PgWalLsnDiff calls the stored function 'pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn) numeric' on db.
func PgWalLsnDiff(ctx context.Context, db DB, p0, p1 pgtypes.PgLsn) (float64, error) {
	// call pg_catalog.pg_wal_lsn_diff
	const sqlstr = `SELECT * FROM pg_catalog.pg_wal_lsn_diff($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PgWalReplayPause calls the stored function 'pg_catalog.pg_wal_replay_pause()' on db.
func PgWalReplayPause(ctx context.Context, db DB) error {
	// call pg_catalog.pg_wal_replay_pause
	const sqlstr = `SELECT * FROM pg_catalog.pg_wal_replay_pause()`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgWalReplayResume calls the stored function 'pg_catalog.pg_wal_replay_resume()' on db.
func PgWalReplayResume(ctx context.Context, db DB) error {
	// call pg_catalog.pg_wal_replay_resume
	const sqlstr = `SELECT * FROM pg_catalog.pg_wal_replay_resume()`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr); err != nil {
		return logerror(err)
	}
	return nil
}

// PgWalfileName calls the stored function 'pg_catalog.pg_walfile_name(pg_lsn) text' on db.
func PgWalfileName(ctx context.Context, db DB, p0 pgtypes.PgLsn) (string, error) {
	// call pg_catalog.pg_walfile_name
	const sqlstr = `SELECT * FROM pg_catalog.pg_walfile_name($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PgWalfileNameOffset calls the stored function 'pg_catalog.pg_walfile_name_offset(pg_lsn) (text, integer)' on db.
func PgWalfileNameOffset(ctx context.Context, db DB, lsn pgtypes.PgLsn) (string, int, error) {
	// call pg_catalog.pg_walfile_name_offset
	const sqlstr = `SELECT * FROM pg_catalog.pg_walfile_name_offset($1)`
	// run
	var fileName string
	var fileOffset int
	logf(sqlstr, lsn)
	if err := db.QueryRowContext(ctx, sqlstr, lsn).Scan(&fileName, &fileOffset); err != nil {
		return "", 0, logerror(err)
	}
	return fileName, fileOffset, nil
}

// PgXactCommitTimestamp calls the stored function 'pg_catalog.pg_xact_commit_timestamp(xid) timestamp with time zone' on db.
func PgXactCommitTimestamp(ctx context.Context, db DB, p0 pgtypes.Xid) (time.Time, error) {
	// call pg_catalog.pg_xact_commit_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.pg_xact_commit_timestamp($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// PgXactStatus calls the stored function 'pg_catalog.pg_xact_status(xid8) text' on db.
func PgXactStatus(ctx context.Context, db DB, p0 pgtypes.Xid8) (string, error) {
	// call pg_catalog.pg_xact_status
	const sqlstr = `SELECT * FROM pg_catalog.pg_xact_status($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// PhrasetoTsqueryByText calls the stored function 'pg_catalog.phraseto_tsquery(text) tsquery' on db.
func PhrasetoTsqueryByText(ctx context.Context, db DB, p0 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.phraseto_tsquery
	const sqlstr = `SELECT * FROM pg_catalog.phraseto_tsquery($1)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// PhrasetoTsqueryByRegconfigAndText calls the stored function 'pg_catalog.phraseto_tsquery(regconfig, text) tsquery' on db.
func PhrasetoTsqueryByRegconfigAndText(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.phraseto_tsquery
	const sqlstr = `SELECT * FROM pg_catalog.phraseto_tsquery($1, $2)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// Pi calls the stored function 'pg_catalog.pi() double precision' on db.
func Pi(ctx context.Context, db DB) (float64, error) {
	// call pg_catalog.pi
	const sqlstr = `SELECT * FROM pg_catalog.pi()`
	// run
	var r0 float64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PlaintoTsqueryByRegconfigAndText calls the stored function 'pg_catalog.plainto_tsquery(regconfig, text) tsquery' on db.
func PlaintoTsqueryByRegconfigAndText(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.plainto_tsquery
	const sqlstr = `SELECT * FROM pg_catalog.plainto_tsquery($1, $2)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// PlaintoTsqueryByText calls the stored function 'pg_catalog.plainto_tsquery(text) tsquery' on db.
func PlaintoTsqueryByText(ctx context.Context, db DB, p0 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.plainto_tsquery
	const sqlstr = `SELECT * FROM pg_catalog.plainto_tsquery($1)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// PlpgsqlCallHandler calls the stored function 'pg_catalog.plpgsql_call_handler() language_handler' on db.
func PlpgsqlCallHandler(ctx context.Context, db DB) (pgtypes.LanguageHandler, error) {
	// call pg_catalog.plpgsql_call_handler
	const sqlstr = `SELECT * FROM pg_catalog.plpgsql_call_handler()`
	// run
	var r0 pgtypes.LanguageHandler
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.LanguageHandler{}, logerror(err)
	}
	return r0, nil
}

// PlpgsqlInlineHandler calls the stored function 'pg_catalog.plpgsql_inline_handler(internal)' on db.
func PlpgsqlInlineHandler(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.plpgsql_inline_handler
	const sqlstr = `SELECT * FROM pg_catalog.plpgsql_inline_handler($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PlpgsqlValidator calls the stored function 'pg_catalog.plpgsql_validator(oid)' on db.
func PlpgsqlValidator(ctx context.Context, db DB, p0 pgtypes.Oid) error {
	// call pg_catalog.plpgsql_validator
	const sqlstr = `SELECT * FROM pg_catalog.plpgsql_validator($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PointByCircle calls the stored function 'pg_catalog.point(circle) point' on db.
func PointByCircle(ctx context.Context, db DB, p0 pgtypes.Circle) (pgtypes.Point, error) {
	// call pg_catalog.point
	const sqlstr = `SELECT * FROM pg_catalog.point($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PointByDoublePrecisionAndDoublePrecision calls the stored function 'pg_catalog.point(double precision, double precision) point' on db.
func PointByDoublePrecisionAndDoublePrecision(ctx context.Context, db DB, p0, p1 float64) (pgtypes.Point, error) {
	// call pg_catalog.point
	const sqlstr = `SELECT * FROM pg_catalog.point($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PointByLseg calls the stored function 'pg_catalog.point(lseg) point' on db.
func PointByLseg(ctx context.Context, db DB, p0 pgtypes.Lseg) (pgtypes.Point, error) {
	// call pg_catalog.point
	const sqlstr = `SELECT * FROM pg_catalog.point($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PointByPath calls the stored function 'pg_catalog.point(path) point' on db.
func PointByPath(ctx context.Context, db DB, p0 pgtypes.Path) (pgtypes.Point, error) {
	// call pg_catalog.point
	const sqlstr = `SELECT * FROM pg_catalog.point($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PointByBox calls the stored function 'pg_catalog.point(box) point' on db.
func PointByBox(ctx context.Context, db DB, p0 pgtypes.Box) (pgtypes.Point, error) {
	// call pg_catalog.point
	const sqlstr = `SELECT * FROM pg_catalog.point($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PointByPolygon calls the stored function 'pg_catalog.point(polygon) point' on db.
func PointByPolygon(ctx context.Context, db DB, p0 pgtypes.Polygon) (pgtypes.Point, error) {
	// call pg_catalog.point
	const sqlstr = `SELECT * FROM pg_catalog.point($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PointAbove calls the stored function 'pg_catalog.point_above(point, point) boolean' on db.
func PointAbove(ctx context.Context, db DB, p0, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_above
	const sqlstr = `SELECT * FROM pg_catalog.point_above($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PointAdd calls the stored function 'pg_catalog.point_add(point, point) point' on db.
func PointAdd(ctx context.Context, db DB, p0, p1 pgtypes.Point) (pgtypes.Point, error) {
	// call pg_catalog.point_add
	const sqlstr = `SELECT * FROM pg_catalog.point_add($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PointBelow calls the stored function 'pg_catalog.point_below(point, point) boolean' on db.
func PointBelow(ctx context.Context, db DB, p0, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_below
	const sqlstr = `SELECT * FROM pg_catalog.point_below($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PointDistance calls the stored function 'pg_catalog.point_distance(point, point) double precision' on db.
func PointDistance(ctx context.Context, db DB, p0, p1 pgtypes.Point) (float64, error) {
	// call pg_catalog.point_distance
	const sqlstr = `SELECT * FROM pg_catalog.point_distance($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PointDiv calls the stored function 'pg_catalog.point_div(point, point) point' on db.
func PointDiv(ctx context.Context, db DB, p0, p1 pgtypes.Point) (pgtypes.Point, error) {
	// call pg_catalog.point_div
	const sqlstr = `SELECT * FROM pg_catalog.point_div($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PointEq calls the stored function 'pg_catalog.point_eq(point, point) boolean' on db.
func PointEq(ctx context.Context, db DB, p0, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_eq
	const sqlstr = `SELECT * FROM pg_catalog.point_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PointHoriz calls the stored function 'pg_catalog.point_horiz(point, point) boolean' on db.
func PointHoriz(ctx context.Context, db DB, p0, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_horiz
	const sqlstr = `SELECT * FROM pg_catalog.point_horiz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PointLeft calls the stored function 'pg_catalog.point_left(point, point) boolean' on db.
func PointLeft(ctx context.Context, db DB, p0, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_left
	const sqlstr = `SELECT * FROM pg_catalog.point_left($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PointMul calls the stored function 'pg_catalog.point_mul(point, point) point' on db.
func PointMul(ctx context.Context, db DB, p0, p1 pgtypes.Point) (pgtypes.Point, error) {
	// call pg_catalog.point_mul
	const sqlstr = `SELECT * FROM pg_catalog.point_mul($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PointNe calls the stored function 'pg_catalog.point_ne(point, point) boolean' on db.
func PointNe(ctx context.Context, db DB, p0, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_ne
	const sqlstr = `SELECT * FROM pg_catalog.point_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PointRecv calls the stored function 'pg_catalog.point_recv(internal) point' on db.
func PointRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Point, error) {
	// call pg_catalog.point_recv
	const sqlstr = `SELECT * FROM pg_catalog.point_recv($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PointRight calls the stored function 'pg_catalog.point_right(point, point) boolean' on db.
func PointRight(ctx context.Context, db DB, p0, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_right
	const sqlstr = `SELECT * FROM pg_catalog.point_right($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PointSend calls the stored function 'pg_catalog.point_send(point) bytea' on db.
func PointSend(ctx context.Context, db DB, p0 pgtypes.Point) ([]byte, error) {
	// call pg_catalog.point_send
	const sqlstr = `SELECT * FROM pg_catalog.point_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PointSub calls the stored function 'pg_catalog.point_sub(point, point) point' on db.
func PointSub(ctx context.Context, db DB, p0, p1 pgtypes.Point) (pgtypes.Point, error) {
	// call pg_catalog.point_sub
	const sqlstr = `SELECT * FROM pg_catalog.point_sub($1, $2)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PointVert calls the stored function 'pg_catalog.point_vert(point, point) boolean' on db.
func PointVert(ctx context.Context, db DB, p0, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.point_vert
	const sqlstr = `SELECT * FROM pg_catalog.point_vert($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyAbove calls the stored function 'pg_catalog.poly_above(polygon, polygon) boolean' on db.
func PolyAbove(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_above
	const sqlstr = `SELECT * FROM pg_catalog.poly_above($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyBelow calls the stored function 'pg_catalog.poly_below(polygon, polygon) boolean' on db.
func PolyBelow(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_below
	const sqlstr = `SELECT * FROM pg_catalog.poly_below($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyCenter calls the stored function 'pg_catalog.poly_center(polygon) point' on db.
func PolyCenter(ctx context.Context, db DB, p0 pgtypes.Polygon) (pgtypes.Point, error) {
	// call pg_catalog.poly_center
	const sqlstr = `SELECT * FROM pg_catalog.poly_center($1)`
	// run
	var r0 pgtypes.Point
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Point{}, logerror(err)
	}
	return r0, nil
}

// PolyContain calls the stored function 'pg_catalog.poly_contain(polygon, polygon) boolean' on db.
func PolyContain(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_contain
	const sqlstr = `SELECT * FROM pg_catalog.poly_contain($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyContainPt calls the stored function 'pg_catalog.poly_contain_pt(polygon, point) boolean' on db.
func PolyContainPt(ctx context.Context, db DB, p0 pgtypes.Polygon, p1 pgtypes.Point) (bool, error) {
	// call pg_catalog.poly_contain_pt
	const sqlstr = `SELECT * FROM pg_catalog.poly_contain_pt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyContained calls the stored function 'pg_catalog.poly_contained(polygon, polygon) boolean' on db.
func PolyContained(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_contained
	const sqlstr = `SELECT * FROM pg_catalog.poly_contained($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyDistance calls the stored function 'pg_catalog.poly_distance(polygon, polygon) double precision' on db.
func PolyDistance(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (float64, error) {
	// call pg_catalog.poly_distance
	const sqlstr = `SELECT * FROM pg_catalog.poly_distance($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PolyLeft calls the stored function 'pg_catalog.poly_left(polygon, polygon) boolean' on db.
func PolyLeft(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_left
	const sqlstr = `SELECT * FROM pg_catalog.poly_left($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyNpoints calls the stored function 'pg_catalog.poly_npoints(polygon) integer' on db.
func PolyNpoints(ctx context.Context, db DB, p0 pgtypes.Polygon) (int, error) {
	// call pg_catalog.poly_npoints
	const sqlstr = `SELECT * FROM pg_catalog.poly_npoints($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PolyOverabove calls the stored function 'pg_catalog.poly_overabove(polygon, polygon) boolean' on db.
func PolyOverabove(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_overabove
	const sqlstr = `SELECT * FROM pg_catalog.poly_overabove($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyOverbelow calls the stored function 'pg_catalog.poly_overbelow(polygon, polygon) boolean' on db.
func PolyOverbelow(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_overbelow
	const sqlstr = `SELECT * FROM pg_catalog.poly_overbelow($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyOverlap calls the stored function 'pg_catalog.poly_overlap(polygon, polygon) boolean' on db.
func PolyOverlap(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_overlap
	const sqlstr = `SELECT * FROM pg_catalog.poly_overlap($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyOverleft calls the stored function 'pg_catalog.poly_overleft(polygon, polygon) boolean' on db.
func PolyOverleft(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_overleft
	const sqlstr = `SELECT * FROM pg_catalog.poly_overleft($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyOverright calls the stored function 'pg_catalog.poly_overright(polygon, polygon) boolean' on db.
func PolyOverright(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_overright
	const sqlstr = `SELECT * FROM pg_catalog.poly_overright($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolyRecv calls the stored function 'pg_catalog.poly_recv(internal) polygon' on db.
func PolyRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Polygon, error) {
	// call pg_catalog.poly_recv
	const sqlstr = `SELECT * FROM pg_catalog.poly_recv($1)`
	// run
	var r0 pgtypes.Polygon
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Polygon{}, logerror(err)
	}
	return r0, nil
}

// PolyRight calls the stored function 'pg_catalog.poly_right(polygon, polygon) boolean' on db.
func PolyRight(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_right
	const sqlstr = `SELECT * FROM pg_catalog.poly_right($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolySame calls the stored function 'pg_catalog.poly_same(polygon, polygon) boolean' on db.
func PolySame(ctx context.Context, db DB, p0, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.poly_same
	const sqlstr = `SELECT * FROM pg_catalog.poly_same($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PolySend calls the stored function 'pg_catalog.poly_send(polygon) bytea' on db.
func PolySend(ctx context.Context, db DB, p0 pgtypes.Polygon) ([]byte, error) {
	// call pg_catalog.poly_send
	const sqlstr = `SELECT * FROM pg_catalog.poly_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// PolygonByBox calls the stored function 'pg_catalog.polygon(box) polygon' on db.
func PolygonByBox(ctx context.Context, db DB, p0 pgtypes.Box) (pgtypes.Polygon, error) {
	// call pg_catalog.polygon
	const sqlstr = `SELECT * FROM pg_catalog.polygon($1)`
	// run
	var r0 pgtypes.Polygon
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Polygon{}, logerror(err)
	}
	return r0, nil
}

// PolygonByPath calls the stored function 'pg_catalog.polygon(path) polygon' on db.
func PolygonByPath(ctx context.Context, db DB, p0 pgtypes.Path) (pgtypes.Polygon, error) {
	// call pg_catalog.polygon
	const sqlstr = `SELECT * FROM pg_catalog.polygon($1)`
	// run
	var r0 pgtypes.Polygon
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Polygon{}, logerror(err)
	}
	return r0, nil
}

// PolygonByIntegerAndCircle calls the stored function 'pg_catalog.polygon(integer, circle) polygon' on db.
func PolygonByIntegerAndCircle(ctx context.Context, db DB, p0 int, p1 pgtypes.Circle) (pgtypes.Polygon, error) {
	// call pg_catalog.polygon
	const sqlstr = `SELECT * FROM pg_catalog.polygon($1, $2)`
	// run
	var r0 pgtypes.Polygon
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Polygon{}, logerror(err)
	}
	return r0, nil
}

// PolygonByCircle calls the stored function 'pg_catalog.polygon(circle) polygon' on db.
func PolygonByCircle(ctx context.Context, db DB, p0 pgtypes.Circle) (pgtypes.Polygon, error) {
	// call pg_catalog.polygon
	const sqlstr = `SELECT * FROM pg_catalog.polygon($1)`
	// run
	var r0 pgtypes.Polygon
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Polygon{}, logerror(err)
	}
	return r0, nil
}

// Popen calls the stored function 'pg_catalog.popen(path) path' on db.
func Popen(ctx context.Context, db DB, p0 pgtypes.Path) (pgtypes.Path, error) {
	// call pg_catalog.popen
	const sqlstr = `SELECT * FROM pg_catalog.popen($1)`
	// run
	var r0 pgtypes.Path
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Path{}, logerror(err)
	}
	return r0, nil
}

// PositionByBitAndBit calls the stored function 'pg_catalog.position(bit, bit) integer' on db.
func PositionByBitAndBit(ctx context.Context, db DB, p0, p1 uint8) (int, error) {
	// call pg_catalog.position
	const sqlstr = `SELECT * FROM pg_catalog.position($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PositionByByteaAndBytea calls the stored function 'pg_catalog.position(bytea, bytea) integer' on db.
func PositionByByteaAndBytea(ctx context.Context, db DB, p0, p1 []byte) (int, error) {
	// call pg_catalog.position
	const sqlstr = `SELECT * FROM pg_catalog.position($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// PositionByTextAndText calls the stored function 'pg_catalog.position(text, text) integer' on db.
func PositionByTextAndText(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.position
	const sqlstr = `SELECT * FROM pg_catalog.position($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Positionjoinsel calls the stored function 'pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Positionjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.positionjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.positionjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Positionsel calls the stored function 'pg_catalog.positionsel(internal, oid, internal, integer) double precision' on db.
func Positionsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.positionsel
	const sqlstr = `SELECT * FROM pg_catalog.positionsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PostgresqlFdwValidator calls the stored function 'pg_catalog.postgresql_fdw_validator(text, oid) boolean' on db.
func PostgresqlFdwValidator(ctx context.Context, db DB, p0 StringSlice, p1 pgtypes.Oid) (bool, error) {
	// call pg_catalog.postgresql_fdw_validator
	const sqlstr = `SELECT * FROM pg_catalog.postgresql_fdw_validator($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PowByDoublePrecisionAndDoublePrecision calls the stored function 'pg_catalog.pow(double precision, double precision) double precision' on db.
func PowByDoublePrecisionAndDoublePrecision(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.pow
	const sqlstr = `SELECT * FROM pg_catalog.pow($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PowByNumericAndNumeric calls the stored function 'pg_catalog.pow(numeric, numeric) numeric' on db.
func PowByNumericAndNumeric(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.pow
	const sqlstr = `SELECT * FROM pg_catalog.pow($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PowerByDoublePrecisionAndDoublePrecision calls the stored function 'pg_catalog.power(double precision, double precision) double precision' on db.
func PowerByDoublePrecisionAndDoublePrecision(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.power
	const sqlstr = `SELECT * FROM pg_catalog.power($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PowerByNumericAndNumeric calls the stored function 'pg_catalog.power(numeric, numeric) numeric' on db.
func PowerByNumericAndNumeric(ctx context.Context, db DB, p0, p1 float64) (float64, error) {
	// call pg_catalog.power
	const sqlstr = `SELECT * FROM pg_catalog.power($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Prefixjoinsel calls the stored function 'pg_catalog.prefixjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Prefixjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.prefixjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.prefixjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Prefixsel calls the stored function 'pg_catalog.prefixsel(internal, oid, internal, integer) double precision' on db.
func Prefixsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.prefixsel
	const sqlstr = `SELECT * FROM pg_catalog.prefixsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// PrsdEnd calls the stored function 'pg_catalog.prsd_end(internal)' on db.
func PrsdEnd(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.prsd_end
	const sqlstr = `SELECT * FROM pg_catalog.prsd_end($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// PrsdHeadline calls the stored function 'pg_catalog.prsd_headline(internal, internal, tsquery) internal' on db.
func PrsdHeadline(ctx context.Context, db DB, p0, p1 pgtypes.Internal, p2 pgtypes.Tsquery) (pgtypes.Internal, error) {
	// call pg_catalog.prsd_headline
	const sqlstr = `SELECT * FROM pg_catalog.prsd_headline($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// PrsdLextype calls the stored function 'pg_catalog.prsd_lextype(internal) internal' on db.
func PrsdLextype(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.prsd_lextype
	const sqlstr = `SELECT * FROM pg_catalog.prsd_lextype($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// PrsdNexttoken calls the stored function 'pg_catalog.prsd_nexttoken(internal, internal, internal) internal' on db.
func PrsdNexttoken(ctx context.Context, db DB, p0, p1, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.prsd_nexttoken
	const sqlstr = `SELECT * FROM pg_catalog.prsd_nexttoken($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// PrsdStart calls the stored function 'pg_catalog.prsd_start(internal, integer) internal' on db.
func PrsdStart(ctx context.Context, db DB, p0 pgtypes.Internal, p1 int) (pgtypes.Internal, error) {
	// call pg_catalog.prsd_start
	const sqlstr = `SELECT * FROM pg_catalog.prsd_start($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// PtContainedCircle calls the stored function 'pg_catalog.pt_contained_circle(point, circle) boolean' on db.
func PtContainedCircle(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Circle) (bool, error) {
	// call pg_catalog.pt_contained_circle
	const sqlstr = `SELECT * FROM pg_catalog.pt_contained_circle($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// PtContainedPoly calls the stored function 'pg_catalog.pt_contained_poly(point, polygon) boolean' on db.
func PtContainedPoly(ctx context.Context, db DB, p0 pgtypes.Point, p1 pgtypes.Polygon) (bool, error) {
	// call pg_catalog.pt_contained_poly
	const sqlstr = `SELECT * FROM pg_catalog.pt_contained_poly($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// QueryToXML calls the stored function 'pg_catalog.query_to_xml(text, boolean, boolean, text) xml' on db.
func QueryToXML(ctx context.Context, db DB, query string, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.query_to_xml
	const sqlstr = `SELECT * FROM pg_catalog.query_to_xml($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, query, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, query, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// QueryToXMLAndXmlschema calls the stored function 'pg_catalog.query_to_xml_and_xmlschema(text, boolean, boolean, text) xml' on db.
func QueryToXMLAndXmlschema(ctx context.Context, db DB, query string, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.query_to_xml_and_xmlschema
	const sqlstr = `SELECT * FROM pg_catalog.query_to_xml_and_xmlschema($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, query, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, query, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// QueryToXmlschema calls the stored function 'pg_catalog.query_to_xmlschema(text, boolean, boolean, text) xml' on db.
func QueryToXmlschema(ctx context.Context, db DB, query string, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.query_to_xmlschema
	const sqlstr = `SELECT * FROM pg_catalog.query_to_xmlschema($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, query, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, query, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Querytree calls the stored function 'pg_catalog.querytree(tsquery) text' on db.
func Querytree(ctx context.Context, db DB, p0 pgtypes.Tsquery) (string, error) {
	// call pg_catalog.querytree
	const sqlstr = `SELECT * FROM pg_catalog.querytree($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// QuoteIdent calls the stored function 'pg_catalog.quote_ident(text) text' on db.
func QuoteIdent(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.quote_ident
	const sqlstr = `SELECT * FROM pg_catalog.quote_ident($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// QuoteLiteralByText calls the stored function 'pg_catalog.quote_literal(text) text' on db.
func QuoteLiteralByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.quote_literal
	const sqlstr = `SELECT * FROM pg_catalog.quote_literal($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// QuoteLiteralByAnyelement calls the stored function 'pg_catalog.quote_literal(anyelement) text' on db.
func QuoteLiteralByAnyelement(ctx context.Context, db DB, p0 pgtypes.Anyelement) (string, error) {
	// call pg_catalog.quote_literal
	const sqlstr = `SELECT * FROM pg_catalog.quote_literal($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// QuoteNullableByText calls the stored function 'pg_catalog.quote_nullable(text) text' on db.
func QuoteNullableByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.quote_nullable
	const sqlstr = `SELECT * FROM pg_catalog.quote_nullable($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// QuoteNullableByAnyelement calls the stored function 'pg_catalog.quote_nullable(anyelement) text' on db.
func QuoteNullableByAnyelement(ctx context.Context, db DB, p0 pgtypes.Anyelement) (string, error) {
	// call pg_catalog.quote_nullable
	const sqlstr = `SELECT * FROM pg_catalog.quote_nullable($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Radians calls the stored function 'pg_catalog.radians(double precision) double precision' on db.
func Radians(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.radians
	const sqlstr = `SELECT * FROM pg_catalog.radians($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Radius calls the stored function 'pg_catalog.radius(circle) double precision' on db.
func Radius(ctx context.Context, db DB, p0 pgtypes.Circle) (float64, error) {
	// call pg_catalog.radius
	const sqlstr = `SELECT * FROM pg_catalog.radius($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Random calls the stored function 'pg_catalog.random() double precision' on db.
func Random(ctx context.Context, db DB) (float64, error) {
	// call pg_catalog.random
	const sqlstr = `SELECT * FROM pg_catalog.random()`
	// run
	var r0 float64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// RangeAdjacent calls the stored function 'pg_catalog.range_adjacent(anyrange, anyrange) boolean' on db.
func RangeAdjacent(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_adjacent
	const sqlstr = `SELECT * FROM pg_catalog.range_adjacent($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeAfter calls the stored function 'pg_catalog.range_after(anyrange, anyrange) boolean' on db.
func RangeAfter(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_after
	const sqlstr = `SELECT * FROM pg_catalog.range_after($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeBefore calls the stored function 'pg_catalog.range_before(anyrange, anyrange) boolean' on db.
func RangeBefore(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_before
	const sqlstr = `SELECT * FROM pg_catalog.range_before($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeCmp calls the stored function 'pg_catalog.range_cmp(anyrange, anyrange) integer' on db.
func RangeCmp(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (int, error) {
	// call pg_catalog.range_cmp
	const sqlstr = `SELECT * FROM pg_catalog.range_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// RangeContainedBy calls the stored function 'pg_catalog.range_contained_by(anyrange, anyrange) boolean' on db.
func RangeContainedBy(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_contained_by
	const sqlstr = `SELECT * FROM pg_catalog.range_contained_by($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeContains calls the stored function 'pg_catalog.range_contains(anyrange, anyrange) boolean' on db.
func RangeContains(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_contains
	const sqlstr = `SELECT * FROM pg_catalog.range_contains($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeContainsElem calls the stored function 'pg_catalog.range_contains_elem(anyrange, anyelement) boolean' on db.
func RangeContainsElem(ctx context.Context, db DB, p0 pgtypes.Anyrange, p1 pgtypes.Anyelement) (bool, error) {
	// call pg_catalog.range_contains_elem
	const sqlstr = `SELECT * FROM pg_catalog.range_contains_elem($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeEq calls the stored function 'pg_catalog.range_eq(anyrange, anyrange) boolean' on db.
func RangeEq(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_eq
	const sqlstr = `SELECT * FROM pg_catalog.range_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeGe calls the stored function 'pg_catalog.range_ge(anyrange, anyrange) boolean' on db.
func RangeGe(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_ge
	const sqlstr = `SELECT * FROM pg_catalog.range_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeGistConsistent calls the stored function 'pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal) boolean' on db.
func RangeGistConsistent(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Anyrange, p2 int16, p3 pgtypes.Oid, p4 pgtypes.Internal) (bool, error) {
	// call pg_catalog.range_gist_consistent
	const sqlstr = `SELECT * FROM pg_catalog.range_gist_consistent($1, $2, $3, $4, $5)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeGistPenalty calls the stored function 'pg_catalog.range_gist_penalty(internal, internal, internal) internal' on db.
func RangeGistPenalty(ctx context.Context, db DB, p0, p1, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.range_gist_penalty
	const sqlstr = `SELECT * FROM pg_catalog.range_gist_penalty($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// RangeGistPicksplit calls the stored function 'pg_catalog.range_gist_picksplit(internal, internal) internal' on db.
func RangeGistPicksplit(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.range_gist_picksplit
	const sqlstr = `SELECT * FROM pg_catalog.range_gist_picksplit($1, $2)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// RangeGistSame calls the stored function 'pg_catalog.range_gist_same(anyrange, anyrange, internal) internal' on db.
func RangeGistSame(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange, p2 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.range_gist_same
	const sqlstr = `SELECT * FROM pg_catalog.range_gist_same($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// RangeGistUnion calls the stored function 'pg_catalog.range_gist_union(internal, internal) anyrange' on db.
func RangeGistUnion(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_gist_union
	const sqlstr = `SELECT * FROM pg_catalog.range_gist_union($1, $2)`
	// run
	var r0 pgtypes.Anyrange
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return r0, nil
}

// RangeGt calls the stored function 'pg_catalog.range_gt(anyrange, anyrange) boolean' on db.
func RangeGt(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_gt
	const sqlstr = `SELECT * FROM pg_catalog.range_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeIntersect calls the stored function 'pg_catalog.range_intersect(anyrange, anyrange) anyrange' on db.
func RangeIntersect(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_intersect
	const sqlstr = `SELECT * FROM pg_catalog.range_intersect($1, $2)`
	// run
	var r0 pgtypes.Anyrange
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return r0, nil
}

// RangeLe calls the stored function 'pg_catalog.range_le(anyrange, anyrange) boolean' on db.
func RangeLe(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_le
	const sqlstr = `SELECT * FROM pg_catalog.range_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeLt calls the stored function 'pg_catalog.range_lt(anyrange, anyrange) boolean' on db.
func RangeLt(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_lt
	const sqlstr = `SELECT * FROM pg_catalog.range_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeMerge calls the stored function 'pg_catalog.range_merge(anyrange, anyrange) anyrange' on db.
func RangeMerge(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_merge
	const sqlstr = `SELECT * FROM pg_catalog.range_merge($1, $2)`
	// run
	var r0 pgtypes.Anyrange
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return r0, nil
}

// RangeMinus calls the stored function 'pg_catalog.range_minus(anyrange, anyrange) anyrange' on db.
func RangeMinus(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_minus
	const sqlstr = `SELECT * FROM pg_catalog.range_minus($1, $2)`
	// run
	var r0 pgtypes.Anyrange
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return r0, nil
}

// RangeNe calls the stored function 'pg_catalog.range_ne(anyrange, anyrange) boolean' on db.
func RangeNe(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_ne
	const sqlstr = `SELECT * FROM pg_catalog.range_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeOverlaps calls the stored function 'pg_catalog.range_overlaps(anyrange, anyrange) boolean' on db.
func RangeOverlaps(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_overlaps
	const sqlstr = `SELECT * FROM pg_catalog.range_overlaps($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeOverleft calls the stored function 'pg_catalog.range_overleft(anyrange, anyrange) boolean' on db.
func RangeOverleft(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_overleft
	const sqlstr = `SELECT * FROM pg_catalog.range_overleft($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeOverright calls the stored function 'pg_catalog.range_overright(anyrange, anyrange) boolean' on db.
func RangeOverright(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.range_overright
	const sqlstr = `SELECT * FROM pg_catalog.range_overright($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeRecv calls the stored function 'pg_catalog.range_recv(internal, oid, integer) anyrange' on db.
func RangeRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_recv
	const sqlstr = `SELECT * FROM pg_catalog.range_recv($1, $2, $3)`
	// run
	var r0 pgtypes.Anyrange
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return r0, nil
}

// RangeSend calls the stored function 'pg_catalog.range_send(anyrange) bytea' on db.
func RangeSend(ctx context.Context, db DB, p0 pgtypes.Anyrange) ([]byte, error) {
	// call pg_catalog.range_send
	const sqlstr = `SELECT * FROM pg_catalog.range_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// RangeTypanalyze calls the stored function 'pg_catalog.range_typanalyze(internal) boolean' on db.
func RangeTypanalyze(ctx context.Context, db DB, p0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.range_typanalyze
	const sqlstr = `SELECT * FROM pg_catalog.range_typanalyze($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RangeUnion calls the stored function 'pg_catalog.range_union(anyrange, anyrange) anyrange' on db.
func RangeUnion(ctx context.Context, db DB, p0, p1 pgtypes.Anyrange) (pgtypes.Anyrange, error) {
	// call pg_catalog.range_union
	const sqlstr = `SELECT * FROM pg_catalog.range_union($1, $2)`
	// run
	var r0 pgtypes.Anyrange
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Anyrange{}, logerror(err)
	}
	return r0, nil
}

// Rangesel calls the stored function 'pg_catalog.rangesel(internal, oid, internal, integer) double precision' on db.
func Rangesel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.rangesel
	const sqlstr = `SELECT * FROM pg_catalog.rangesel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// RecordEq calls the stored function 'pg_catalog.record_eq(record, record) boolean' on db.
func RecordEq(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_eq
	const sqlstr = `SELECT * FROM pg_catalog.record_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordGe calls the stored function 'pg_catalog.record_ge(record, record) boolean' on db.
func RecordGe(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_ge
	const sqlstr = `SELECT * FROM pg_catalog.record_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordGt calls the stored function 'pg_catalog.record_gt(record, record) boolean' on db.
func RecordGt(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_gt
	const sqlstr = `SELECT * FROM pg_catalog.record_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordImageEq calls the stored function 'pg_catalog.record_image_eq(record, record) boolean' on db.
func RecordImageEq(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_eq
	const sqlstr = `SELECT * FROM pg_catalog.record_image_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordImageGe calls the stored function 'pg_catalog.record_image_ge(record, record) boolean' on db.
func RecordImageGe(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_ge
	const sqlstr = `SELECT * FROM pg_catalog.record_image_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordImageGt calls the stored function 'pg_catalog.record_image_gt(record, record) boolean' on db.
func RecordImageGt(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_gt
	const sqlstr = `SELECT * FROM pg_catalog.record_image_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordImageLe calls the stored function 'pg_catalog.record_image_le(record, record) boolean' on db.
func RecordImageLe(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_le
	const sqlstr = `SELECT * FROM pg_catalog.record_image_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordImageLt calls the stored function 'pg_catalog.record_image_lt(record, record) boolean' on db.
func RecordImageLt(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_lt
	const sqlstr = `SELECT * FROM pg_catalog.record_image_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordImageNe calls the stored function 'pg_catalog.record_image_ne(record, record) boolean' on db.
func RecordImageNe(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_image_ne
	const sqlstr = `SELECT * FROM pg_catalog.record_image_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordLe calls the stored function 'pg_catalog.record_le(record, record) boolean' on db.
func RecordLe(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_le
	const sqlstr = `SELECT * FROM pg_catalog.record_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordLt calls the stored function 'pg_catalog.record_lt(record, record) boolean' on db.
func RecordLt(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_lt
	const sqlstr = `SELECT * FROM pg_catalog.record_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordNe calls the stored function 'pg_catalog.record_ne(record, record) boolean' on db.
func RecordNe(ctx context.Context, db DB, p0, p1 pgtypes.Record) (bool, error) {
	// call pg_catalog.record_ne
	const sqlstr = `SELECT * FROM pg_catalog.record_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RecordRecv calls the stored function 'pg_catalog.record_recv(internal, oid, integer) record' on db.
func RecordRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (pgtypes.Record, error) {
	// call pg_catalog.record_recv
	const sqlstr = `SELECT * FROM pg_catalog.record_recv($1, $2, $3)`
	// run
	var r0 pgtypes.Record
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Record{}, logerror(err)
	}
	return r0, nil
}

// RecordSend calls the stored function 'pg_catalog.record_send(record) bytea' on db.
func RecordSend(ctx context.Context, db DB, p0 pgtypes.Record) ([]byte, error) {
	// call pg_catalog.record_send
	const sqlstr = `SELECT * FROM pg_catalog.record_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Regclass calls the stored function 'pg_catalog.regclass(text) regclass' on db.
func Regclass(ctx context.Context, db DB, p0 string) (pgtypes.Regclass, error) {
	// call pg_catalog.regclass
	const sqlstr = `SELECT * FROM pg_catalog.regclass($1)`
	// run
	var r0 pgtypes.Regclass
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return r0, nil
}

// Regclassrecv calls the stored function 'pg_catalog.regclassrecv(internal) regclass' on db.
func Regclassrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Regclass, error) {
	// call pg_catalog.regclassrecv
	const sqlstr = `SELECT * FROM pg_catalog.regclassrecv($1)`
	// run
	var r0 pgtypes.Regclass
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return r0, nil
}

// Regclasssend calls the stored function 'pg_catalog.regclasssend(regclass) bytea' on db.
func Regclasssend(ctx context.Context, db DB, p0 pgtypes.Regclass) ([]byte, error) {
	// call pg_catalog.regclasssend
	const sqlstr = `SELECT * FROM pg_catalog.regclasssend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Regcollationrecv calls the stored function 'pg_catalog.regcollationrecv(internal) regcollation' on db.
func Regcollationrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Regcollation, error) {
	// call pg_catalog.regcollationrecv
	const sqlstr = `SELECT * FROM pg_catalog.regcollationrecv($1)`
	// run
	var r0 pgtypes.Regcollation
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regcollation{}, logerror(err)
	}
	return r0, nil
}

// Regcollationsend calls the stored function 'pg_catalog.regcollationsend(regcollation) bytea' on db.
func Regcollationsend(ctx context.Context, db DB, p0 pgtypes.Regcollation) ([]byte, error) {
	// call pg_catalog.regcollationsend
	const sqlstr = `SELECT * FROM pg_catalog.regcollationsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Regconfigrecv calls the stored function 'pg_catalog.regconfigrecv(internal) regconfig' on db.
func Regconfigrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Regconfig, error) {
	// call pg_catalog.regconfigrecv
	const sqlstr = `SELECT * FROM pg_catalog.regconfigrecv($1)`
	// run
	var r0 pgtypes.Regconfig
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regconfig{}, logerror(err)
	}
	return r0, nil
}

// Regconfigsend calls the stored function 'pg_catalog.regconfigsend(regconfig) bytea' on db.
func Regconfigsend(ctx context.Context, db DB, p0 pgtypes.Regconfig) ([]byte, error) {
	// call pg_catalog.regconfigsend
	const sqlstr = `SELECT * FROM pg_catalog.regconfigsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Regdictionaryrecv calls the stored function 'pg_catalog.regdictionaryrecv(internal) regdictionary' on db.
func Regdictionaryrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Regdictionary, error) {
	// call pg_catalog.regdictionaryrecv
	const sqlstr = `SELECT * FROM pg_catalog.regdictionaryrecv($1)`
	// run
	var r0 pgtypes.Regdictionary
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regdictionary{}, logerror(err)
	}
	return r0, nil
}

// Regdictionarysend calls the stored function 'pg_catalog.regdictionarysend(regdictionary) bytea' on db.
func Regdictionarysend(ctx context.Context, db DB, p0 pgtypes.Regdictionary) ([]byte, error) {
	// call pg_catalog.regdictionarysend
	const sqlstr = `SELECT * FROM pg_catalog.regdictionarysend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Regexeqjoinsel calls the stored function 'pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Regexeqjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.regexeqjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.regexeqjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Regexeqsel calls the stored function 'pg_catalog.regexeqsel(internal, oid, internal, integer) double precision' on db.
func Regexeqsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.regexeqsel
	const sqlstr = `SELECT * FROM pg_catalog.regexeqsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Regexnejoinsel calls the stored function 'pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Regexnejoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.regexnejoinsel
	const sqlstr = `SELECT * FROM pg_catalog.regexnejoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Regexnesel calls the stored function 'pg_catalog.regexnesel(internal, oid, internal, integer) double precision' on db.
func Regexnesel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.regexnesel
	const sqlstr = `SELECT * FROM pg_catalog.regexnesel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// RegexpMatchByTextAndText calls the stored function 'pg_catalog.regexp_match(text, text) text' on db.
func RegexpMatchByTextAndText(ctx context.Context, db DB, p0, p1 string) (StringSlice, error) {
	// call pg_catalog.regexp_match
	const sqlstr = `SELECT * FROM pg_catalog.regexp_match($1, $2)`
	// run
	var r0 StringSlice
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// RegexpMatchByTextTextAndText calls the stored function 'pg_catalog.regexp_match(text, text, text) text' on db.
func RegexpMatchByTextTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (StringSlice, error) {
	// call pg_catalog.regexp_match
	const sqlstr = `SELECT * FROM pg_catalog.regexp_match($1, $2, $3)`
	// run
	var r0 StringSlice
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// RegexpMatchesByTextAndText calls the stored function 'pg_catalog.regexp_matches(text, text) text' on db.
func RegexpMatchesByTextAndText(ctx context.Context, db DB, p0, p1 string) (StringSlice, error) {
	// call pg_catalog.regexp_matches
	const sqlstr = `SELECT * FROM pg_catalog.regexp_matches($1, $2)`
	// run
	var r0 StringSlice
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// RegexpMatchesByTextTextAndText calls the stored function 'pg_catalog.regexp_matches(text, text, text) text' on db.
func RegexpMatchesByTextTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (StringSlice, error) {
	// call pg_catalog.regexp_matches
	const sqlstr = `SELECT * FROM pg_catalog.regexp_matches($1, $2, $3)`
	// run
	var r0 StringSlice
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// RegexpReplaceByTextTextAndText calls the stored function 'pg_catalog.regexp_replace(text, text, text) text' on db.
func RegexpReplaceByTextTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (string, error) {
	// call pg_catalog.regexp_replace
	const sqlstr = `SELECT * FROM pg_catalog.regexp_replace($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// RegexpReplaceByTextTextTextAndText calls the stored function 'pg_catalog.regexp_replace(text, text, text, text) text' on db.
func RegexpReplaceByTextTextTextAndText(ctx context.Context, db DB, p0, p1, p2, p3 string) (string, error) {
	// call pg_catalog.regexp_replace
	const sqlstr = `SELECT * FROM pg_catalog.regexp_replace($1, $2, $3, $4)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// RegexpSplitToArrayByTextAndText calls the stored function 'pg_catalog.regexp_split_to_array(text, text) text' on db.
func RegexpSplitToArrayByTextAndText(ctx context.Context, db DB, p0, p1 string) (StringSlice, error) {
	// call pg_catalog.regexp_split_to_array
	const sqlstr = `SELECT * FROM pg_catalog.regexp_split_to_array($1, $2)`
	// run
	var r0 StringSlice
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// RegexpSplitToArrayByTextTextAndText calls the stored function 'pg_catalog.regexp_split_to_array(text, text, text) text' on db.
func RegexpSplitToArrayByTextTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (StringSlice, error) {
	// call pg_catalog.regexp_split_to_array
	const sqlstr = `SELECT * FROM pg_catalog.regexp_split_to_array($1, $2, $3)`
	// run
	var r0 StringSlice
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// RegexpSplitToTableByTextAndText calls the stored function 'pg_catalog.regexp_split_to_table(text, text) text' on db.
func RegexpSplitToTableByTextAndText(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.regexp_split_to_table
	const sqlstr = `SELECT * FROM pg_catalog.regexp_split_to_table($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// RegexpSplitToTableByTextTextAndText calls the stored function 'pg_catalog.regexp_split_to_table(text, text, text) text' on db.
func RegexpSplitToTableByTextTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (string, error) {
	// call pg_catalog.regexp_split_to_table
	const sqlstr = `SELECT * FROM pg_catalog.regexp_split_to_table($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Regnamespacerecv calls the stored function 'pg_catalog.regnamespacerecv(internal) regnamespace' on db.
func Regnamespacerecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Regnamespace, error) {
	// call pg_catalog.regnamespacerecv
	const sqlstr = `SELECT * FROM pg_catalog.regnamespacerecv($1)`
	// run
	var r0 pgtypes.Regnamespace
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regnamespace{}, logerror(err)
	}
	return r0, nil
}

// Regnamespacesend calls the stored function 'pg_catalog.regnamespacesend(regnamespace) bytea' on db.
func Regnamespacesend(ctx context.Context, db DB, p0 pgtypes.Regnamespace) ([]byte, error) {
	// call pg_catalog.regnamespacesend
	const sqlstr = `SELECT * FROM pg_catalog.regnamespacesend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Regoperatorrecv calls the stored function 'pg_catalog.regoperatorrecv(internal) regoperator' on db.
func Regoperatorrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Regoperator, error) {
	// call pg_catalog.regoperatorrecv
	const sqlstr = `SELECT * FROM pg_catalog.regoperatorrecv($1)`
	// run
	var r0 pgtypes.Regoperator
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regoperator{}, logerror(err)
	}
	return r0, nil
}

// Regoperatorsend calls the stored function 'pg_catalog.regoperatorsend(regoperator) bytea' on db.
func Regoperatorsend(ctx context.Context, db DB, p0 pgtypes.Regoperator) ([]byte, error) {
	// call pg_catalog.regoperatorsend
	const sqlstr = `SELECT * FROM pg_catalog.regoperatorsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Regoperrecv calls the stored function 'pg_catalog.regoperrecv(internal) regoper' on db.
func Regoperrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Regoper, error) {
	// call pg_catalog.regoperrecv
	const sqlstr = `SELECT * FROM pg_catalog.regoperrecv($1)`
	// run
	var r0 pgtypes.Regoper
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regoper{}, logerror(err)
	}
	return r0, nil
}

// Regopersend calls the stored function 'pg_catalog.regopersend(regoper) bytea' on db.
func Regopersend(ctx context.Context, db DB, p0 pgtypes.Regoper) ([]byte, error) {
	// call pg_catalog.regopersend
	const sqlstr = `SELECT * FROM pg_catalog.regopersend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Regprocedurerecv calls the stored function 'pg_catalog.regprocedurerecv(internal) regprocedure' on db.
func Regprocedurerecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Regprocedure, error) {
	// call pg_catalog.regprocedurerecv
	const sqlstr = `SELECT * FROM pg_catalog.regprocedurerecv($1)`
	// run
	var r0 pgtypes.Regprocedure
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regprocedure{}, logerror(err)
	}
	return r0, nil
}

// Regproceduresend calls the stored function 'pg_catalog.regproceduresend(regprocedure) bytea' on db.
func Regproceduresend(ctx context.Context, db DB, p0 pgtypes.Regprocedure) ([]byte, error) {
	// call pg_catalog.regproceduresend
	const sqlstr = `SELECT * FROM pg_catalog.regproceduresend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Regprocrecv calls the stored function 'pg_catalog.regprocrecv(internal) regproc' on db.
func Regprocrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Regproc, error) {
	// call pg_catalog.regprocrecv
	const sqlstr = `SELECT * FROM pg_catalog.regprocrecv($1)`
	// run
	var r0 pgtypes.Regproc
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regproc{}, logerror(err)
	}
	return r0, nil
}

// Regprocsend calls the stored function 'pg_catalog.regprocsend(regproc) bytea' on db.
func Regprocsend(ctx context.Context, db DB, p0 pgtypes.Regproc) ([]byte, error) {
	// call pg_catalog.regprocsend
	const sqlstr = `SELECT * FROM pg_catalog.regprocsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Regrolerecv calls the stored function 'pg_catalog.regrolerecv(internal) regrole' on db.
func Regrolerecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Regrole, error) {
	// call pg_catalog.regrolerecv
	const sqlstr = `SELECT * FROM pg_catalog.regrolerecv($1)`
	// run
	var r0 pgtypes.Regrole
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regrole{}, logerror(err)
	}
	return r0, nil
}

// Regrolesend calls the stored function 'pg_catalog.regrolesend(regrole) bytea' on db.
func Regrolesend(ctx context.Context, db DB, p0 pgtypes.Regrole) ([]byte, error) {
	// call pg_catalog.regrolesend
	const sqlstr = `SELECT * FROM pg_catalog.regrolesend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Regtyperecv calls the stored function 'pg_catalog.regtyperecv(internal) regtype' on db.
func Regtyperecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Regtype, error) {
	// call pg_catalog.regtyperecv
	const sqlstr = `SELECT * FROM pg_catalog.regtyperecv($1)`
	// run
	var r0 pgtypes.Regtype
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regtype{}, logerror(err)
	}
	return r0, nil
}

// Regtypesend calls the stored function 'pg_catalog.regtypesend(regtype) bytea' on db.
func Regtypesend(ctx context.Context, db DB, p0 pgtypes.Regtype) ([]byte, error) {
	// call pg_catalog.regtypesend
	const sqlstr = `SELECT * FROM pg_catalog.regtypesend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Repeat calls the stored function 'pg_catalog.repeat(text, integer) text' on db.
func Repeat(ctx context.Context, db DB, p0 string, p1 int) (string, error) {
	// call pg_catalog.repeat
	const sqlstr = `SELECT * FROM pg_catalog.repeat($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Replace calls the stored function 'pg_catalog.replace(text, text, text) text' on db.
func Replace(ctx context.Context, db DB, p0, p1, p2 string) (string, error) {
	// call pg_catalog.replace
	const sqlstr = `SELECT * FROM pg_catalog.replace($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Reverse calls the stored function 'pg_catalog.reverse(text) text' on db.
func Reverse(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.reverse
	const sqlstr = `SELECT * FROM pg_catalog.reverse($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// RiFkeyCascadeDel calls the stored function 'pg_catalog.RI_FKey_cascade_del() trigger' on db.
func RiFkeyCascadeDel(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_cascade_del
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_cascade_del()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// RiFkeyCascadeUpd calls the stored function 'pg_catalog.RI_FKey_cascade_upd() trigger' on db.
func RiFkeyCascadeUpd(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_cascade_upd
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_cascade_upd()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// RiFkeyCheckIns calls the stored function 'pg_catalog.RI_FKey_check_ins() trigger' on db.
func RiFkeyCheckIns(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_check_ins
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_check_ins()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// RiFkeyCheckUpd calls the stored function 'pg_catalog.RI_FKey_check_upd() trigger' on db.
func RiFkeyCheckUpd(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_check_upd
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_check_upd()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// RiFkeyNoactionDel calls the stored function 'pg_catalog.RI_FKey_noaction_del() trigger' on db.
func RiFkeyNoactionDel(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_noaction_del
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_noaction_del()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// RiFkeyNoactionUpd calls the stored function 'pg_catalog.RI_FKey_noaction_upd() trigger' on db.
func RiFkeyNoactionUpd(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_noaction_upd
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_noaction_upd()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// RiFkeyRestrictDel calls the stored function 'pg_catalog.RI_FKey_restrict_del() trigger' on db.
func RiFkeyRestrictDel(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_restrict_del
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_restrict_del()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// RiFkeyRestrictUpd calls the stored function 'pg_catalog.RI_FKey_restrict_upd() trigger' on db.
func RiFkeyRestrictUpd(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_restrict_upd
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_restrict_upd()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// RiFkeySetdefaultDel calls the stored function 'pg_catalog.RI_FKey_setdefault_del() trigger' on db.
func RiFkeySetdefaultDel(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_setdefault_del
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_setdefault_del()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// RiFkeySetdefaultUpd calls the stored function 'pg_catalog.RI_FKey_setdefault_upd() trigger' on db.
func RiFkeySetdefaultUpd(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_setdefault_upd
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_setdefault_upd()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// RiFkeySetnullDel calls the stored function 'pg_catalog.RI_FKey_setnull_del() trigger' on db.
func RiFkeySetnullDel(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_setnull_del
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_setnull_del()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// RiFkeySetnullUpd calls the stored function 'pg_catalog.RI_FKey_setnull_upd() trigger' on db.
func RiFkeySetnullUpd(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.RI_FKey_setnull_upd
	const sqlstr = `SELECT * FROM pg_catalog.RI_FKey_setnull_upd()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// Right calls the stored function 'pg_catalog.right(text, integer) text' on db.
func Right(ctx context.Context, db DB, p0 string, p1 int) (string, error) {
	// call pg_catalog.right
	const sqlstr = `SELECT * FROM pg_catalog.right($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// RoundByDoublePrecision calls the stored function 'pg_catalog.round(double precision) double precision' on db.
func RoundByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.round
	const sqlstr = `SELECT * FROM pg_catalog.round($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// RoundByNumericAndInteger calls the stored function 'pg_catalog.round(numeric, integer) numeric' on db.
func RoundByNumericAndInteger(ctx context.Context, db DB, p0 float64, p1 int) (float64, error) {
	// call pg_catalog.round
	const sqlstr = `SELECT * FROM pg_catalog.round($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// RoundByNumeric calls the stored function 'pg_catalog.round(numeric) numeric' on db.
func RoundByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.round
	const sqlstr = `SELECT * FROM pg_catalog.round($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// RowSecurityActiveByOid calls the stored function 'pg_catalog.row_security_active(oid) boolean' on db.
func RowSecurityActiveByOid(ctx context.Context, db DB, p0 pgtypes.Oid) (bool, error) {
	// call pg_catalog.row_security_active
	const sqlstr = `SELECT * FROM pg_catalog.row_security_active($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RowSecurityActiveByText calls the stored function 'pg_catalog.row_security_active(text) boolean' on db.
func RowSecurityActiveByText(ctx context.Context, db DB, p0 string) (bool, error) {
	// call pg_catalog.row_security_active
	const sqlstr = `SELECT * FROM pg_catalog.row_security_active($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// RowToJSONByRecord calls the stored function 'pg_catalog.row_to_json(record) json' on db.
func RowToJSONByRecord(ctx context.Context, db DB, p0 pgtypes.Record) ([]byte, error) {
	// call pg_catalog.row_to_json
	const sqlstr = `SELECT * FROM pg_catalog.row_to_json($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// RowToJSONByRecordAndBoolean calls the stored function 'pg_catalog.row_to_json(record, boolean) json' on db.
func RowToJSONByRecordAndBoolean(ctx context.Context, db DB, p0 pgtypes.Record, p1 bool) ([]byte, error) {
	// call pg_catalog.row_to_json
	const sqlstr = `SELECT * FROM pg_catalog.row_to_json($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// RpadByTextIntegerAndText calls the stored function 'pg_catalog.rpad(text, integer, text) text' on db.
func RpadByTextIntegerAndText(ctx context.Context, db DB, p0 string, p1 int, p2 string) (string, error) {
	// call pg_catalog.rpad
	const sqlstr = `SELECT * FROM pg_catalog.rpad($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// RpadByTextAndInteger calls the stored function 'pg_catalog.rpad(text, integer) text' on db.
func RpadByTextAndInteger(ctx context.Context, db DB, p0 string, p1 int) (string, error) {
	// call pg_catalog.rpad
	const sqlstr = `SELECT * FROM pg_catalog.rpad($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// RtrimByTextAndText calls the stored function 'pg_catalog.rtrim(text, text) text' on db.
func RtrimByTextAndText(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.rtrim
	const sqlstr = `SELECT * FROM pg_catalog.rtrim($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// RtrimByText calls the stored function 'pg_catalog.rtrim(text) text' on db.
func RtrimByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.rtrim
	const sqlstr = `SELECT * FROM pg_catalog.rtrim($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Scalargejoinsel calls the stored function 'pg_catalog.scalargejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Scalargejoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.scalargejoinsel
	const sqlstr = `SELECT * FROM pg_catalog.scalargejoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Scalargesel calls the stored function 'pg_catalog.scalargesel(internal, oid, internal, integer) double precision' on db.
func Scalargesel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.scalargesel
	const sqlstr = `SELECT * FROM pg_catalog.scalargesel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Scalargtjoinsel calls the stored function 'pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Scalargtjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.scalargtjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.scalargtjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Scalargtsel calls the stored function 'pg_catalog.scalargtsel(internal, oid, internal, integer) double precision' on db.
func Scalargtsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.scalargtsel
	const sqlstr = `SELECT * FROM pg_catalog.scalargtsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Scalarlejoinsel calls the stored function 'pg_catalog.scalarlejoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Scalarlejoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.scalarlejoinsel
	const sqlstr = `SELECT * FROM pg_catalog.scalarlejoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Scalarlesel calls the stored function 'pg_catalog.scalarlesel(internal, oid, internal, integer) double precision' on db.
func Scalarlesel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.scalarlesel
	const sqlstr = `SELECT * FROM pg_catalog.scalarlesel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Scalarltjoinsel calls the stored function 'pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Scalarltjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.scalarltjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.scalarltjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Scalarltsel calls the stored function 'pg_catalog.scalarltsel(internal, oid, internal, integer) double precision' on db.
func Scalarltsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.scalarltsel
	const sqlstr = `SELECT * FROM pg_catalog.scalarltsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Scale calls the stored function 'pg_catalog.scale(numeric) integer' on db.
func Scale(ctx context.Context, db DB, p0 float64) (int, error) {
	// call pg_catalog.scale
	const sqlstr = `SELECT * FROM pg_catalog.scale($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// SchemaToXML calls the stored function 'pg_catalog.schema_to_xml(name, boolean, boolean, text) xml' on db.
func SchemaToXML(ctx context.Context, db DB, schema string, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.schema_to_xml
	const sqlstr = `SELECT * FROM pg_catalog.schema_to_xml($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, schema, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, schema, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// SchemaToXMLAndXmlschema calls the stored function 'pg_catalog.schema_to_xml_and_xmlschema(name, boolean, boolean, text) xml' on db.
func SchemaToXMLAndXmlschema(ctx context.Context, db DB, schema string, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.schema_to_xml_and_xmlschema
	const sqlstr = `SELECT * FROM pg_catalog.schema_to_xml_and_xmlschema($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, schema, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, schema, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// SchemaToXmlschema calls the stored function 'pg_catalog.schema_to_xmlschema(name, boolean, boolean, text) xml' on db.
func SchemaToXmlschema(ctx context.Context, db DB, schema string, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.schema_to_xmlschema
	const sqlstr = `SELECT * FROM pg_catalog.schema_to_xmlschema($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, schema, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, schema, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// SessionUser calls the stored function 'pg_catalog.session_user() name' on db.
func SessionUser(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.session_user
	const sqlstr = `SELECT * FROM pg_catalog.session_user()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SetBitByBitIntegerAndInteger calls the stored function 'pg_catalog.set_bit(bit, integer, integer) bit' on db.
func SetBitByBitIntegerAndInteger(ctx context.Context, db DB, p0 uint8, p1, p2 int) (uint8, error) {
	// call pg_catalog.set_bit
	const sqlstr = `SELECT * FROM pg_catalog.set_bit($1, $2, $3)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// SetBitByByteaBigintAndInteger calls the stored function 'pg_catalog.set_bit(bytea, bigint, integer) bytea' on db.
func SetBitByByteaBigintAndInteger(ctx context.Context, db DB, p0 []byte, p1 int64, p2 int) ([]byte, error) {
	// call pg_catalog.set_bit
	const sqlstr = `SELECT * FROM pg_catalog.set_bit($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// SetByte calls the stored function 'pg_catalog.set_byte(bytea, integer, integer) bytea' on db.
func SetByte(ctx context.Context, db DB, p0 []byte, p1, p2 int) ([]byte, error) {
	// call pg_catalog.set_byte
	const sqlstr = `SELECT * FROM pg_catalog.set_byte($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// SetConfig calls the stored function 'pg_catalog.set_config(text, text, boolean) text' on db.
func SetConfig(ctx context.Context, db DB, p0, p1 string, p2 bool) (string, error) {
	// call pg_catalog.set_config
	const sqlstr = `SELECT * FROM pg_catalog.set_config($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SetMasklenByInetAndInteger calls the stored function 'pg_catalog.set_masklen(inet, integer) inet' on db.
func SetMasklenByInetAndInteger(ctx context.Context, db DB, p0 string, p1 int) (string, error) {
	// call pg_catalog.set_masklen
	const sqlstr = `SELECT * FROM pg_catalog.set_masklen($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SetMasklenByCidrAndInteger calls the stored function 'pg_catalog.set_masklen(cidr, integer) cidr' on db.
func SetMasklenByCidrAndInteger(ctx context.Context, db DB, p0 pgtypes.Cidr, p1 int) (pgtypes.Cidr, error) {
	// call pg_catalog.set_masklen
	const sqlstr = `SELECT * FROM pg_catalog.set_masklen($1, $2)`
	// run
	var r0 pgtypes.Cidr
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Cidr{}, logerror(err)
	}
	return r0, nil
}

// Setseed calls the stored function 'pg_catalog.setseed(double precision)' on db.
func Setseed(ctx context.Context, db DB, p0 float64) error {
	// call pg_catalog.setseed
	const sqlstr = `SELECT * FROM pg_catalog.setseed($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// SetvalByRegclassAndBigint calls the stored function 'pg_catalog.setval(regclass, bigint) bigint' on db.
func SetvalByRegclassAndBigint(ctx context.Context, db DB, p0 pgtypes.Regclass, p1 int64) (int64, error) {
	// call pg_catalog.setval
	const sqlstr = `SELECT * FROM pg_catalog.setval($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// SetvalByRegclassBigintAndBoolean calls the stored function 'pg_catalog.setval(regclass, bigint, boolean) bigint' on db.
func SetvalByRegclassBigintAndBoolean(ctx context.Context, db DB, p0 pgtypes.Regclass, p1 int64, p2 bool) (int64, error) {
	// call pg_catalog.setval
	const sqlstr = `SELECT * FROM pg_catalog.setval($1, $2, $3)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// SetweightByTsvectorCharAndText calls the stored function 'pg_catalog.setweight(tsvector, "char", text) tsvector' on db.
func SetweightByTsvectorCharAndText(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 pgtypes.Char, p2 StringSlice) (pgtypes.Tsvector, error) {
	// call pg_catalog.setweight
	const sqlstr = `SELECT * FROM pg_catalog.setweight($1, $2, $3)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// SetweightByTsvectorAndChar calls the stored function 'pg_catalog.setweight(tsvector, "char") tsvector' on db.
func SetweightByTsvectorAndChar(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 pgtypes.Char) (pgtypes.Tsvector, error) {
	// call pg_catalog.setweight
	const sqlstr = `SELECT * FROM pg_catalog.setweight($1, $2)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// Sha224 calls the stored function 'pg_catalog.sha224(bytea) bytea' on db.
func Sha224(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.sha224
	const sqlstr = `SELECT * FROM pg_catalog.sha224($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Sha256 calls the stored function 'pg_catalog.sha256(bytea) bytea' on db.
func Sha256(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.sha256
	const sqlstr = `SELECT * FROM pg_catalog.sha256($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Sha384 calls the stored function 'pg_catalog.sha384(bytea) bytea' on db.
func Sha384(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.sha384
	const sqlstr = `SELECT * FROM pg_catalog.sha384($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Sha512 calls the stored function 'pg_catalog.sha512(bytea) bytea' on db.
func Sha512(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.sha512
	const sqlstr = `SELECT * FROM pg_catalog.sha512($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// ShiftJis2004ToEucJis2004 calls the stored function 'pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer)' on db.
func ShiftJis2004ToEucJis2004(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.shift_jis_2004_to_euc_jis_2004
	const sqlstr = `SELECT * FROM pg_catalog.shift_jis_2004_to_euc_jis_2004($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// ShiftJis2004ToUTF8 calls the stored function 'pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer)' on db.
func ShiftJis2004ToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.shift_jis_2004_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.shift_jis_2004_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// ShobjDescription calls the stored function 'pg_catalog.shobj_description(oid, name) text' on db.
func ShobjDescription(ctx context.Context, db DB, p0 pgtypes.Oid, p1 string) (string, error) {
	// call pg_catalog.shobj_description
	const sqlstr = `SELECT * FROM pg_catalog.shobj_description($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SignByNumeric calls the stored function 'pg_catalog.sign(numeric) numeric' on db.
func SignByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.sign
	const sqlstr = `SELECT * FROM pg_catalog.sign($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// SignByDoublePrecision calls the stored function 'pg_catalog.sign(double precision) double precision' on db.
func SignByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.sign
	const sqlstr = `SELECT * FROM pg_catalog.sign($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// SimilarEscape calls the stored function 'pg_catalog.similar_escape(text, text) text' on db.
func SimilarEscape(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.similar_escape
	const sqlstr = `SELECT * FROM pg_catalog.similar_escape($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SimilarToEscapeByTextAndText calls the stored function 'pg_catalog.similar_to_escape(text, text) text' on db.
func SimilarToEscapeByTextAndText(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.similar_to_escape
	const sqlstr = `SELECT * FROM pg_catalog.similar_to_escape($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SimilarToEscapeByText calls the stored function 'pg_catalog.similar_to_escape(text) text' on db.
func SimilarToEscapeByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.similar_to_escape
	const sqlstr = `SELECT * FROM pg_catalog.similar_to_escape($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Sin calls the stored function 'pg_catalog.sin(double precision) double precision' on db.
func Sin(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.sin
	const sqlstr = `SELECT * FROM pg_catalog.sin($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Sind calls the stored function 'pg_catalog.sind(double precision) double precision' on db.
func Sind(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.sind
	const sqlstr = `SELECT * FROM pg_catalog.sind($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Sinh calls the stored function 'pg_catalog.sinh(double precision) double precision' on db.
func Sinh(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.sinh
	const sqlstr = `SELECT * FROM pg_catalog.sinh($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// SjisToEucJp calls the stored function 'pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer)' on db.
func SjisToEucJp(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.sjis_to_euc_jp
	const sqlstr = `SELECT * FROM pg_catalog.sjis_to_euc_jp($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// SjisToMic calls the stored function 'pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer)' on db.
func SjisToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.sjis_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.sjis_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// SjisToUTF8 calls the stored function 'pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer)' on db.
func SjisToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.sjis_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.sjis_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Slope calls the stored function 'pg_catalog.slope(point, point) double precision' on db.
func Slope(ctx context.Context, db DB, p0, p1 pgtypes.Point) (float64, error) {
	// call pg_catalog.slope
	const sqlstr = `SELECT * FROM pg_catalog.slope($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// SpgBboxQuadConfig calls the stored function 'pg_catalog.spg_bbox_quad_config(internal, internal)' on db.
func SpgBboxQuadConfig(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_bbox_quad_config
	const sqlstr = `SELECT * FROM pg_catalog.spg_bbox_quad_config($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgBoxQuadChoose calls the stored function 'pg_catalog.spg_box_quad_choose(internal, internal)' on db.
func SpgBoxQuadChoose(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_box_quad_choose
	const sqlstr = `SELECT * FROM pg_catalog.spg_box_quad_choose($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgBoxQuadConfig calls the stored function 'pg_catalog.spg_box_quad_config(internal, internal)' on db.
func SpgBoxQuadConfig(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_box_quad_config
	const sqlstr = `SELECT * FROM pg_catalog.spg_box_quad_config($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgBoxQuadInnerConsistent calls the stored function 'pg_catalog.spg_box_quad_inner_consistent(internal, internal)' on db.
func SpgBoxQuadInnerConsistent(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_box_quad_inner_consistent
	const sqlstr = `SELECT * FROM pg_catalog.spg_box_quad_inner_consistent($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgBoxQuadLeafConsistent calls the stored function 'pg_catalog.spg_box_quad_leaf_consistent(internal, internal) boolean' on db.
func SpgBoxQuadLeafConsistent(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (bool, error) {
	// call pg_catalog.spg_box_quad_leaf_consistent
	const sqlstr = `SELECT * FROM pg_catalog.spg_box_quad_leaf_consistent($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// SpgBoxQuadPicksplit calls the stored function 'pg_catalog.spg_box_quad_picksplit(internal, internal)' on db.
func SpgBoxQuadPicksplit(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_box_quad_picksplit
	const sqlstr = `SELECT * FROM pg_catalog.spg_box_quad_picksplit($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgKdChoose calls the stored function 'pg_catalog.spg_kd_choose(internal, internal)' on db.
func SpgKdChoose(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_kd_choose
	const sqlstr = `SELECT * FROM pg_catalog.spg_kd_choose($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgKdConfig calls the stored function 'pg_catalog.spg_kd_config(internal, internal)' on db.
func SpgKdConfig(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_kd_config
	const sqlstr = `SELECT * FROM pg_catalog.spg_kd_config($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgKdInnerConsistent calls the stored function 'pg_catalog.spg_kd_inner_consistent(internal, internal)' on db.
func SpgKdInnerConsistent(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_kd_inner_consistent
	const sqlstr = `SELECT * FROM pg_catalog.spg_kd_inner_consistent($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgKdPicksplit calls the stored function 'pg_catalog.spg_kd_picksplit(internal, internal)' on db.
func SpgKdPicksplit(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_kd_picksplit
	const sqlstr = `SELECT * FROM pg_catalog.spg_kd_picksplit($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgPolyQuadCompress calls the stored function 'pg_catalog.spg_poly_quad_compress(polygon) box' on db.
func SpgPolyQuadCompress(ctx context.Context, db DB, p0 pgtypes.Polygon) (pgtypes.Box, error) {
	// call pg_catalog.spg_poly_quad_compress
	const sqlstr = `SELECT * FROM pg_catalog.spg_poly_quad_compress($1)`
	// run
	var r0 pgtypes.Box
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Box{}, logerror(err)
	}
	return r0, nil
}

// SpgQuadChoose calls the stored function 'pg_catalog.spg_quad_choose(internal, internal)' on db.
func SpgQuadChoose(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_quad_choose
	const sqlstr = `SELECT * FROM pg_catalog.spg_quad_choose($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgQuadConfig calls the stored function 'pg_catalog.spg_quad_config(internal, internal)' on db.
func SpgQuadConfig(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_quad_config
	const sqlstr = `SELECT * FROM pg_catalog.spg_quad_config($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgQuadInnerConsistent calls the stored function 'pg_catalog.spg_quad_inner_consistent(internal, internal)' on db.
func SpgQuadInnerConsistent(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_quad_inner_consistent
	const sqlstr = `SELECT * FROM pg_catalog.spg_quad_inner_consistent($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgQuadLeafConsistent calls the stored function 'pg_catalog.spg_quad_leaf_consistent(internal, internal) boolean' on db.
func SpgQuadLeafConsistent(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (bool, error) {
	// call pg_catalog.spg_quad_leaf_consistent
	const sqlstr = `SELECT * FROM pg_catalog.spg_quad_leaf_consistent($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// SpgQuadPicksplit calls the stored function 'pg_catalog.spg_quad_picksplit(internal, internal)' on db.
func SpgQuadPicksplit(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_quad_picksplit
	const sqlstr = `SELECT * FROM pg_catalog.spg_quad_picksplit($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgRangeQuadChoose calls the stored function 'pg_catalog.spg_range_quad_choose(internal, internal)' on db.
func SpgRangeQuadChoose(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_range_quad_choose
	const sqlstr = `SELECT * FROM pg_catalog.spg_range_quad_choose($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgRangeQuadConfig calls the stored function 'pg_catalog.spg_range_quad_config(internal, internal)' on db.
func SpgRangeQuadConfig(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_range_quad_config
	const sqlstr = `SELECT * FROM pg_catalog.spg_range_quad_config($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgRangeQuadInnerConsistent calls the stored function 'pg_catalog.spg_range_quad_inner_consistent(internal, internal)' on db.
func SpgRangeQuadInnerConsistent(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_range_quad_inner_consistent
	const sqlstr = `SELECT * FROM pg_catalog.spg_range_quad_inner_consistent($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgRangeQuadLeafConsistent calls the stored function 'pg_catalog.spg_range_quad_leaf_consistent(internal, internal) boolean' on db.
func SpgRangeQuadLeafConsistent(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (bool, error) {
	// call pg_catalog.spg_range_quad_leaf_consistent
	const sqlstr = `SELECT * FROM pg_catalog.spg_range_quad_leaf_consistent($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// SpgRangeQuadPicksplit calls the stored function 'pg_catalog.spg_range_quad_picksplit(internal, internal)' on db.
func SpgRangeQuadPicksplit(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_range_quad_picksplit
	const sqlstr = `SELECT * FROM pg_catalog.spg_range_quad_picksplit($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgTextChoose calls the stored function 'pg_catalog.spg_text_choose(internal, internal)' on db.
func SpgTextChoose(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_text_choose
	const sqlstr = `SELECT * FROM pg_catalog.spg_text_choose($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgTextConfig calls the stored function 'pg_catalog.spg_text_config(internal, internal)' on db.
func SpgTextConfig(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_text_config
	const sqlstr = `SELECT * FROM pg_catalog.spg_text_config($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgTextInnerConsistent calls the stored function 'pg_catalog.spg_text_inner_consistent(internal, internal)' on db.
func SpgTextInnerConsistent(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_text_inner_consistent
	const sqlstr = `SELECT * FROM pg_catalog.spg_text_inner_consistent($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// SpgTextLeafConsistent calls the stored function 'pg_catalog.spg_text_leaf_consistent(internal, internal) boolean' on db.
func SpgTextLeafConsistent(ctx context.Context, db DB, p0, p1 pgtypes.Internal) (bool, error) {
	// call pg_catalog.spg_text_leaf_consistent
	const sqlstr = `SELECT * FROM pg_catalog.spg_text_leaf_consistent($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// SpgTextPicksplit calls the stored function 'pg_catalog.spg_text_picksplit(internal, internal)' on db.
func SpgTextPicksplit(ctx context.Context, db DB, p0, p1 pgtypes.Internal) error {
	// call pg_catalog.spg_text_picksplit
	const sqlstr = `SELECT * FROM pg_catalog.spg_text_picksplit($1, $2)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1); err != nil {
		return logerror(err)
	}
	return nil
}

// Spghandler calls the stored function 'pg_catalog.spghandler(internal) index_am_handler' on db.
func Spghandler(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.IndexAmHandler, error) {
	// call pg_catalog.spghandler
	const sqlstr = `SELECT * FROM pg_catalog.spghandler($1)`
	// run
	var r0 pgtypes.IndexAmHandler
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.IndexAmHandler{}, logerror(err)
	}
	return r0, nil
}

// SplitPart calls the stored function 'pg_catalog.split_part(text, text, integer) text' on db.
func SplitPart(ctx context.Context, db DB, p0, p1 string, p2 int) (string, error) {
	// call pg_catalog.split_part
	const sqlstr = `SELECT * FROM pg_catalog.split_part($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SqrtByDoublePrecision calls the stored function 'pg_catalog.sqrt(double precision) double precision' on db.
func SqrtByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.sqrt
	const sqlstr = `SELECT * FROM pg_catalog.sqrt($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// SqrtByNumeric calls the stored function 'pg_catalog.sqrt(numeric) numeric' on db.
func SqrtByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.sqrt
	const sqlstr = `SELECT * FROM pg_catalog.sqrt($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// StartsWith calls the stored function 'pg_catalog.starts_with(text, text) boolean' on db.
func StartsWith(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.starts_with
	const sqlstr = `SELECT * FROM pg_catalog.starts_with($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// StatementTimestamp calls the stored function 'pg_catalog.statement_timestamp() timestamp with time zone' on db.
func StatementTimestamp(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.statement_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.statement_timestamp()`
	// run
	var r0 time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// StringAggFinalfn calls the stored function 'pg_catalog.string_agg_finalfn(internal) text' on db.
func StringAggFinalfn(ctx context.Context, db DB, p0 pgtypes.Internal) (string, error) {
	// call pg_catalog.string_agg_finalfn
	const sqlstr = `SELECT * FROM pg_catalog.string_agg_finalfn($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// StringAggTransfn calls the stored function 'pg_catalog.string_agg_transfn(internal, text, text) internal' on db.
func StringAggTransfn(ctx context.Context, db DB, p0 pgtypes.Internal, p1, p2 string) (pgtypes.Internal, error) {
	// call pg_catalog.string_agg_transfn
	const sqlstr = `SELECT * FROM pg_catalog.string_agg_transfn($1, $2, $3)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// StringToArrayByTextTextAndText calls the stored function 'pg_catalog.string_to_array(text, text, text) text' on db.
func StringToArrayByTextTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (StringSlice, error) {
	// call pg_catalog.string_to_array
	const sqlstr = `SELECT * FROM pg_catalog.string_to_array($1, $2, $3)`
	// run
	var r0 StringSlice
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// StringToArrayByTextAndText calls the stored function 'pg_catalog.string_to_array(text, text) text' on db.
func StringToArrayByTextAndText(ctx context.Context, db DB, p0, p1 string) (StringSlice, error) {
	// call pg_catalog.string_to_array
	const sqlstr = `SELECT * FROM pg_catalog.string_to_array($1, $2)`
	// run
	var r0 StringSlice
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// Strip calls the stored function 'pg_catalog.strip(tsvector) tsvector' on db.
func Strip(ctx context.Context, db DB, p0 pgtypes.Tsvector) (pgtypes.Tsvector, error) {
	// call pg_catalog.strip
	const sqlstr = `SELECT * FROM pg_catalog.strip($1)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// Strpos calls the stored function 'pg_catalog.strpos(text, text) integer' on db.
func Strpos(ctx context.Context, db DB, p0, p1 string) (int, error) {
	// call pg_catalog.strpos
	const sqlstr = `SELECT * FROM pg_catalog.strpos($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// SubstrByByteaIntegerAndInteger calls the stored function 'pg_catalog.substr(bytea, integer, integer) bytea' on db.
func SubstrByByteaIntegerAndInteger(ctx context.Context, db DB, p0 []byte, p1, p2 int) ([]byte, error) {
	// call pg_catalog.substr
	const sqlstr = `SELECT * FROM pg_catalog.substr($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// SubstrByByteaAndInteger calls the stored function 'pg_catalog.substr(bytea, integer) bytea' on db.
func SubstrByByteaAndInteger(ctx context.Context, db DB, p0 []byte, p1 int) ([]byte, error) {
	// call pg_catalog.substr
	const sqlstr = `SELECT * FROM pg_catalog.substr($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// SubstrByTextIntegerAndInteger calls the stored function 'pg_catalog.substr(text, integer, integer) text' on db.
func SubstrByTextIntegerAndInteger(ctx context.Context, db DB, p0 string, p1, p2 int) (string, error) {
	// call pg_catalog.substr
	const sqlstr = `SELECT * FROM pg_catalog.substr($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SubstrByTextAndInteger calls the stored function 'pg_catalog.substr(text, integer) text' on db.
func SubstrByTextAndInteger(ctx context.Context, db DB, p0 string, p1 int) (string, error) {
	// call pg_catalog.substr
	const sqlstr = `SELECT * FROM pg_catalog.substr($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SubstringByBitIntegerAndInteger calls the stored function 'pg_catalog.substring(bit, integer, integer) bit' on db.
func SubstringByBitIntegerAndInteger(ctx context.Context, db DB, p0 uint8, p1, p2 int) (uint8, error) {
	// call pg_catalog.substring
	const sqlstr = `SELECT * FROM pg_catalog.substring($1, $2, $3)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// SubstringByBitAndInteger calls the stored function 'pg_catalog.substring(bit, integer) bit' on db.
func SubstringByBitAndInteger(ctx context.Context, db DB, p0 uint8, p1 int) (uint8, error) {
	// call pg_catalog.substring
	const sqlstr = `SELECT * FROM pg_catalog.substring($1, $2)`
	// run
	var r0 uint8
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// SubstringByByteaIntegerAndInteger calls the stored function 'pg_catalog.substring(bytea, integer, integer) bytea' on db.
func SubstringByByteaIntegerAndInteger(ctx context.Context, db DB, p0 []byte, p1, p2 int) ([]byte, error) {
	// call pg_catalog.substring
	const sqlstr = `SELECT * FROM pg_catalog.substring($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// SubstringByByteaAndInteger calls the stored function 'pg_catalog.substring(bytea, integer) bytea' on db.
func SubstringByByteaAndInteger(ctx context.Context, db DB, p0 []byte, p1 int) ([]byte, error) {
	// call pg_catalog.substring
	const sqlstr = `SELECT * FROM pg_catalog.substring($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// SubstringByTextAndText calls the stored function 'pg_catalog.substring(text, text) text' on db.
func SubstringByTextAndText(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.substring
	const sqlstr = `SELECT * FROM pg_catalog.substring($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SubstringByTextTextAndText calls the stored function 'pg_catalog.substring(text, text, text) text' on db.
func SubstringByTextTextAndText(ctx context.Context, db DB, p0, p1, p2 string) (string, error) {
	// call pg_catalog.substring
	const sqlstr = `SELECT * FROM pg_catalog.substring($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SubstringByTextIntegerAndInteger calls the stored function 'pg_catalog.substring(text, integer, integer) text' on db.
func SubstringByTextIntegerAndInteger(ctx context.Context, db DB, p0 string, p1, p2 int) (string, error) {
	// call pg_catalog.substring
	const sqlstr = `SELECT * FROM pg_catalog.substring($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SubstringByTextAndInteger calls the stored function 'pg_catalog.substring(text, integer) text' on db.
func SubstringByTextAndInteger(ctx context.Context, db DB, p0 string, p1 int) (string, error) {
	// call pg_catalog.substring
	const sqlstr = `SELECT * FROM pg_catalog.substring($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// SuppressRedundantUpdatesTrigger calls the stored function 'pg_catalog.suppress_redundant_updates_trigger() trigger' on db.
func SuppressRedundantUpdatesTrigger(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.suppress_redundant_updates_trigger
	const sqlstr = `SELECT * FROM pg_catalog.suppress_redundant_updates_trigger()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// System calls the stored function 'pg_catalog.system(internal) tsm_handler' on db.
func System(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.TsmHandler, error) {
	// call pg_catalog.system
	const sqlstr = `SELECT * FROM pg_catalog.system($1)`
	// run
	var r0 pgtypes.TsmHandler
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.TsmHandler{}, logerror(err)
	}
	return r0, nil
}

// TableToXML calls the stored function 'pg_catalog.table_to_xml(regclass, boolean, boolean, text) xml' on db.
func TableToXML(ctx context.Context, db DB, tbl pgtypes.Regclass, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.table_to_xml
	const sqlstr = `SELECT * FROM pg_catalog.table_to_xml($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, tbl, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, tbl, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TableToXMLAndXmlschema calls the stored function 'pg_catalog.table_to_xml_and_xmlschema(regclass, boolean, boolean, text) xml' on db.
func TableToXMLAndXmlschema(ctx context.Context, db DB, tbl pgtypes.Regclass, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.table_to_xml_and_xmlschema
	const sqlstr = `SELECT * FROM pg_catalog.table_to_xml_and_xmlschema($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, tbl, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, tbl, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TableToXmlschema calls the stored function 'pg_catalog.table_to_xmlschema(regclass, boolean, boolean, text) xml' on db.
func TableToXmlschema(ctx context.Context, db DB, tbl pgtypes.Regclass, nulls, tableforest bool, targetns string) ([]byte, error) {
	// call pg_catalog.table_to_xmlschema
	const sqlstr = `SELECT * FROM pg_catalog.table_to_xmlschema($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, tbl, nulls, tableforest, targetns)
	if err := db.QueryRowContext(ctx, sqlstr, tbl, nulls, tableforest, targetns).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Tan calls the stored function 'pg_catalog.tan(double precision) double precision' on db.
func Tan(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.tan
	const sqlstr = `SELECT * FROM pg_catalog.tan($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Tand calls the stored function 'pg_catalog.tand(double precision) double precision' on db.
func Tand(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.tand
	const sqlstr = `SELECT * FROM pg_catalog.tand($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Tanh calls the stored function 'pg_catalog.tanh(double precision) double precision' on db.
func Tanh(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.tanh
	const sqlstr = `SELECT * FROM pg_catalog.tanh($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TextByXML calls the stored function 'pg_catalog.text(xml) text' on db.
func TextByXML(ctx context.Context, db DB, p0 []byte) (string, error) {
	// call pg_catalog.text
	const sqlstr = `SELECT * FROM pg_catalog.text($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TextByBoolean calls the stored function 'pg_catalog.text(boolean) text' on db.
func TextByBoolean(ctx context.Context, db DB, p0 bool) (string, error) {
	// call pg_catalog.text
	const sqlstr = `SELECT * FROM pg_catalog.text($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TextByCharacter calls the stored function 'pg_catalog.text(character) text' on db.
func TextByCharacter(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.text
	const sqlstr = `SELECT * FROM pg_catalog.text($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TextByName calls the stored function 'pg_catalog.text(name) text' on db.
func TextByName(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.text
	const sqlstr = `SELECT * FROM pg_catalog.text($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TextByInet calls the stored function 'pg_catalog.text(inet) text' on db.
func TextByInet(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.text
	const sqlstr = `SELECT * FROM pg_catalog.text($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TextByChar calls the stored function 'pg_catalog.text("char") text' on db.
func TextByChar(ctx context.Context, db DB, p0 pgtypes.Char) (string, error) {
	// call pg_catalog.text
	const sqlstr = `SELECT * FROM pg_catalog.text($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TextGe calls the stored function 'pg_catalog.text_ge(text, text) boolean' on db.
func TextGe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.text_ge
	const sqlstr = `SELECT * FROM pg_catalog.text_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TextGt calls the stored function 'pg_catalog.text_gt(text, text) boolean' on db.
func TextGt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.text_gt
	const sqlstr = `SELECT * FROM pg_catalog.text_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TextLarger calls the stored function 'pg_catalog.text_larger(text, text) text' on db.
func TextLarger(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.text_larger
	const sqlstr = `SELECT * FROM pg_catalog.text_larger($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TextLe calls the stored function 'pg_catalog.text_le(text, text) boolean' on db.
func TextLe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.text_le
	const sqlstr = `SELECT * FROM pg_catalog.text_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TextLt calls the stored function 'pg_catalog.text_lt(text, text) boolean' on db.
func TextLt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.text_lt
	const sqlstr = `SELECT * FROM pg_catalog.text_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TextPatternGe calls the stored function 'pg_catalog.text_pattern_ge(text, text) boolean' on db.
func TextPatternGe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.text_pattern_ge
	const sqlstr = `SELECT * FROM pg_catalog.text_pattern_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TextPatternGt calls the stored function 'pg_catalog.text_pattern_gt(text, text) boolean' on db.
func TextPatternGt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.text_pattern_gt
	const sqlstr = `SELECT * FROM pg_catalog.text_pattern_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TextPatternLe calls the stored function 'pg_catalog.text_pattern_le(text, text) boolean' on db.
func TextPatternLe(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.text_pattern_le
	const sqlstr = `SELECT * FROM pg_catalog.text_pattern_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TextPatternLt calls the stored function 'pg_catalog.text_pattern_lt(text, text) boolean' on db.
func TextPatternLt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.text_pattern_lt
	const sqlstr = `SELECT * FROM pg_catalog.text_pattern_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TextSmaller calls the stored function 'pg_catalog.text_smaller(text, text) text' on db.
func TextSmaller(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.text_smaller
	const sqlstr = `SELECT * FROM pg_catalog.text_smaller($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Textanycat calls the stored function 'pg_catalog.textanycat(text, anynonarray) text' on db.
func Textanycat(ctx context.Context, db DB, p0 string, p1 pgtypes.Anynonarray) (string, error) {
	// call pg_catalog.textanycat
	const sqlstr = `SELECT * FROM pg_catalog.textanycat($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Textcat calls the stored function 'pg_catalog.textcat(text, text) text' on db.
func Textcat(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.textcat
	const sqlstr = `SELECT * FROM pg_catalog.textcat($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Texteq calls the stored function 'pg_catalog.texteq(text, text) boolean' on db.
func Texteq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.texteq
	const sqlstr = `SELECT * FROM pg_catalog.texteq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Texteqname calls the stored function 'pg_catalog.texteqname(text, name) boolean' on db.
func Texteqname(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.texteqname
	const sqlstr = `SELECT * FROM pg_catalog.texteqname($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Textgename calls the stored function 'pg_catalog.textgename(text, name) boolean' on db.
func Textgename(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.textgename
	const sqlstr = `SELECT * FROM pg_catalog.textgename($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Textgtname calls the stored function 'pg_catalog.textgtname(text, name) boolean' on db.
func Textgtname(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.textgtname
	const sqlstr = `SELECT * FROM pg_catalog.textgtname($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Texticlike calls the stored function 'pg_catalog.texticlike(text, text) boolean' on db.
func Texticlike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.texticlike
	const sqlstr = `SELECT * FROM pg_catalog.texticlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TexticlikeSupport calls the stored function 'pg_catalog.texticlike_support(internal) internal' on db.
func TexticlikeSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.texticlike_support
	const sqlstr = `SELECT * FROM pg_catalog.texticlike_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Texticnlike calls the stored function 'pg_catalog.texticnlike(text, text) boolean' on db.
func Texticnlike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.texticnlike
	const sqlstr = `SELECT * FROM pg_catalog.texticnlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Texticregexeq calls the stored function 'pg_catalog.texticregexeq(text, text) boolean' on db.
func Texticregexeq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.texticregexeq
	const sqlstr = `SELECT * FROM pg_catalog.texticregexeq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TexticregexeqSupport calls the stored function 'pg_catalog.texticregexeq_support(internal) internal' on db.
func TexticregexeqSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.texticregexeq_support
	const sqlstr = `SELECT * FROM pg_catalog.texticregexeq_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Texticregexne calls the stored function 'pg_catalog.texticregexne(text, text) boolean' on db.
func Texticregexne(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.texticregexne
	const sqlstr = `SELECT * FROM pg_catalog.texticregexne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Textlen calls the stored function 'pg_catalog.textlen(text) integer' on db.
func Textlen(ctx context.Context, db DB, p0 string) (int, error) {
	// call pg_catalog.textlen
	const sqlstr = `SELECT * FROM pg_catalog.textlen($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Textlename calls the stored function 'pg_catalog.textlename(text, name) boolean' on db.
func Textlename(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.textlename
	const sqlstr = `SELECT * FROM pg_catalog.textlename($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Textlike calls the stored function 'pg_catalog.textlike(text, text) boolean' on db.
func Textlike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.textlike
	const sqlstr = `SELECT * FROM pg_catalog.textlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TextlikeSupport calls the stored function 'pg_catalog.textlike_support(internal) internal' on db.
func TextlikeSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.textlike_support
	const sqlstr = `SELECT * FROM pg_catalog.textlike_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Textltname calls the stored function 'pg_catalog.textltname(text, name) boolean' on db.
func Textltname(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.textltname
	const sqlstr = `SELECT * FROM pg_catalog.textltname($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Textne calls the stored function 'pg_catalog.textne(text, text) boolean' on db.
func Textne(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.textne
	const sqlstr = `SELECT * FROM pg_catalog.textne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Textnename calls the stored function 'pg_catalog.textnename(text, name) boolean' on db.
func Textnename(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.textnename
	const sqlstr = `SELECT * FROM pg_catalog.textnename($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Textnlike calls the stored function 'pg_catalog.textnlike(text, text) boolean' on db.
func Textnlike(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.textnlike
	const sqlstr = `SELECT * FROM pg_catalog.textnlike($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Textrecv calls the stored function 'pg_catalog.textrecv(internal) text' on db.
func Textrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (string, error) {
	// call pg_catalog.textrecv
	const sqlstr = `SELECT * FROM pg_catalog.textrecv($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Textregexeq calls the stored function 'pg_catalog.textregexeq(text, text) boolean' on db.
func Textregexeq(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.textregexeq
	const sqlstr = `SELECT * FROM pg_catalog.textregexeq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TextregexeqSupport calls the stored function 'pg_catalog.textregexeq_support(internal) internal' on db.
func TextregexeqSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.textregexeq_support
	const sqlstr = `SELECT * FROM pg_catalog.textregexeq_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Textregexne calls the stored function 'pg_catalog.textregexne(text, text) boolean' on db.
func Textregexne(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.textregexne
	const sqlstr = `SELECT * FROM pg_catalog.textregexne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Textsend calls the stored function 'pg_catalog.textsend(text) bytea' on db.
func Textsend(ctx context.Context, db DB, p0 string) ([]byte, error) {
	// call pg_catalog.textsend
	const sqlstr = `SELECT * FROM pg_catalog.textsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// ThesaurusInit calls the stored function 'pg_catalog.thesaurus_init(internal) internal' on db.
func ThesaurusInit(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.thesaurus_init
	const sqlstr = `SELECT * FROM pg_catalog.thesaurus_init($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// ThesaurusLexize calls the stored function 'pg_catalog.thesaurus_lexize(internal, internal, internal, internal) internal' on db.
func ThesaurusLexize(ctx context.Context, db DB, p0, p1, p2, p3 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.thesaurus_lexize
	const sqlstr = `SELECT * FROM pg_catalog.thesaurus_lexize($1, $2, $3, $4)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Tideq calls the stored function 'pg_catalog.tideq(tid, tid) boolean' on db.
func Tideq(ctx context.Context, db DB, p0, p1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tideq
	const sqlstr = `SELECT * FROM pg_catalog.tideq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Tidge calls the stored function 'pg_catalog.tidge(tid, tid) boolean' on db.
func Tidge(ctx context.Context, db DB, p0, p1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tidge
	const sqlstr = `SELECT * FROM pg_catalog.tidge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Tidgt calls the stored function 'pg_catalog.tidgt(tid, tid) boolean' on db.
func Tidgt(ctx context.Context, db DB, p0, p1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tidgt
	const sqlstr = `SELECT * FROM pg_catalog.tidgt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Tidlarger calls the stored function 'pg_catalog.tidlarger(tid, tid) tid' on db.
func Tidlarger(ctx context.Context, db DB, p0, p1 pgtypes.Tid) (pgtypes.Tid, error) {
	// call pg_catalog.tidlarger
	const sqlstr = `SELECT * FROM pg_catalog.tidlarger($1, $2)`
	// run
	var r0 pgtypes.Tid
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tid{}, logerror(err)
	}
	return r0, nil
}

// Tidle calls the stored function 'pg_catalog.tidle(tid, tid) boolean' on db.
func Tidle(ctx context.Context, db DB, p0, p1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tidle
	const sqlstr = `SELECT * FROM pg_catalog.tidle($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Tidlt calls the stored function 'pg_catalog.tidlt(tid, tid) boolean' on db.
func Tidlt(ctx context.Context, db DB, p0, p1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tidlt
	const sqlstr = `SELECT * FROM pg_catalog.tidlt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Tidne calls the stored function 'pg_catalog.tidne(tid, tid) boolean' on db.
func Tidne(ctx context.Context, db DB, p0, p1 pgtypes.Tid) (bool, error) {
	// call pg_catalog.tidne
	const sqlstr = `SELECT * FROM pg_catalog.tidne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Tidrecv calls the stored function 'pg_catalog.tidrecv(internal) tid' on db.
func Tidrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Tid, error) {
	// call pg_catalog.tidrecv
	const sqlstr = `SELECT * FROM pg_catalog.tidrecv($1)`
	// run
	var r0 pgtypes.Tid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tid{}, logerror(err)
	}
	return r0, nil
}

// Tidsend calls the stored function 'pg_catalog.tidsend(tid) bytea' on db.
func Tidsend(ctx context.Context, db DB, p0 pgtypes.Tid) ([]byte, error) {
	// call pg_catalog.tidsend
	const sqlstr = `SELECT * FROM pg_catalog.tidsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Tidsmaller calls the stored function 'pg_catalog.tidsmaller(tid, tid) tid' on db.
func Tidsmaller(ctx context.Context, db DB, p0, p1 pgtypes.Tid) (pgtypes.Tid, error) {
	// call pg_catalog.tidsmaller
	const sqlstr = `SELECT * FROM pg_catalog.tidsmaller($1, $2)`
	// run
	var r0 pgtypes.Tid
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tid{}, logerror(err)
	}
	return r0, nil
}

// TimeByTimestampWithoutTimeZone calls the stored function 'pg_catalog.time(timestamp without time zone) time without time zone' on db.
func TimeByTimestampWithoutTimeZone(ctx context.Context, db DB, p0 time.Time) (time.Time, error) {
	// call pg_catalog.time
	const sqlstr = `SELECT * FROM pg_catalog.time($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimeByInterval calls the stored function 'pg_catalog.time(interval) time without time zone' on db.
func TimeByInterval(ctx context.Context, db DB, p0 []byte) (time.Time, error) {
	// call pg_catalog.time
	const sqlstr = `SELECT * FROM pg_catalog.time($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimeByTimeWithoutTimeZoneAndInteger calls the stored function 'pg_catalog.time(time without time zone, integer) time without time zone' on db.
func TimeByTimeWithoutTimeZoneAndInteger(ctx context.Context, db DB, p0 time.Time, p1 int) (time.Time, error) {
	// call pg_catalog.time
	const sqlstr = `SELECT * FROM pg_catalog.time($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimeByTimestampWithTimeZone calls the stored function 'pg_catalog.time(timestamp with time zone) time without time zone' on db.
func TimeByTimestampWithTimeZone(ctx context.Context, db DB, p0 time.Time) (time.Time, error) {
	// call pg_catalog.time
	const sqlstr = `SELECT * FROM pg_catalog.time($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimeByTimeWithTimeZone calls the stored function 'pg_catalog.time(time with time zone) time without time zone' on db.
func TimeByTimeWithTimeZone(ctx context.Context, db DB, p0 time.Time) (time.Time, error) {
	// call pg_catalog.time
	const sqlstr = `SELECT * FROM pg_catalog.time($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimeCmp calls the stored function 'pg_catalog.time_cmp(time without time zone, time without time zone) integer' on db.
func TimeCmp(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.time_cmp
	const sqlstr = `SELECT * FROM pg_catalog.time_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimeEq calls the stored function 'pg_catalog.time_eq(time without time zone, time without time zone) boolean' on db.
func TimeEq(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.time_eq
	const sqlstr = `SELECT * FROM pg_catalog.time_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimeGe calls the stored function 'pg_catalog.time_ge(time without time zone, time without time zone) boolean' on db.
func TimeGe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.time_ge
	const sqlstr = `SELECT * FROM pg_catalog.time_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimeGt calls the stored function 'pg_catalog.time_gt(time without time zone, time without time zone) boolean' on db.
func TimeGt(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.time_gt
	const sqlstr = `SELECT * FROM pg_catalog.time_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimeHash calls the stored function 'pg_catalog.time_hash(time without time zone) integer' on db.
func TimeHash(ctx context.Context, db DB, p0 time.Time) (int, error) {
	// call pg_catalog.time_hash
	const sqlstr = `SELECT * FROM pg_catalog.time_hash($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimeHashExtended calls the stored function 'pg_catalog.time_hash_extended(time without time zone, bigint) bigint' on db.
func TimeHashExtended(ctx context.Context, db DB, p0 time.Time, p1 int64) (int64, error) {
	// call pg_catalog.time_hash_extended
	const sqlstr = `SELECT * FROM pg_catalog.time_hash_extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimeLarger calls the stored function 'pg_catalog.time_larger(time without time zone, time without time zone) time without time zone' on db.
func TimeLarger(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.time_larger
	const sqlstr = `SELECT * FROM pg_catalog.time_larger($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimeLe calls the stored function 'pg_catalog.time_le(time without time zone, time without time zone) boolean' on db.
func TimeLe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.time_le
	const sqlstr = `SELECT * FROM pg_catalog.time_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimeLt calls the stored function 'pg_catalog.time_lt(time without time zone, time without time zone) boolean' on db.
func TimeLt(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.time_lt
	const sqlstr = `SELECT * FROM pg_catalog.time_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimeMiInterval calls the stored function 'pg_catalog.time_mi_interval(time without time zone, interval) time without time zone' on db.
func TimeMiInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte) (time.Time, error) {
	// call pg_catalog.time_mi_interval
	const sqlstr = `SELECT * FROM pg_catalog.time_mi_interval($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimeMiTime calls the stored function 'pg_catalog.time_mi_time(time without time zone, time without time zone) interval' on db.
func TimeMiTime(ctx context.Context, db DB, p0, p1 time.Time) ([]byte, error) {
	// call pg_catalog.time_mi_time
	const sqlstr = `SELECT * FROM pg_catalog.time_mi_time($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TimeNe calls the stored function 'pg_catalog.time_ne(time without time zone, time without time zone) boolean' on db.
func TimeNe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.time_ne
	const sqlstr = `SELECT * FROM pg_catalog.time_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimePlInterval calls the stored function 'pg_catalog.time_pl_interval(time without time zone, interval) time without time zone' on db.
func TimePlInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte) (time.Time, error) {
	// call pg_catalog.time_pl_interval
	const sqlstr = `SELECT * FROM pg_catalog.time_pl_interval($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimeRecv calls the stored function 'pg_catalog.time_recv(internal, oid, integer) time without time zone' on db.
func TimeRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (time.Time, error) {
	// call pg_catalog.time_recv
	const sqlstr = `SELECT * FROM pg_catalog.time_recv($1, $2, $3)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimeSend calls the stored function 'pg_catalog.time_send(time without time zone) bytea' on db.
func TimeSend(ctx context.Context, db DB, p0 time.Time) ([]byte, error) {
	// call pg_catalog.time_send
	const sqlstr = `SELECT * FROM pg_catalog.time_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TimeSmaller calls the stored function 'pg_catalog.time_smaller(time without time zone, time without time zone) time without time zone' on db.
func TimeSmaller(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.time_smaller
	const sqlstr = `SELECT * FROM pg_catalog.time_smaller($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimeSupport calls the stored function 'pg_catalog.time_support(internal) internal' on db.
func TimeSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.time_support
	const sqlstr = `SELECT * FROM pg_catalog.time_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// TimedatePl calls the stored function 'pg_catalog.timedate_pl(time without time zone, date) timestamp without time zone' on db.
func TimedatePl(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timedate_pl
	const sqlstr = `SELECT * FROM pg_catalog.timedate_pl($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// Timeofday calls the stored function 'pg_catalog.timeofday() text' on db.
func Timeofday(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.timeofday
	const sqlstr = `SELECT * FROM pg_catalog.timeofday()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TimestampByTimestampWithoutTimeZoneAndInteger calls the stored function 'pg_catalog.timestamp(timestamp without time zone, integer) timestamp without time zone' on db.
func TimestampByTimestampWithoutTimeZoneAndInteger(ctx context.Context, db DB, p0 time.Time, p1 int) (time.Time, error) {
	// call pg_catalog.timestamp
	const sqlstr = `SELECT * FROM pg_catalog.timestamp($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestampByDate calls the stored function 'pg_catalog.timestamp(date) timestamp without time zone' on db.
func TimestampByDate(ctx context.Context, db DB, p0 time.Time) (time.Time, error) {
	// call pg_catalog.timestamp
	const sqlstr = `SELECT * FROM pg_catalog.timestamp($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestampByDateAndTimeWithoutTimeZone calls the stored function 'pg_catalog.timestamp(date, time without time zone) timestamp without time zone' on db.
func TimestampByDateAndTimeWithoutTimeZone(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timestamp
	const sqlstr = `SELECT * FROM pg_catalog.timestamp($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestampByTimestampWithTimeZone calls the stored function 'pg_catalog.timestamp(timestamp with time zone) timestamp without time zone' on db.
func TimestampByTimestampWithTimeZone(ctx context.Context, db DB, p0 time.Time) (time.Time, error) {
	// call pg_catalog.timestamp
	const sqlstr = `SELECT * FROM pg_catalog.timestamp($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestampCmp calls the stored function 'pg_catalog.timestamp_cmp(timestamp without time zone, timestamp without time zone) integer' on db.
func TimestampCmp(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.timestamp_cmp
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimestampCmpDate calls the stored function 'pg_catalog.timestamp_cmp_date(timestamp without time zone, date) integer' on db.
func TimestampCmpDate(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.timestamp_cmp_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_cmp_date($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimestampCmpTimestamptz calls the stored function 'pg_catalog.timestamp_cmp_timestamptz(timestamp without time zone, timestamp with time zone) integer' on db.
func TimestampCmpTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.timestamp_cmp_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_cmp_timestamptz($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimestampEq calls the stored function 'pg_catalog.timestamp_eq(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampEq(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_eq
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampEqDate calls the stored function 'pg_catalog.timestamp_eq_date(timestamp without time zone, date) boolean' on db.
func TimestampEqDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_eq_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_eq_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampEqTimestamptz calls the stored function 'pg_catalog.timestamp_eq_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampEqTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_eq_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_eq_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampGe calls the stored function 'pg_catalog.timestamp_ge(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampGe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ge
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampGeDate calls the stored function 'pg_catalog.timestamp_ge_date(timestamp without time zone, date) boolean' on db.
func TimestampGeDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ge_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_ge_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampGeTimestamptz calls the stored function 'pg_catalog.timestamp_ge_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampGeTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ge_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_ge_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampGt calls the stored function 'pg_catalog.timestamp_gt(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampGt(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_gt
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampGtDate calls the stored function 'pg_catalog.timestamp_gt_date(timestamp without time zone, date) boolean' on db.
func TimestampGtDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_gt_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_gt_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampGtTimestamptz calls the stored function 'pg_catalog.timestamp_gt_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampGtTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_gt_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_gt_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampHash calls the stored function 'pg_catalog.timestamp_hash(timestamp without time zone) integer' on db.
func TimestampHash(ctx context.Context, db DB, p0 time.Time) (int, error) {
	// call pg_catalog.timestamp_hash
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_hash($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimestampHashExtended calls the stored function 'pg_catalog.timestamp_hash_extended(timestamp without time zone, bigint) bigint' on db.
func TimestampHashExtended(ctx context.Context, db DB, p0 time.Time, p1 int64) (int64, error) {
	// call pg_catalog.timestamp_hash_extended
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_hash_extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimestampLarger calls the stored function 'pg_catalog.timestamp_larger(timestamp without time zone, timestamp without time zone) timestamp without time zone' on db.
func TimestampLarger(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timestamp_larger
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_larger($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestampLe calls the stored function 'pg_catalog.timestamp_le(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampLe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_le
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampLeDate calls the stored function 'pg_catalog.timestamp_le_date(timestamp without time zone, date) boolean' on db.
func TimestampLeDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_le_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_le_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampLeTimestamptz calls the stored function 'pg_catalog.timestamp_le_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampLeTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_le_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_le_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampLt calls the stored function 'pg_catalog.timestamp_lt(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampLt(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_lt
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampLtDate calls the stored function 'pg_catalog.timestamp_lt_date(timestamp without time zone, date) boolean' on db.
func TimestampLtDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_lt_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_lt_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampLtTimestamptz calls the stored function 'pg_catalog.timestamp_lt_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampLtTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_lt_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_lt_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampMi calls the stored function 'pg_catalog.timestamp_mi(timestamp without time zone, timestamp without time zone) interval' on db.
func TimestampMi(ctx context.Context, db DB, p0, p1 time.Time) ([]byte, error) {
	// call pg_catalog.timestamp_mi
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_mi($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TimestampMiInterval calls the stored function 'pg_catalog.timestamp_mi_interval(timestamp without time zone, interval) timestamp without time zone' on db.
func TimestampMiInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte) (time.Time, error) {
	// call pg_catalog.timestamp_mi_interval
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_mi_interval($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestampNe calls the stored function 'pg_catalog.timestamp_ne(timestamp without time zone, timestamp without time zone) boolean' on db.
func TimestampNe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ne
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampNeDate calls the stored function 'pg_catalog.timestamp_ne_date(timestamp without time zone, date) boolean' on db.
func TimestampNeDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ne_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_ne_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampNeTimestamptz calls the stored function 'pg_catalog.timestamp_ne_timestamptz(timestamp without time zone, timestamp with time zone) boolean' on db.
func TimestampNeTimestamptz(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamp_ne_timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_ne_timestamptz($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestampPlInterval calls the stored function 'pg_catalog.timestamp_pl_interval(timestamp without time zone, interval) timestamp without time zone' on db.
func TimestampPlInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte) (time.Time, error) {
	// call pg_catalog.timestamp_pl_interval
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_pl_interval($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestampRecv calls the stored function 'pg_catalog.timestamp_recv(internal, oid, integer) timestamp without time zone' on db.
func TimestampRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (time.Time, error) {
	// call pg_catalog.timestamp_recv
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_recv($1, $2, $3)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestampSend calls the stored function 'pg_catalog.timestamp_send(timestamp without time zone) bytea' on db.
func TimestampSend(ctx context.Context, db DB, p0 time.Time) ([]byte, error) {
	// call pg_catalog.timestamp_send
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TimestampSmaller calls the stored function 'pg_catalog.timestamp_smaller(timestamp without time zone, timestamp without time zone) timestamp without time zone' on db.
func TimestampSmaller(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timestamp_smaller
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_smaller($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestampSortsupport calls the stored function 'pg_catalog.timestamp_sortsupport(internal)' on db.
func TimestampSortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.timestamp_sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// TimestampSupport calls the stored function 'pg_catalog.timestamp_support(internal) internal' on db.
func TimestampSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.timestamp_support
	const sqlstr = `SELECT * FROM pg_catalog.timestamp_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Timestamptypmodin calls the stored function 'pg_catalog.timestamptypmodin(cstring) integer' on db.
func Timestamptypmodin(ctx context.Context, db DB, p0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.timestamptypmodin
	const sqlstr = `SELECT * FROM pg_catalog.timestamptypmodin($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimestamptzByDate calls the stored function 'pg_catalog.timestamptz(date) timestamp with time zone' on db.
func TimestamptzByDate(ctx context.Context, db DB, p0 time.Time) (time.Time, error) {
	// call pg_catalog.timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestamptzByDateAndTimeWithoutTimeZone calls the stored function 'pg_catalog.timestamptz(date, time without time zone) timestamp with time zone' on db.
func TimestamptzByDateAndTimeWithoutTimeZone(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestamptzByDateAndTimeWithTimeZone calls the stored function 'pg_catalog.timestamptz(date, time with time zone) timestamp with time zone' on db.
func TimestamptzByDateAndTimeWithTimeZone(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestamptzByTimestampWithTimeZoneAndInteger calls the stored function 'pg_catalog.timestamptz(timestamp with time zone, integer) timestamp with time zone' on db.
func TimestamptzByTimestampWithTimeZoneAndInteger(ctx context.Context, db DB, p0 time.Time, p1 int) (time.Time, error) {
	// call pg_catalog.timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestamptzByTimestampWithoutTimeZone calls the stored function 'pg_catalog.timestamptz(timestamp without time zone) timestamp with time zone' on db.
func TimestamptzByTimestampWithoutTimeZone(ctx context.Context, db DB, p0 time.Time) (time.Time, error) {
	// call pg_catalog.timestamptz
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestamptzCmp calls the stored function 'pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone) integer' on db.
func TimestamptzCmp(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.timestamptz_cmp
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimestamptzCmpDate calls the stored function 'pg_catalog.timestamptz_cmp_date(timestamp with time zone, date) integer' on db.
func TimestamptzCmpDate(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.timestamptz_cmp_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_cmp_date($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimestamptzCmpTimestamp calls the stored function 'pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp without time zone) integer' on db.
func TimestamptzCmpTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.timestamptz_cmp_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_cmp_timestamp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimestamptzEq calls the stored function 'pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzEq(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_eq
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzEqDate calls the stored function 'pg_catalog.timestamptz_eq_date(timestamp with time zone, date) boolean' on db.
func TimestamptzEqDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_eq_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_eq_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzEqTimestamp calls the stored function 'pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzEqTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_eq_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_eq_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzGe calls the stored function 'pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzGe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ge
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzGeDate calls the stored function 'pg_catalog.timestamptz_ge_date(timestamp with time zone, date) boolean' on db.
func TimestamptzGeDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ge_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_ge_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzGeTimestamp calls the stored function 'pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzGeTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ge_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_ge_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzGt calls the stored function 'pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzGt(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_gt
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzGtDate calls the stored function 'pg_catalog.timestamptz_gt_date(timestamp with time zone, date) boolean' on db.
func TimestamptzGtDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_gt_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_gt_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzGtTimestamp calls the stored function 'pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzGtTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_gt_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_gt_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzLarger calls the stored function 'pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone) timestamp with time zone' on db.
func TimestamptzLarger(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timestamptz_larger
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_larger($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestamptzLe calls the stored function 'pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzLe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_le
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzLeDate calls the stored function 'pg_catalog.timestamptz_le_date(timestamp with time zone, date) boolean' on db.
func TimestamptzLeDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_le_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_le_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzLeTimestamp calls the stored function 'pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzLeTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_le_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_le_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzLt calls the stored function 'pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzLt(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_lt
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzLtDate calls the stored function 'pg_catalog.timestamptz_lt_date(timestamp with time zone, date) boolean' on db.
func TimestamptzLtDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_lt_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_lt_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzLtTimestamp calls the stored function 'pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzLtTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_lt_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_lt_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzMi calls the stored function 'pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone) interval' on db.
func TimestamptzMi(ctx context.Context, db DB, p0, p1 time.Time) ([]byte, error) {
	// call pg_catalog.timestamptz_mi
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_mi($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TimestamptzMiInterval calls the stored function 'pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval) timestamp with time zone' on db.
func TimestamptzMiInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte) (time.Time, error) {
	// call pg_catalog.timestamptz_mi_interval
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_mi_interval($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestamptzNe calls the stored function 'pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone) boolean' on db.
func TimestamptzNe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ne
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzNeDate calls the stored function 'pg_catalog.timestamptz_ne_date(timestamp with time zone, date) boolean' on db.
func TimestamptzNeDate(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ne_date
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_ne_date($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzNeTimestamp calls the stored function 'pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp without time zone) boolean' on db.
func TimestamptzNeTimestamp(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timestamptz_ne_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_ne_timestamp($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimestamptzPlInterval calls the stored function 'pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval) timestamp with time zone' on db.
func TimestamptzPlInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte) (time.Time, error) {
	// call pg_catalog.timestamptz_pl_interval
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_pl_interval($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestamptzRecv calls the stored function 'pg_catalog.timestamptz_recv(internal, oid, integer) timestamp with time zone' on db.
func TimestamptzRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (time.Time, error) {
	// call pg_catalog.timestamptz_recv
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_recv($1, $2, $3)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimestamptzSend calls the stored function 'pg_catalog.timestamptz_send(timestamp with time zone) bytea' on db.
func TimestamptzSend(ctx context.Context, db DB, p0 time.Time) ([]byte, error) {
	// call pg_catalog.timestamptz_send
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TimestamptzSmaller calls the stored function 'pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone) timestamp with time zone' on db.
func TimestamptzSmaller(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timestamptz_smaller
	const sqlstr = `SELECT * FROM pg_catalog.timestamptz_smaller($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// Timestamptztypmodin calls the stored function 'pg_catalog.timestamptztypmodin(cstring) integer' on db.
func Timestamptztypmodin(ctx context.Context, db DB, p0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.timestamptztypmodin
	const sqlstr = `SELECT * FROM pg_catalog.timestamptztypmodin($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Timetypmodin calls the stored function 'pg_catalog.timetypmodin(cstring) integer' on db.
func Timetypmodin(ctx context.Context, db DB, p0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.timetypmodin
	const sqlstr = `SELECT * FROM pg_catalog.timetypmodin($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimetzByTimestampWithTimeZone calls the stored function 'pg_catalog.timetz(timestamp with time zone) time with time zone' on db.
func TimetzByTimestampWithTimeZone(ctx context.Context, db DB, p0 time.Time) (time.Time, error) {
	// call pg_catalog.timetz
	const sqlstr = `SELECT * FROM pg_catalog.timetz($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimetzByTimeWithTimeZoneAndInteger calls the stored function 'pg_catalog.timetz(time with time zone, integer) time with time zone' on db.
func TimetzByTimeWithTimeZoneAndInteger(ctx context.Context, db DB, p0 time.Time, p1 int) (time.Time, error) {
	// call pg_catalog.timetz
	const sqlstr = `SELECT * FROM pg_catalog.timetz($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimetzByTimeWithoutTimeZone calls the stored function 'pg_catalog.timetz(time without time zone) time with time zone' on db.
func TimetzByTimeWithoutTimeZone(ctx context.Context, db DB, p0 time.Time) (time.Time, error) {
	// call pg_catalog.timetz
	const sqlstr = `SELECT * FROM pg_catalog.timetz($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimetzCmp calls the stored function 'pg_catalog.timetz_cmp(time with time zone, time with time zone) integer' on db.
func TimetzCmp(ctx context.Context, db DB, p0, p1 time.Time) (int, error) {
	// call pg_catalog.timetz_cmp
	const sqlstr = `SELECT * FROM pg_catalog.timetz_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimetzEq calls the stored function 'pg_catalog.timetz_eq(time with time zone, time with time zone) boolean' on db.
func TimetzEq(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timetz_eq
	const sqlstr = `SELECT * FROM pg_catalog.timetz_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimetzGe calls the stored function 'pg_catalog.timetz_ge(time with time zone, time with time zone) boolean' on db.
func TimetzGe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timetz_ge
	const sqlstr = `SELECT * FROM pg_catalog.timetz_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimetzGt calls the stored function 'pg_catalog.timetz_gt(time with time zone, time with time zone) boolean' on db.
func TimetzGt(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timetz_gt
	const sqlstr = `SELECT * FROM pg_catalog.timetz_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimetzHash calls the stored function 'pg_catalog.timetz_hash(time with time zone) integer' on db.
func TimetzHash(ctx context.Context, db DB, p0 time.Time) (int, error) {
	// call pg_catalog.timetz_hash
	const sqlstr = `SELECT * FROM pg_catalog.timetz_hash($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimetzHashExtended calls the stored function 'pg_catalog.timetz_hash_extended(time with time zone, bigint) bigint' on db.
func TimetzHashExtended(ctx context.Context, db DB, p0 time.Time, p1 int64) (int64, error) {
	// call pg_catalog.timetz_hash_extended
	const sqlstr = `SELECT * FROM pg_catalog.timetz_hash_extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimetzLarger calls the stored function 'pg_catalog.timetz_larger(time with time zone, time with time zone) time with time zone' on db.
func TimetzLarger(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timetz_larger
	const sqlstr = `SELECT * FROM pg_catalog.timetz_larger($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimetzLe calls the stored function 'pg_catalog.timetz_le(time with time zone, time with time zone) boolean' on db.
func TimetzLe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timetz_le
	const sqlstr = `SELECT * FROM pg_catalog.timetz_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimetzLt calls the stored function 'pg_catalog.timetz_lt(time with time zone, time with time zone) boolean' on db.
func TimetzLt(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timetz_lt
	const sqlstr = `SELECT * FROM pg_catalog.timetz_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimetzMiInterval calls the stored function 'pg_catalog.timetz_mi_interval(time with time zone, interval) time with time zone' on db.
func TimetzMiInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte) (time.Time, error) {
	// call pg_catalog.timetz_mi_interval
	const sqlstr = `SELECT * FROM pg_catalog.timetz_mi_interval($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimetzNe calls the stored function 'pg_catalog.timetz_ne(time with time zone, time with time zone) boolean' on db.
func TimetzNe(ctx context.Context, db DB, p0, p1 time.Time) (bool, error) {
	// call pg_catalog.timetz_ne
	const sqlstr = `SELECT * FROM pg_catalog.timetz_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TimetzPlInterval calls the stored function 'pg_catalog.timetz_pl_interval(time with time zone, interval) time with time zone' on db.
func TimetzPlInterval(ctx context.Context, db DB, p0 time.Time, p1 []byte) (time.Time, error) {
	// call pg_catalog.timetz_pl_interval
	const sqlstr = `SELECT * FROM pg_catalog.timetz_pl_interval($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimetzRecv calls the stored function 'pg_catalog.timetz_recv(internal, oid, integer) time with time zone' on db.
func TimetzRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (time.Time, error) {
	// call pg_catalog.timetz_recv
	const sqlstr = `SELECT * FROM pg_catalog.timetz_recv($1, $2, $3)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimetzSend calls the stored function 'pg_catalog.timetz_send(time with time zone) bytea' on db.
func TimetzSend(ctx context.Context, db DB, p0 time.Time) ([]byte, error) {
	// call pg_catalog.timetz_send
	const sqlstr = `SELECT * FROM pg_catalog.timetz_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TimetzSmaller calls the stored function 'pg_catalog.timetz_smaller(time with time zone, time with time zone) time with time zone' on db.
func TimetzSmaller(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timetz_smaller
	const sqlstr = `SELECT * FROM pg_catalog.timetz_smaller($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimetzdatePl calls the stored function 'pg_catalog.timetzdate_pl(time with time zone, date) timestamp with time zone' on db.
func TimetzdatePl(ctx context.Context, db DB, p0, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timetzdate_pl
	const sqlstr = `SELECT * FROM pg_catalog.timetzdate_pl($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// Timetztypmodin calls the stored function 'pg_catalog.timetztypmodin(cstring) integer' on db.
func Timetztypmodin(ctx context.Context, db DB, p0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.timetztypmodin
	const sqlstr = `SELECT * FROM pg_catalog.timetztypmodin($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TimezoneByIntervalAndTimestampWithTimeZone calls the stored function 'pg_catalog.timezone(interval, timestamp with time zone) timestamp without time zone' on db.
func TimezoneByIntervalAndTimestampWithTimeZone(ctx context.Context, db DB, p0 []byte, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timezone
	const sqlstr = `SELECT * FROM pg_catalog.timezone($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimezoneByTextAndTimestampWithTimeZone calls the stored function 'pg_catalog.timezone(text, timestamp with time zone) timestamp without time zone' on db.
func TimezoneByTextAndTimestampWithTimeZone(ctx context.Context, db DB, p0 string, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timezone
	const sqlstr = `SELECT * FROM pg_catalog.timezone($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimezoneByTextAndTimeWithTimeZone calls the stored function 'pg_catalog.timezone(text, time with time zone) time with time zone' on db.
func TimezoneByTextAndTimeWithTimeZone(ctx context.Context, db DB, p0 string, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timezone
	const sqlstr = `SELECT * FROM pg_catalog.timezone($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimezoneByIntervalAndTimeWithTimeZone calls the stored function 'pg_catalog.timezone(interval, time with time zone) time with time zone' on db.
func TimezoneByIntervalAndTimeWithTimeZone(ctx context.Context, db DB, p0 []byte, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timezone
	const sqlstr = `SELECT * FROM pg_catalog.timezone($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimezoneByTextAndTimestampWithoutTimeZone calls the stored function 'pg_catalog.timezone(text, timestamp without time zone) timestamp with time zone' on db.
func TimezoneByTextAndTimestampWithoutTimeZone(ctx context.Context, db DB, p0 string, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timezone
	const sqlstr = `SELECT * FROM pg_catalog.timezone($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// TimezoneByIntervalAndTimestampWithoutTimeZone calls the stored function 'pg_catalog.timezone(interval, timestamp without time zone) timestamp with time zone' on db.
func TimezoneByIntervalAndTimestampWithoutTimeZone(ctx context.Context, db DB, p0 []byte, p1 time.Time) (time.Time, error) {
	// call pg_catalog.timezone
	const sqlstr = `SELECT * FROM pg_catalog.timezone($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// ToASCIIByText calls the stored function 'pg_catalog.to_ascii(text) text' on db.
func ToASCIIByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.to_ascii
	const sqlstr = `SELECT * FROM pg_catalog.to_ascii($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToASCIIByTextAndInteger calls the stored function 'pg_catalog.to_ascii(text, integer) text' on db.
func ToASCIIByTextAndInteger(ctx context.Context, db DB, p0 string, p1 int) (string, error) {
	// call pg_catalog.to_ascii
	const sqlstr = `SELECT * FROM pg_catalog.to_ascii($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToASCIIByTextAndName calls the stored function 'pg_catalog.to_ascii(text, name) text' on db.
func ToASCIIByTextAndName(ctx context.Context, db DB, p0, p1 string) (string, error) {
	// call pg_catalog.to_ascii
	const sqlstr = `SELECT * FROM pg_catalog.to_ascii($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToCharByIntervalAndText calls the stored function 'pg_catalog.to_char(interval, text) text' on db.
func ToCharByIntervalAndText(ctx context.Context, db DB, p0 []byte, p1 string) (string, error) {
	// call pg_catalog.to_char
	const sqlstr = `SELECT * FROM pg_catalog.to_char($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToCharByTimestampWithTimeZoneAndText calls the stored function 'pg_catalog.to_char(timestamp with time zone, text) text' on db.
func ToCharByTimestampWithTimeZoneAndText(ctx context.Context, db DB, p0 time.Time, p1 string) (string, error) {
	// call pg_catalog.to_char
	const sqlstr = `SELECT * FROM pg_catalog.to_char($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToCharByNumericAndText calls the stored function 'pg_catalog.to_char(numeric, text) text' on db.
func ToCharByNumericAndText(ctx context.Context, db DB, p0 float64, p1 string) (string, error) {
	// call pg_catalog.to_char
	const sqlstr = `SELECT * FROM pg_catalog.to_char($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToCharByIntegerAndText calls the stored function 'pg_catalog.to_char(integer, text) text' on db.
func ToCharByIntegerAndText(ctx context.Context, db DB, p0 int, p1 string) (string, error) {
	// call pg_catalog.to_char
	const sqlstr = `SELECT * FROM pg_catalog.to_char($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToCharByBigintAndText calls the stored function 'pg_catalog.to_char(bigint, text) text' on db.
func ToCharByBigintAndText(ctx context.Context, db DB, p0 int64, p1 string) (string, error) {
	// call pg_catalog.to_char
	const sqlstr = `SELECT * FROM pg_catalog.to_char($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToCharByRealAndText calls the stored function 'pg_catalog.to_char(real, text) text' on db.
func ToCharByRealAndText(ctx context.Context, db DB, p0 float32, p1 string) (string, error) {
	// call pg_catalog.to_char
	const sqlstr = `SELECT * FROM pg_catalog.to_char($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToCharByDoublePrecisionAndText calls the stored function 'pg_catalog.to_char(double precision, text) text' on db.
func ToCharByDoublePrecisionAndText(ctx context.Context, db DB, p0 float64, p1 string) (string, error) {
	// call pg_catalog.to_char
	const sqlstr = `SELECT * FROM pg_catalog.to_char($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToCharByTimestampWithoutTimeZoneAndText calls the stored function 'pg_catalog.to_char(timestamp without time zone, text) text' on db.
func ToCharByTimestampWithoutTimeZoneAndText(ctx context.Context, db DB, p0 time.Time, p1 string) (string, error) {
	// call pg_catalog.to_char
	const sqlstr = `SELECT * FROM pg_catalog.to_char($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToDate calls the stored function 'pg_catalog.to_date(text, text) date' on db.
func ToDate(ctx context.Context, db DB, p0, p1 string) (time.Time, error) {
	// call pg_catalog.to_date
	const sqlstr = `SELECT * FROM pg_catalog.to_date($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// ToHexByInteger calls the stored function 'pg_catalog.to_hex(integer) text' on db.
func ToHexByInteger(ctx context.Context, db DB, p0 int) (string, error) {
	// call pg_catalog.to_hex
	const sqlstr = `SELECT * FROM pg_catalog.to_hex($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToHexByBigint calls the stored function 'pg_catalog.to_hex(bigint) text' on db.
func ToHexByBigint(ctx context.Context, db DB, p0 int64) (string, error) {
	// call pg_catalog.to_hex
	const sqlstr = `SELECT * FROM pg_catalog.to_hex($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// ToJSON calls the stored function 'pg_catalog.to_json(anyelement) json' on db.
func ToJSON(ctx context.Context, db DB, p0 pgtypes.Anyelement) ([]byte, error) {
	// call pg_catalog.to_json
	const sqlstr = `SELECT * FROM pg_catalog.to_json($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// ToJsonb calls the stored function 'pg_catalog.to_jsonb(anyelement) jsonb' on db.
func ToJsonb(ctx context.Context, db DB, p0 pgtypes.Anyelement) ([]byte, error) {
	// call pg_catalog.to_jsonb
	const sqlstr = `SELECT * FROM pg_catalog.to_jsonb($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// ToNumber calls the stored function 'pg_catalog.to_number(text, text) numeric' on db.
func ToNumber(ctx context.Context, db DB, p0, p1 string) (float64, error) {
	// call pg_catalog.to_number
	const sqlstr = `SELECT * FROM pg_catalog.to_number($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// ToRegclass calls the stored function 'pg_catalog.to_regclass(text) regclass' on db.
func ToRegclass(ctx context.Context, db DB, p0 string) (pgtypes.Regclass, error) {
	// call pg_catalog.to_regclass
	const sqlstr = `SELECT * FROM pg_catalog.to_regclass($1)`
	// run
	var r0 pgtypes.Regclass
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regclass{}, logerror(err)
	}
	return r0, nil
}

// ToRegcollation calls the stored function 'pg_catalog.to_regcollation(text) regcollation' on db.
func ToRegcollation(ctx context.Context, db DB, p0 string) (pgtypes.Regcollation, error) {
	// call pg_catalog.to_regcollation
	const sqlstr = `SELECT * FROM pg_catalog.to_regcollation($1)`
	// run
	var r0 pgtypes.Regcollation
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regcollation{}, logerror(err)
	}
	return r0, nil
}

// ToRegnamespace calls the stored function 'pg_catalog.to_regnamespace(text) regnamespace' on db.
func ToRegnamespace(ctx context.Context, db DB, p0 string) (pgtypes.Regnamespace, error) {
	// call pg_catalog.to_regnamespace
	const sqlstr = `SELECT * FROM pg_catalog.to_regnamespace($1)`
	// run
	var r0 pgtypes.Regnamespace
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regnamespace{}, logerror(err)
	}
	return r0, nil
}

// ToRegoper calls the stored function 'pg_catalog.to_regoper(text) regoper' on db.
func ToRegoper(ctx context.Context, db DB, p0 string) (pgtypes.Regoper, error) {
	// call pg_catalog.to_regoper
	const sqlstr = `SELECT * FROM pg_catalog.to_regoper($1)`
	// run
	var r0 pgtypes.Regoper
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regoper{}, logerror(err)
	}
	return r0, nil
}

// ToRegoperator calls the stored function 'pg_catalog.to_regoperator(text) regoperator' on db.
func ToRegoperator(ctx context.Context, db DB, p0 string) (pgtypes.Regoperator, error) {
	// call pg_catalog.to_regoperator
	const sqlstr = `SELECT * FROM pg_catalog.to_regoperator($1)`
	// run
	var r0 pgtypes.Regoperator
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regoperator{}, logerror(err)
	}
	return r0, nil
}

// ToRegproc calls the stored function 'pg_catalog.to_regproc(text) regproc' on db.
func ToRegproc(ctx context.Context, db DB, p0 string) (pgtypes.Regproc, error) {
	// call pg_catalog.to_regproc
	const sqlstr = `SELECT * FROM pg_catalog.to_regproc($1)`
	// run
	var r0 pgtypes.Regproc
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regproc{}, logerror(err)
	}
	return r0, nil
}

// ToRegprocedure calls the stored function 'pg_catalog.to_regprocedure(text) regprocedure' on db.
func ToRegprocedure(ctx context.Context, db DB, p0 string) (pgtypes.Regprocedure, error) {
	// call pg_catalog.to_regprocedure
	const sqlstr = `SELECT * FROM pg_catalog.to_regprocedure($1)`
	// run
	var r0 pgtypes.Regprocedure
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regprocedure{}, logerror(err)
	}
	return r0, nil
}

// ToRegrole calls the stored function 'pg_catalog.to_regrole(text) regrole' on db.
func ToRegrole(ctx context.Context, db DB, p0 string) (pgtypes.Regrole, error) {
	// call pg_catalog.to_regrole
	const sqlstr = `SELECT * FROM pg_catalog.to_regrole($1)`
	// run
	var r0 pgtypes.Regrole
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regrole{}, logerror(err)
	}
	return r0, nil
}

// ToRegtype calls the stored function 'pg_catalog.to_regtype(text) regtype' on db.
func ToRegtype(ctx context.Context, db DB, p0 string) (pgtypes.Regtype, error) {
	// call pg_catalog.to_regtype
	const sqlstr = `SELECT * FROM pg_catalog.to_regtype($1)`
	// run
	var r0 pgtypes.Regtype
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Regtype{}, logerror(err)
	}
	return r0, nil
}

// ToTimestampByDoublePrecision calls the stored function 'pg_catalog.to_timestamp(double precision) timestamp with time zone' on db.
func ToTimestampByDoublePrecision(ctx context.Context, db DB, p0 float64) (time.Time, error) {
	// call pg_catalog.to_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.to_timestamp($1)`
	// run
	var r0 time.Time
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// ToTimestampByTextAndText calls the stored function 'pg_catalog.to_timestamp(text, text) timestamp with time zone' on db.
func ToTimestampByTextAndText(ctx context.Context, db DB, p0, p1 string) (time.Time, error) {
	// call pg_catalog.to_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.to_timestamp($1, $2)`
	// run
	var r0 time.Time
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// ToTsqueryByRegconfigAndText calls the stored function 'pg_catalog.to_tsquery(regconfig, text) tsquery' on db.
func ToTsqueryByRegconfigAndText(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.to_tsquery
	const sqlstr = `SELECT * FROM pg_catalog.to_tsquery($1, $2)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// ToTsqueryByText calls the stored function 'pg_catalog.to_tsquery(text) tsquery' on db.
func ToTsqueryByText(ctx context.Context, db DB, p0 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.to_tsquery
	const sqlstr = `SELECT * FROM pg_catalog.to_tsquery($1)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// ToTsvectorByRegconfigAndText calls the stored function 'pg_catalog.to_tsvector(regconfig, text) tsvector' on db.
func ToTsvectorByRegconfigAndText(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 string) (pgtypes.Tsvector, error) {
	// call pg_catalog.to_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.to_tsvector($1, $2)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// ToTsvectorByText calls the stored function 'pg_catalog.to_tsvector(text) tsvector' on db.
func ToTsvectorByText(ctx context.Context, db DB, p0 string) (pgtypes.Tsvector, error) {
	// call pg_catalog.to_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.to_tsvector($1)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// ToTsvectorByJsonb calls the stored function 'pg_catalog.to_tsvector(jsonb) tsvector' on db.
func ToTsvectorByJsonb(ctx context.Context, db DB, p0 []byte) (pgtypes.Tsvector, error) {
	// call pg_catalog.to_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.to_tsvector($1)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// ToTsvectorByJSON calls the stored function 'pg_catalog.to_tsvector(json) tsvector' on db.
func ToTsvectorByJSON(ctx context.Context, db DB, p0 []byte) (pgtypes.Tsvector, error) {
	// call pg_catalog.to_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.to_tsvector($1)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// ToTsvectorByRegconfigAndJsonb calls the stored function 'pg_catalog.to_tsvector(regconfig, jsonb) tsvector' on db.
func ToTsvectorByRegconfigAndJsonb(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 []byte) (pgtypes.Tsvector, error) {
	// call pg_catalog.to_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.to_tsvector($1, $2)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// ToTsvectorByRegconfigAndJSON calls the stored function 'pg_catalog.to_tsvector(regconfig, json) tsvector' on db.
func ToTsvectorByRegconfigAndJSON(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 []byte) (pgtypes.Tsvector, error) {
	// call pg_catalog.to_tsvector
	const sqlstr = `SELECT * FROM pg_catalog.to_tsvector($1, $2)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// TransactionTimestamp calls the stored function 'pg_catalog.transaction_timestamp() timestamp with time zone' on db.
func TransactionTimestamp(ctx context.Context, db DB) (time.Time, error) {
	// call pg_catalog.transaction_timestamp
	const sqlstr = `SELECT * FROM pg_catalog.transaction_timestamp()`
	// run
	var r0 time.Time
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return time.Time{}, logerror(err)
	}
	return r0, nil
}

// Translate calls the stored function 'pg_catalog.translate(text, text, text) text' on db.
func Translate(ctx context.Context, db DB, p0, p1, p2 string) (string, error) {
	// call pg_catalog.translate
	const sqlstr = `SELECT * FROM pg_catalog.translate($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TrimScale calls the stored function 'pg_catalog.trim_scale(numeric) numeric' on db.
func TrimScale(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.trim_scale
	const sqlstr = `SELECT * FROM pg_catalog.trim_scale($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TruncByDoublePrecision calls the stored function 'pg_catalog.trunc(double precision) double precision' on db.
func TruncByDoublePrecision(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.trunc
	const sqlstr = `SELECT * FROM pg_catalog.trunc($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TruncByNumericAndInteger calls the stored function 'pg_catalog.trunc(numeric, integer) numeric' on db.
func TruncByNumericAndInteger(ctx context.Context, db DB, p0 float64, p1 int) (float64, error) {
	// call pg_catalog.trunc
	const sqlstr = `SELECT * FROM pg_catalog.trunc($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TruncByNumeric calls the stored function 'pg_catalog.trunc(numeric) numeric' on db.
func TruncByNumeric(ctx context.Context, db DB, p0 float64) (float64, error) {
	// call pg_catalog.trunc
	const sqlstr = `SELECT * FROM pg_catalog.trunc($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TruncByMacaddr8 calls the stored function 'pg_catalog.trunc(macaddr8) macaddr8' on db.
func TruncByMacaddr8(ctx context.Context, db DB, p0 pgtypes.Macaddr8) (pgtypes.Macaddr8, error) {
	// call pg_catalog.trunc
	const sqlstr = `SELECT * FROM pg_catalog.trunc($1)`
	// run
	var r0 pgtypes.Macaddr8
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Macaddr8{}, logerror(err)
	}
	return r0, nil
}

// TruncByMacaddr calls the stored function 'pg_catalog.trunc(macaddr) macaddr' on db.
func TruncByMacaddr(ctx context.Context, db DB, p0 pgtypes.Macaddr) (pgtypes.Macaddr, error) {
	// call pg_catalog.trunc
	const sqlstr = `SELECT * FROM pg_catalog.trunc($1)`
	// run
	var r0 pgtypes.Macaddr
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Macaddr{}, logerror(err)
	}
	return r0, nil
}

// TsDebugByConfigAndDocument calls the stored function 'pg_catalog.ts_debug(regconfig, text) (text, text, text, regdictionary, regdictionary, text)' on db.
func TsDebugByConfigAndDocument(ctx context.Context, db DB, config pgtypes.Regconfig, document string) (string, string, string, []pgtypes.Regdictionary, pgtypes.Regdictionary, StringSlice, error) {
	// call pg_catalog.ts_debug
	const sqlstr = `SELECT * FROM pg_catalog.ts_debug($1, $2)`
	// run
	var alias string
	var description string
	var token string
	var dictionaries []pgtypes.Regdictionary
	var dictionary pgtypes.Regdictionary
	var lexemes StringSlice
	logf(sqlstr, config, document)
	if err := db.QueryRowContext(ctx, sqlstr, config, document).Scan(&alias, &description, &token, &dictionaries, &dictionary, &lexemes); err != nil {
		return "", "", "", nil, pgtypes.Regdictionary{}, StringSlice{}, logerror(err)
	}
	return alias, description, token, dictionaries, dictionary, lexemes, nil
}

// TsDebugByDocument calls the stored function 'pg_catalog.ts_debug(text) (text, text, text, regdictionary, regdictionary, text)' on db.
func TsDebugByDocument(ctx context.Context, db DB, document string) (string, string, string, []pgtypes.Regdictionary, pgtypes.Regdictionary, StringSlice, error) {
	// call pg_catalog.ts_debug
	const sqlstr = `SELECT * FROM pg_catalog.ts_debug($1)`
	// run
	var alias string
	var description string
	var token string
	var dictionaries []pgtypes.Regdictionary
	var dictionary pgtypes.Regdictionary
	var lexemes StringSlice
	logf(sqlstr, document)
	if err := db.QueryRowContext(ctx, sqlstr, document).Scan(&alias, &description, &token, &dictionaries, &dictionary, &lexemes); err != nil {
		return "", "", "", nil, pgtypes.Regdictionary{}, StringSlice{}, logerror(err)
	}
	return alias, description, token, dictionaries, dictionary, lexemes, nil
}

// TsDeleteByTsvectorAndText calls the stored function 'pg_catalog.ts_delete(tsvector, text) tsvector' on db.
func TsDeleteByTsvectorAndText(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 string) (pgtypes.Tsvector, error) {
	// call pg_catalog.ts_delete
	const sqlstr = `SELECT * FROM pg_catalog.ts_delete($1, $2)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// TsDeleteByTsvectorAndText calls the stored function 'pg_catalog.ts_delete(tsvector, text) tsvector' on db.
func TsDeleteByTsvectorAndText(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 StringSlice) (pgtypes.Tsvector, error) {
	// call pg_catalog.ts_delete
	const sqlstr = `SELECT * FROM pg_catalog.ts_delete($1, $2)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// TsFilter calls the stored function 'pg_catalog.ts_filter(tsvector, "char") tsvector' on db.
func TsFilter(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 []pgtypes.Char) (pgtypes.Tsvector, error) {
	// call pg_catalog.ts_filter
	const sqlstr = `SELECT * FROM pg_catalog.ts_filter($1, $2)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// TsHeadlineByRegconfigTextTsqueryAndText calls the stored function 'pg_catalog.ts_headline(regconfig, text, tsquery, text) text' on db.
func TsHeadlineByRegconfigTextTsqueryAndText(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 string, p2 pgtypes.Tsquery, p3 string) (string, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2, $3, $4)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TsHeadlineByRegconfigTextAndTsquery calls the stored function 'pg_catalog.ts_headline(regconfig, text, tsquery) text' on db.
func TsHeadlineByRegconfigTextAndTsquery(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 string, p2 pgtypes.Tsquery) (string, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TsHeadlineByTextTsqueryAndText calls the stored function 'pg_catalog.ts_headline(text, tsquery, text) text' on db.
func TsHeadlineByTextTsqueryAndText(ctx context.Context, db DB, p0 string, p1 pgtypes.Tsquery, p2 string) (string, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TsHeadlineByTextAndTsquery calls the stored function 'pg_catalog.ts_headline(text, tsquery) text' on db.
func TsHeadlineByTextAndTsquery(ctx context.Context, db DB, p0 string, p1 pgtypes.Tsquery) (string, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2)`
	// run
	var r0 string
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TsHeadlineByRegconfigJsonbTsqueryAndText calls the stored function 'pg_catalog.ts_headline(regconfig, jsonb, tsquery, text) jsonb' on db.
func TsHeadlineByRegconfigJsonbTsqueryAndText(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 []byte, p2 pgtypes.Tsquery, p3 string) ([]byte, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TsHeadlineByRegconfigJsonbAndTsquery calls the stored function 'pg_catalog.ts_headline(regconfig, jsonb, tsquery) jsonb' on db.
func TsHeadlineByRegconfigJsonbAndTsquery(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 []byte, p2 pgtypes.Tsquery) ([]byte, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TsHeadlineByJsonbTsqueryAndText calls the stored function 'pg_catalog.ts_headline(jsonb, tsquery, text) jsonb' on db.
func TsHeadlineByJsonbTsqueryAndText(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Tsquery, p2 string) ([]byte, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TsHeadlineByJsonbAndTsquery calls the stored function 'pg_catalog.ts_headline(jsonb, tsquery) jsonb' on db.
func TsHeadlineByJsonbAndTsquery(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Tsquery) ([]byte, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TsHeadlineByRegconfigJSONTsqueryAndText calls the stored function 'pg_catalog.ts_headline(regconfig, json, tsquery, text) json' on db.
func TsHeadlineByRegconfigJSONTsqueryAndText(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 []byte, p2 pgtypes.Tsquery, p3 string) ([]byte, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2, $3, $4)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TsHeadlineByRegconfigJSONAndTsquery calls the stored function 'pg_catalog.ts_headline(regconfig, json, tsquery) json' on db.
func TsHeadlineByRegconfigJSONAndTsquery(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 []byte, p2 pgtypes.Tsquery) ([]byte, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TsHeadlineByJSONTsqueryAndText calls the stored function 'pg_catalog.ts_headline(json, tsquery, text) json' on db.
func TsHeadlineByJSONTsqueryAndText(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Tsquery, p2 string) ([]byte, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TsHeadlineByJSONAndTsquery calls the stored function 'pg_catalog.ts_headline(json, tsquery) json' on db.
func TsHeadlineByJSONAndTsquery(ctx context.Context, db DB, p0 []byte, p1 pgtypes.Tsquery) ([]byte, error) {
	// call pg_catalog.ts_headline
	const sqlstr = `SELECT * FROM pg_catalog.ts_headline($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TsLexize calls the stored function 'pg_catalog.ts_lexize(regdictionary, text) text' on db.
func TsLexize(ctx context.Context, db DB, p0 pgtypes.Regdictionary, p1 string) (StringSlice, error) {
	// call pg_catalog.ts_lexize
	const sqlstr = `SELECT * FROM pg_catalog.ts_lexize($1, $2)`
	// run
	var r0 StringSlice
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// TsMatchQv calls the stored function 'pg_catalog.ts_match_qv(tsquery, tsvector) boolean' on db.
func TsMatchQv(ctx context.Context, db DB, p0 pgtypes.Tsquery, p1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.ts_match_qv
	const sqlstr = `SELECT * FROM pg_catalog.ts_match_qv($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsMatchTq calls the stored function 'pg_catalog.ts_match_tq(text, tsquery) boolean' on db.
func TsMatchTq(ctx context.Context, db DB, p0 string, p1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.ts_match_tq
	const sqlstr = `SELECT * FROM pg_catalog.ts_match_tq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsMatchTt calls the stored function 'pg_catalog.ts_match_tt(text, text) boolean' on db.
func TsMatchTt(ctx context.Context, db DB, p0, p1 string) (bool, error) {
	// call pg_catalog.ts_match_tt
	const sqlstr = `SELECT * FROM pg_catalog.ts_match_tt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsMatchVq calls the stored function 'pg_catalog.ts_match_vq(tsvector, tsquery) boolean' on db.
func TsMatchVq(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.ts_match_vq
	const sqlstr = `SELECT * FROM pg_catalog.ts_match_vq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsParseByParserOidAndTxt calls the stored function 'pg_catalog.ts_parse(oid, text) (integer, text)' on db.
func TsParseByParserOidAndTxt(ctx context.Context, db DB, parserOid pgtypes.Oid, txt string) (int, string, error) {
	// call pg_catalog.ts_parse
	const sqlstr = `SELECT * FROM pg_catalog.ts_parse($1, $2)`
	// run
	var tokid int
	var token string
	logf(sqlstr, parserOid, txt)
	if err := db.QueryRowContext(ctx, sqlstr, parserOid, txt).Scan(&tokid, &token); err != nil {
		return 0, "", logerror(err)
	}
	return tokid, token, nil
}

// TsParseByParserNameAndTxt calls the stored function 'pg_catalog.ts_parse(text, text) (integer, text)' on db.
func TsParseByParserNameAndTxt(ctx context.Context, db DB, parserName, txt string) (int, string, error) {
	// call pg_catalog.ts_parse
	const sqlstr = `SELECT * FROM pg_catalog.ts_parse($1, $2)`
	// run
	var tokid int
	var token string
	logf(sqlstr, parserName, txt)
	if err := db.QueryRowContext(ctx, sqlstr, parserName, txt).Scan(&tokid, &token); err != nil {
		return 0, "", logerror(err)
	}
	return tokid, token, nil
}

// TsRankByRealTsvectorTsqueryAndInteger calls the stored function 'pg_catalog.ts_rank(real, tsvector, tsquery, integer) real' on db.
func TsRankByRealTsvectorTsqueryAndInteger(ctx context.Context, db DB, p0 []float32, p1 pgtypes.Tsvector, p2 pgtypes.Tsquery, p3 int) (float32, error) {
	// call pg_catalog.ts_rank
	const sqlstr = `SELECT * FROM pg_catalog.ts_rank($1, $2, $3, $4)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TsRankByRealTsvectorAndTsquery calls the stored function 'pg_catalog.ts_rank(real, tsvector, tsquery) real' on db.
func TsRankByRealTsvectorAndTsquery(ctx context.Context, db DB, p0 []float32, p1 pgtypes.Tsvector, p2 pgtypes.Tsquery) (float32, error) {
	// call pg_catalog.ts_rank
	const sqlstr = `SELECT * FROM pg_catalog.ts_rank($1, $2, $3)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TsRankByTsvectorTsqueryAndInteger calls the stored function 'pg_catalog.ts_rank(tsvector, tsquery, integer) real' on db.
func TsRankByTsvectorTsqueryAndInteger(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 pgtypes.Tsquery, p2 int) (float32, error) {
	// call pg_catalog.ts_rank
	const sqlstr = `SELECT * FROM pg_catalog.ts_rank($1, $2, $3)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TsRankByTsvectorAndTsquery calls the stored function 'pg_catalog.ts_rank(tsvector, tsquery) real' on db.
func TsRankByTsvectorAndTsquery(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 pgtypes.Tsquery) (float32, error) {
	// call pg_catalog.ts_rank
	const sqlstr = `SELECT * FROM pg_catalog.ts_rank($1, $2)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TsRankCdByRealTsvectorTsqueryAndInteger calls the stored function 'pg_catalog.ts_rank_cd(real, tsvector, tsquery, integer) real' on db.
func TsRankCdByRealTsvectorTsqueryAndInteger(ctx context.Context, db DB, p0 []float32, p1 pgtypes.Tsvector, p2 pgtypes.Tsquery, p3 int) (float32, error) {
	// call pg_catalog.ts_rank_cd
	const sqlstr = `SELECT * FROM pg_catalog.ts_rank_cd($1, $2, $3, $4)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TsRankCdByRealTsvectorAndTsquery calls the stored function 'pg_catalog.ts_rank_cd(real, tsvector, tsquery) real' on db.
func TsRankCdByRealTsvectorAndTsquery(ctx context.Context, db DB, p0 []float32, p1 pgtypes.Tsvector, p2 pgtypes.Tsquery) (float32, error) {
	// call pg_catalog.ts_rank_cd
	const sqlstr = `SELECT * FROM pg_catalog.ts_rank_cd($1, $2, $3)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TsRankCdByTsvectorTsqueryAndInteger calls the stored function 'pg_catalog.ts_rank_cd(tsvector, tsquery, integer) real' on db.
func TsRankCdByTsvectorTsqueryAndInteger(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 pgtypes.Tsquery, p2 int) (float32, error) {
	// call pg_catalog.ts_rank_cd
	const sqlstr = `SELECT * FROM pg_catalog.ts_rank_cd($1, $2, $3)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TsRankCdByTsvectorAndTsquery calls the stored function 'pg_catalog.ts_rank_cd(tsvector, tsquery) real' on db.
func TsRankCdByTsvectorAndTsquery(ctx context.Context, db DB, p0 pgtypes.Tsvector, p1 pgtypes.Tsquery) (float32, error) {
	// call pg_catalog.ts_rank_cd
	const sqlstr = `SELECT * FROM pg_catalog.ts_rank_cd($1, $2)`
	// run
	var r0 float32
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TsRewriteByTsqueryTsqueryAndTsquery calls the stored function 'pg_catalog.ts_rewrite(tsquery, tsquery, tsquery) tsquery' on db.
func TsRewriteByTsqueryTsqueryAndTsquery(ctx context.Context, db DB, p0, p1, p2 pgtypes.Tsquery) (pgtypes.Tsquery, error) {
	// call pg_catalog.ts_rewrite
	const sqlstr = `SELECT * FROM pg_catalog.ts_rewrite($1, $2, $3)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// TsRewriteByTsqueryAndText calls the stored function 'pg_catalog.ts_rewrite(tsquery, text) tsquery' on db.
func TsRewriteByTsqueryAndText(ctx context.Context, db DB, p0 pgtypes.Tsquery, p1 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.ts_rewrite
	const sqlstr = `SELECT * FROM pg_catalog.ts_rewrite($1, $2)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// TsStatByQuery calls the stored function 'pg_catalog.ts_stat(text) (text, integer, integer)' on db.
func TsStatByQuery(ctx context.Context, db DB, query string) (string, int, int, error) {
	// call pg_catalog.ts_stat
	const sqlstr = `SELECT * FROM pg_catalog.ts_stat($1)`
	// run
	var word string
	var ndoc int
	var nentry int
	logf(sqlstr, query)
	if err := db.QueryRowContext(ctx, sqlstr, query).Scan(&word, &ndoc, &nentry); err != nil {
		return "", 0, 0, logerror(err)
	}
	return word, ndoc, nentry, nil
}

// TsStatByQueryAndWeights calls the stored function 'pg_catalog.ts_stat(text, text) (text, integer, integer)' on db.
func TsStatByQueryAndWeights(ctx context.Context, db DB, query, weights string) (string, int, int, error) {
	// call pg_catalog.ts_stat
	const sqlstr = `SELECT * FROM pg_catalog.ts_stat($1, $2)`
	// run
	var word string
	var ndoc int
	var nentry int
	logf(sqlstr, query, weights)
	if err := db.QueryRowContext(ctx, sqlstr, query, weights).Scan(&word, &ndoc, &nentry); err != nil {
		return "", 0, 0, logerror(err)
	}
	return word, ndoc, nentry, nil
}

// TsTokenTypeByParserOid calls the stored function 'pg_catalog.ts_token_type(oid) (integer, text, text)' on db.
func TsTokenTypeByParserOid(ctx context.Context, db DB, parserOid pgtypes.Oid) (int, string, string, error) {
	// call pg_catalog.ts_token_type
	const sqlstr = `SELECT * FROM pg_catalog.ts_token_type($1)`
	// run
	var tokid int
	var alias string
	var description string
	logf(sqlstr, parserOid)
	if err := db.QueryRowContext(ctx, sqlstr, parserOid).Scan(&tokid, &alias, &description); err != nil {
		return 0, "", "", logerror(err)
	}
	return tokid, alias, description, nil
}

// TsTokenTypeByParserName calls the stored function 'pg_catalog.ts_token_type(text) (integer, text, text)' on db.
func TsTokenTypeByParserName(ctx context.Context, db DB, parserName string) (int, string, string, error) {
	// call pg_catalog.ts_token_type
	const sqlstr = `SELECT * FROM pg_catalog.ts_token_type($1)`
	// run
	var tokid int
	var alias string
	var description string
	logf(sqlstr, parserName)
	if err := db.QueryRowContext(ctx, sqlstr, parserName).Scan(&tokid, &alias, &description); err != nil {
		return 0, "", "", logerror(err)
	}
	return tokid, alias, description, nil
}

// TsTypanalyze calls the stored function 'pg_catalog.ts_typanalyze(internal) boolean' on db.
func TsTypanalyze(ctx context.Context, db DB, p0 pgtypes.Internal) (bool, error) {
	// call pg_catalog.ts_typanalyze
	const sqlstr = `SELECT * FROM pg_catalog.ts_typanalyze($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Tsmatchjoinsel calls the stored function 'pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal) double precision' on db.
func Tsmatchjoinsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int16, p4 pgtypes.Internal) (float64, error) {
	// call pg_catalog.tsmatchjoinsel
	const sqlstr = `SELECT * FROM pg_catalog.tsmatchjoinsel($1, $2, $3, $4, $5)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3, p4)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3, p4).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// Tsmatchsel calls the stored function 'pg_catalog.tsmatchsel(internal, oid, internal, integer) double precision' on db.
func Tsmatchsel(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 pgtypes.Internal, p3 int) (float64, error) {
	// call pg_catalog.tsmatchsel
	const sqlstr = `SELECT * FROM pg_catalog.tsmatchsel($1, $2, $3, $4)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TsqMcontained calls the stored function 'pg_catalog.tsq_mcontained(tsquery, tsquery) boolean' on db.
func TsqMcontained(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsq_mcontained
	const sqlstr = `SELECT * FROM pg_catalog.tsq_mcontained($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsqMcontains calls the stored function 'pg_catalog.tsq_mcontains(tsquery, tsquery) boolean' on db.
func TsqMcontains(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsq_mcontains
	const sqlstr = `SELECT * FROM pg_catalog.tsq_mcontains($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsqueryAnd calls the stored function 'pg_catalog.tsquery_and(tsquery, tsquery) tsquery' on db.
func TsqueryAnd(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsquery_and
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_and($1, $2)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// TsqueryCmp calls the stored function 'pg_catalog.tsquery_cmp(tsquery, tsquery) integer' on db.
func TsqueryCmp(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (int, error) {
	// call pg_catalog.tsquery_cmp
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TsqueryEq calls the stored function 'pg_catalog.tsquery_eq(tsquery, tsquery) boolean' on db.
func TsqueryEq(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_eq
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsqueryGe calls the stored function 'pg_catalog.tsquery_ge(tsquery, tsquery) boolean' on db.
func TsqueryGe(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_ge
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsqueryGt calls the stored function 'pg_catalog.tsquery_gt(tsquery, tsquery) boolean' on db.
func TsqueryGt(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_gt
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsqueryLe calls the stored function 'pg_catalog.tsquery_le(tsquery, tsquery) boolean' on db.
func TsqueryLe(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_le
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsqueryLt calls the stored function 'pg_catalog.tsquery_lt(tsquery, tsquery) boolean' on db.
func TsqueryLt(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_lt
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsqueryNe calls the stored function 'pg_catalog.tsquery_ne(tsquery, tsquery) boolean' on db.
func TsqueryNe(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (bool, error) {
	// call pg_catalog.tsquery_ne
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsqueryNot calls the stored function 'pg_catalog.tsquery_not(tsquery) tsquery' on db.
func TsqueryNot(ctx context.Context, db DB, p0 pgtypes.Tsquery) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsquery_not
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_not($1)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// TsqueryOr calls the stored function 'pg_catalog.tsquery_or(tsquery, tsquery) tsquery' on db.
func TsqueryOr(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsquery_or
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_or($1, $2)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// TsqueryPhraseByTsqueryAndTsquery calls the stored function 'pg_catalog.tsquery_phrase(tsquery, tsquery) tsquery' on db.
func TsqueryPhraseByTsqueryAndTsquery(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsquery_phrase
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_phrase($1, $2)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// TsqueryPhraseByTsqueryTsqueryAndInteger calls the stored function 'pg_catalog.tsquery_phrase(tsquery, tsquery, integer) tsquery' on db.
func TsqueryPhraseByTsqueryTsqueryAndInteger(ctx context.Context, db DB, p0, p1 pgtypes.Tsquery, p2 int) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsquery_phrase
	const sqlstr = `SELECT * FROM pg_catalog.tsquery_phrase($1, $2, $3)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// Tsqueryrecv calls the stored function 'pg_catalog.tsqueryrecv(internal) tsquery' on db.
func Tsqueryrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Tsquery, error) {
	// call pg_catalog.tsqueryrecv
	const sqlstr = `SELECT * FROM pg_catalog.tsqueryrecv($1)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// Tsquerysend calls the stored function 'pg_catalog.tsquerysend(tsquery) bytea' on db.
func Tsquerysend(ctx context.Context, db DB, p0 pgtypes.Tsquery) ([]byte, error) {
	// call pg_catalog.tsquerysend
	const sqlstr = `SELECT * FROM pg_catalog.tsquerysend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TsrangeByTimestampWithoutTimeZoneAndTimestampWithoutTimeZone calls the stored function 'pg_catalog.tsrange(timestamp without time zone, timestamp without time zone) tsrange' on db.
func TsrangeByTimestampWithoutTimeZoneAndTimestampWithoutTimeZone(ctx context.Context, db DB, p0, p1 time.Time) (pgtypes.Tsrange, error) {
	// call pg_catalog.tsrange
	const sqlstr = `SELECT * FROM pg_catalog.tsrange($1, $2)`
	// run
	var r0 pgtypes.Tsrange
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsrange{}, logerror(err)
	}
	return r0, nil
}

// TsrangeByTimestampWithoutTimeZoneTimestampWithoutTimeZoneAndText calls the stored function 'pg_catalog.tsrange(timestamp without time zone, timestamp without time zone, text) tsrange' on db.
func TsrangeByTimestampWithoutTimeZoneTimestampWithoutTimeZoneAndText(ctx context.Context, db DB, p0, p1 time.Time, p2 string) (pgtypes.Tsrange, error) {
	// call pg_catalog.tsrange
	const sqlstr = `SELECT * FROM pg_catalog.tsrange($1, $2, $3)`
	// run
	var r0 pgtypes.Tsrange
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Tsrange{}, logerror(err)
	}
	return r0, nil
}

// TsrangeSubdiff calls the stored function 'pg_catalog.tsrange_subdiff(timestamp without time zone, timestamp without time zone) double precision' on db.
func TsrangeSubdiff(ctx context.Context, db DB, p0, p1 time.Time) (float64, error) {
	// call pg_catalog.tsrange_subdiff
	const sqlstr = `SELECT * FROM pg_catalog.tsrange_subdiff($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TstzrangeByTimestampWithTimeZoneAndTimestampWithTimeZone calls the stored function 'pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone) tstzrange' on db.
func TstzrangeByTimestampWithTimeZoneAndTimestampWithTimeZone(ctx context.Context, db DB, p0, p1 time.Time) (pgtypes.Tstzrange, error) {
	// call pg_catalog.tstzrange
	const sqlstr = `SELECT * FROM pg_catalog.tstzrange($1, $2)`
	// run
	var r0 pgtypes.Tstzrange
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tstzrange{}, logerror(err)
	}
	return r0, nil
}

// TstzrangeByTimestampWithTimeZoneTimestampWithTimeZoneAndText calls the stored function 'pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text) tstzrange' on db.
func TstzrangeByTimestampWithTimeZoneTimestampWithTimeZoneAndText(ctx context.Context, db DB, p0, p1 time.Time, p2 string) (pgtypes.Tstzrange, error) {
	// call pg_catalog.tstzrange
	const sqlstr = `SELECT * FROM pg_catalog.tstzrange($1, $2, $3)`
	// run
	var r0 pgtypes.Tstzrange
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return pgtypes.Tstzrange{}, logerror(err)
	}
	return r0, nil
}

// TstzrangeSubdiff calls the stored function 'pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone) double precision' on db.
func TstzrangeSubdiff(ctx context.Context, db DB, p0, p1 time.Time) (float64, error) {
	// call pg_catalog.tstzrange_subdiff
	const sqlstr = `SELECT * FROM pg_catalog.tstzrange_subdiff($1, $2)`
	// run
	var r0 float64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// TsvectorCmp calls the stored function 'pg_catalog.tsvector_cmp(tsvector, tsvector) integer' on db.
func TsvectorCmp(ctx context.Context, db DB, p0, p1 pgtypes.Tsvector) (int, error) {
	// call pg_catalog.tsvector_cmp
	const sqlstr = `SELECT * FROM pg_catalog.tsvector_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TsvectorConcat calls the stored function 'pg_catalog.tsvector_concat(tsvector, tsvector) tsvector' on db.
func TsvectorConcat(ctx context.Context, db DB, p0, p1 pgtypes.Tsvector) (pgtypes.Tsvector, error) {
	// call pg_catalog.tsvector_concat
	const sqlstr = `SELECT * FROM pg_catalog.tsvector_concat($1, $2)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// TsvectorEq calls the stored function 'pg_catalog.tsvector_eq(tsvector, tsvector) boolean' on db.
func TsvectorEq(ctx context.Context, db DB, p0, p1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_eq
	const sqlstr = `SELECT * FROM pg_catalog.tsvector_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsvectorGe calls the stored function 'pg_catalog.tsvector_ge(tsvector, tsvector) boolean' on db.
func TsvectorGe(ctx context.Context, db DB, p0, p1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_ge
	const sqlstr = `SELECT * FROM pg_catalog.tsvector_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsvectorGt calls the stored function 'pg_catalog.tsvector_gt(tsvector, tsvector) boolean' on db.
func TsvectorGt(ctx context.Context, db DB, p0, p1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_gt
	const sqlstr = `SELECT * FROM pg_catalog.tsvector_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsvectorLe calls the stored function 'pg_catalog.tsvector_le(tsvector, tsvector) boolean' on db.
func TsvectorLe(ctx context.Context, db DB, p0, p1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_le
	const sqlstr = `SELECT * FROM pg_catalog.tsvector_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsvectorLt calls the stored function 'pg_catalog.tsvector_lt(tsvector, tsvector) boolean' on db.
func TsvectorLt(ctx context.Context, db DB, p0, p1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_lt
	const sqlstr = `SELECT * FROM pg_catalog.tsvector_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsvectorNe calls the stored function 'pg_catalog.tsvector_ne(tsvector, tsvector) boolean' on db.
func TsvectorNe(ctx context.Context, db DB, p0, p1 pgtypes.Tsvector) (bool, error) {
	// call pg_catalog.tsvector_ne
	const sqlstr = `SELECT * FROM pg_catalog.tsvector_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// TsvectorToArray calls the stored function 'pg_catalog.tsvector_to_array(tsvector) text' on db.
func TsvectorToArray(ctx context.Context, db DB, p0 pgtypes.Tsvector) (StringSlice, error) {
	// call pg_catalog.tsvector_to_array
	const sqlstr = `SELECT * FROM pg_catalog.tsvector_to_array($1)`
	// run
	var r0 StringSlice
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return StringSlice{}, logerror(err)
	}
	return r0, nil
}

// TsvectorUpdateTrigger calls the stored function 'pg_catalog.tsvector_update_trigger() trigger' on db.
func TsvectorUpdateTrigger(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.tsvector_update_trigger
	const sqlstr = `SELECT * FROM pg_catalog.tsvector_update_trigger()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// TsvectorUpdateTriggerColumn calls the stored function 'pg_catalog.tsvector_update_trigger_column() trigger' on db.
func TsvectorUpdateTriggerColumn(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.tsvector_update_trigger_column
	const sqlstr = `SELECT * FROM pg_catalog.tsvector_update_trigger_column()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// Tsvectorrecv calls the stored function 'pg_catalog.tsvectorrecv(internal) tsvector' on db.
func Tsvectorrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Tsvector, error) {
	// call pg_catalog.tsvectorrecv
	const sqlstr = `SELECT * FROM pg_catalog.tsvectorrecv($1)`
	// run
	var r0 pgtypes.Tsvector
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsvector{}, logerror(err)
	}
	return r0, nil
}

// Tsvectorsend calls the stored function 'pg_catalog.tsvectorsend(tsvector) bytea' on db.
func Tsvectorsend(ctx context.Context, db DB, p0 pgtypes.Tsvector) ([]byte, error) {
	// call pg_catalog.tsvectorsend
	const sqlstr = `SELECT * FROM pg_catalog.tsvectorsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TxidCurrent calls the stored function 'pg_catalog.txid_current() bigint' on db.
func TxidCurrent(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.txid_current
	const sqlstr = `SELECT * FROM pg_catalog.txid_current()`
	// run
	var r0 int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TxidCurrentIfAssigned calls the stored function 'pg_catalog.txid_current_if_assigned() bigint' on db.
func TxidCurrentIfAssigned(ctx context.Context, db DB) (int64, error) {
	// call pg_catalog.txid_current_if_assigned
	const sqlstr = `SELECT * FROM pg_catalog.txid_current_if_assigned()`
	// run
	var r0 int64
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TxidCurrentSnapshot calls the stored function 'pg_catalog.txid_current_snapshot() txid_snapshot' on db.
func TxidCurrentSnapshot(ctx context.Context, db DB) (pgtypes.TxidSnapshot, error) {
	// call pg_catalog.txid_current_snapshot
	const sqlstr = `SELECT * FROM pg_catalog.txid_current_snapshot()`
	// run
	var r0 pgtypes.TxidSnapshot
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.TxidSnapshot{}, logerror(err)
	}
	return r0, nil
}

// TxidSnapshotRecv calls the stored function 'pg_catalog.txid_snapshot_recv(internal) txid_snapshot' on db.
func TxidSnapshotRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.TxidSnapshot, error) {
	// call pg_catalog.txid_snapshot_recv
	const sqlstr = `SELECT * FROM pg_catalog.txid_snapshot_recv($1)`
	// run
	var r0 pgtypes.TxidSnapshot
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.TxidSnapshot{}, logerror(err)
	}
	return r0, nil
}

// TxidSnapshotSend calls the stored function 'pg_catalog.txid_snapshot_send(txid_snapshot) bytea' on db.
func TxidSnapshotSend(ctx context.Context, db DB, p0 pgtypes.TxidSnapshot) ([]byte, error) {
	// call pg_catalog.txid_snapshot_send
	const sqlstr = `SELECT * FROM pg_catalog.txid_snapshot_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// TxidSnapshotXip calls the stored function 'pg_catalog.txid_snapshot_xip(txid_snapshot) bigint' on db.
func TxidSnapshotXip(ctx context.Context, db DB, p0 pgtypes.TxidSnapshot) (int64, error) {
	// call pg_catalog.txid_snapshot_xip
	const sqlstr = `SELECT * FROM pg_catalog.txid_snapshot_xip($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TxidSnapshotXmax calls the stored function 'pg_catalog.txid_snapshot_xmax(txid_snapshot) bigint' on db.
func TxidSnapshotXmax(ctx context.Context, db DB, p0 pgtypes.TxidSnapshot) (int64, error) {
	// call pg_catalog.txid_snapshot_xmax
	const sqlstr = `SELECT * FROM pg_catalog.txid_snapshot_xmax($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TxidSnapshotXmin calls the stored function 'pg_catalog.txid_snapshot_xmin(txid_snapshot) bigint' on db.
func TxidSnapshotXmin(ctx context.Context, db DB, p0 pgtypes.TxidSnapshot) (int64, error) {
	// call pg_catalog.txid_snapshot_xmin
	const sqlstr = `SELECT * FROM pg_catalog.txid_snapshot_xmin($1)`
	// run
	var r0 int64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// TxidStatus calls the stored function 'pg_catalog.txid_status(bigint) text' on db.
func TxidStatus(ctx context.Context, db DB, p0 int64) (string, error) {
	// call pg_catalog.txid_status
	const sqlstr = `SELECT * FROM pg_catalog.txid_status($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// TxidVisibleInSnapshot calls the stored function 'pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot) boolean' on db.
func TxidVisibleInSnapshot(ctx context.Context, db DB, p0 int64, p1 pgtypes.TxidSnapshot) (bool, error) {
	// call pg_catalog.txid_visible_in_snapshot
	const sqlstr = `SELECT * FROM pg_catalog.txid_visible_in_snapshot($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// UTF8ToBig5 calls the stored function 'pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer)' on db.
func UTF8ToBig5(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_big5
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_big5($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToEucCn calls the stored function 'pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer)' on db.
func UTF8ToEucCn(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_euc_cn
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_euc_cn($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToEucJis2004 calls the stored function 'pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer)' on db.
func UTF8ToEucJis2004(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_euc_jis_2004
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_euc_jis_2004($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToEucJp calls the stored function 'pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer)' on db.
func UTF8ToEucJp(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_euc_jp
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_euc_jp($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToEucKr calls the stored function 'pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer)' on db.
func UTF8ToEucKr(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_euc_kr
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_euc_kr($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToEucTw calls the stored function 'pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer)' on db.
func UTF8ToEucTw(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_euc_tw
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_euc_tw($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToGb18030 calls the stored function 'pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer)' on db.
func UTF8ToGb18030(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_gb18030
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_gb18030($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToGbk calls the stored function 'pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer)' on db.
func UTF8ToGbk(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_gbk
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_gbk($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToIso8859 calls the stored function 'pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer)' on db.
func UTF8ToIso8859(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_iso8859
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_iso8859($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToIso88591 calls the stored function 'pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer)' on db.
func UTF8ToIso88591(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_iso8859_1
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_iso8859_1($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToJohab calls the stored function 'pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer)' on db.
func UTF8ToJohab(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_johab
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_johab($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToKoi8r calls the stored function 'pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer)' on db.
func UTF8ToKoi8r(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_koi8r
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_koi8r($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToKoi8u calls the stored function 'pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer)' on db.
func UTF8ToKoi8u(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_koi8u
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_koi8u($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToShiftJis2004 calls the stored function 'pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer)' on db.
func UTF8ToShiftJis2004(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_shift_jis_2004
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_shift_jis_2004($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToSjis calls the stored function 'pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer)' on db.
func UTF8ToSjis(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_sjis
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_sjis($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToUhc calls the stored function 'pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer)' on db.
func UTF8ToUhc(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_uhc
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_uhc($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UTF8ToWin calls the stored function 'pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer)' on db.
func UTF8ToWin(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.utf8_to_win
	const sqlstr = `SELECT * FROM pg_catalog.utf8_to_win($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UUIDCmp calls the stored function 'pg_catalog.uuid_cmp(uuid, uuid) integer' on db.
func UUIDCmp(ctx context.Context, db DB, p0, p1 uuid.UUID) (int, error) {
	// call pg_catalog.uuid_cmp
	const sqlstr = `SELECT * FROM pg_catalog.uuid_cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// UUIDEq calls the stored function 'pg_catalog.uuid_eq(uuid, uuid) boolean' on db.
func UUIDEq(ctx context.Context, db DB, p0, p1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_eq
	const sqlstr = `SELECT * FROM pg_catalog.uuid_eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// UUIDGe calls the stored function 'pg_catalog.uuid_ge(uuid, uuid) boolean' on db.
func UUIDGe(ctx context.Context, db DB, p0, p1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_ge
	const sqlstr = `SELECT * FROM pg_catalog.uuid_ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// UUIDGt calls the stored function 'pg_catalog.uuid_gt(uuid, uuid) boolean' on db.
func UUIDGt(ctx context.Context, db DB, p0, p1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_gt
	const sqlstr = `SELECT * FROM pg_catalog.uuid_gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// UUIDHash calls the stored function 'pg_catalog.uuid_hash(uuid) integer' on db.
func UUIDHash(ctx context.Context, db DB, p0 uuid.UUID) (int, error) {
	// call pg_catalog.uuid_hash
	const sqlstr = `SELECT * FROM pg_catalog.uuid_hash($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// UUIDHashExtended calls the stored function 'pg_catalog.uuid_hash_extended(uuid, bigint) bigint' on db.
func UUIDHashExtended(ctx context.Context, db DB, p0 uuid.UUID, p1 int64) (int64, error) {
	// call pg_catalog.uuid_hash_extended
	const sqlstr = `SELECT * FROM pg_catalog.uuid_hash_extended($1, $2)`
	// run
	var r0 int64
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// UUIDLe calls the stored function 'pg_catalog.uuid_le(uuid, uuid) boolean' on db.
func UUIDLe(ctx context.Context, db DB, p0, p1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_le
	const sqlstr = `SELECT * FROM pg_catalog.uuid_le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// UUIDLt calls the stored function 'pg_catalog.uuid_lt(uuid, uuid) boolean' on db.
func UUIDLt(ctx context.Context, db DB, p0, p1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_lt
	const sqlstr = `SELECT * FROM pg_catalog.uuid_lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// UUIDNe calls the stored function 'pg_catalog.uuid_ne(uuid, uuid) boolean' on db.
func UUIDNe(ctx context.Context, db DB, p0, p1 uuid.UUID) (bool, error) {
	// call pg_catalog.uuid_ne
	const sqlstr = `SELECT * FROM pg_catalog.uuid_ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// UUIDRecv calls the stored function 'pg_catalog.uuid_recv(internal) uuid' on db.
func UUIDRecv(ctx context.Context, db DB, p0 pgtypes.Internal) (uuid.UUID, error) {
	// call pg_catalog.uuid_recv
	const sqlstr = `SELECT * FROM pg_catalog.uuid_recv($1)`
	// run
	var r0 uuid.UUID
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return uuid.UUID{}, logerror(err)
	}
	return r0, nil
}

// UUIDSend calls the stored function 'pg_catalog.uuid_send(uuid) bytea' on db.
func UUIDSend(ctx context.Context, db DB, p0 uuid.UUID) ([]byte, error) {
	// call pg_catalog.uuid_send
	const sqlstr = `SELECT * FROM pg_catalog.uuid_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// UUIDSortsupport calls the stored function 'pg_catalog.uuid_sortsupport(internal)' on db.
func UUIDSortsupport(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.uuid_sortsupport
	const sqlstr = `SELECT * FROM pg_catalog.uuid_sortsupport($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// UhcToUTF8 calls the stored function 'pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer)' on db.
func UhcToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.uhc_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.uhc_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// UniqueKeyRecheck calls the stored function 'pg_catalog.unique_key_recheck() trigger' on db.
func UniqueKeyRecheck(ctx context.Context, db DB) (pgtypes.Trigger, error) {
	// call pg_catalog.unique_key_recheck
	const sqlstr = `SELECT * FROM pg_catalog.unique_key_recheck()`
	// run
	var r0 pgtypes.Trigger
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return pgtypes.Trigger{}, logerror(err)
	}
	return r0, nil
}

// Unknownrecv calls the stored function 'pg_catalog.unknownrecv(internal) unknown' on db.
func Unknownrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Unknown, error) {
	// call pg_catalog.unknownrecv
	const sqlstr = `SELECT * FROM pg_catalog.unknownrecv($1)`
	// run
	var r0 pgtypes.Unknown
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Unknown{}, logerror(err)
	}
	return r0, nil
}

// Unknownsend calls the stored function 'pg_catalog.unknownsend(unknown) bytea' on db.
func Unknownsend(ctx context.Context, db DB, p0 pgtypes.Unknown) ([]byte, error) {
	// call pg_catalog.unknownsend
	const sqlstr = `SELECT * FROM pg_catalog.unknownsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// UnnestByAnyarray calls the stored function 'pg_catalog.unnest(anyarray) anyelement' on db.
func UnnestByAnyarray(ctx context.Context, db DB, p0 pgtypes.Anyarray) (pgtypes.Anyelement, error) {
	// call pg_catalog.unnest
	const sqlstr = `SELECT * FROM pg_catalog.unnest($1)`
	// run
	var r0 pgtypes.Anyelement
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return r0, nil
}

// UnnestByTsvector calls the stored function 'pg_catalog.unnest(tsvector) (text, smallint, text)' on db.
func UnnestByTsvector(ctx context.Context, db DB, tsvector pgtypes.Tsvector) (string, []int16, StringSlice, error) {
	// call pg_catalog.unnest
	const sqlstr = `SELECT * FROM pg_catalog.unnest($1)`
	// run
	var lexeme string
	var positions []int16
	var weights StringSlice
	logf(sqlstr, tsvector)
	if err := db.QueryRowContext(ctx, sqlstr, tsvector).Scan(&lexeme, &positions, &weights); err != nil {
		return "", nil, StringSlice{}, logerror(err)
	}
	return lexeme, positions, weights, nil
}

// UpperByAnyrange calls the stored function 'pg_catalog.upper(anyrange) anyelement' on db.
func UpperByAnyrange(ctx context.Context, db DB, p0 pgtypes.Anyrange) (pgtypes.Anyelement, error) {
	// call pg_catalog.upper
	const sqlstr = `SELECT * FROM pg_catalog.upper($1)`
	// run
	var r0 pgtypes.Anyelement
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Anyelement{}, logerror(err)
	}
	return r0, nil
}

// UpperByText calls the stored function 'pg_catalog.upper(text) text' on db.
func UpperByText(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.upper
	const sqlstr = `SELECT * FROM pg_catalog.upper($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// UpperInc calls the stored function 'pg_catalog.upper_inc(anyrange) boolean' on db.
func UpperInc(ctx context.Context, db DB, p0 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.upper_inc
	const sqlstr = `SELECT * FROM pg_catalog.upper_inc($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// UpperInf calls the stored function 'pg_catalog.upper_inf(anyrange) boolean' on db.
func UpperInf(ctx context.Context, db DB, p0 pgtypes.Anyrange) (bool, error) {
	// call pg_catalog.upper_inf
	const sqlstr = `SELECT * FROM pg_catalog.upper_inf($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Varbit calls the stored function 'pg_catalog.varbit(bit varying, integer, boolean) bit varying' on db.
func Varbit(ctx context.Context, db DB, p0 []byte, p1 int, p2 bool) ([]byte, error) {
	// call pg_catalog.varbit
	const sqlstr = `SELECT * FROM pg_catalog.varbit($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// VarbitRecv calls the stored function 'pg_catalog.varbit_recv(internal, oid, integer) bit varying' on db.
func VarbitRecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) ([]byte, error) {
	// call pg_catalog.varbit_recv
	const sqlstr = `SELECT * FROM pg_catalog.varbit_recv($1, $2, $3)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// VarbitSend calls the stored function 'pg_catalog.varbit_send(bit varying) bytea' on db.
func VarbitSend(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.varbit_send
	const sqlstr = `SELECT * FROM pg_catalog.varbit_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// VarbitSupport calls the stored function 'pg_catalog.varbit_support(internal) internal' on db.
func VarbitSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.varbit_support
	const sqlstr = `SELECT * FROM pg_catalog.varbit_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Varbitcmp calls the stored function 'pg_catalog.varbitcmp(bit varying, bit varying) integer' on db.
func Varbitcmp(ctx context.Context, db DB, p0, p1 []byte) (int, error) {
	// call pg_catalog.varbitcmp
	const sqlstr = `SELECT * FROM pg_catalog.varbitcmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Varbiteq calls the stored function 'pg_catalog.varbiteq(bit varying, bit varying) boolean' on db.
func Varbiteq(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.varbiteq
	const sqlstr = `SELECT * FROM pg_catalog.varbiteq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Varbitge calls the stored function 'pg_catalog.varbitge(bit varying, bit varying) boolean' on db.
func Varbitge(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.varbitge
	const sqlstr = `SELECT * FROM pg_catalog.varbitge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Varbitgt calls the stored function 'pg_catalog.varbitgt(bit varying, bit varying) boolean' on db.
func Varbitgt(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.varbitgt
	const sqlstr = `SELECT * FROM pg_catalog.varbitgt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Varbitle calls the stored function 'pg_catalog.varbitle(bit varying, bit varying) boolean' on db.
func Varbitle(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.varbitle
	const sqlstr = `SELECT * FROM pg_catalog.varbitle($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Varbitlt calls the stored function 'pg_catalog.varbitlt(bit varying, bit varying) boolean' on db.
func Varbitlt(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.varbitlt
	const sqlstr = `SELECT * FROM pg_catalog.varbitlt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Varbitne calls the stored function 'pg_catalog.varbitne(bit varying, bit varying) boolean' on db.
func Varbitne(ctx context.Context, db DB, p0, p1 []byte) (bool, error) {
	// call pg_catalog.varbitne
	const sqlstr = `SELECT * FROM pg_catalog.varbitne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Varbittypmodin calls the stored function 'pg_catalog.varbittypmodin(cstring) integer' on db.
func Varbittypmodin(ctx context.Context, db DB, p0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.varbittypmodin
	const sqlstr = `SELECT * FROM pg_catalog.varbittypmodin($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// VarcharByName calls the stored function 'pg_catalog.varchar(name) character varying' on db.
func VarcharByName(ctx context.Context, db DB, p0 string) (string, error) {
	// call pg_catalog.varchar
	const sqlstr = `SELECT * FROM pg_catalog.varchar($1)`
	// run
	var r0 string
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// VarcharByCharacterVaryingIntegerAndBoolean calls the stored function 'pg_catalog.varchar(character varying, integer, boolean) character varying' on db.
func VarcharByCharacterVaryingIntegerAndBoolean(ctx context.Context, db DB, p0 string, p1 int, p2 bool) (string, error) {
	// call pg_catalog.varchar
	const sqlstr = `SELECT * FROM pg_catalog.varchar($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// VarcharSupport calls the stored function 'pg_catalog.varchar_support(internal) internal' on db.
func VarcharSupport(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Internal, error) {
	// call pg_catalog.varchar_support
	const sqlstr = `SELECT * FROM pg_catalog.varchar_support($1)`
	// run
	var r0 pgtypes.Internal
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Internal{}, logerror(err)
	}
	return r0, nil
}

// Varcharrecv calls the stored function 'pg_catalog.varcharrecv(internal, oid, integer) character varying' on db.
func Varcharrecv(ctx context.Context, db DB, p0 pgtypes.Internal, p1 pgtypes.Oid, p2 int) (string, error) {
	// call pg_catalog.varcharrecv
	const sqlstr = `SELECT * FROM pg_catalog.varcharrecv($1, $2, $3)`
	// run
	var r0 string
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// Varcharsend calls the stored function 'pg_catalog.varcharsend(character varying) bytea' on db.
func Varcharsend(ctx context.Context, db DB, p0 string) ([]byte, error) {
	// call pg_catalog.varcharsend
	const sqlstr = `SELECT * FROM pg_catalog.varcharsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Varchartypmodin calls the stored function 'pg_catalog.varchartypmodin(cstring) integer' on db.
func Varchartypmodin(ctx context.Context, db DB, p0 []pgtypes.Cstring) (int, error) {
	// call pg_catalog.varchartypmodin
	const sqlstr = `SELECT * FROM pg_catalog.varchartypmodin($1)`
	// run
	var r0 int
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Version calls the stored function 'pg_catalog.version() text' on db.
func Version(ctx context.Context, db DB) (string, error) {
	// call pg_catalog.version
	const sqlstr = `SELECT * FROM pg_catalog.version()`
	// run
	var r0 string
	logf(sqlstr)
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&r0); err != nil {
		return "", logerror(err)
	}
	return r0, nil
}

// VoidRecv calls the stored function 'pg_catalog.void_recv(internal)' on db.
func VoidRecv(ctx context.Context, db DB, p0 pgtypes.Internal) error {
	// call pg_catalog.void_recv
	const sqlstr = `SELECT * FROM pg_catalog.void_recv($1)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0); err != nil {
		return logerror(err)
	}
	return nil
}

// VoidSend calls the stored function 'pg_catalog.void_send(void) bytea' on db.
func VoidSend(ctx context.Context, db DB, p0 pgtypes.Void) ([]byte, error) {
	// call pg_catalog.void_send
	const sqlstr = `SELECT * FROM pg_catalog.void_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// WebsearchToTsqueryByRegconfigAndText calls the stored function 'pg_catalog.websearch_to_tsquery(regconfig, text) tsquery' on db.
func WebsearchToTsqueryByRegconfigAndText(ctx context.Context, db DB, p0 pgtypes.Regconfig, p1 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.websearch_to_tsquery
	const sqlstr = `SELECT * FROM pg_catalog.websearch_to_tsquery($1, $2)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// WebsearchToTsqueryByText calls the stored function 'pg_catalog.websearch_to_tsquery(text) tsquery' on db.
func WebsearchToTsqueryByText(ctx context.Context, db DB, p0 string) (pgtypes.Tsquery, error) {
	// call pg_catalog.websearch_to_tsquery
	const sqlstr = `SELECT * FROM pg_catalog.websearch_to_tsquery($1)`
	// run
	var r0 pgtypes.Tsquery
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Tsquery{}, logerror(err)
	}
	return r0, nil
}

// Width calls the stored function 'pg_catalog.width(box) double precision' on db.
func Width(ctx context.Context, db DB, p0 pgtypes.Box) (float64, error) {
	// call pg_catalog.width
	const sqlstr = `SELECT * FROM pg_catalog.width($1)`
	// run
	var r0 float64
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return 0.0, logerror(err)
	}
	return r0, nil
}

// WidthBucketByNumericNumericNumericAndInteger calls the stored function 'pg_catalog.width_bucket(numeric, numeric, numeric, integer) integer' on db.
func WidthBucketByNumericNumericNumericAndInteger(ctx context.Context, db DB, p0, p1, p2 float64, p3 int) (int, error) {
	// call pg_catalog.width_bucket
	const sqlstr = `SELECT * FROM pg_catalog.width_bucket($1, $2, $3, $4)`
	// run
	var r0 int
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// WidthBucketByDoublePrecisionDoublePrecisionDoublePrecisionAndInteger calls the stored function 'pg_catalog.width_bucket(double precision, double precision, double precision, integer) integer' on db.
func WidthBucketByDoublePrecisionDoublePrecisionDoublePrecisionAndInteger(ctx context.Context, db DB, p0, p1, p2 float64, p3 int) (int, error) {
	// call pg_catalog.width_bucket
	const sqlstr = `SELECT * FROM pg_catalog.width_bucket($1, $2, $3, $4)`
	// run
	var r0 int
	logf(sqlstr, p0, p1, p2, p3)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2, p3).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// WidthBucketByAnyelementAndAnyarray calls the stored function 'pg_catalog.width_bucket(anyelement, anyarray) integer' on db.
func WidthBucketByAnyelementAndAnyarray(ctx context.Context, db DB, p0 pgtypes.Anyelement, p1 pgtypes.Anyarray) (int, error) {
	// call pg_catalog.width_bucket
	const sqlstr = `SELECT * FROM pg_catalog.width_bucket($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Win1250ToLatin2 calls the stored function 'pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer)' on db.
func Win1250ToLatin2(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.win1250_to_latin2
	const sqlstr = `SELECT * FROM pg_catalog.win1250_to_latin2($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Win1250ToMic calls the stored function 'pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer)' on db.
func Win1250ToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.win1250_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.win1250_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Win1251ToIso calls the stored function 'pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer)' on db.
func Win1251ToIso(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.win1251_to_iso
	const sqlstr = `SELECT * FROM pg_catalog.win1251_to_iso($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Win1251ToKoi8r calls the stored function 'pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer)' on db.
func Win1251ToKoi8r(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.win1251_to_koi8r
	const sqlstr = `SELECT * FROM pg_catalog.win1251_to_koi8r($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Win1251ToMic calls the stored function 'pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer)' on db.
func Win1251ToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.win1251_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.win1251_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Win1251ToWin866 calls the stored function 'pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer)' on db.
func Win1251ToWin866(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.win1251_to_win866
	const sqlstr = `SELECT * FROM pg_catalog.win1251_to_win866($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Win866ToIso calls the stored function 'pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer)' on db.
func Win866ToIso(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.win866_to_iso
	const sqlstr = `SELECT * FROM pg_catalog.win866_to_iso($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Win866ToKoi8r calls the stored function 'pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer)' on db.
func Win866ToKoi8r(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.win866_to_koi8r
	const sqlstr = `SELECT * FROM pg_catalog.win866_to_koi8r($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Win866ToMic calls the stored function 'pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer)' on db.
func Win866ToMic(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.win866_to_mic
	const sqlstr = `SELECT * FROM pg_catalog.win866_to_mic($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// Win866ToWin1251 calls the stored function 'pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer)' on db.
func Win866ToWin1251(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.win866_to_win1251
	const sqlstr = `SELECT * FROM pg_catalog.win866_to_win1251($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// WinToUTF8 calls the stored function 'pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer)' on db.
func WinToUTF8(ctx context.Context, db DB, p0, p1 int, p2 pgtypes.Cstring, p3 pgtypes.Internal, p4 int) error {
	// call pg_catalog.win_to_utf8
	const sqlstr = `SELECT * FROM pg_catalog.win_to_utf8($1, $2, $3, $4, $5)`
	// runlogf(sqlstr)
	if _, err := db.ExecContext(ctx, sqlstr, p0, p1, p2, p3, p4); err != nil {
		return logerror(err)
	}
	return nil
}

// XML calls the stored function 'pg_catalog.xml(text) xml' on db.
func XML(ctx context.Context, db DB, p0 string) ([]byte, error) {
	// call pg_catalog.xml
	const sqlstr = `SELECT * FROM pg_catalog.xml($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// XMLIsWellFormed calls the stored function 'pg_catalog.xml_is_well_formed(text) boolean' on db.
func XMLIsWellFormed(ctx context.Context, db DB, p0 string) (bool, error) {
	// call pg_catalog.xml_is_well_formed
	const sqlstr = `SELECT * FROM pg_catalog.xml_is_well_formed($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// XMLIsWellFormedContent calls the stored function 'pg_catalog.xml_is_well_formed_content(text) boolean' on db.
func XMLIsWellFormedContent(ctx context.Context, db DB, p0 string) (bool, error) {
	// call pg_catalog.xml_is_well_formed_content
	const sqlstr = `SELECT * FROM pg_catalog.xml_is_well_formed_content($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// XMLIsWellFormedDocument calls the stored function 'pg_catalog.xml_is_well_formed_document(text) boolean' on db.
func XMLIsWellFormedDocument(ctx context.Context, db DB, p0 string) (bool, error) {
	// call pg_catalog.xml_is_well_formed_document
	const sqlstr = `SELECT * FROM pg_catalog.xml_is_well_formed_document($1)`
	// run
	var r0 bool
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// XMLRecv calls the stored function 'pg_catalog.xml_recv(internal) xml' on db.
func XMLRecv(ctx context.Context, db DB, p0 pgtypes.Internal) ([]byte, error) {
	// call pg_catalog.xml_recv
	const sqlstr = `SELECT * FROM pg_catalog.xml_recv($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// XMLSend calls the stored function 'pg_catalog.xml_send(xml) bytea' on db.
func XMLSend(ctx context.Context, db DB, p0 []byte) ([]byte, error) {
	// call pg_catalog.xml_send
	const sqlstr = `SELECT * FROM pg_catalog.xml_send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Xid calls the stored function 'pg_catalog.xid(xid8) xid' on db.
func Xid(ctx context.Context, db DB, p0 pgtypes.Xid8) (pgtypes.Xid, error) {
	// call pg_catalog.xid
	const sqlstr = `SELECT * FROM pg_catalog.xid($1)`
	// run
	var r0 pgtypes.Xid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Xid{}, logerror(err)
	}
	return r0, nil
}

// Xid8cmp calls the stored function 'pg_catalog.xid8cmp(xid8, xid8) integer' on db.
func Xid8cmp(ctx context.Context, db DB, p0, p1 pgtypes.Xid8) (int, error) {
	// call pg_catalog.xid8cmp
	const sqlstr = `SELECT * FROM pg_catalog.xid8cmp($1, $2)`
	// run
	var r0 int
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return 0, logerror(err)
	}
	return r0, nil
}

// Xid8eq calls the stored function 'pg_catalog.xid8eq(xid8, xid8) boolean' on db.
func Xid8eq(ctx context.Context, db DB, p0, p1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8eq
	const sqlstr = `SELECT * FROM pg_catalog.xid8eq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Xid8ge calls the stored function 'pg_catalog.xid8ge(xid8, xid8) boolean' on db.
func Xid8ge(ctx context.Context, db DB, p0, p1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8ge
	const sqlstr = `SELECT * FROM pg_catalog.xid8ge($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Xid8gt calls the stored function 'pg_catalog.xid8gt(xid8, xid8) boolean' on db.
func Xid8gt(ctx context.Context, db DB, p0, p1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8gt
	const sqlstr = `SELECT * FROM pg_catalog.xid8gt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Xid8le calls the stored function 'pg_catalog.xid8le(xid8, xid8) boolean' on db.
func Xid8le(ctx context.Context, db DB, p0, p1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8le
	const sqlstr = `SELECT * FROM pg_catalog.xid8le($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Xid8lt calls the stored function 'pg_catalog.xid8lt(xid8, xid8) boolean' on db.
func Xid8lt(ctx context.Context, db DB, p0, p1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8lt
	const sqlstr = `SELECT * FROM pg_catalog.xid8lt($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Xid8ne calls the stored function 'pg_catalog.xid8ne(xid8, xid8) boolean' on db.
func Xid8ne(ctx context.Context, db DB, p0, p1 pgtypes.Xid8) (bool, error) {
	// call pg_catalog.xid8ne
	const sqlstr = `SELECT * FROM pg_catalog.xid8ne($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Xid8recv calls the stored function 'pg_catalog.xid8recv(internal) xid8' on db.
func Xid8recv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Xid8, error) {
	// call pg_catalog.xid8recv
	const sqlstr = `SELECT * FROM pg_catalog.xid8recv($1)`
	// run
	var r0 pgtypes.Xid8
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Xid8{}, logerror(err)
	}
	return r0, nil
}

// Xid8send calls the stored function 'pg_catalog.xid8send(xid8) bytea' on db.
func Xid8send(ctx context.Context, db DB, p0 pgtypes.Xid8) ([]byte, error) {
	// call pg_catalog.xid8send
	const sqlstr = `SELECT * FROM pg_catalog.xid8send($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Xideq calls the stored function 'pg_catalog.xideq(xid, xid) boolean' on db.
func Xideq(ctx context.Context, db DB, p0, p1 pgtypes.Xid) (bool, error) {
	// call pg_catalog.xideq
	const sqlstr = `SELECT * FROM pg_catalog.xideq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Xideqint4 calls the stored function 'pg_catalog.xideqint4(xid, integer) boolean' on db.
func Xideqint4(ctx context.Context, db DB, p0 pgtypes.Xid, p1 int) (bool, error) {
	// call pg_catalog.xideqint4
	const sqlstr = `SELECT * FROM pg_catalog.xideqint4($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Xidneq calls the stored function 'pg_catalog.xidneq(xid, xid) boolean' on db.
func Xidneq(ctx context.Context, db DB, p0, p1 pgtypes.Xid) (bool, error) {
	// call pg_catalog.xidneq
	const sqlstr = `SELECT * FROM pg_catalog.xidneq($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Xidneqint4 calls the stored function 'pg_catalog.xidneqint4(xid, integer) boolean' on db.
func Xidneqint4(ctx context.Context, db DB, p0 pgtypes.Xid, p1 int) (bool, error) {
	// call pg_catalog.xidneqint4
	const sqlstr = `SELECT * FROM pg_catalog.xidneqint4($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Xidrecv calls the stored function 'pg_catalog.xidrecv(internal) xid' on db.
func Xidrecv(ctx context.Context, db DB, p0 pgtypes.Internal) (pgtypes.Xid, error) {
	// call pg_catalog.xidrecv
	const sqlstr = `SELECT * FROM pg_catalog.xidrecv($1)`
	// run
	var r0 pgtypes.Xid
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return pgtypes.Xid{}, logerror(err)
	}
	return r0, nil
}

// Xidsend calls the stored function 'pg_catalog.xidsend(xid) bytea' on db.
func Xidsend(ctx context.Context, db DB, p0 pgtypes.Xid) ([]byte, error) {
	// call pg_catalog.xidsend
	const sqlstr = `SELECT * FROM pg_catalog.xidsend($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Xmlcomment calls the stored function 'pg_catalog.xmlcomment(text) xml' on db.
func Xmlcomment(ctx context.Context, db DB, p0 string) ([]byte, error) {
	// call pg_catalog.xmlcomment
	const sqlstr = `SELECT * FROM pg_catalog.xmlcomment($1)`
	// run
	var r0 []byte
	logf(sqlstr, p0)
	if err := db.QueryRowContext(ctx, sqlstr, p0).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Xmlconcat2 calls the stored function 'pg_catalog.xmlconcat2(xml, xml) xml' on db.
func Xmlconcat2(ctx context.Context, db DB, p0, p1 []byte) ([]byte, error) {
	// call pg_catalog.xmlconcat2
	const sqlstr = `SELECT * FROM pg_catalog.xmlconcat2($1, $2)`
	// run
	var r0 []byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// Xmlexists calls the stored function 'pg_catalog.xmlexists(text, xml) boolean' on db.
func Xmlexists(ctx context.Context, db DB, p0 string, p1 []byte) (bool, error) {
	// call pg_catalog.xmlexists
	const sqlstr = `SELECT * FROM pg_catalog.xmlexists($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// Xmlvalidate calls the stored function 'pg_catalog.xmlvalidate(xml, text) boolean' on db.
func Xmlvalidate(ctx context.Context, db DB, p0 []byte, p1 string) (bool, error) {
	// call pg_catalog.xmlvalidate
	const sqlstr = `SELECT * FROM pg_catalog.xmlvalidate($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// XpathByTextXMLAndText calls the stored function 'pg_catalog.xpath(text, xml, text) xml' on db.
func XpathByTextXMLAndText(ctx context.Context, db DB, p0 string, p1 []byte, p2 StringSlice) ([][]byte, error) {
	// call pg_catalog.xpath
	const sqlstr = `SELECT * FROM pg_catalog.xpath($1, $2, $3)`
	// run
	var r0 [][]byte
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// XpathByTextAndXML calls the stored function 'pg_catalog.xpath(text, xml) xml' on db.
func XpathByTextAndXML(ctx context.Context, db DB, p0 string, p1 []byte) ([][]byte, error) {
	// call pg_catalog.xpath
	const sqlstr = `SELECT * FROM pg_catalog.xpath($1, $2)`
	// run
	var r0 [][]byte
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return nil, logerror(err)
	}
	return r0, nil
}

// XpathExistsByTextXMLAndText calls the stored function 'pg_catalog.xpath_exists(text, xml, text) boolean' on db.
func XpathExistsByTextXMLAndText(ctx context.Context, db DB, p0 string, p1 []byte, p2 StringSlice) (bool, error) {
	// call pg_catalog.xpath_exists
	const sqlstr = `SELECT * FROM pg_catalog.xpath_exists($1, $2, $3)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1, p2)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1, p2).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}

// XpathExistsByTextAndXML calls the stored function 'pg_catalog.xpath_exists(text, xml) boolean' on db.
func XpathExistsByTextAndXML(ctx context.Context, db DB, p0 string, p1 []byte) (bool, error) {
	// call pg_catalog.xpath_exists
	const sqlstr = `SELECT * FROM pg_catalog.xpath_exists($1, $2)`
	// run
	var r0 bool
	logf(sqlstr, p0, p1)
	if err := db.QueryRowContext(ctx, sqlstr, p0, p1).Scan(&r0); err != nil {
		return false, logerror(err)
	}
	return r0, nil
}
